# Project Documentation: terra-awg-main (9)
## 3. Project File Tree
```
temp_terra-awg-main (9)
└── terra-awg-main
    ├── Design.md
    ├── LICENSE
    ├── Makefile
    ├── README.md
    ├── img
    │   └── map.png
    ├── src
    │   ├── Chest.h
    │   ├── Cleanup.cpp
    │   ├── Cleanup.h
    │   ├── Config.cpp
    │   ├── Config.h
    │   ├── GenRules.cpp
    │   ├── GenRules.h
    │   ├── Item.h
    │   ├── Point.h
    │   ├── Random.cpp
    │   ├── Random.h
    │   ├── Tile.h
    │   ├── TileBuffer.cpp
    │   ├── TileBuffer.h
    │   ├── Util.h
    │   ├── World.cpp
    │   ├── World.h
    │   ├── Writer.cpp
    │   ├── Writer.h
    │   ├── biomes
    │   │   ├── Aether.cpp
    │   │   ├── Aether.h
    │   │   ├── AshenField.cpp
    │   │   ├── AshenField.h
    │   │   ├── AsteroidField.cpp
    │   │   ├── AsteroidField.h
    │   │   ├── Base.cpp
    │   │   ├── Base.h
    │   │   ├── BiomeUtil.cpp
    │   │   ├── BiomeUtil.h
    │   │   ├── Cloud.cpp
    │   │   ├── Cloud.h
    │   │   ├── Corruption.cpp
    │   │   ├── Corruption.h
    │   │   ├── Crimson.cpp
    │   │   ├── Crimson.h
    │   │   ├── Forest.cpp
    │   │   ├── Forest.h
    │   │   ├── GemCave.cpp
    │   │   ├── GemCave.h
    │   │   ├── GemGrove.cpp
    │   │   ├── GemGrove.h
    │   │   ├── GlowingMoss.cpp
    │   │   ├── GlowingMoss.h
    │   │   ├── GlowingMushroom.cpp
    │   │   ├── GlowingMushroom.h
    │   │   ├── GraniteCave.cpp
    │   │   ├── GraniteCave.h
    │   │   ├── Hive.cpp
    │   │   ├── Hive.h
    │   │   ├── Jungle.cpp
    │   │   ├── Jungle.h
    │   │   ├── MarbleCave.cpp
    │   │   ├── MarbleCave.h
    │   │   ├── Meteorite.cpp
    │   │   ├── Meteorite.h
    │   │   ├── Ocean.cpp
    │   │   ├── Ocean.h
    │   │   ├── SpiderNest.cpp
    │   │   ├── SpiderNest.h
    │   │   ├── Underworld.cpp
    │   │   ├── Underworld.h
    │   │   ├── celebration
    │   │   │   ├── AsteroidField.cpp
    │   │   │   └── AsteroidField.h
    │   │   ├── doubleTrouble
    │   │   │   ├── Corruption.cpp
    │   │   │   ├── Corruption.h
    │   │   │   ├── Crimson.cpp
    │   │   │   ├── Crimson.h
    │   │   │   ├── ResourceSwap.cpp
    │   │   │   └── ResourceSwap.h
    │   │   ├── hardmode
    │   │   │   ├── Hallow.cpp
    │   │   │   ├── Hallow.h
    │   │   │   ├── HmOres.cpp
    │   │   │   └── HmOres.h
    │   │   ├── hiveQueen
    │   │   │   ├── Aether.cpp
    │   │   │   ├── Aether.h
    │   │   │   ├── AsteroidField.cpp
    │   │   │   ├── AsteroidField.h
    │   │   │   ├── Base.cpp
    │   │   │   ├── Base.h
    │   │   │   ├── GemGrove.cpp
    │   │   │   ├── GemGrove.h
    │   │   │   ├── GlowingMoss.cpp
    │   │   │   ├── GlowingMoss.h
    │   │   │   ├── GlowingMushroom.cpp
    │   │   │   ├── GlowingMushroom.h
    │   │   │   ├── GraniteCave.cpp
    │   │   │   ├── GraniteCave.h
    │   │   │   ├── Hive.cpp
    │   │   │   ├── Hive.h
    │   │   │   ├── MarbleCave.cpp
    │   │   │   └── MarbleCave.h
    │   │   ├── patches
    │   │   │   ├── Base.cpp
    │   │   │   └── Base.h
    │   │   └── shattered
    │   │       ├── ShatteredLand.cpp
    │   │       └── ShatteredLand.h
    │   ├── ids
    │   │   ├── Biome.h
    │   │   ├── ItemID.h
    │   │   ├── Paint.h
    │   │   ├── Prefix.cpp
    │   │   ├── Prefix.h
    │   │   ├── TileID.h
    │   │   ├── TileVariant.h
    │   │   └── WallID.h
    │   ├── main.cpp
    │   ├── map
    │   │   ├── DiegeticColor.cpp
    │   │   ├── DiegeticColor.h
    │   │   ├── ImgWriter.cpp
    │   │   ├── ImgWriter.h
    │   │   ├── TileColor.cpp
    │   │   └── TileColor.h
    │   ├── structures
    │   │   ├── BuriedBoat.cpp
    │   │   ├── BuriedBoat.h
    │   │   ├── CavernSpawn.cpp
    │   │   ├── CavernSpawn.h
    │   │   ├── DesertTomb.cpp
    │   │   ├── DesertTomb.h
    │   │   ├── Dungeon.cpp
    │   │   ├── Dungeon.h
    │   │   ├── GlobalEcho.cpp
    │   │   ├── GlobalEcho.h
    │   │   ├── Lake.cpp
    │   │   ├── Lake.h
    │   │   ├── LootRules.cpp
    │   │   ├── LootRules.h
    │   │   ├── MinecartTracks.cpp
    │   │   ├── MinecartTracks.h
    │   │   ├── MushroomCabin.cpp
    │   │   ├── MushroomCabin.h
    │   │   ├── OceanWreck.cpp
    │   │   ├── OceanWreck.h
    │   │   ├── Plants.cpp
    │   │   ├── Plants.h
    │   │   ├── Platforms.cpp
    │   │   ├── Platforms.h
    │   │   ├── Pyramid.cpp
    │   │   ├── Pyramid.h
    │   │   ├── Ruins.cpp
    │   │   ├── Ruins.h
    │   │   ├── SpiderHall.cpp
    │   │   ├── SpiderHall.h
    │   │   ├── StarterHome.cpp
    │   │   ├── StarterHome.h
    │   │   ├── Statues.cpp
    │   │   ├── Statues.h
    │   │   ├── StructureUtil.cpp
    │   │   ├── StructureUtil.h
    │   │   ├── SurfaceIgloo.cpp
    │   │   ├── SurfaceIgloo.h
    │   │   ├── Temple.cpp
    │   │   ├── Temple.h
    │   │   ├── TorchArena.cpp
    │   │   ├── TorchArena.h
    │   │   ├── Traps.cpp
    │   │   ├── Traps.h
    │   │   ├── Treasure.cpp
    │   │   ├── Treasure.h
    │   │   ├── UndergroundCabin.cpp
    │   │   ├── UndergroundCabin.h
    │   │   ├── Vines.cpp
    │   │   ├── Vines.h
    │   │   ├── data
    │   │   │   ├── Altars.cpp
    │   │   │   ├── Altars.h
    │   │   │   ├── Balloons.cpp
    │   │   │   ├── Balloons.h
    │   │   │   ├── Boats.cpp
    │   │   │   ├── Boats.h
    │   │   │   ├── Bridges.cpp
    │   │   │   ├── Bridges.h
    │   │   │   ├── Buildings.cpp
    │   │   │   ├── Buildings.h
    │   │   │   ├── DecoGems.cpp
    │   │   │   ├── DecoGems.h
    │   │   │   ├── DungeonRooms.cpp
    │   │   │   ├── DungeonRooms.h
    │   │   │   ├── DynCabin.cpp
    │   │   │   ├── DynCabin.h
    │   │   │   ├── Furniture.cpp
    │   │   │   ├── Furniture.h
    │   │   │   ├── Homes.cpp
    │   │   │   ├── Homes.h
    │   │   │   ├── Igloos.cpp
    │   │   │   ├── Igloos.h
    │   │   │   ├── JungleShrines.cpp
    │   │   │   ├── JungleShrines.h
    │   │   │   ├── Mushrooms.cpp
    │   │   │   ├── Mushrooms.h
    │   │   │   ├── RoomWindows.cpp
    │   │   │   ├── RoomWindows.h
    │   │   │   ├── Rooms.cpp
    │   │   │   ├── Rooms.h
    │   │   │   ├── SkyBoxes.cpp
    │   │   │   ├── SkyBoxes.h
    │   │   │   ├── SwordShrines.cpp
    │   │   │   ├── SwordShrines.h
    │   │   │   ├── Torches.cpp
    │   │   │   ├── Torches.h
    │   │   │   ├── Trees.cpp
    │   │   │   ├── Trees.h
    │   │   │   ├── Wrecks.cpp
    │   │   │   └── Wrecks.h
    │   │   ├── hardmode
    │   │   │   ├── LootRules.cpp
    │   │   │   └── LootRules.h
    │   │   ├── hiveQueen
    │   │   │   ├── GlobalHive.cpp
    │   │   │   ├── GlobalHive.h
    │   │   │   ├── Temple.cpp
    │   │   │   └── Temple.h
    │   │   └── sunken
    │   │       ├── Flood.cpp
    │   │       └── Flood.h
    │   └── vendor
    │       ├── INIReader.cpp
    │       ├── INIReader.h
    │       ├── OpenSimplexNoise.hpp
    │       ├── fpng.cpp
    │       ├── fpng.h
    │       ├── frozen
    │       │   ├── bits
    │       │   │   ├── algorithms.h
    │       │   │   ├── basic_types.h
    │       │   │   ├── constexpr_assert.h
    │       │   │   ├── defines.h
    │       │   │   ├── exceptions.h
    │       │   │   ├── mpl.h
    │       │   │   └── version.h
    │       │   ├── map.h
    │       │   └── set.h
    │       ├── ieee754_types.hpp
    │       ├── ini.c
    │       └── ini.h
    └── util
        └── importStructure.py

22 directories, 231 files
```
## 4. Source Files
### Folder: `temp_terra-awg-main (9)/terra-awg-main`
#### File: `temp_terra-awg-main (9)/terra-awg-main/.gitignore`
```
build/
/*.png
*.wld
terra-awg.ini

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/LICENSE`
```
MIT License

Copyright (c) 2025 alpha0010

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/Makefile`
```
# Config values

CFLAGS := -Wall -Wextra -pedantic -Werror -O2 -msse4.1 -mpclmul
CXXFLAGS := -Wall -Wextra -pedantic -Werror -std=c++20 -O2 -msse4.1 -mpclmul

SRCS := $(wildcard src/*.cpp) $(wildcard src/biomes/*.cpp) \
    $(wildcard src/biomes/celebration/*.cpp) \
    $(wildcard src/biomes/doubleTrouble/*.cpp) \
    $(wildcard src/biomes/hardmode/*.cpp) \
    $(wildcard src/biomes/hiveQueen/*.cpp) \
    $(wildcard src/biomes/patches/*.cpp) \
    $(wildcard src/biomes/shattered/*.cpp) \
    $(wildcard src/ids/*.cpp) \
    $(wildcard src/map/*.cpp) $(wildcard src/structures/*.cpp) \
    $(wildcard src/structures/hardmode/*.cpp) \
    $(wildcard src/structures/hiveQueen/*.cpp) \
    $(wildcard src/structures/sunken/*.cpp) \
    $(wildcard src/structures/data/*.cpp) $(wildcard src/vendor/*.c) \
    $(wildcard src/vendor/*.cpp)
OUT := terra-awg

BUILD_DIR := build


# Build rules.

CPPFLAGS := -Isrc

OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)

$(BUILD_DIR)/$(OUT): $(OBJS)
	$(CXX) $(OBJS) -o $@ $(LDFLAGS)

$(BUILD_DIR)/%.c.o: %.c
	@mkdir -p $(dir $@)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/%.cpp.o: %.cpp
	@mkdir -p $(dir $@)
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@

clean:
	rm -r $(BUILD_DIR)

format:
	clang-format -i $(SRCS)

.PHONY: clean format

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/.clang-format`
```
---
Language:        Cpp
# BasedOnStyle:  LLVM
AccessModifierOffset: -4
AlignAfterOpenBracket: AlwaysBreak
AlignConsecutiveMacros: false
AlignConsecutiveAssignments: false
AlignConsecutiveDeclarations: false
AlignEscapedNewlines: Right
AlignOperands:   true
AlignTrailingComments: true
AllowAllArgumentsOnNextLine: false
AllowAllConstructorInitializersOnNextLine: true
AllowAllParametersOfDeclarationOnNextLine: false
AllowShortBlocksOnASingleLine: Never
AllowShortCaseLabelsOnASingleLine: false
AllowShortFunctionsOnASingleLine: Empty
AllowShortLambdasOnASingleLine: All
AllowShortIfStatementsOnASingleLine: Never
AllowShortLoopsOnASingleLine: false
AlwaysBreakAfterDefinitionReturnType: None
AlwaysBreakAfterReturnType: None
AlwaysBreakBeforeMultilineStrings: false
AlwaysBreakTemplateDeclarations: MultiLine
BinPackArguments: false
BinPackParameters: false
BraceWrapping:
  AfterCaseLabel:  false
  AfterClass:      false
  AfterControlStatement: false
  AfterEnum:       false
  AfterFunction:   false
  AfterNamespace:  false
  AfterObjCDeclaration: false
  AfterStruct:     false
  AfterUnion:      false
  AfterExternBlock: false
  BeforeCatch:     false
  BeforeElse:      false
  IndentBraces:    false
  SplitEmptyFunction: true
  SplitEmptyRecord: true
  SplitEmptyNamespace: true
BreakBeforeBinaryOperators: None
BreakBeforeBraces: Linux
BreakBeforeInheritanceComma: false
BreakInheritanceList: BeforeColon
BreakBeforeTernaryOperators: true
BreakConstructorInitializersBeforeComma: false
BreakConstructorInitializers: BeforeColon
BreakAfterJavaFieldAnnotations: false
BreakStringLiterals: true
ColumnLimit:     80
CommentPragmas:  '^ IWYU pragma:'
CompactNamespaces: false
ConstructorInitializerAllOnOneLineOrOnePerLine: false
ConstructorInitializerIndentWidth: 4
ContinuationIndentWidth: 4
Cpp11BracedListStyle: true
DeriveLineEnding: true
DerivePointerAlignment: false
DisableFormat:   false
ExperimentalAutoDetectBinPacking: false
FixNamespaceComments: true
ForEachMacros:
  - foreach
  - Q_FOREACH
  - BOOST_FOREACH
IncludeBlocks:   Preserve
IncludeCategories:
  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
    Priority:        2
    SortPriority:    0
  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
    Priority:        3
    SortPriority:    0
  - Regex:           '.*'
    Priority:        1
    SortPriority:    0
IncludeIsMainRegex: '(Test)?$'
IncludeIsMainSourceRegex: ''
IndentCaseLabels: false
IndentCaseBlocks: false
IndentGotoLabels: true
IndentPPDirectives: None
IndentWidth:     4
IndentWrappedFunctionNames: false
JavaScriptQuotes: Leave
JavaScriptWrapImports: true
KeepEmptyLinesAtTheStartOfBlocks: true
MacroBlockBegin: ''
MacroBlockEnd:   ''
MaxEmptyLinesToKeep: 1
NamespaceIndentation: None
ObjCBinPackProtocolList: Auto
ObjCBlockIndentWidth: 2
ObjCSpaceAfterProperty: false
ObjCSpaceBeforeProtocolList: true
PenaltyBreakAssignment: 2
PenaltyBreakBeforeFirstCallParameter: 19
PenaltyBreakComment: 300
PenaltyBreakFirstLessLess: 120
PenaltyBreakString: 1000
PenaltyBreakTemplateDeclaration: 10
PenaltyExcessCharacter: 1000000
PenaltyReturnTypeOnItsOwnLine: 60
PointerAlignment: Right
ReflowComments:  true
SortIncludes:    true
SortUsingDeclarations: true
SpaceAfterCStyleCast: false
SpaceAfterLogicalNot: false
SpaceAfterTemplateKeyword: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeCpp11BracedList: false
SpaceBeforeCtorInitializerColon: true
SpaceBeforeInheritanceColon: true
SpaceBeforeParens: ControlStatements
SpaceBeforeRangeBasedForLoopColon: true
SpaceInEmptyBlock: false
SpaceInEmptyParentheses: false
SpacesBeforeTrailingComments: 1
SpacesInAngles:  false
SpacesInConditionalStatement: false
SpacesInContainerLiterals: true
SpacesInCStyleCastParentheses: false
SpacesInParentheses: false
SpacesInSquareBrackets: false
SpaceBeforeSquareBrackets: false
Standard:        Latest
StatementMacros:
  - Q_UNUSED
  - QT_REQUIRE_VERSION
TabWidth:        8
UseCRLF:         false
UseTab:          Never
...

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/.clang-format-ignore`
```
vendor/*

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Chest.h`
```
#ifndef CHEST_H
#define CHEST_H

#include "Item.h"
#include <array>

class Chest
{
public:
    int x;
    int y;
    std::array<Item, 40> items;
};

#endif // CHEST_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Cleanup.cpp`
```
#include "Cleanup.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include "vendor/frozen/map.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>
#include <map>

std::pair<int, int> getAttachedOpenWall(World &world, int x, int y)
{
    Tile &origin = world.getTile(x, y);
    std::pair<int, int> res{origin.wallID, origin.wallPaint};
    bool keepOrigin = false;
    for (int i = -1; i < 2; ++i) {
        for (int j = -1; j < 2; ++j) {
            if (i == 0 && j == 0) {
                continue;
            }
            Tile &tile = world.getTile(x + i, y + j);
            if (tile.blockID == TileID::empty) {
                if (tile.wallID == WallID::empty) {
                    return {WallID::empty, Paint::none};
                } else if (!keepOrigin) {
                    if (tile.wallID == origin.wallID) {
                        keepOrigin = true;
                    } else {
                        res = {tile.wallID, tile.wallPaint};
                    }
                }
            }
        }
    }
    return keepOrigin ? std::pair{origin.wallID, origin.wallPaint} : res;
}

Slope computeSlope(World &world, int x, int y)
{
    // Bit layout:
    // 035
    // 1 6
    // 247
    size_t flags = 0;
    constexpr auto emptyIds =
        frozen::make_set<int>({TileID::empty, TileID::minecartTrack});
    for (int i = -1; i < 2; ++i) {
        for (int j = -1; j < 2; ++j) {
            if (i == 0 && j == 0) {
                continue;
            }
            flags <<= 1;
            if (emptyIds.contains(world.getTile(x + i, y + j).blockID)) {
                flags |= 1;
            }
        }
    }
    switch (flags) {
    case 0b11010110:
    case 0b11110110:
    case 0b11010111:
        return Slope::half;
    case 0b10010110:
    case 0b10010111:
        if (world.getTile(x - 2, y).blockID == TileID::empty &&
            world.getTile(x, y).blockID != TileID::crystalBlock) {
            return Slope::half;
        }
        [[fallthrough]];
    case 0b00010110:
    case 0b00010111:
    case 0b00110110:
        return Slope::topRight;
    case 0b11010100:
    case 0b11110100:
        if (world.getTile(x + 2, y).blockID == TileID::empty &&
            world.getTile(x, y).blockID != TileID::crystalBlock) {
            return Slope::half;
        }
        [[fallthrough]];
    case 0b11010000:
    case 0b11110000:
    case 0b11010001:
        return Slope::topLeft;
    case 0b00001011:
    case 0b00101011:
    case 0b00001111:
    case 0b00101111:
    case 0b10001011:
        return Slope::bottomRight;
    case 0b01101000:
    case 0b11101000:
    case 0b01101001:
    case 0b11101001:
    case 0b01101100:
        return Slope::bottomLeft;
    default:
        return Slope::none;
    }
}

void smoothSurfaces(World &world)
{
    std::cout << "Smoothing surfaces\n";
    constexpr auto stablizeBlocks = frozen::make_map<int, int>({
        {TileID::sand, TileID::hardenedSand},
        {TileID::ebonsand, TileID::hardenedEbonsand},
        {TileID::pearlsand, TileID::hardenedPearlsand},
        {TileID::silt, TileID::mud},
        {TileID::slush, TileID::snow},
        {TileID::crimsand, TileID::hardenedCrimsand},
        {TileID::shellPile, TileID::hardenedSand},
    });
    constexpr auto slopedTiles = frozen::make_set<int>({
        TileID::dirt,
        TileID::stone,
        TileID::grass,
        TileID::corruptGrass,
        TileID::ebonstone,
        TileID::meteorite,
        TileID::clay,
        TileID::sand,
        TileID::obsidian,
        TileID::ash,
        TileID::mud,
        TileID::jungleGrass,
        TileID::mushroomGrass,
        TileID::hallowedGrass,
        TileID::ebonsand,
        TileID::pearlsand,
        TileID::pearlstone,
        TileID::silt,
        TileID::snow,
        TileID::ice,
        TileID::corruptIce,
        TileID::hallowedIce,
        TileID::cloud,
        TileID::livingWood,
        TileID::leaf,
        TileID::slime,
        TileID::flesh,
        TileID::rainCloud,
        TileID::crimsonGrass,
        TileID::crimsonIce,
        TileID::crimstone,
        TileID::slush,
        TileID::hive,
        TileID::honey,
        TileID::crispyHoney,
        TileID::crimsand,
        TileID::coralstone,
        TileID::smoothMarble,
        TileID::marble,
        TileID::granite,
        TileID::smoothGranite,
        TileID::pinkSlime,
        TileID::lavaMossStone,
        TileID::livingMahogany,
        TileID::mahoganyLeaf,
        TileID::crystalBlock,
        TileID::sandstone,
        TileID::hardenedSand,
        TileID::hardenedEbonsand,
        TileID::hardenedCrimsand,
        TileID::ebonsandstone,
        TileID::crimsandstone,
        TileID::hardenedPearlsand,
        TileID::pearlsandstone,
        TileID::snowCloud,
        TileID::lesion,
        TileID::kryptonMossStone,
        TileID::xenonMossStone,
        TileID::argonMossStone,
        TileID::neonMossStone,
        TileID::heliumMossStone,
        TileID::ashGrass,
        TileID::corruptJungleGrass,
        TileID::crimsonJungleGrass,
        TileID::aetherium,
    });
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [&stablizeBlocks, &slopedTiles, &world](int x) {
            for (int y = 0; y < world.getHeight(); ++y) {
                Tile &tile = world.getTile(x, y);
                if (tile.guarded || !isSolidBlock(tile.blockID) ||
                    !world.isExposed(x, y)) {
                    continue;
                }
                if (tile.wallID != WallID::empty) {
                    // Blend with surrounding walls by matching wall type
                    // used/blank in orthogonal non-block-covered space.
                    std::tie(tile.wallID, tile.wallPaint) =
                        getAttachedOpenWall(world, x, y);
                }
                if (world.isIsolated(x, y)) {
                    tile.blockID = TileID::empty;
                    continue;
                }
                if (!isSolidBlock(world.getTile(x, y + 1).blockID)) {
                    // Stop falling sand.
                    auto itr = stablizeBlocks.find(tile.blockID);
                    if (itr != stablizeBlocks.end()) {
                        tile.blockID = itr->second;
                    }
                }
                if (slopedTiles.contains(tile.blockID)) {
                    tile.slope = computeSlope(world, x, y);
                }
            }
        });
}

void applyCelebrationFinalize(int x, int y, int rainbowOffset, World &world)
{
    if (!world.conf.celebration) {
        return;
    }
    Tile &tile = world.getTile(x, y);
    if (tile.blockID == TileID::grass &&
        y < 0.45 * world.getUndergroundLevel()) {
        tile.blockID = TileID::hallowedGrass;
    }
    if (world.conf.unpainted) {
        return;
    }
    if (tile.blockPaint == Paint::none) {
        switch (tile.blockID) {
        case TileID::cloud:
        case TileID::rainCloud:
        case TileID::snowCloud:
            if (world.conf.forTheWorthy) {
                break;
            }
            [[fallthrough]];
        case TileID::leaf:
        case TileID::livingWood:
            tile.blockPaint = Paint::pink;
            break;
        case TileID::sand:
        case TileID::hardenedSand:
        case TileID::sandstone:
        case TileID::shellPile:
        case TileID::coralstone:
            tile.blockPaint = Paint::cyan;
            break;
        case TileID::glowingMushroom:
        case TileID::mushroomGrass:
        case TileID::slime:
            tile.blockPaint = getRainbowPaint((x + y) / 45, rainbowOffset);
            break;
        }
    }
    if (tile.wallPaint == Paint::none) {
        switch (tile.wallID) {
        case WallID::Safe::cloud:
            if (world.conf.forTheWorthy) {
                break;
            }
            [[fallthrough]];
        case WallID::Safe::livingLeaf:
        case WallID::Unsafe::livingWood:
            tile.wallPaint = Paint::pink;
            break;
        case WallID::Unsafe::hardenedSand:
        case WallID::Unsafe::sandstone:
        case WallID::Safe::hardenedSand:
        case WallID::Safe::sandstone:
        case WallID::Safe::smoothSandstone:
            tile.wallPaint = Paint::cyan;
            break;
        case WallID::Unsafe::mushroom:
            tile.wallPaint = getRainbowPaint((x + y) / 45, rainbowOffset);
            break;
        }
    }
}

struct MossRegion {
    int blockID;
    int wallID;
    int rndX;
    int rndY;
};

bool convertToMoss(
    int x,
    int y,
    Tile &tile,
    const std::vector<MossRegion> &mosses,
    Random &rnd,
    World &world)
{
    for (const auto &region : mosses) {
        if (rnd.getCoarseNoise(x + region.rndX, y + region.rndY) > 0.6) {
            tile.wallID = region.wallID;
            if (tile.blockID == TileID::stone) {
                tile.blockID = region.blockID;
                growMossOn(x, y, world);
            }
            return true;
        }
    }
    return false;
}

void finalizeWalls(Random &rnd, World &world)
{
    std::cout << "Hardening walls\n";
    std::vector<MossRegion> mosses;
    for (auto [blockID, wallID] :
         {std::pair{TileID::greenMossStone, WallID::Unsafe::greenMossy},
          {TileID::brownMossStone, WallID::Unsafe::brownMossy},
          {TileID::redMossStone, WallID::Unsafe::redMossy},
          {TileID::blueMossStone, WallID::Unsafe::blueMossy},
          {TileID::purpleMossStone, WallID::Unsafe::purpleMossy}}) {
        mosses.emplace_back(
            blockID,
            wallID,
            rnd.getInt(0, world.getWidth()),
            rnd.getInt(0, world.getHeight()));
    }
    std::shuffle(mosses.begin(), mosses.end(), rnd.getPRNG());
    std::map<int, int> stoneWalls;
    for (int wallId : WallVariants::dirt) {
        stoneWalls[wallId] = rnd.select(WallVariants::stone);
    }
    double mossBound =
        (2 * world.getUndergroundLevel() + world.getCavernLevel()) / 3;
    double stoneBound =
        (4 * world.getCavernLevel() + world.getUnderworldLevel()) / 5;
    int rainbowOffset = rnd.getInt(0, 999);
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [mossBound,
         stoneBound,
         rainbowOffset,
         &mosses,
         &stoneWalls,
         &rnd,
         &world](int x) {
            for (int y = 0; y < world.getHeight(); ++y) {
                applyCelebrationFinalize(x, y, rainbowOffset, world);
                if (y < world.getUndergroundLevel()) {
                    continue;
                }
                double threshold = 15 * (mossBound - y) / world.getHeight();
                if (rnd.getCoarseNoise(x, y) < threshold) {
                    continue;
                }
                Tile &tile = world.getTile(x, y);
                auto itr = stoneWalls.find(tile.wallID);
                if (itr != stoneWalls.end() && world.isExposed(x, y) &&
                    convertToMoss(x, y, tile, mosses, rnd, world)) {
                    continue;
                }
                threshold = 15 * (stoneBound - y) / world.getHeight();
                if (rnd.getCoarseNoise(x, y) < threshold) {
                    continue;
                }
                if (tile.blockID != TileID::dirt && itr != stoneWalls.end()) {
                    tile.wallID = itr->second;
                }
            }
        });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Cleanup.h`
```
#ifndef CLEANUP_H
#define CLEANUP_H

#include <utility>

class Random;
class World;

std::pair<int, int> getAttachedOpenWall(World &world, int x, int y);
void smoothSurfaces(World &world);
void finalizeWalls(Random &rnd, World &world);

#endif // CLEANUP_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Config.cpp`
```
#include "Config.h"

#include "Random.h"
#include "ids/ItemID.h"
#include "vendor/INIReader.h"
#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>

inline const char *confName = "terra-awg.ini";

inline const char *defaultConfigStr = R"([world]
# Name of the generated world.
# Use the name:
#   RANDOM
# for a randomly generated name.
name = Terra AWG World

# World generation seed. (Other settings must match for seed to
# produce an equivalent world.)
# Use the value:
#   RANDOM
# for a randomly generated seed.
#
# Note that that vanilla secret seeds have no special meaning here. To
# integrate with secret seeds, see the related settings below.
seed = RANDOM

# World size:
# - Small: 4200 x 1200
# - Medium: 6400 x 1800
# - Large: 8400 x 2400
# Other values may produce unexpected results.
width = 6400
height = 1800

# Difficulty: journey/classic/expert/master
mode = classic

# Evil biome: RANDOM/corruption/crimson
evil = RANDOM

# Add a starter home at the spawn point.
home = false

# For a balanced world keep all the following settings at defaults.
#
# Unless mentioned otherwise on a specific option, all settings can be
# mixed together. Note that if an impossible condition is requested, for
# example more clouds than can fit in the sky, Terra AWG will make a best
# effort attempt anyway, but some features may fail to generate, and in
# rare cases, Terra AWG may freeze or crash (please report this so I can
# fix it).
[variation]
# Add starter equipment at the spawn point. Options:
#   none/iron/platinum/hellstone/mythril
equipment = none

# Select spawn point. "normal" spawn automatically determines location
# based on active secret seeds.
# "ashen" spawn increases the chances (but does not guarantee) of
# spawning in surface ashen fields. Options:
#   normal/surface/ashen/cloud/ocean/cavern/underworld
spawn = normal

# Prevent other settings from fully painting large structures and biomes.
unpainted = false

# Apply echo coating to a portion of the world. 0.5 means apply to half
# the tiles, 1.0 means apply to everything.
fadedMemories = 0.0

# Include both evil biomes and all ore variants.
# Activates "drunk world" secret seed.
doubleTrouble = false

# Break up the world into floating islands.
shattered = false

# Flood the majority of the world surface.
#
# Note that this may prevent meteorites. Also, Terraria's liquid engine
# has poor performance when settling large bodies of water.
sunken = false

# Only generate non-spreading biomes.
purity = false

# Start with hardmode activated.
hardmode = false

# Modify chest loot to be more applicable to a hardmode start.
hardmodeLoot = false

# Biome distribution layout. Options:
#   columns/layers/patches
biomes = columns

# Tuning options for biome patches. Reasonable values
# are between -0.5 and 0.5.
patchesHumidity = 0.0
patchesTemperature = 0.0

# How rapidly to transition biomes for biome patches.
patchesSize = 1.0

# Activates "celebrationmk10" secret seed.
celebration = false

# Activates "not the bees" secret seed.
hiveQueen = false

# Activates "for the worthy" secret seed.
forTheWorthy = false

# Activates "dont dig up" secret seed.
dontDigUp = false

# Number of meteorites to place.
meteorites = 0
meteoriteSize = 1.0

# Prevent corruption/crimson tendrils from extending into the sky.
trimEvilTendrils = false

# Reduce corruption/crimson overlap with major biomes.
avoidantEvil = false

# Placement frequency multipliers. 0.5 means half the
# normal amount, 2.0 means double the normal amount.
ore = 1.0
lifeCrystals = 1.0
manaCrystals = 1.0
pots = 1.0
chests = 1.0
gems = 1.0
# Activates "no traps" secret seed when greater than 15.
traps = 1.0
trees = 1.0
livingTrees = 1.0
clouds = 1.0
asteroids = 1.0
minecartTracks = 1.0
minecartLength = 1.0
aetherSize = 1.0
dungeonSize = 1.0
templeSize = 1.0
evilSize = 1.0
oceanSize = 1.0
oceanCaveSize = 1.0
marbleFreq = 1.0
marbleSize = 1.0
graniteFreq = 1.0
graniteSize = 1.0
glowingMushroomFreq = 1.0
glowingMushroomSize = 1.0
hiveFreq = 1.0
hiveSize = 1.0
spiderNestFreq = 1.0
spiderNestSize = 1.0
glowingMossFreq = 1.0
glowingMossSize = 1.0
# Snow, desert, and jungle size are ignored for biome patches.
snowSize = 1.0
desertSize = 1.0
jungleSize = 1.0
# Controls how flat/mountainous to generate surface terrain.
surfaceAmplitude = 1.0

[extra]
# Output a map preview image.
map = true
)";

// clang-format off
inline const std::vector adjectives{
    "Abandoned", "Abhorrent", "Adorable", "Adventurous", "Ageless",
    "Aggravating", "Aggressive", "Agile", "Agreeable", "Alert", "Alien",
    "Alive", "Alleged", "Aloof", "Amber", "Amethyst", "Amusing", "Ancient",
    "Angelic", "Angry", "Annoyed", "Annoying", "Anxious", "Archaic", "Ardent",
    "Arrogant", "Ashamed", "Attractive", "Average", "Awful", "Awkward",
    "Babbling", "Bad", "Baleful", "Bashful", "Basic", "Beautiful", "Best",
    "Bewildered", "Big", "Bitter", "Bizarre", "Black", "Blackish", "Bleeding",
    "Blistering", "Blocky", "Bloody", "Blooming", "Bloopy", "Blue", "Blushful",
    "Blushing", "Boorish", "Bored", "Boundless", "Brainy", "Brash", "Brave",
    "Breakable", "Breakless", "Breathtaking", "Bright", "Brilliant", "Broken",
    "Brown", "Brutal", "Budding", "Burning", "Busy", "Calm", "Canceled",
    "Careful", "Cautious", "Celestial", "Charming", "Chartreuse", "Cheap",
    "Cheerful", "Cherry", "Chicken", "Clean", "Clear", "Clearable", "Clever",
    "Cleverish", "Cloudy", "Clumsy", "Cold", "Colorful", "Combative",
    "Comfortable", "Comical", "Common", "Complacent", "Compulsive",
    "Concerned", "Condemnable", "Condemned", "Confident", "Confusable",
    "Confused", "Constant", "Cooked", "Cooperative", "Corpulent", "Corrupt",
    "Corrupted", "Cosmic", "Courageous", "Cranky", "Crazy", "Creepy", "Cringe",
    "Crowded", "Crude", "Cruel", "Cuddly", "Curious", "Cursed", "Cute", "Cyan",
    "Daft", "Damaged", "Dangerous", "Dank", "Dapper", "Dark", "Daunting",
    "Dead", "Decaying", "Deceased", "Defeated", "Defiant", "Degenerative",
    "Delightful", "Demented", "Demonic", "Dense", "Depressed", "Deranged",
    "Desolate", "Desperate", "Determined", "Devious", "Diamond", "Different",
    "Difficult", "Dire", "Dirty", "Disappointing", "Discarded", "Disgusting",
    "Disloyal", "Disruptive", "Distant", "Distinct", "Distorted",
    "Distressing", "Disturbed", "Divine", "Dizzy", "Docile", "Dope",
    "Doubtful", "Drab", "Draconian", "Dreadful", "Dreamy", "Dripping", "Dry",
    "Dubious", "Dull", "Eager", "Easy", "Eerie", "Elated", "Elegant",
    "Embarrassed", "Embarrassing", "Emerald", "Empty", "Enchanting",
    "Encouraging", "Enduring", "Energetic", "Enthusiastic", "Envious",
    "Erratic", "Eternal", "Euphoric", "Everlasting", "Evil", "Exalted",
    "Excellent", "Excited", "Exiled", "Existential", "Exotic", "Expensive",
    "Extinct", "Extra", "Extraordinary", "Extravagant", "Exuberant",
    "Fabulous", "Fair", "Faithful", "Fallen", "Famous", "Fancy", "Fantastic",
    "Far", "Faraway", "Fearful", "Fearsome", "Feckless", "Feral", "Fertile",
    "Festering", "Fetid", "Fierce", "Filthy", "Fine", "Firm", "Flaky",
    "Flaming", "Flat", "Flexing", "Flowering", "Flowing", "Fluffy",
    "Foolhardy", "Foolish", "Forceful", "Foreign", "Forgiving", "Forgotten",
    "Forsaken", "Fortified", "Foul", "Fragile", "Frail", "Frantic",
    "Fraudulent", "Fresh", "Friendly", "Frightened", "Frightening", "Frisky",
    "Fruitful", "Funny", "Furious", "Gangrenous", "Gentle", "Ghosted",
    "Gifted", "Glamorous", "Gleaming", "Gleamless", "Gloomy", "Glorious",
    "Glowing", "Goblin", "Godly", "Golden", "Good", "Gorgeous", "Graceful",
    "Grand", "Grassy", "Gray", "Greasy", "Great", "Greedy", "Green",
    "Griefing", "Grieving", "Grizzly", "Grotesque", "Grouchy", "Growing",
    "Gruesome", "Grumpy", "Guilty", "Gutless", "Hallowed", "Handsome", "Happy",
    "Hardcore", "Harsh", "Hateful", "Hazardous", "Healthy", "Heartless",
    "Heavenly", "Heinous", "Helpful", "Helpless", "Hesitant", "Hidden",
    "Hideous", "Highkey", "Hilarious", "Holy", "Homeless", "Homely",
    "Horrible", "Horrific", "Horrifying", "Hot", "Hungry", "Hurt", "Hurtable",
    "Hurtful", "Hybrid", "Hyper", "Hysterical", "Ignorant", "Illicit",
    "Illusive", "Imaginary", "Immortal", "Incompetent", "Inconvenient",
    "Indecisive", "Indifferent", "Infected", "Inferior", "Infinite",
    "Insecure", "Insidious", "Insolent", "Intense", "Irresponsible",
    "Irritating", "Isolated", "Itchy", "Jade", "Jealous", "Jiggly", "Jittery",
    "Jolly", "Joyous", "Judgmental", "Keen", "Kind", "Kooky", "Lagging",
    "Large", "Lasting", "Lavender", "Lavish", "Lazy", "Leafy", "Legendary",
    "Lemon", "Light", "Lightful", "Lime", "Little Known", "Lively", "Lonely",
    "Long", "Lost", "Lousy", "Lovely", "Lowkey", "Loyal", "Lucky", "Luminous",
    "Lumpy", "Lush", "Mad", "Magical", "Magnetic", "Magnificent",
    "Marshmallow", "Marvelous", "Massive", "Mathematical", "Menacing",
    "Merciless", "Mischievous", "Miserable", "Misty", "Modern", "Modular",
    "Moist", "Moldy", "Moonlit", "Mopey", "Motionless", "Mourning", "Muddy",
    "Multitalented", "Murderous", "Murky", "Mushy", "Mysterious", "Mythical",
    "Naive", "Nameless", "Nasty", "Natchy", "Natural", "Naughty", "Nauseating",
    "Navy", "Neglected", "Nervous", "New", "Nice", "Nimble", "Noxious",
    "Nutty", "Obedient", "Obnoxious", "Obsessive", "Obstructed", "Obtuse",
    "Odd", "Offended", "Offensive", "Old", "Old-fashioned", "Olive", "Open",
    "Optimistic", "Orange", "Outraged", "Outrageous", "Outstanding",
    "Overcrowded", "Overeasy", "Overjealous", "Overjoyous", "Overrun", "Pale",
    "Panicky", "Partying", "Patronizing", "Peaceful", "Peach", "Perfect",
    "Perilous", "Perpetual", "Persistent", "Petrified", "Pine", "Pink",
    "Placid", "Plain", "Planking", "Pleasant", "Pleasing", "Pointy", "Poised",
    "Poison", "Poor", "Posturing", "Powerful", "Precious", "Prickly",
    "Prismatic", "Proud", "Pumpkin", "Purified", "Purple", "Putrid", "Puzzled",
    "Quaint", "Quick", "Quiet", "Quirky", "Rancid", "Rank", "Raunchy", "Raw",
    "Real", "Reckless", "Red", "Reeking", "Rejected", "Relentless",
    "Relievable", "Relieved", "Remote", "Repugnant", "Repulsive", "Resentful",
    "Restful", "Revolting", "Rich", "Ridiculous", "Risky", "Rotten", "Rotting",
    "Round", "Royal", "Ruby", "Rude", "Ruthless", "Sacred", "Sad", "Safe",
    "Sage", "Sallow", "Salty", "Sandy", "Sapphire", "Saucy", "Savage",
    "Scandalous", "Scary", "Searing", "Seasick", "Sedated", "Selfish",
    "Senile", "Senseless", "Sensitive", "Serene", "Serious", "Shabby",
    "Shameful", "Sharp", "Shiny", "Shocking", "Shoddy", "Shy", "Significant",
    "Silenced", "Silly", "Silver", "Simple", "Skeleton", "Sleepy", "Slow",
    "Sluggish", "Smelly", "Smiling", "Smoggy", "Smol", "Smooth", "Smouldering",
    "Solar", "Solid", "Sore", "Sour", "Sparkling", "Spicy", "Spiritual",
    "Splendid", "Spoiled", "Spooky", "Spotless", "Stable", "Stalwart",
    "Staunch", "Steaming", "Sticky", "Stiff", "Still", "Stinky", "Stormy",
    "Strange", "Strong", "Subaverage", "Subpar", "Successful", "Super",
    "Superb", "Superior", "Supernatural", "Supreme", "Sweaty", "Tainted",
    "Talented", "Tame", "Tasty", "Teal", "Tenacious", "Tender", "Tense",
    "Terrible", "Terrified", "Thankful", "Thick", "Thoughtful", "Thoughtless",
    "Timeless", "Tiny", "Tired", "Topaz", "Tough", "Tranquil", "Trashy",
    "Traveling", "Tropical", "Troubled", "Trusting", "Ugliest", "Ugly",
    "Unacceptable", "Unbreakable", "Unbroken", "Uncanny", "Uncharming",
    "Uncharted", "Uncombative", "Uncooperative", "Undead", "Undetermined",
    "Undiscovered", "Undying", "Unending", "Unexplored", "Unforgivable",
    "Unhappy", "Unhurt", "Unhurting", "Uninterested", "Unknown", "Unlawful",
    "Unpleasant", "Unreal", "Unruly", "Unsightly", "Unsure", "Untalented",
    "Untamed", "Unusual", "Unwicked", "Unworried", "Upset", "Upsetable",
    "Uptight", "Useless", "Vague", "Vain", "Vampiric", "Vanilla", "Vast",
    "Verdant", "Vibrant", "Vicious", "Victorious", "Vile", "Violent", "Violet",
    "Viridian", "Vivacious", "Volatile", "Wacky", "Wandering", "Wary", "Weak",
    "Weary", "Weepy", "Weird", "Wet", "White", "Wicked", "Wild", "Windy",
    "Wishful", "Withered", "Witless", "Witty", "Woke", "Wonderful", "Wondrous",
    "Worried", "Worrisome", "Wriggly", "Wrong", "Yellow", "Zany", "Zealous"
};

inline const std::vector locations{
    "Abode", "Abyss", "Accident", "Acres", "Afterworld", "Alcove", "Alley",
    "Apogee", "Arbor", "Archipelago", "Area", "Arena", "Artwork", "Asylum",
    "Backcountry", "Backwater", "Backwoods", "Badlands", "Bane", "Bank",
    "Barren", "Base", "Basin", "Bastion", "Bay", "Bayou", "Beach", "Bed",
    "Bedrock", "Beyond", "Biosphere", "Bluff", "Body", "Bog", "Boil",
    "Boondocks", "Boonies", "Border", "Bottoms", "Boundary", "Bowl", "Box",
    "Breach", "Brewery", "Brook", "Bubble", "Bundle", "Bunker", "Burrow",
    "Bush", "Butte", "Camp", "Canal", "Canopy", "Canvas", "Canyon", "Cape",
    "Carton", "Center", "Chance", "Chaparral", "Chasm", "Citadel", "City",
    "Clearing", "Climax", "Cloudland", "Coast", "Colony", "Commune",
    "Confluence", "Constant", "Continent", "Convention", "Core", "Cosmos",
    "Couch", "Country", "County", "Court", "Courtyard", "Cove", "Crater",
    "Creek", "Crest", "Croak", "Crossing", "Crossroads", "Crown", "Cult",
    "Dale", "Daybreak", "Daydream", "Defecation", "Delight", "Dell", "Delta",
    "Den", "Depths", "Desert", "Dimension", "Dirt", "Disease", "District",
    "Dollop", "Domain", "Dome", "Door", "Dream", "Dreamland", "Dreamworld",
    "Drip", "Dump", "Dune", "Dungeon", "Easement", "Eater", "Eclipse", "Edge",
    "Egg", "Elevation", "Empire", "Empyrean", "Enclosure", "End", "Entity",
    "Essence", "Estate", "Estuary", "Eternity", "Ether", "Everglade",
    "Existence", "Expanse", "Exterior", "Eye", "Fable", "Fabrication", "Faith",
    "Fantasia", "Farm", "Field", "Figment", "Finger", "Firmament", "Fjord",
    "Flapper", "Flatland", "Flats", "Flex", "Flower", "Fold", "Folly", "Foot",
    "Foothold", "Forest", "Forge", "Fort", "Fortress", "Foundation",
    "Fountain", "Fraternity", "Front", "Frontier", "Galaxy", "Garden", "Gaze",
    "Geyser", "Glacier", "Glade", "Globe", "Grange", "Grassland", "Grave",
    "Graveyard", "Grounds", "Grove", "Gulf", "Gully", "Gutter", "Hamlet",
    "Harbor", "Harvest", "Haven", "Head", "Heap", "Heart", "Heaven", "Hedge",
    "Heights", "Hideout", "Highland", "Hill", "Hilltop", "Hinterland", "Hive",
    "Hole", "Hollow", "Homeland", "Honey", "Hope", "Horizon", "Hovel", "Hub",
    "Illusion", "Image", "Infection", "Interior", "Island", "Isle", "Islet",
    "Jalopy", "Jungle", "Keystone", "Kingdom", "Knoll", "Labor", "Labyrinth",
    "Lagoon", "Lair", "Lake", "Land", "Latte", "Leaf", "Legend", "Legs", "Lie",
    "Limbo", "Lining", "Locale", "Loch", "Magic", "Marsh", "Marshland", "Mass",
    "Maze", "Meadow", "Meridian", "Mesa", "Miasma", "Midland", "Mine",
    "Mirage", "Mire", "Mistake", "Mood", "Moon", "Moorland", "Morass",
    "Mortuary", "Moss", "Mound", "Mountain", "Mouth", "Myth", "Nation",
    "Neighborhood", "Nest", "Niche", "Nightmare", "Nirvana", "Nugget",
    "Nursery", "Oasis", "Object", "Ocean", "Orchard", "Origin", "Outback",
    "Outland", "Outskirts", "Overworld", "Paintbrush", "Parable", "Paradise",
    "Park", "Passage", "Passenger", "Passing", "Pasture", "Patch", "Peak",
    "Pearl", "Pedestal", "Peninsula", "Picture", "Pie", "Pile", "Pinnacle",
    "Pit", "Place", "Plains", "Planet", "Plateau", "Plaza", "Plot", "Plumbus",
    "Point", "Polestar", "Pond", "Port", "Portrait", "Pothole", "Prairie",
    "Prison", "Province", "Pub", "Quagmire", "Quarantine", "Ranch", "Rapids",
    "Ravine", "Reach", "Reality", "Realm", "Reef", "Refuge", "Region",
    "Regret", "Remotes", "Residence", "Rest", "Retreat", "Ridge", "Rift",
    "Ring", "River", "Roost", "Root", "Route", "Run", "Sack", "Salt",
    "Sanctuary", "Savanna", "Scrubland", "Sea", "Seaside", "Section", "Sector",
    "Settlement", "Shallows", "Shanty", "Shantytown", "Sheet", "Shire", "Shoe",
    "Shore", "Shrine", "Shroud", "Shrubbery", "Shrublands", "Site", "Sky",
    "Slice", "Slime", "Slope", "Slumber", "Snack", "Snap", "Sock", "Soil",
    "Soup", "Source", "Space", "Span", "Speedrun", "Sphere", "Spiral",
    "Spring", "Square", "State", "Station", "Steppe", "Stick", "Sticks",
    "Story", "Strait", "Stream", "Stretch", "Study", "Suburb", "Summit",
    "Sunrise", "Sunset", "Swamp", "Sweater", "Sweep", "Table", "Taiga", "Tale",
    "Tears", "Temple", "Terrace", "Terrain", "Terraria", "Terrarium",
    "Territory", "Thicket", "Throat", "Throne", "Tilt", "Timberland", "Tip",
    "Token", "Tomb", "Torch", "Touch", "Towel", "Town", "Tract", "Trail",
    "Trap", "Treasure", "Tree", "Trench", "Triangle", "Tributary", "Tropic",
    "Tundra", "Tunnel", "Turf", "Underbelly", "Undergrowth", "Underwear",
    "Underwood", "Universe", "Unknown", "Upland", "Utopia", "Vale", "Valley",
    "Vault", "Vibe", "Vicinity", "Vineyard", "Virus", "Vision", "Void", "Wall",
    "Ward", "Waste", "Wasteland", "Web", "Well", "Wetland", "Wharf",
    "Wilderness", "Wilds", "Wildwood", "Wonderland", "Wood", "Woodland",
    "Woods", "World", "Yard", "Zone"
};

inline const std::vector nouns{
    "Ability", "Absurdity", "Accidents", "Acorns", "Adamantite", "Adoration",
    "Advantage", "Adventure", "Agony", "Alarm", "Allergies", "Amazement",
    "Angels", "Anger", "Anguish", "Annoyance", "Anvils", "Anxiety", "Apples",
    "Apricots", "Argon", "Arrows", "Arthritis", "Asbestos", "Ash", "Assassins",
    "Atrophy", "Awareness", "Awe", "Bacon", "Balance", "Balloons", "Bamboo",
    "Bananas", "Bandits", "Bankruptcy", "Bark", "Bats", "Beauty", "Beenades",
    "Bees", "Beggars", "Belief", "Betrayers", "Birds", "Birthdays",
    "Bitterness", "Blasphemy", "Blindness", "Blinkroot", "Blocks", "Blood",
    "Bloodletting", "Bloodshed", "Blossoms", "Bodies", "Bone", "Bones",
    "Boomers", "Boots", "Boredom", "Boulders", "Brains", "Branches", "Bravery",
    "Bribery", "Bridges", "Brilliance", "Bubbles", "Buckets", "Bugs",
    "Bunnies", "Burglars", "Burnination", "Buttercups", "Butterflies", "Cacti",
    "Calmness", "Candy", "Care", "Carnage", "Carrion", "Casualty", "Cats",
    "Cattails", "Caves", "Celebration", "Chainsaws", "Change", "Chaos",
    "Charity", "Cheats", "Cherries", "Chests", "Childhood", "Children",
    "Chlorophyte", "Cilantro", "Clarity", "Clay", "Clentamination",
    "Cleverness", "Clouds", "Cobalt", "Coconuts", "Coffee", "Coins",
    "Coldness", "Comfort", "Compassion", "Compost", "Concern", "Confidence",
    "Confinement", "Confusion", "Contentment", "Convicts", "Copper", "Corpses",
    "Corruption", "Courage", "Creation", "Creatures", "Creepers", "Crests",
    "Crime", "Criminals", "Crimtane", "Crooks", "Crows", "Crystals", "Cthulhu",
    "Curiosity", "Cyborgs", "Daisies", "Darkness", "Darts", "Daughters",
    "Dawn", "Daybloom", "Deadbeats", "Death", "Deathweed", "Debt", "Deceit",
    "Deception", "Dedication", "Defeat", "Degradation", "Delay", "Delusion",
    "Demonite", "Demons", "Derangement", "Despair", "Desperation",
    "Destruction", "Dirt", "Disappointment", "Disgust", "Dishonesty", "Dismay",
    "Distortion", "Distribution", "Dogs", "Doom", "Dragonfruit", "Dragons",
    "Dread", "Dreams", "Drills", "Drums", "Ducks", "Dusk", "Dust", "Duty",
    "Dysphoria", "Ears", "Education", "Eggs", "Elderberries", "Elegance",
    "Envy", "Evasion", "Evil", "Exile", "Exploits", "Explosives", "Extortion",
    "Eyes", "Fable", "Facts", "Failures", "Fairies", "Faith", "Falsehood",
    "Fame", "Famine", "Fantasy", "Fascination", "Fatality", "Fear", "Feathers",
    "Felons", "Ferns", "Fiction", "Fiends", "Fingers", "Fireblossom",
    "Fireflies", "Fish", "Flails", "Flatulence", "Flatus", "Flesh", "Floof",
    "Flowers", "Foam", "Forgery", "Forgiveness", "Forks", "Fortitude", "Fraud",
    "Freaks", "Freckles", "Freedom", "Friendship", "Fright", "Frogs", "Frost",
    "Fruit", "Gangsters", "Garbage", "Gears", "Gel", "Gemcorns", "Generation",
    "Ghosts", "Giggles", "Gingers", "Glass", "Gloom", "Gluttony", "Goals",
    "Goblins", "Gold", "Goldfish", "Gossip", "Grain", "Granite", "Grapefruit",
    "Grapes", "Grass", "Grasshoppers", "Graves", "Greed", "Grief", "Griefers",
    "Guitars", "Guts", "Hair", "Hamburgers", "Hammers", "Hands", "Happiness",
    "Hardship", "Harmony", "Harpies", "Hate", "Hatred", "Heart", "Heartache",
    "Hearts", "Heels", "Hellstone", "Herbs", "Heresy", "Hoiks", "Honey",
    "Hoodlums", "Hooks", "Hooligans", "Hope", "Hopelessness", "Hornets",
    "Horns", "Hornswoggle", "Horror", "Horrors", "Houses", "Humanity",
    "Humiliation", "Hurt", "Hysteria", "Ice", "Ichor", "Illness",
    "Indictments", "Indigestion", "Indignity", "Infancy", "Infections",
    "Inflammation", "Inflation", "Injury", "Insanity", "Insects",
    "Intelligence", "Intestines", "Invasions", "Iron", "Irritation",
    "Isolation", "Ivy", "Jaws", "Jealousy", "Jellyfish", "Joy", "Justice",
    "Kidneys", "Kindness", "Kittens", "Knives", "Krypton", "Lamps", "Larceny",
    "Laughter", "Lava", "Lawsuits", "Lawyers", "Lead", "Learning", "Leaves",
    "Legend", "Legends", "Leggings", "Legs", "Lemons", "Letdown", "Lethargy",
    "Liberty", "Lies", "Life", "Lilies", "Lilith", "Lilypads", "Lips",
    "Listening", "Litigation", "Livers", "Loathing", "Lombago", "Loneliness",
    "Loot", "Lore", "Losers", "Loss", "Love", "Luck", "Luggage", "Luminite",
    "Lungs", "Luxury", "Lyrics", "Madness", "Maggots", "Man", "Mana", "Mangos",
    "Mania", "Mankind", "Manslaughter", "Marble", "Markets", "Marvel",
    "Mastication", "Maturity", "Medicine", "Melancholy", "Melodies", "Memes",
    "Mercy", "Meteorite", "Mice", "Midnight", "Milk", "Mimics", "Miracles",
    "Mirrors", "Misery", "Misfortune", "Models", "Money", "Monotony",
    "Moonglow", "Moonlight", "Morons", "Mortality", "Moss", "Mourning",
    "Mouths", "Movement", "Mucus", "Mud", "Mushrooms", "Music", "Mystery",
    "Myth", "Mythril", "Nausea", "Necromancers", "Necromancy", "Night",
    "Nightcrawlers", "Nightmares", "Nostalgia", "Obscurity", "Obsidian",
    "Odor", "Ogres", "Ooze", "Opportunity", "Options", "Oranges", "Orchids",
    "Organs", "Orichalcum", "Outlaws", "Owls", "Pain", "Palladium",
    "Panhandlers", "Panic", "Pansies", "Parasites", "Parties", "Partying",
    "Patience", "Peace", "Penguins", "Peril", "Perjury", "Perspiration",
    "Pickaxes", "Pickpockets", "Pineapples", "Pinky", "Piranha", "Piranhas",
    "Pirates", "Pixies", "Pizza", "Plantero", "Plants", "Platinum", "Pleasure",
    "Plums", "Politicians", "Ponies", "Potions", "Poverty", "Power", "Pride",
    "Prisms", "Privacy", "Promises", "Prophecy", "Psychology", "Puppies",
    "Purity", "Rain", "Rainbows", "Ramen", "Rats", "Reality", "Redemption",
    "Regret", "Regurgitation", "Relaxation", "Relief", "Remorse", "Repugnance",
    "Riches", "Rocks", "Rope", "Roses", "Ruination", "Rumours", "Sacrifice",
    "Sacrilege", "Sadness", "Salesmen", "Sand", "Sandstone", "Sanity", "Sap",
    "Saplings", "Sashimi", "Satisfaction", "Sauce", "Scandal", "Scorpions",
    "Screams", "Seasons", "Seaweed", "Seclusion", "Secrecy", "Secrets",
    "Seeds", "Services", "Shade", "Shadows", "Shenanigans", "Shivers",
    "Shiverthorn", "Shock", "Shrimp", "Silliness", "Silt", "Silver", "Sin",
    "Skeletons", "Skill", "Skin", "Skulls", "Sleep", "Slime", "Sloth",
    "Sloths", "Smiles", "Smoke", "Snails", "Snakes", "Snatchers", "Snow",
    "Solicitation", "Songs", "Sorrow", "Souls", "Sounds", "Spaghetti",
    "Sparkles", "Spears", "Speed", "Spikes", "Spirits", "Splinters", "Sponges",
    "Sprinkles", "Spurs", "Squid", "Squirrels", "Starfruit", "Starvation",
    "Statues", "Stone", "Strength", "Stress", "Strictness", "Stumps",
    "Suffering", "Sunflowers", "Sunshine", "Superstition", "Surprise",
    "Swagger", "Swindlers", "Swords", "Talent", "Taxation", "Taxes",
    "Teamwork", "Teeth", "Terror", "the Ancients", "the Angler", "the Apple",
    "the Archer", "the Aunt", "the Axe", "the Baby", "the Ball", "the Balloon",
    "the Bat", "the Beast", "the Betrayed", "the Blender", "the Blood Moon",
    "the Bow", "the Bride", "the Bubble", "the Bunny", "the Cactus",
    "the Cloud", "the Corruptor", "the Crab", "the Dance", "the Dark",
    "the Dead", "the Devourer", "the Drax", "the Ducks", "the Eclipse",
    "the Elderly", "the Fairy", "the Father", "the Fool", "the Foot",
    "the Frozen", "the Gift", "the Ginger", "the Goat", "the Goblin",
    "the Golem", "the Groom", "the Guest", "the Hammer", "the Hammush",
    "the Head", "the Heavens", "the Hipster", "the Hobo", "the Homeless",
    "the King", "the Law", "the Library", "the Lihzahrd", "the Lilith",
    "the Lizard King", "the Lost Generation", "the Manager", "the Merchant",
    "the Mirror", "the Monster", "the Moon", "the Mother", "the Mummy",
    "the Mushroom", "the Needy", "the Old One", "the Pandemic", "the Pickaxe",
    "the Picksaw", "the Pigron", "the Porcelain God", "the Princess",
    "the Prism", "the Prodigy", "the Prophecy", "the Pwnhammer", "the Queen",
    "the Ramen", "the Right", "the Scholar", "the Shark", "the Sickle",
    "the Sky", "the Snap", "the Snitch", "the Spelunker", "the Spirits",
    "the Staff", "the Stars", "the Stench", "the Stooge", "the Sun",
    "the Sword", "the Tooth", "The Torch God", "the Tortoise", "the Tree",
    "the Trend", "the Undead", "the Unicorn", "the Union", "the Unknown",
    "the Varmint", "the Waraxe", "the Wise", "the World", "the Yoyo",
    "the Zoologist", "Thieves", "Thinking", "Thorns", "Thunder", "Time", "Tin",
    "Tingling", "Tiredness", "Titanium", "Tombstones", "Torches", "Torment",
    "Traitors", "Tranquility", "Traps", "Trash", "Treasure", "Trees", "Trends",
    "Trouble", "Truffles", "Trunks", "Trust", "Tulips", "Tungsten", "Twigs",
    "Twilight", "Umbrellas", "Understanding", "Vagabonds", "Vampires",
    "Vanity", "Venom", "Victims", "Victory", "Villains", "Vines", "Violets",
    "Vomit", "Vultures", "Wands", "Wariness", "Warmth", "Wasps", "Waterleaf",
    "Weakness", "Wealth", "Webs", "Weeds", "Werewolves", "Whoopsies", "Wings",
    "Winners", "Winning", "Wires", "Wisdom", "Wizards", "Woe", "Wolves",
    "Wonder", "Wood", "Worlds", "Worms", "Worries", "Wrath", "Wrenches",
    "Wyverns", "Xenon", "Yoyos", "Zombies"
};
// clang-format on

GameMode parseGameMode(const std::string &mode)
{
    if (mode == "journey") {
        return GameMode::journey;
    } else if (mode == "expert") {
        return GameMode::expert;
    } else if (mode == "master") {
        return GameMode::master;
    } else if (mode != "classic") {
        std::cout << "Unknown mode '" << mode << "'\n";
    }
    return GameMode::classic;
}

EvilBiome parseEvilBiome(const std::string &evil)
{
    if (evil == "corruption") {
        return EvilBiome::corruption;
    } else if (evil == "crimson") {
        return EvilBiome::crimson;
    } else if (evil != "RANDOM") {
        std::cout << "Unknown evil '" << evil << "'\n";
    }
    return EvilBiome::random;
}

int parseEquipment(const std::string &equipment)
{
    if (equipment == "iron") {
        return ItemID::ironBar;
    } else if (equipment == "platinum") {
        return ItemID::platinumBar;
    } else if (equipment == "hellstone") {
        return ItemID::hellstoneBar;
    } else if (equipment == "mythril") {
        return ItemID::mythrilBar;
    } else if (equipment == "debug") {
        return ItemID::zenith;
    } else if (equipment != "none") {
        std::cout << "Unknown equipment '" << equipment << "'\n";
    }
    return 0;
}

SpawnPoint parseSpawn(const std::string &spawn)
{
    if (spawn == "surface") {
        return SpawnPoint::surface;
    } else if (spawn == "ashen") {
        return SpawnPoint::ashen;
    } else if (spawn == "cloud") {
        return SpawnPoint::cloud;
    } else if (spawn == "ocean") {
        return SpawnPoint::ocean;
    } else if (spawn == "cavern") {
        return SpawnPoint::cavern;
    } else if (spawn == "underworld") {
        return SpawnPoint::underworld;
    } else if (spawn != "normal") {
        std::cout << "Unknown spawn '" << spawn << "'\n";
    }
    return SpawnPoint::normal;
}

BiomeLayout parseBiomeLayout(const std::string &biomes)
{
    if (biomes == "layers") {
        return BiomeLayout::layers;
    } else if (biomes == "patches") {
        return BiomeLayout::patches;
    } else if (biomes != "columns") {
        std::cout << "Unknown biome layout '" << biomes << "'\n";
    }
    return BiomeLayout::columns;
}

std::string genRandomName(Random &rnd)
{
    switch (rnd.getInt(0, 7)) {
    default:
    case 0:
    case 1:
        return std::string{"The "} + rnd.select(adjectives) + " " +
               rnd.select(locations) + " of " + rnd.select(nouns);
    case 2:
    case 3:
        return std::string{} + rnd.select(adjectives) + " " +
               rnd.select(locations) + " of " + rnd.select(nouns);
    case 4:
        return std::string{"The "} + rnd.select(adjectives) + " " +
               rnd.select(locations);
    case 5:
        return std::string{} + rnd.select(adjectives) + " " +
               rnd.select(locations);
    case 6:
        return std::string{"The "} + rnd.select(locations) + " of " +
               rnd.select(nouns);
    case 7:
        return std::string{} + rnd.select(locations) + " of " +
               rnd.select(nouns);
    }
}

std::string processSeed(const std::string &baseSeed, Random &rnd)
{
    if (baseSeed == "RANDOM" || baseSeed.empty()) {
        return "AWG-" + std::to_string(
                            rnd.getInt(0, std::numeric_limits<int32_t>::max()));
    }
    if (baseSeed.size() < 7) {
        return baseSeed;
    }
    for (int i = 0; i < 3; ++i) {
        if (!std::isdigit(baseSeed[2 * i]) || baseSeed[2 * i + 1] != '.') {
            return baseSeed;
        }
    }
    return baseSeed.substr(6);
}

std::string Config::getFilename() const
{
    std::string filename(name);
    for (char &c : filename) {
        if (!std::isalnum(c)) {
            c = '_';
        }
    }
    return filename;
}

#define READ_CONF_VALUE(SECTION, KEY, TYPE)                                    \
    conf.KEY = reader.Get##TYPE(#SECTION, #KEY, conf.KEY)

#define READ_CONF_AREA_VALUE(SECTION, KEY)                                     \
    conf.KEY =                                                                 \
        std::sqrt(std::max(reader.GetReal(#SECTION, #KEY, conf.KEY), 0.0))

Config readConfig(Random &rnd)
{
    Config conf{
        "Terra AWG World",
        "RANDOM",
        6400,
        1800,
        GameMode::classic,
        EvilBiome::random,
        false, // starterHome
        0,     // equipment
        SpawnPoint::normal,
        false, // unpainted
        0.0,   // fadedMemories
        false, // doubleTrouble
        false, // shattered
        false, // sunken
        false, // purity
        false, // hardmode
        false, // hardmodeLoot
        BiomeLayout::columns,
        0.0,   // patchesHumidity
        0.0,   // patchesTemperature
        1.0,   // patchesSize
        false, // celebration
        false, // hiveQueen
        false, // forTheWorthy
        false, // dontDigUp
        0,     // meteorites
        1.0,   // meteoriteSize
        false, // trimEvilTendrils
        false, // avoidantEvil
        1.0,   // ore
        1.0,   // lifeCrystals
        1.0,   // manaCrystals
        1.0,   // pots
        1.0,   // chests
        1.0,   // gems
        1.0,   // traps
        1.0,   // trees
        1.0,   // livingTrees
        1.0,   // clouds
        1.0,   // asteroids
        1.0,   // minecartTracks
        1.0,   // minecartLength
        1.0,   // aetherSize
        1.0,   // dungeonSize
        1.0,   // templeSize
        1.0,   // evilSize
        1.0,   // oceanSize
        1.0,   // oceanCaveSize
        1.0,   // marbleFreq
        1.0,   // marbleSize
        1.0,   // graniteFreq
        1.0,   // graniteSize
        1.0,   // glowingMushroomFreq
        1.0,   // glowingMushroomSize
        1.0,   // hiveFreq
        1.0,   // hiveSize
        1.0,   // spiderNestFreq
        1.0,   // spiderNestSize
        1.0,   // glowingMossFreq
        1.0,   // glowingMossSize
        1.0,   // snowSize
        1.0,   // desertSize
        1.0,   // jungleSize
        1.0,   // surfaceAmplitude
        true}; // map
    if (!std::filesystem::exists(confName)) {
        std::ofstream out(confName, std::ios::out);
        out.write(defaultConfigStr, std::strlen(defaultConfigStr));
    }
    INIReader reader(confName);
    if (reader.ParseError() < 0) {
        std::cout << "Unable to load config from'" << confName << "'\n";
        conf.seed = processSeed(conf.seed, rnd);
        return conf;
    }
    conf.name = reader.Get("world", "name", conf.name);
    if (conf.name == "RANDOM") {
        conf.name = genRandomName(rnd);
    }
    conf.seed = processSeed(reader.Get("world", "seed", conf.seed), rnd);
    READ_CONF_VALUE(world, width, Integer);
    READ_CONF_VALUE(world, height, Integer);
    conf.mode = parseGameMode(reader.Get("world", "mode", "classic"));
    conf.evil = parseEvilBiome(reader.Get("world", "evil", "RANDOM"));
    READ_CONF_VALUE(world, home, Boolean);
    conf.equipment =
        parseEquipment(reader.Get("variation", "equipment", "none"));
    conf.spawn = parseSpawn(reader.Get("variation", "spawn", "normal"));
    READ_CONF_VALUE(variation, unpainted, Boolean);
    READ_CONF_VALUE(variation, fadedMemories, Real);
    READ_CONF_VALUE(variation, doubleTrouble, Boolean);
    READ_CONF_VALUE(variation, shattered, Boolean);
    READ_CONF_VALUE(variation, sunken, Boolean);
    READ_CONF_VALUE(variation, purity, Boolean);
    READ_CONF_VALUE(variation, hardmode, Boolean);
    READ_CONF_VALUE(variation, hardmodeLoot, Boolean);
    conf.biomes =
        parseBiomeLayout(reader.Get("variation", "biomes", "columns"));
    READ_CONF_VALUE(variation, patchesHumidity, Real);
    READ_CONF_VALUE(variation, patchesTemperature, Real);
    READ_CONF_AREA_VALUE(variation, patchesSize);
    READ_CONF_VALUE(variation, celebration, Boolean);
    READ_CONF_VALUE(variation, hiveQueen, Boolean);
    READ_CONF_VALUE(variation, forTheWorthy, Boolean);
    READ_CONF_VALUE(variation, dontDigUp, Boolean);
    READ_CONF_VALUE(variation, meteorites, Integer);
    READ_CONF_AREA_VALUE(variation, meteoriteSize);
    READ_CONF_VALUE(variation, trimEvilTendrils, Boolean);
    READ_CONF_VALUE(variation, avoidantEvil, Boolean);
    READ_CONF_VALUE(variation, ore, Real);
    READ_CONF_VALUE(variation, lifeCrystals, Real);
    READ_CONF_VALUE(variation, manaCrystals, Real);
    READ_CONF_VALUE(variation, pots, Real);
    READ_CONF_VALUE(variation, chests, Real);
    READ_CONF_VALUE(variation, gems, Real);
    READ_CONF_VALUE(variation, traps, Real);
    READ_CONF_VALUE(variation, trees, Real);
    READ_CONF_VALUE(variation, livingTrees, Real);
    READ_CONF_VALUE(variation, clouds, Real);
    READ_CONF_VALUE(variation, asteroids, Real);
    READ_CONF_VALUE(variation, minecartTracks, Real);
    READ_CONF_VALUE(variation, minecartLength, Real);
    READ_CONF_AREA_VALUE(variation, aetherSize);
    READ_CONF_VALUE(variation, dungeonSize, Real);
    READ_CONF_AREA_VALUE(variation, templeSize);
    READ_CONF_AREA_VALUE(variation, evilSize);
    READ_CONF_VALUE(variation, oceanSize, Real);
    READ_CONF_VALUE(variation, oceanCaveSize, Real);
    READ_CONF_VALUE(variation, marbleFreq, Real);
    READ_CONF_AREA_VALUE(variation, marbleSize);
    READ_CONF_VALUE(variation, graniteFreq, Real);
    READ_CONF_AREA_VALUE(variation, graniteSize);
    READ_CONF_VALUE(variation, glowingMushroomFreq, Real);
    READ_CONF_AREA_VALUE(variation, glowingMushroomSize);
    READ_CONF_VALUE(variation, hiveFreq, Real);
    READ_CONF_AREA_VALUE(variation, hiveSize);
    READ_CONF_VALUE(variation, spiderNestFreq, Real);
    READ_CONF_AREA_VALUE(variation, spiderNestSize);
    READ_CONF_VALUE(variation, glowingMossFreq, Real);
    READ_CONF_AREA_VALUE(variation, glowingMossSize);
    READ_CONF_VALUE(variation, snowSize, Real);
    READ_CONF_VALUE(variation, desertSize, Real);
    READ_CONF_VALUE(variation, jungleSize, Real);
    READ_CONF_VALUE(variation, surfaceAmplitude, Real);
    READ_CONF_VALUE(extra, map, Boolean);
    return conf;
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Config.h`
```
#ifndef CONFIG_H
#define CONFIG_H

#include <string>

class Random;

enum class GameMode { journey = 3, classic = 0, expert = 1, master = 2 };

enum class EvilBiome { random, corruption, crimson };

enum class SpawnPoint {
    normal,
    surface,
    ashen,
    cloud,
    ocean,
    cavern,
    underworld,
};

enum class BiomeLayout { columns, layers, patches };

struct Config {
    std::string name;
    std::string seed;
    int width;
    int height;
    GameMode mode;
    EvilBiome evil;
    bool home;
    int equipment;
    SpawnPoint spawn;
    bool unpainted;
    double fadedMemories;
    bool doubleTrouble;
    bool shattered;
    bool sunken;
    bool purity;
    bool hardmode;
    bool hardmodeLoot;
    BiomeLayout biomes;
    double patchesHumidity;
    double patchesTemperature;
    double patchesSize;
    bool celebration;
    bool hiveQueen;
    bool forTheWorthy;
    bool dontDigUp;
    int meteorites;
    double meteoriteSize;
    bool trimEvilTendrils;
    bool avoidantEvil;
    double ore;
    double lifeCrystals;
    double manaCrystals;
    double pots;
    double chests;
    double gems;
    double traps;
    double trees;
    double livingTrees;
    double clouds;
    double asteroids;
    double minecartTracks;
    double minecartLength;
    double aetherSize;
    double dungeonSize;
    double templeSize;
    double evilSize;
    double oceanSize;
    double oceanCaveSize;
    double marbleFreq;
    double marbleSize;
    double graniteFreq;
    double graniteSize;
    double glowingMushroomFreq;
    double glowingMushroomSize;
    double hiveFreq;
    double hiveSize;
    double spiderNestFreq;
    double spiderNestSize;
    double glowingMossFreq;
    double glowingMossSize;
    double snowSize;
    double desertSize;
    double jungleSize;
    double surfaceAmplitude;
    bool map;

    std::string getFilename() const;
};

Config readConfig(Random &rnd);

#endif // CONFIG_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/GenRules.cpp`
```
#include "GenRules.h"

#include "Cleanup.h"
#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/Aether.h"
#include "biomes/AshenField.h"
#include "biomes/AsteroidField.h"
#include "biomes/Base.h"
#include "biomes/Cloud.h"
#include "biomes/Corruption.h"
#include "biomes/Crimson.h"
#include "biomes/Forest.h"
#include "biomes/GemCave.h"
#include "biomes/GemGrove.h"
#include "biomes/GlowingMoss.h"
#include "biomes/GlowingMushroom.h"
#include "biomes/GraniteCave.h"
#include "biomes/Hive.h"
#include "biomes/Jungle.h"
#include "biomes/MarbleCave.h"
#include "biomes/Meteorite.h"
#include "biomes/Ocean.h"
#include "biomes/SpiderNest.h"
#include "biomes/Underworld.h"
#include "biomes/celebration/AsteroidField.h"
#include "biomes/doubleTrouble/Corruption.h"
#include "biomes/doubleTrouble/Crimson.h"
#include "biomes/doubleTrouble/ResourceSwap.h"
#include "biomes/hardmode/Hallow.h"
#include "biomes/hardmode/HmOres.h"
#include "biomes/hiveQueen/Aether.h"
#include "biomes/hiveQueen/AsteroidField.h"
#include "biomes/hiveQueen/Base.h"
#include "biomes/hiveQueen/GemGrove.h"
#include "biomes/hiveQueen/GlowingMoss.h"
#include "biomes/hiveQueen/GlowingMushroom.h"
#include "biomes/hiveQueen/GraniteCave.h"
#include "biomes/hiveQueen/Hive.h"
#include "biomes/hiveQueen/MarbleCave.h"
#include "biomes/patches/Base.h"
#include "biomes/shattered/ShatteredLand.h"
#include "structures/BuriedBoat.h"
#include "structures/CavernSpawn.h"
#include "structures/DesertTomb.h"
#include "structures/Dungeon.h"
#include "structures/GlobalEcho.h"
#include "structures/Lake.h"
#include "structures/MinecartTracks.h"
#include "structures/MushroomCabin.h"
#include "structures/OceanWreck.h"
#include "structures/Plants.h"
#include "structures/Pyramid.h"
#include "structures/Ruins.h"
#include "structures/SpiderHall.h"
#include "structures/StarterHome.h"
#include "structures/SurfaceIgloo.h"
#include "structures/Temple.h"
#include "structures/TorchArena.h"
#include "structures/Traps.h"
#include "structures/Treasure.h"
#include "structures/Vines.h"
#include "structures/hardmode/LootRules.h"
#include "structures/hiveQueen/GlobalHive.h"
#include "structures/hiveQueen/Temple.h"
#include "structures/sunken/Flood.h"
#include <ranges>
#include <set>

enum class Step {
    planBiomes,
    initNoise,
    genWorldBase,
    genOceans,
    genCloud,
    genMarbleCave,
    genJungle,
    genForest,
    genAshenField,
    genUnderworld,
    genGlowingMushroom,
    genGraniteCave,
    genHive,
    genAether,
    genCrimson,
    genCorruption,
    applyQueuedEvil,
    genMeteorite,
    genAsteroidField,
    genGemCave,
    genSpiderNest,
    genGlowingMoss,
    genGemGrove,
    genDungeon,
    genTemple,
    genCavernSpawn,
    genPyramid,
    genDesertTomb,
    genBuriedBoat,
    genSpiderHall,
    genRuins,
    genTorchArena,
    genLake,
    genStarterHome,
    genIgloo,
    genMushroomCabin,
    genOceanWreck,
    genTreasure,
    genPlants,
    genTraps,
    genTracks,
    smoothSurfaces,
    finalizeWalls,
    genVines,
    genGrasses,
    genGlobalEcho,
    // Double Trouble.
    swapResources,
    genSecondaryCrimson,
    genSecondaryCorruption,
    // Shattered.
    genShatteredLand,
    // Sunken.
    genFlood,
    // Hardmode.
    genHardmodeOres,
    genHallow,
    // Hardmode loot.
    applyHardmodeLoot,
    // Patches.
    initBiomeNoise,
    genWorldBasePatches,
    // Celebration
    genAsteroidFieldCelebration,
    // Hive queen.
    genWorldBaseHiveQueen,
    genMarbleCaveHiveQueen,
    genGlowingMushroomHiveQueen,
    genGraniteCaveHiveQueen,
    genHiveHiveQueen,
    genAetherHiveQueen,
    genAsteroidFieldHiveQueen,
    genGlowingMossHiveQueen,
    genGemGroveHiveQueen,
    genTempleHiveQueen,
    genGlobalHive,
};

inline std::array baseBiomeRules{
    Step::planBiomes,
    Step::initNoise,
    Step::initBiomeNoise,
    Step::genWorldBase,
    Step::genWorldBasePatches,
    Step::genOceans,
    Step::genShatteredLand,
    Step::genCloud,
    Step::genMarbleCave,
    Step::genJungle,
    Step::genForest,
    Step::genAshenField,
    Step::genUnderworld,
    Step::genGlowingMushroom,
    Step::genGraniteCave,
    Step::genHive,
    Step::genAether,
    Step::genCrimson,
    Step::genCorruption,
    Step::genSecondaryCrimson,
    Step::genSecondaryCorruption,
    Step::applyQueuedEvil,
    Step::genMeteorite,
    Step::genHardmodeOres,
    Step::genHallow,
    Step::swapResources,
    Step::genAsteroidField,
    Step::genAsteroidFieldCelebration,
    Step::genGemCave,
    Step::genSpiderNest,
    Step::genGlowingMoss,
    Step::genGemGrove,
};

inline std::array baseStructureRules{
    Step::genDungeon,     Step::genTemple,         Step::genTempleHiveQueen,
    Step::genCavernSpawn, Step::genPyramid,        Step::genDesertTomb,
    Step::genBuriedBoat,  Step::genSpiderHall,     Step::genRuins,
    Step::genTorchArena,  Step::genOceanWreck,     Step::genLake,
    Step::genStarterHome, Step::genIgloo,          Step::genMushroomCabin,
    Step::genTreasure,    Step::applyHardmodeLoot, Step::genGlobalHive,
    Step::genPlants,      Step::genTraps,          Step::genTracks,
    Step::genFlood,       Step::smoothSurfaces,    Step::finalizeWalls,
    Step::genVines,       Step::genGrasses,        Step::genGlobalEcho,
};

inline std::array hiveQueenBiomeRules{
    Step::planBiomes,
    Step::initNoise,
    Step::initBiomeNoise,
    Step::genWorldBaseHiveQueen,
    Step::genOceans,
    Step::genShatteredLand,
    Step::genCloud,
    Step::genMarbleCaveHiveQueen,
    Step::genJungle,
    Step::genForest,
    Step::genUnderworld,
    Step::genGlowingMushroomHiveQueen,
    Step::genGraniteCaveHiveQueen,
    Step::genHiveHiveQueen,
    Step::genAetherHiveQueen,
    Step::genCrimson,
    Step::genCorruption,
    Step::genSecondaryCrimson,
    Step::genSecondaryCorruption,
    Step::applyQueuedEvil,
    Step::genMeteorite,
    Step::genHardmodeOres,
    Step::genHallow,
    Step::swapResources,
    Step::genAsteroidFieldHiveQueen,
    Step::genGemCave,
    Step::genSpiderNest,
    Step::genGlowingMossHiveQueen,
    Step::genGemGroveHiveQueen,
};

#define GEN_STEP(step)                                                         \
    case Step::step:                                                           \
        step(rnd, world);                                                      \
        break;

#define GEN_STEP_WORLD(step)                                                   \
    case Step::step:                                                           \
        step(world);                                                           \
        break;

void doGenStep(Step step, LocationBins &locations, Random &rnd, World &world)
{
    switch (step) {
    case Step::planBiomes:
        world.planBiomes(rnd);
        break;
    case Step::initNoise:
        rnd.initNoise(world.getWidth(), world.getHeight(), 0.07);
        break;
        GEN_STEP(genWorldBase)
        GEN_STEP(genOceans)
        GEN_STEP(genCloud)
        GEN_STEP(genMarbleCave)
        GEN_STEP(genJungle)
        GEN_STEP(genForest)
        GEN_STEP(genAshenField)
        GEN_STEP(genUnderworld)
        GEN_STEP(genGlowingMushroom)
        GEN_STEP(genGraniteCave)
        GEN_STEP(genHive)
        GEN_STEP(genAether)
        GEN_STEP(genCrimson)
        GEN_STEP(genCorruption)
    case Step::applyQueuedEvil:
        for (const auto &applyQueuedEvil : world.queuedEvil) {
            applyQueuedEvil(rnd, world);
        }
        break;
        GEN_STEP(genMeteorite)
        GEN_STEP(genAsteroidField)
        GEN_STEP(genGemCave)
        GEN_STEP(genSpiderNest)
        GEN_STEP(genGlowingMoss)
        GEN_STEP(genGemGrove)
        GEN_STEP(genDungeon)
        GEN_STEP(genTemple)
        GEN_STEP(genCavernSpawn)
        GEN_STEP(genPyramid)
        GEN_STEP(genDesertTomb)
        GEN_STEP(genBuriedBoat)
        GEN_STEP(genSpiderHall)
        GEN_STEP(genRuins)
        GEN_STEP(genTorchArena)
        GEN_STEP(genLake)
        GEN_STEP(genStarterHome)
        GEN_STEP(genIgloo)
        GEN_STEP(genMushroomCabin)
        GEN_STEP(genOceanWreck)
    case Step::genTreasure:
        locations = genTreasure(rnd, world);
        break;
    case Step::genPlants:
        genPlants(locations, rnd, world);
        break;
        GEN_STEP(genTraps)
        GEN_STEP(genTracks)
        GEN_STEP_WORLD(smoothSurfaces)
        GEN_STEP(finalizeWalls)
        GEN_STEP(genVines)
    case Step::genGrasses:
        genGrasses(locations, rnd, world);
        break;
        GEN_STEP(genGlobalEcho)
        GEN_STEP(swapResources)
        GEN_STEP(genSecondaryCrimson)
        GEN_STEP(genSecondaryCorruption)
        GEN_STEP(genShatteredLand)
        GEN_STEP_WORLD(genFlood)
        GEN_STEP(genHardmodeOres)
        GEN_STEP(genHallow)
        GEN_STEP_WORLD(applyHardmodeLoot)
    case Step::initBiomeNoise:
        rnd.initBiomeNoise(0.00097 / world.conf.patchesSize, world.conf);
        break;
        GEN_STEP(genWorldBasePatches)
        GEN_STEP(genAsteroidFieldCelebration)
        GEN_STEP(genWorldBaseHiveQueen)
        GEN_STEP(genMarbleCaveHiveQueen)
        GEN_STEP(genGlowingMushroomHiveQueen)
        GEN_STEP(genGraniteCaveHiveQueen)
        GEN_STEP(genHiveHiveQueen)
        GEN_STEP(genAetherHiveQueen)
        GEN_STEP(genAsteroidFieldHiveQueen)
        GEN_STEP(genGlowingMossHiveQueen)
        GEN_STEP(genGemGroveHiveQueen)
        GEN_STEP(genTempleHiveQueen)
        GEN_STEP_WORLD(genGlobalHive)
    }
}

void doWorldGen(Random &rnd, World &world)
{
    std::set<Step> excludes;
    excludes.insert(world.isCrimson ? Step::genCorruption : Step::genCrimson);
    if (!world.conf.home) {
        excludes.insert(Step::genStarterHome);
    }
    if (world.conf.spawn != SpawnPoint::cavern) {
        excludes.insert(Step::genCavernSpawn);
    }
    if (world.conf.fadedMemories < 0.001) {
        excludes.insert(Step::genGlobalEcho);
    }
    if (world.conf.doubleTrouble) {
        excludes.insert(
            world.isCrimson ? Step::genSecondaryCrimson
                            : Step::genSecondaryCorruption);
    } else {
        excludes.insert(
            {Step::swapResources,
             Step::genSecondaryCrimson,
             Step::genSecondaryCorruption});
    }
    if (!world.conf.shattered) {
        excludes.insert(Step::genShatteredLand);
    }
    if (!world.conf.sunken) {
        excludes.insert(Step::genFlood);
    }
    if (world.conf.purity) {
        world.surfaceEvilCenter = 0;
        excludes.insert(
            {Step::genCrimson,
             Step::genCorruption,
             Step::genSecondaryCrimson,
             Step::genSecondaryCorruption,
             Step::genHallow});
    }
    if (!world.conf.hardmode) {
        excludes.insert({Step::genHardmodeOres, Step::genHallow});
    }
    if (!world.conf.hardmodeLoot) {
        excludes.insert(Step::applyHardmodeLoot);
    }
    if (world.conf.biomes == BiomeLayout::columns) {
        excludes.insert({Step::initBiomeNoise, Step::genWorldBasePatches});
    } else {
        excludes.insert(Step::genWorldBase);
    }
    excludes.insert(
        world.conf.celebration ? Step::genAsteroidField
                               : Step::genAsteroidFieldCelebration);
    if (world.conf.hiveQueen) {
        excludes.insert(Step::genTemple);
    } else {
        excludes.insert({Step::genTempleHiveQueen, Step::genGlobalHive});
    }
    LocationBins locations;
    std::vector<Step> steps;
    if (world.conf.hiveQueen) {
        steps.insert(
            steps.end(),
            hiveQueenBiomeRules.begin(),
            hiveQueenBiomeRules.end());
    } else {
        steps.insert(steps.end(), baseBiomeRules.begin(), baseBiomeRules.end());
    }
    steps.insert(
        steps.end(),
        baseStructureRules.begin(),
        baseStructureRules.end());
    for (Step step : steps | std::views::filter([&excludes](Step s) {
                         return !excludes.contains(s);
                     })) {
        doGenStep(step, locations, rnd, world);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/GenRules.h`
```
#ifndef GENRULES_H
#define GENRULES_H

class Random;
class World;

void doWorldGen(Random &rnd, World &world);

#endif // GENRULES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Item.h`
```
#ifndef ITEM_H
#define ITEM_H

class Item
{
public:
    int id;
    int prefix;
    int stack;
};

#endif // ITEM_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Point.h`
```
#ifndef POINT_H
#define POINT_H

#include <cmath>
#include <concepts>
#include <utility>

namespace detail
{
template <typename T, typename... U>
concept one_of = (std::same_as<T, U> || ...);

template <typename T>
concept number = one_of<T, int, double, size_t>;
} // namespace detail

template <typename T> struct PointT {
    T x;
    T y;

    PointT() = default;
    template <detail::number P1, detail::number P2>
    PointT(P1 _x, P2 _y) : x(_x), y(_y)
    {
    }

    std::pair<T, T> asPair() const
    {
        return {x, y};
    }

    auto operator<=>(const PointT<T> &) const = default;
    PointT<T> &operator+=(PointT<T> rhs)
    {
        x += rhs.x;
        y += rhs.y;
        return *this;
    }
    PointT<T> &operator-=(PointT<T> rhs)
    {
        x -= rhs.x;
        y -= rhs.y;
        return *this;
    }
    PointT<T> operator+(PointT<T> rhs) const
    {
        return rhs += *this;
    }
    PointT<T> operator-(PointT<T> rhs) const
    {
        return PointT{*this} -= rhs;
    }
};

typedef PointT<int> Point;
typedef PointT<double> Pointf;

template <typename T> double hypot(PointT<T> a, PointT<T> b)
{
    auto [x, y] = a - b;
    return std::hypot(x, y);
}

#endif // POINT_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Random.cpp`
```
#include "Random.h"

#include "Config.h"
#include "Util.h"
#include "vendor/OpenSimplexNoise.hpp"
#include <algorithm>
#include <iostream>
#include <numbers>

Random::Random() : noiseWidth(0), noiseHeight(0), noiseDeltaX(0), noiseDeltaY(0)
{
    std::string tmpSeed = std::to_string(std::random_device{}());
    tmpSeed += '-';
    auto now = std::chrono::high_resolution_clock::now();
    tmpSeed +=
        std::to_string(std::chrono::duration_cast<std::chrono::nanoseconds>(
                           now.time_since_epoch())
                           .count());
    setSeed(tmpSeed);
}

void Random::setSeed(const std::string &seed)
{
    uint64_t hash = 14695981039346656037u;
    for (auto c : seed) {
        hash ^= c;
        hash *= 1099511628211;
    }
    rnd.seed(hash);
}

void Random::initNoise(int width, int height, double scale)
{
    std::cout << "Sampling noise\n";
    fineNoise.resize(width * height);
    coarseNoise.resize(width * height);
    std::uniform_int_distribution<int64_t> dist(
        0,
        std::numeric_limits<int64_t>::max());
    OpenSimplexNoise noise{dist(rnd)};
    double radiusX = scale * width * 0.5 * std::numbers::inv_pi;
    double radiusY = scale * height * 0.5 * std::numbers::inv_pi;
    parallelFor(
        std::views::iota(0, width),
        [width, height, radiusX, radiusY, &noise, this](int x) {
            double tX = 2 * std::numbers::pi * x / width;
            double x1 = radiusX * std::cos(tX);
            double x2 = radiusX * std::sin(tX);
            for (int y = 0; y < height; ++y) {
                double tY = 2 * std::numbers::pi * y / height;
                double y1 = radiusY * std::cos(tY);
                double y2 = radiusY * std::sin(tY);
                // Seamless looping 2d noise with fractal details.
                fineNoise[x * height + y] =
                    noise.Evaluate(x1, x2, y1, y2) +
                    0.5 * noise.Evaluate(2 * x1, 2 * x2, 2 * y1, 2 * y2) +
                    0.25 * noise.Evaluate(4 * x1, 4 * x2, 4 * y1, 4 * y2);
                coarseNoise[x * height + y] =
                    noise.Evaluate(x1 / 8, x2 / 8, y1 / 8, y2 / 8) +
                    0.5 * noise.Evaluate(x1 / 4, x2 / 4, y1 / 4, y2 / 4) +
                    0.25 * noise.Evaluate(x1 / 2, x2 / 2, y1 / 2, y2 / 2) +
                    0.125 * fineNoise[x * height + y];
            }
        });

    noiseWidth = width;
    noiseHeight = height;

    computeBlurNoise();
}

void Random::computeBlurNoise()
{
    std::cout << "Blurring noise\n";
    blurNoise.resize(coarseNoise.size());
    // Fast approximate Gaussian blur via horizontal/vertical smearing with
    // rolling averages.
    parallelFor(std::views::iota(0, noiseWidth), [this](int x) {
        double accu = 0;
        for (int y = noiseHeight - 40; y < noiseHeight; ++y) {
            accu = 0.9 * accu + 0.1 * coarseNoise[x * noiseHeight + y];
        }
        for (int y = 0; y < noiseHeight; ++y) {
            accu = 0.9 * accu + 0.1 * coarseNoise[x * noiseHeight + y];
            blurNoise[x * noiseHeight + y] = accu;
        }
    });
    parallelFor(std::views::iota(0, noiseHeight), [this](int y) {
        double accu = 0;
        for (int x = noiseWidth - 40; x < noiseWidth; ++x) {
            accu = 0.9 * accu + 0.1 * blurNoise[x * noiseHeight + y];
        }
        for (int x = 0; x < noiseWidth; ++x) {
            accu = 0.9 * accu + 0.1 * blurNoise[x * noiseHeight + y];
            blurNoise[x * noiseHeight + y] = accu;
        }
    });
}

void Random::initBiomeNoise(double scale, const Config &conf)
{
    std::cout << "Measuring weather\n";
    humidity.resize(noiseWidth * noiseHeight);
    temperature.resize(noiseWidth * noiseHeight);
    std::uniform_int_distribution<int64_t> dist(
        0,
        std::numeric_limits<int64_t>::max());
    OpenSimplexNoise noise{dist(rnd)};
    parallelFor(
        std::views::iota(0, noiseWidth),
        [scale, &conf, &noise, this](int x) {
            double offset = scale * (noiseWidth + noiseHeight);
            double xS = 1.4 * scale * x;
            for (int y = 0; y < noiseHeight; ++y) {
                double yS = scale * y;
                int index = x * noiseHeight + y;
                humidity[index] = noise.Evaluate(xS, yS) +
                                  0.5 * noise.Evaluate(2 * xS, 2 * yS) +
                                  0.25 * noise.Evaluate(4 * xS, 4 * yS) +
                                  conf.patchesHumidity;
                temperature[index] =
                    noise.Evaluate(offset + xS, offset + yS) +
                    0.5 * noise.Evaluate(offset + 2 * xS, offset + 2 * yS) +
                    0.25 * noise.Evaluate(offset + 4 * xS, offset + 4 * yS) +
                    std::max(0.01 * (y + 355 - noiseHeight), 0.0) +
                    conf.patchesTemperature;
                if (conf.hiveQueen || conf.biomes == BiomeLayout::layers) {
                    double forestBoost = 0;
                    double snowBoost = 0;
                    double desertBoost = 0;
                    double jungleBoost = 0;
                    if (conf.biomes == BiomeLayout::layers) {
                        forestBoost = std::clamp(
                            0.9 - 2.1 * std::abs(y - 0.196 * noiseHeight) /
                                      noiseHeight,
                            0.0,
                            0.53);
                        snowBoost = std::clamp(
                            conf.snowSize * 0.7 -
                                4.8 * std::abs(y - 0.345 * noiseHeight) /
                                    noiseHeight,
                            0.0,
                            0.5);
                        desertBoost = std::clamp(
                            conf.desertSize * 0.7 -
                                4.8 * std::abs(y - 0.526 * noiseHeight) /
                                    noiseHeight,
                            0.0,
                            0.5);
                        jungleBoost = std::clamp(
                            conf.jungleSize * 0.73 -
                                4.5 * std::abs(y - 0.759 * noiseHeight) /
                                    noiseHeight,
                            0.0,
                            0.5);
                    }
                    if (conf.hiveQueen) {
                        jungleBoost = std::max(
                            std::min(
                                0.7 - 2.4 * std::abs(x - 0.5 * noiseWidth) /
                                          noiseWidth,
                                0.5),
                            jungleBoost);
                    }
                    for (auto [boost, minH, maxH, minT, maxT] : {
                             std::tuple{forestBoost, -0.15, 0.0, -0.15, 0.0},
                             {snowBoost, -0.1, 0.1, -2.0, -1.1},
                             {desertBoost, -2, -1.1, -0.1, 0.1},
                             {jungleBoost, 0.82, 1.01, 0.82, 1.01},
                         }) {
                        humidity[index] = std::lerp(
                            humidity[index],
                            std::clamp(humidity[index], minH, maxH),
                            boost);
                        temperature[index] = std::lerp(
                            temperature[index],
                            std::clamp(temperature[index], minT, maxT),
                            boost);
                    }
                }
            }
        });
}

int Random::getPoolIndex(int size, std::source_location origin)
{
    std::string key = std::to_string(origin.line()) + ':' +
                      std::to_string(origin.column()) + ':' +
                      origin.function_name();
    if (!poolState.contains(key)) {
        poolState[key] = getInt(0, size - 1);
    }
    ++poolState[key];
    return poolState[key] % size;
}

void Random::shuffleNoise()
{
    noiseDeltaX = getInt(0, noiseWidth);
    noiseDeltaY = getInt(0, noiseHeight);
}

void Random::saveShuffleState()
{
    savedNoiseDeltaX = noiseDeltaX;
    savedNoiseDeltaY = noiseDeltaY;
}

void Random::restoreShuffleState()
{
    noiseDeltaX = savedNoiseDeltaX;
    noiseDeltaY = savedNoiseDeltaY;
}

bool Random::getBool()
{
    return getInt(0, 1) == 0;
}

uint8_t Random::getByte()
{
    return getInt(0, 0xff);
}

double Random::getDouble(double min, double max)
{
    std::uniform_real_distribution<> dist(min, max);
    return dist(rnd);
}

int Random::getInt(int min, int max)
{
    std::uniform_int_distribution<> dist(min, max);
    return dist(rnd);
}

double Random::getBlurNoise(int x, int y) const
{
    // Note: positive out-of-bounds is fine, negative may crash.
    return blurNoise
        [noiseHeight * ((x + noiseDeltaX) % noiseWidth) +
         ((y + noiseDeltaY) % noiseHeight)];
}

double Random::getCoarseNoise(int x, int y) const
{
    // Note: positive out-of-bounds is fine, negative may crash.
    return coarseNoise
        [noiseHeight * ((x + noiseDeltaX) % noiseWidth) +
         ((y + noiseDeltaY) % noiseHeight)];
}

double Random::getFineNoise(int x, int y) const
{
    // Note: positive out-of-bounds is fine, negative may crash.
    return fineNoise
        [noiseHeight * ((x + noiseDeltaX) % noiseWidth) +
         ((y + noiseDeltaY) % noiseHeight)];
}

double Random::getHumidity(int x, int y) const
{
    return x < 0 || y < 0 || x >= noiseWidth || y >= noiseHeight
               ? 0
               : humidity[noiseHeight * x + y];
}

double Random::getTemperature(int x, int y) const
{
    return x < 0 || y < 0 || x >= noiseWidth || y >= noiseHeight
               ? 0
               : temperature[noiseHeight * x + y];
}

std::vector<int> Random::partitionRange(int numSegments, int range)
{
    std::uniform_real_distribution<> dist(0.1, 1.0);
    double total = 0;
    std::vector<double> segments;
    for (int i = 0; i < numSegments; ++i) {
        total += dist(rnd);
        segments.push_back(total);
    }
    segments.pop_back();
    std::vector<int> partitions;
    for (double seg : segments) {
        partitions.push_back(range * (seg / total));
    }
    return partitions;
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Random.h`
```
#ifndef RANDOM_H
#define RANDOM_H

#include <map>
#include <random>
#include <source_location>
#include <vector>

struct Config;

class Random
{
private:
    std::vector<double> blurNoise;
    std::vector<double> coarseNoise;
    std::vector<double> fineNoise;
    std::vector<double> humidity;
    std::vector<double> temperature;
    int noiseWidth;
    int noiseHeight;
    int noiseDeltaX;
    int noiseDeltaY;
    int savedNoiseDeltaX;
    int savedNoiseDeltaY;
    std::map<std::string, int> poolState;
    std::mt19937_64 rnd;

    void computeBlurNoise();

    int getPoolIndex(int size, std::source_location origin);

public:
    Random();

    void setSeed(const std::string &seed);

    std::mt19937_64 &getPRNG()
    {
        return rnd;
    }

    /**
     * Precompute noise samples for other noise functions.
     */
    void initNoise(int width, int height, double scale);
    void initBiomeNoise(double scale, const Config &conf);
    /**
     * Shift cached noise samples, effectively producing new noise samples,
     * cheaply.
     */
    void shuffleNoise();
    /**
     * Save current noise offsets.
     */
    void saveShuffleState();
    /**
     * Restore saved noise offsets, allowing to query matching an earlier noise
     * state before shuffling.
     */
    void restoreShuffleState();

    /**
     * Random boolean value.
     */
    bool getBool();
    /**
     * Random byte.
     */
    uint8_t getByte();
    /**
     * Random floating point in range.
     */
    double getDouble(double min, double max);
    /**
     * Random integer in range. Range includes both `min` and `max`.
     */
    int getInt(int min, int max);
    /**
     * Get a sample of the blurred noise at the specified location.
     */
    double getBlurNoise(int x, int y) const;
    /**
     * Get a sample of the coarse sized noise at the specified location.
     */
    double getCoarseNoise(int x, int y) const;
    /**
     * Get a sample of the fine detailed noise at the specified location.
     */
    double getFineNoise(int x, int y) const;
    double getHumidity(int x, int y) const;
    double getTemperature(int x, int y) const;
    /**
     * Randomly select integers in a range to split the range into segments.
     */
    std::vector<int> partitionRange(int numSegments, int range);

    /**
     * Select a random value from a list. Repeatedly calling will loop through
     * the list in order, following the first selected item.
     *
     * Repeats are keyed on call site source location; intended use is within a
     * loop/wrapper function.
     */
    template <typename T>
    T pool(
        std::initializer_list<T> list,
        std::source_location origin = std::source_location::current())
    {
        return *(list.begin() + getPoolIndex(list.size(), origin));
    }
    template <typename T>
    auto
    pool(T list, std::source_location origin = std::source_location::current())
    {
        return *(list.begin() + getPoolIndex(list.size(), origin));
    }

    /**
     * Select a random value from a list.
     */
    template <typename T> T select(std::initializer_list<T> list)
    {
        return *(list.begin() + getInt(0, list.size() - 1));
    }
    template <typename T> auto select(T list)
    {
        auto first = std::begin(list);
        auto last = std::end(list);
        return *(first + getInt(0, std::distance(first, last) - 1));
    }
};

#endif // RANDOM_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Tile.h`
```
#ifndef TILE_H
#define TILE_H

#include "ids/TileID.h"

enum class Liquid { none, water, lava, honey, shimmer };

// Described location is the portion of the block that will display as empty
// space.
enum class Slope { none = 0, half, topRight, topLeft, bottomRight, bottomLeft };

enum class Flag { none, border, hive, crispyHoney, yellow, orange };

class Tile
{
public:
    int blockID = TileID::empty;
    int frameX;
    int frameY;
    int wallID;
    int blockPaint;
    int wallPaint;
    Liquid liquid;
    Slope slope;
    bool wireRed : 1;
    bool wireBlue : 1;
    bool wireGreen : 1;
    bool wireYellow : 1;
    bool actuated : 1;
    bool actuator : 1;
    bool echoCoatBlock : 1;
    bool echoCoatWall : 1;
    bool illuminantBlock : 1;
    bool illuminantWall : 1;
    /**
     * Flag this tile for cooperative protection against overwrites/cleanup
     * changes.
     */
    bool guarded : 1;
    Flag flag;

    bool operator==(const Tile &) const = default;
};

#endif // TILE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/TileBuffer.cpp`
```
#include "TileBuffer.h"

TileBuffer::TileBuffer(
    const uint16_t *data,
    const std::vector<bool> &framedTiles)
    : width(*data >> 8), height(*data & 0xff), tiles(width * height)
{
    ++data;
    int rle = 0;
    for (size_t i = 0; i < tiles.size(); ++i) {
        if (rle > 0) {
            // Copy previous tile to handle run-length encoding compression.
            tiles[i] = tiles[i - 1];
            --rle;
            continue;
        }
        uint16_t header = *data;
        ++data;
        rle = header & 0x0fff;
        Tile &tile = tiles[i];
        if (header & 0x1000) {
            tile.blockID = *data;
            ++data;
            if (framedTiles[tile.blockID]) {
                tile.frameX = *data;
                ++data;
                tile.frameY = *data;
                ++data;
            }
        }
        if (header & 0x2000) {
            tile.wallID = *data;
            ++data;
        }
        if (header & 0x4000) {
            tile.blockPaint = *data & 0x00ff;
            tile.wallPaint = *data >> 8;
            ++data;
        }
        if (header & 0x8000) {
            uint16_t flags = *data;
            ++data;
            switch (flags & 0x0007) {
            case 1:
                tile.liquid = Liquid::water;
                break;
            case 2:
                tile.liquid = Liquid::lava;
                break;
            case 3:
                tile.liquid = Liquid::honey;
                break;
            case 4:
                tile.liquid = Liquid::shimmer;
                break;
            }
            tile.slope = static_cast<Slope>((flags >> 3) & 0x0007);
            tile.wireRed = (flags & 0x0040) != 0;
            tile.wireBlue = (flags & 0x0080) != 0;
            tile.wireGreen = (flags & 0x0100) != 0;
            tile.wireYellow = (flags & 0x0200) != 0;
            tile.actuator = (flags & 0x0400) != 0;
            tile.actuated = (flags & 0x0800) != 0;
            tile.echoCoatBlock = (flags & 0x1000) != 0;
            tile.echoCoatWall = (flags & 0x2000) != 0;
            tile.illuminantBlock = (flags & 0x4000) != 0;
            tile.illuminantWall = (flags & 0x8000) != 0;
        }
    }
}

Tile &TileBuffer::getTile(int x, int y)
{
    return tiles[y + x * height];
}

const Tile &TileBuffer::getTile(int x, int y) const
{
    return tiles[y + x * height];
}

void TileBuffer::resize(int w, int h)
{
    width = w;
    height = h;
    tiles.resize(w * h);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/TileBuffer.h`
```
#ifndef TILEBUFFER_H
#define TILEBUFFER_H

#include "Tile.h"
#include <cstdint>
#include <vector>

class TileBuffer
{
private:
    int width;
    int height;
    std::vector<Tile> tiles;

public:
    TileBuffer() = default;
    /**
     * Max dimensions supported by data format are 255x255 tiles.
     */
    TileBuffer(const uint16_t *data, const std::vector<bool> &framedTiles);

    Tile &getTile(int x, int y);

    const Tile &getTile(int x, int y) const;

    /**
     * Existing tiles are invalidated if height changes.
     */
    void resize(int w, int h);

    int getWidth() const
    {
        return width;
    }

    int getHeight() const
    {
        return height;
    }
};

#endif // TILEBUFFER_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Util.h`
```
#ifndef UTIL_H
#define UTIL_H

#include <ranges>
#include <thread>
#include <vector>

/**
 * Automatic thread management for parallel loop execution.
 *
 * Before:
 * @code
 * for (int i = 0; i < 100; ++i) {
 *     handleData(i);
 * }
 * @endcode
 *
 * After:
 * @code
 * parallelFor(std::views::iota(0, 100), [](int i) {
 *     handleData(i);
 * });
 * @endcode
 */
template <std::ranges::input_range R, class UnaryFunc>
constexpr void parallelFor(R &&r, UnaryFunc f)
{
    std::vector<std::thread> pool;
    size_t numThreads = std::max(std::thread::hardware_concurrency(), 4u);
    size_t total = std::distance(r.begin(), r.end());
    size_t chunkSize = std::max<size_t>(total / numThreads, 1);
    for (size_t chunkStart = 0; chunkStart < total; chunkStart += chunkSize) {
        pool.emplace_back([&r, &f, chunkStart, chunkSize]() {
            auto itr = r.begin();
            std::advance(itr, chunkStart);
            for (size_t i = 0; i < chunkSize && itr != r.end(); ++i, ++itr) {
                f(*itr);
            }
        });
    }
    for (auto &worker : pool) {
        worker.join();
    }
}

#endif // UTIL_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/World.cpp`
```
#include "World.h"

#include "Config.h"
#include "Random.h"
#include "TileBuffer.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include <iostream>

constexpr std::vector<bool> genFramedTileLookup()
{
    int tileIds[] = {
        3,   4,   5,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,
        21,  24,  26,  27,  28,  29,  31,  33,  34,  35,  36,  42,  49,  50,
        55,  61,  71,  72,  73,  74,  77,  78,  79,  81,  82,  83,  84,  85,
        86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99,
        100, 101, 102, 103, 104, 105, 106, 110, 113, 114, 125, 126, 128, 129,
        132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 144, 149, 165,
        171, 172, 173, 174, 178, 184, 185, 186, 187, 201, 207, 209, 210, 212,
        215, 216, 217, 218, 219, 220, 227, 228, 231, 233, 235, 236, 237, 238,
        239, 240, 241, 242, 243, 244, 245, 246, 247, 254, 269, 270, 271, 275,
        276, 277, 278, 279, 280, 281, 282, 283, 285, 286, 287, 288, 289, 290,
        291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304,
        305, 306, 307, 308, 309, 310, 314, 316, 317, 318, 319, 320, 323, 324,
        334, 335, 337, 338, 339, 349, 354, 355, 356, 358, 359, 360, 361, 362,
        363, 364, 372, 373, 374, 375, 376, 377, 378, 380, 386, 387, 388, 389,
        390, 391, 392, 393, 394, 395, 405, 406, 410, 411, 412, 413, 414, 419,
        420, 423, 424, 425, 427, 428, 429, 435, 436, 437, 438, 439, 440, 441,
        442, 443, 444, 445, 452, 453, 454, 455, 456, 457, 461, 462, 463, 464,
        465, 466, 467, 468, 469, 470, 471, 475, 476, 480, 484, 485, 486, 487,
        488, 489, 490, 491, 493, 494, 497, 499, 505, 506, 509, 510, 511, 518,
        519, 520, 521, 522, 523, 524, 525, 526, 527, 529, 530, 531, 532, 533,
        538, 542, 543, 544, 545, 547, 548, 549, 550, 551, 552, 553, 554, 555,
        556, 558, 559, 560, 564, 565, 567, 568, 569, 570, 571, 572, 573, 579,
        580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593,
        594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607,
        608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 619, 620, 621, 622,
        623, 624, 629, 630, 631, 632, 634, 637, 639, 640, 642, 643, 644, 645,
        646, 647, 648, 649, 650, 651, 652, 653, 654, 656, 657, 658, 660, 663,
        664, 665};
    std::vector<bool> table(693);
    for (int tileId : tileIds) {
        table[tileId] = true;
    }
    return table;
}

Point framedTileToDims(int tileID)
{
    switch (tileID) {
    case TileID::painting2x3:
        return {2, 3};
    case TileID::painting3x2:
        return {3, 2};
    case TileID::catacomb:
        return {4, 3};
    case TileID::painting3x3:
        return {3, 3};
    case TileID::painting6x4:
        return {6, 4};
    default:
        return {1, 1};
    }
}

uint32_t fnv1a32pt(uint32_t x, uint32_t y)
{
    const uint32_t prime = 16777619;
    uint32_t hash = 2166136261;
    hash ^= x;
    hash *= prime;
    hash ^= y;
    hash *= prime;
    return hash;
}

World::World(const Config &c)
    : width(c.width), height(c.height), tiles(width * height),
      framedTiles(genFramedTileLookup()), surface(width),
      biomeMap(width * height), conf(c)
{
}

int World::getWidth() const
{
    return width;
}

int World::getHeight() const
{
    return height;
}

int &World::getSurfaceLevel(int x)
{
    return surface[(x + surface.size()) % surface.size()];
}

int World::getUndergroundLevel() const
{
    return 0.28 * height;
}

int World::getCavernLevel() const
{
    return (conf.dontDigUp ? 0.61 : 0.41) * height;
}

int World::getUnderworldLevel() const
{
    return height - 230;
}

Tile &World::getTile(int x, int y)
{
    if (x < 0 || x >= width || y < 0 || y >= height) {
        // Handle out-of-bounds request with junk data.
        return scratchTile;
    }
    return tiles[y + x * height];
}

BiomeData &World::getBiome(int x, int y)
{
    if (x < 0 || x >= width || y < 0 || y >= height) {
        return biomeMap.front();
    }
    return biomeMap[y + x * height];
}

std::vector<Point>
World::placeBuffer(int x, int y, const TileBuffer &data, Blend blendMode)
{
    std::vector<Point> storageLocations;
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            const Tile &dataTile = data.getTile(i, j);
            if (blendMode == Blend::blockOnly &&
                dataTile.blockID == TileID::empty) {
                continue;
            }
            Tile &tile = getTile(x + i, y + j);
            if (dataTile.blockID == TileID::cloud) {
                if (dataTile.slope != Slope::none &&
                    tile.blockID != TileID::empty) {
                    tile.slope = dataTile.slope;
                    tile.guarded = true;
                }
                continue;
            }
            if (blendMode == Blend::blockOnly) {
                tile.blockID = dataTile.blockID;
                tile.frameX = dataTile.frameX;
                tile.frameY = dataTile.frameY;
                tile.blockPaint = dataTile.blockPaint;
                tile.slope = dataTile.slope;
            } else {
                int wallId = tile.wallID;
                int wallPaint = tile.wallPaint;
                tile = dataTile;
                if (dataTile.wallID == WallID::Safe::cloud) {
                    tile.wallID = WallID::empty;
                } else if (dataTile.wallID == WallID::empty) {
                    tile.wallID = wallId;
                    tile.wallPaint = wallPaint;
                }
            }
            tile.guarded =
                tile.blockID != TileID::empty || tile.wallID != WallID::empty;
            if (((tile.blockID == TileID::dresser && tile.frameX % 54 == 0) ||
                 ((tile.blockID == TileID::chest ||
                   tile.blockID == TileID::chestGroup2) &&
                  tile.frameX % 36 == 0)) &&
                tile.frameY == 0) {
                storageLocations.emplace_back(x + i, y + j);
            }
        }
    }
    return storageLocations;
}

struct FrameDetails {
    int width;
    int height;
    int offsetX;
    int offsetY;
};

inline const std::map<std::pair<int, Variant>, FrameDetails> tileFrameData{
    {{TileID::alchemyTable, Variant::none}, {3, 3, 0, 0}},
    {{TileID::altar, Variant::corruption}, {3, 2, 0, 0}},
    {{TileID::altar, Variant::crimson}, {3, 2, 54, 0}},
    {{TileID::ashPlant, Variant::none}, {1, 1, 0, 0}},
    {{TileID::banner, Variant::ankh}, {1, 3, 72, 0}},
    {{TileID::banner, Variant::omega}, {1, 3, 108, 0}},
    {{TileID::banner, Variant::snake}, {1, 3, 90, 0}},
    {{TileID::bewitchingTable, Variant::none}, {3, 3, 0, 0}},
    {{TileID::boneWelder, Variant::none}, {3, 3, 0, 0}},
    {{TileID::bottle, Variant::health}, {1, 1, 18, 0}},
    {{TileID::bottle, Variant::mana}, {1, 1, 36, 0}},
    {{TileID::chest, Variant::barrel}, {2, 2, 180, 0}},
    {{TileID::chest, Variant::corruption}, {2, 2, 864, 0}},
    {{TileID::chest, Variant::crimson}, {2, 2, 900, 0}},
    {{TileID::chest, Variant::flesh}, {2, 2, 1548, 0}},
    {{TileID::chest, Variant::frozen}, {2, 2, 396, 0}},
    {{TileID::chest, Variant::gold}, {2, 2, 36, 0}},
    {{TileID::chest, Variant::goldLocked}, {2, 2, 72, 0}},
    {{TileID::chest, Variant::granite}, {2, 2, 1800, 0}},
    {{TileID::chest, Variant::hallowed}, {2, 2, 936, 0}},
    {{TileID::chest, Variant::honey}, {2, 2, 1044, 0}},
    {{TileID::chest, Variant::ice}, {2, 2, 972, 0}},
    {{TileID::chest, Variant::ivy}, {2, 2, 360, 0}},
    {{TileID::chest, Variant::jungle}, {2, 2, 828, 0}},
    {{TileID::chest, Variant::lihzahrd}, {2, 2, 576, 0}},
    {{TileID::chest, Variant::livingWood}, {2, 2, 432, 0}},
    {{TileID::chest, Variant::marble}, {2, 2, 1836, 0}},
    {{TileID::chest, Variant::meteorite}, {2, 2, 1764, 0}},
    {{TileID::chest, Variant::mushroom}, {2, 2, 1152, 0}},
    {{TileID::chest, Variant::palmWood}, {2, 2, 1116, 0}},
    {{TileID::chest, Variant::pearlwood}, {2, 2, 324, 0}},
    {{TileID::chest, Variant::richMahogany}, {2, 2, 288, 0}},
    {{TileID::chest, Variant::shadow}, {2, 2, 144, 0}},
    {{TileID::chest, Variant::skyware}, {2, 2, 468, 0}},
    {{TileID::chest, Variant::water}, {2, 2, 612, 0}},
    {{TileID::chestGroup2, Variant::ashWood}, {2, 2, 576, 0}},
    {{TileID::chestGroup2, Variant::deadMans}, {2, 2, 144, 0}},
    {{TileID::chestGroup2, Variant::desert}, {2, 2, 468, 0}},
    {{TileID::chestGroup2, Variant::lesion}, {2, 2, 108, 0}},
    {{TileID::chestGroup2, Variant::reef}, {2, 2, 504, 0}},
    {{TileID::chestGroup2, Variant::sandstone}, {2, 2, 360, 0}},
    {{TileID::corruptPlant, Variant::none}, {1, 1, 0, 0}},
    {{TileID::crimsonPlant, Variant::none}, {1, 1, 0, 0}},
    {{TileID::door, Variant::dungeon}, {1, 3, 0, 702}},
    {{TileID::door, Variant::lihzahrd}, {1, 3, 0, 594}},
    {{TileID::door, Variant::mushroom}, {1, 3, 0, 324}},
    {{TileID::door, Variant::obsidian}, {1, 3, 0, 1026}},
    {{TileID::fallenLog, Variant::none}, {3, 2, 0, 0}},
    {{TileID::grassPlant, Variant::none}, {1, 1, 0, 0}},
    {{TileID::geyser, Variant::none}, {2, 1, 0, 0}},
    {{TileID::hellforge, Variant::none}, {3, 2, 0, 0}},
    {{TileID::junglePlant, Variant::none}, {1, 1, 0, 0}},
    {{TileID::lamp, Variant::crystal}, {1, 3, 0, 1674}},
    {{TileID::lamp, Variant::dynasty}, {1, 3, 0, 918}},
    {{TileID::lamp, Variant::flesh}, {1, 3, 0, 162}},
    {{TileID::lamp, Variant::frozen}, {1, 3, 0, 270}},
    {{TileID::lamp, Variant::lesion}, {1, 3, 0, 1782}},
    {{TileID::lamp, Variant::lihzahrd}, {1, 3, 0, 432}},
    {{TileID::lamp, Variant::sandstone}, {1, 3, 0, 2052}},
    {{TileID::lantern, Variant::alchemy}, {1, 2, 0, 144}},
    {{TileID::lantern, Variant::oilRagSconce}, {1, 2, 0, 216}},
    {{TileID::lantern, Variant::bone}, {1, 2, 18, 900}},
    {{TileID::largePile, Variant::bone}, {3, 2, 0, 0}},
    {{TileID::largePile, Variant::furniture}, {3, 2, 1188, 0}},
    {{TileID::largePile, Variant::ice}, {3, 2, 1404, 0}},
    {{TileID::largePile, Variant::mushroom}, {3, 2, 1728, 0}},
    {{TileID::largePile, Variant::stone}, {3, 2, 378, 0}},
    {{TileID::largePileGroup2, Variant::ash}, {3, 2, 324, 0}},
    {{TileID::largePileGroup2, Variant::dryBone}, {3, 2, 2808, 0}},
    {{TileID::largePileGroup2, Variant::forest}, {3, 2, 756, 0}},
    {{TileID::largePileGroup2, Variant::granite}, {3, 2, 1890, 0}},
    {{TileID::largePileGroup2, Variant::jungle}, {3, 2, 0, 0}},
    {{TileID::largePileGroup2, Variant::lihzahrd}, {3, 2, 972, 0}},
    {{TileID::largePileGroup2, Variant::livingWood}, {3, 2, 2538, 0}},
    {{TileID::largePileGroup2, Variant::livingLeaf}, {3, 2, 2700, 0}},
    {{TileID::largePileGroup2, Variant::marble}, {3, 2, 2214, 0}},
    {{TileID::largePileGroup2, Variant::sandstone}, {3, 2, 1566, 0}},
    {{TileID::largePileGroup2, Variant::spider}, {3, 2, 486, 0}},
    {{TileID::larva, Variant::none}, {3, 3, 0, 0}},
    {{TileID::lihzahrdAltar, Variant::none}, {3, 2, 0, 0}},
    {{TileID::loom, Variant::none}, {3, 2, 0, 0}},
    {{TileID::mushroomPlant, Variant::none}, {1, 1, 0, 0}},
    {{TileID::orbHeart, Variant::crimson}, {2, 2, 36, 0}},
    {{TileID::pot, Variant::corruption}, {2, 2, 0, 576}},
    {{TileID::pot, Variant::crimson}, {2, 2, 0, 792}},
    {{TileID::pot, Variant::desert}, {2, 2, 0, 1224}},
    {{TileID::pot, Variant::dungeon}, {2, 2, 0, 360}},
    {{TileID::pot, Variant::jungle}, {2, 2, 0, 252}},
    {{TileID::pot, Variant::lihzahrd}, {2, 2, 0, 1008}},
    {{TileID::pot, Variant::marble}, {2, 2, 0, 1116}},
    {{TileID::pot, Variant::pyramid}, {2, 2, 0, 900}},
    {{TileID::pot, Variant::spider}, {2, 2, 0, 684}},
    {{TileID::pot, Variant::tundra}, {2, 2, 0, 144}},
    {{TileID::pot, Variant::underworld}, {2, 2, 0, 468}},
    {{TileID::pressurePlate, Variant::lihzahrd}, {1, 1, 0, 108}},
    {{TileID::sharpeningStation, Variant::none}, {3, 2, 0, 0}},
    {{TileID::smallPile, Variant::bone}, {2, 1, 216, 0}},
    {{TileID::smallPile, Variant::dirt}, {1, 1, 108, 0}},
    {{TileID::smallPile, Variant::forest}, {2, 1, 1368, 18}},
    {{TileID::smallPile, Variant::furniture}, {2, 1, 1116, 18}},
    {{TileID::smallPile, Variant::gold}, {2, 1, 648, 18}},
    {{TileID::smallPile, Variant::granite}, {2, 1, 0, 0}},
    {{TileID::smallPile, Variant::ice}, {2, 1, 0, 0}},
    {{TileID::smallPile, Variant::livingWood}, {2, 1, 2124, 18}},
    {{TileID::smallPile, Variant::marble}, {2, 1, 0, 0}},
    {{TileID::smallPile, Variant::sandstone}, {2, 1, 0, 0}},
    {{TileID::smallPile, Variant::spider}, {2, 1, 0, 0}},
    {{TileID::smallPile, Variant::stone}, {2, 1, 0, 0}},
    {{TileID::statue, Variant::lihzahrd}, {2, 3, 1548, 0}},
    {{TileID::sunflower, Variant::none}, {2, 4, 0, 0}},
    {{TileID::tallGrassPlant, Variant::none}, {1, 1, 0, 0}},
    {{TileID::tallJunglePlant, Variant::none}, {1, 1, 0, 0}},
    {{TileID::trap, Variant::dartLeft}, {1, 1, 0, 0}},
    {{TileID::trap, Variant::dartRight}, {1, 1, 18, 0}},
    {{TileID::trap, Variant::flameLeft}, {1, 1, 0, 36}},
    {{TileID::trap, Variant::flameRight}, {1, 1, 18, 36}},
    {{TileID::trap, Variant::spear}, {1, 1, 0, 72}},
    {{TileID::trap, Variant::spikyBall}, {1, 1, 0, 54}},
    {{TileID::trap, Variant::superDartLeft}, {1, 1, 0, 18}},
    {{TileID::trap, Variant::superDartRight}, {1, 1, 18, 18}},
};

void World::placeFramedTile(int x, int y, int blockID, Variant type, int paint)
{
    if (blockID == TileID::chest &&
        (type == Variant::ashWood || type == Variant::crystal ||
         type == Variant::deadMans || type == Variant::desert ||
         type == Variant::lesion || type == Variant::reef ||
         type == Variant::sandstone)) {
        blockID = TileID::chestGroup2;
    }
    int offsetX = 0;
    int offsetY = 0;
    int frameWidth = 2;
    int frameHeight = 2;
    auto itr = tileFrameData.find({blockID, type});
    if (itr != tileFrameData.end()) {
        const FrameDetails &data = itr->second;
        offsetX = data.offsetX;
        offsetY = data.offsetY;
        frameWidth = data.width;
        frameHeight = data.height;
    }
    uint32_t coordHash = fnv1a32pt(x, y);
    if (blockID == TileID::pot) {
        // Cycle pot variations based on world coordinates.
        switch (type) {
        case Variant::crimson:
        case Variant::marble:
        case Variant::pyramid:
            offsetY += 36 * (coordHash % 3);
            break;
        case Variant::forest:
            offsetX += 36 * (coordHash % 3);
            offsetY += 36 * (coordHash % 4);
            break;
        case Variant::lihzahrd:
            offsetX += 36 * (coordHash % 2);
            offsetY += 36 * (coordHash % 3);
            break;
        default:
            offsetX += 36 * (coordHash % 3);
            offsetY += 36 * (coordHash % 3);
        }
    } else if (blockID == TileID::statue && type == Variant::lihzahrd) {
        offsetX += 36 * (coordHash % 3);
        offsetY += 162 * (coordHash % 2);
    } else if (blockID == TileID::smallPile) {
        if (type == Variant::forest && coordHash % 41 > 30) {
            type = Variant::stone;
        }
        switch (type) {
        case Variant::bone: {
            int mod = coordHash % 26;
            if (mod < 16) {
                frameWidth = 1;
                offsetX += 18 * mod;
            } else {
                offsetX += 36 * (mod - 16);
                offsetY = 18;
            }
        } break;
        case Variant::dirt:
            offsetX += 18 * (coordHash % 6);
            break;
        case Variant::forest:
        case Variant::furniture:
        case Variant::livingWood:
            offsetX += 36 * (coordHash % 3);
            break;
        case Variant::granite: {
            int mod = coordHash % 12;
            if (mod < 6) {
                frameWidth = 1;
                offsetX = 1080 + 18 * mod;
            } else {
                offsetX = 1692 + 36 * (mod - 6);
                offsetY = 18;
            }
        } break;
        case Variant::ice: {
            int mod = coordHash % 18;
            if (mod < 12) {
                frameWidth = 1;
                offsetX = 648 + 18 * mod;
            } else {
                offsetX = 900 + 36 * (mod - 12);
                offsetY = 18;
            }
        } break;
        case Variant::marble: {
            int mod = coordHash % 12;
            if (mod < 6) {
                frameWidth = 1;
                offsetX = 1188 + 18 * mod;
            } else {
                offsetX = 1908 + 36 * (mod - 6);
                offsetY = 18;
            }
        } break;
        case Variant::sandstone: {
            int mod = coordHash % 12;
            if (mod < 6) {
                frameWidth = 1;
                offsetX = 972 + 18 * mod;
            } else {
                offsetX = 1476 + 36 * (mod - 6);
                offsetY = 18;
            }
        } break;
        case Variant::spider: {
            int mod = coordHash % 10;
            if (mod < 6) {
                frameWidth = 1;
                offsetX = 864 + 18 * mod;
            } else {
                offsetX = 1224 + 36 * (mod - 6);
                offsetY = 18;
            }
        } break;
        case Variant::stone: {
            int mod = coordHash % 12;
            if (mod < 6) {
                frameWidth = 1;
                offsetX = 18 * mod;
            } else {
                offsetX = 36 * (mod - 6);
                offsetY = 18;
            }
        } break;
        default:
            break;
        }
    } else if (
        blockID == TileID::largePile || blockID == TileID::largePileGroup2) {
        switch (type) {
        case Variant::ash:
        case Variant::dryBone:
        case Variant::forest:
        case Variant::lihzahrd:
        case Variant::livingWood:
        case Variant::mushroom:
            offsetX += 54 * (coordHash % 3);
            break;
        case Variant::bone:
        case Variant::granite:
        case Variant::ice:
        case Variant::jungle:
        case Variant::marble:
        case Variant::sandstone:
        case Variant::stone:
            offsetX += 54 * (coordHash % 6);
            break;
        case Variant::furniture:
            offsetX += 54 * (coordHash % 4);
            break;
        case Variant::livingLeaf:
            offsetX += 54 * (coordHash % 2);
            break;
        case Variant::spider:
            offsetX += 54 * (coordHash % 5);
            break;
        default:
            break;
        }
    } else {
        switch (blockID) {
        case TileID::ashPlant:
            offsetX += 18 * (coordHash % 11);
            break;
        case TileID::corruptPlant:
        case TileID::crimsonPlant:
            offsetX += 18 * (coordHash % 23);
            break;
        case TileID::grassPlant:
        case TileID::tallGrassPlant: {
            int mod = coordHash % (coordHash % 7 == 1 ? 45 : 6);
            if (mod == 8 && blockID == TileID::tallGrassPlant) {
                mod = coordHash % 6;
            }
            offsetX += 18 * mod;
        } break;
        case TileID::junglePlant: {
            int mod = coordHash % (coordHash % 7 == 1 ? 23 : 6);
            if ((mod == 8 && y < getCavernLevel()) ||
                (mod == 9 && y < getUndergroundLevel())) {
                mod = coordHash % 6;
            }
            offsetX += 18 * mod;
        } break;
        case TileID::largeJunglePlant: {
            int mod = coordHash % 21;
            if (mod > 8) {
                offsetX = 36 * (mod - 9);
                offsetY = 36;
            } else {
                frameWidth = 3;
                offsetX += 54 * mod;
            }
        } break;
        case TileID::mushroomPlant:
            offsetX += 18 * (coordHash % 5);
            break;
        case TileID::tallJunglePlant: {
            int mod = coordHash % (coordHash % 7 == 1 ? 17 : 6);
            if (mod == 8) {
                mod = coordHash % 6;
            }
            offsetX += 18 * mod;
        } break;
        case TileID::sunflower:
            offsetX += 36 * (coordHash % 3);
            break;
        case TileID::tombstone:
            offsetX += 36 * (coordHash % 11);
            break;
        }
    }
    for (int i = 0; i < frameWidth; ++i) {
        for (int j = 0; j < frameHeight; ++j) {
            Tile &tile = getTile(x + i, y + j);
            tile.blockID = blockID;
            tile.frameX = 18 * i + offsetX;
            tile.frameY = 18 * j + offsetY;
            if (paint != Paint::none) {
                tile.blockPaint = paint;
            }
        }
    }
}

struct PaintingDetails {
    int blockID;
    int offsetX;
    int offsetY;
};

inline const std::map<Painting, PaintingDetails> paintingData{
    {Painting::americanExplosive, {TileID::painting2x3, 180, 0}},
    {Painting::darkness, {TileID::painting2x3, 36, 0}},
    {Painting::darkSoulReaper, {TileID::painting2x3, 72, 0}},
    {Painting::gloriousNight, {TileID::painting2x3, 216, 0}},
    {Painting::happyLittleTree, {TileID::painting2x3, 684, 0}},
    {Painting::land, {TileID::painting2x3, 108, 0}},
    {Painting::secrets, {TileID::painting2x3, 756, 0}},
    {Painting::strangeDeadFellows, {TileID::painting2x3, 720, 0}},
    {Painting::strangeGrowth, {TileID::painting2x3, 540, 0}},
    {Painting::sufficientlyAdvanced, {TileID::painting2x3, 504, 0}},
    {Painting::trappedGhost, {TileID::painting2x3, 144, 0}},
    {Painting::auroraBorealis, {TileID::painting3x2, 0, 1296}},
    {Painting::bifrost, {TileID::painting3x2, 0, 1188}},
    {Painting::bioluminescence, {TileID::painting3x2, 0, 1080}},
    {Painting::demonsEye, {TileID::painting3x2, 0, 0}},
    {Painting::livingGore, {TileID::painting3x2, 0, 576}},
    {Painting::findingGold, {TileID::painting3x2, 0, 36}},
    {Painting::flowingMagma, {TileID::painting3x2, 0, 612}},
    {Painting::forestTroll, {TileID::painting3x2, 0, 1260}},
    {Painting::heartlands, {TileID::painting3x2, 0, 1224}},
    {Painting::vikingVoyage, {TileID::painting3x2, 0, 1152}},
    {Painting::wildflowers, {TileID::painting3x2, 0, 1116}},
    {Painting::aHorribleNightForAlchemy, {TileID::painting3x3, 324, 108}},
    {Painting::bloodMoonRising, {TileID::painting3x3, 648, 0}},
    {Painting::boneWarp, {TileID::painting3x3, 810, 0}},
    {Painting::catSword, {TileID::painting3x3, 540, 108}},
    {Painting::crownoDevoursHisLunch, {TileID::painting3x3, 1836, 0}},
    {Painting::discover, {TileID::painting3x3, 1404, 0}},
    {Painting::fairyGuides, {TileID::painting3x3, 270, 108}},
    {Painting::fatherOfSomeone, {TileID::painting3x3, 1296, 0}},
    {Painting::gloryOfTheFire, {TileID::painting3x3, 756, 0}},
    {Painting::guidePicasso, {TileID::painting3x3, 1188, 0}},
    {Painting::handEarth, {TileID::painting3x3, 1458, 0}},
    {Painting::hangingSkeleton, {TileID::painting3x3, 918, 0}},
    {Painting::impFace, {TileID::painting3x3, 1620, 0}},
    {Painting::morningHunt, {TileID::painting3x3, 378, 108}},
    {Painting::nurseLisa, {TileID::painting3x3, 1350, 0}},
    {Painting::oldMiner, {TileID::painting3x3, 1512, 0}},
    {Painting::ominousPresence, {TileID::painting3x3, 1674, 0}},
    {Painting::outcast, {TileID::painting3x3, 216, 108}},
    {Painting::rareEnchantment, {TileID::painting3x3, 1890, 0}},
    {Painting::shiningMoon, {TileID::painting3x3, 1728, 0}},
    {Painting::skelehead, {TileID::painting3x3, 1566, 0}},
    {Painting::skellingtonJSkellingsworth, {TileID::painting3x3, 972, 0}},
    {Painting::sunflowers, {TileID::painting3x3, 1080, 0}},
    {Painting::terrarianGothic, {TileID::painting3x3, 1134, 0}},
    {Painting::theCursedMan, {TileID::painting3x3, 1026, 0}},
    {Painting::theGuardiansGaze, {TileID::painting3x3, 1242, 0}},
    {Painting::theHangedMan, {TileID::painting3x3, 702, 0}},
    {Painting::theMerchant, {TileID::painting3x3, 1782, 0}},
    {Painting::wallSkeleton, {TileID::painting3x3, 864, 0}},
    {Painting::catacomb1, {TileID::catacomb, 0, 0}},
    {Painting::catacomb2, {TileID::catacomb, 0, 54}},
    {Painting::catacomb3, {TileID::catacomb, 0, 108}},
    {Painting::catacomb4, {TileID::catacomb, 0, 162}},
    {Painting::catacomb5, {TileID::catacomb, 0, 216}},
    {Painting::catacomb6, {TileID::catacomb, 0, 270}},
    {Painting::catacomb7, {TileID::catacomb, 0, 324}},
    {Painting::catacomb8, {TileID::catacomb, 0, 378}},
    {Painting::catacomb9, {TileID::catacomb, 0, 432}},
    {Painting::ancientTablet, {TileID::painting6x4, 108, 936}},
    {Painting::dryadisque, {TileID::painting6x4, 0, 360}},
    {Painting::facingTheCerebralMastermind, {TileID::painting6x4, 0, 936}},
    {Painting::goblinsPlayingPoker, {TileID::painting6x4, 0, 288}},
    {Painting::greatWave, {TileID::painting6x4, 0, 792}},
    {Painting::impact, {TileID::painting6x4, 0, 432}},
    {Painting::lakeOfFire, {TileID::painting6x4, 0, 1008}},
    {Painting::lifeAboveTheSand, {TileID::painting6x4, 108, 720}},
    {Painting::oasis, {TileID::painting6x4, 108, 792}},
    {Painting::poweredByBirds, {TileID::painting6x4, 0, 504}},
    {Painting::somethingEvilIsWatchingYou, {TileID::painting6x4, 0, 72}},
    {Painting::sparky, {TileID::painting6x4, 108, 216}},
    {Painting::starryNight, {TileID::painting6x4, 0, 864}},
    {Painting::theCreationOfTheGuide, {TileID::painting6x4, 0, 1152}},
    {Painting::theDestroyer, {TileID::painting6x4, 0, 576}},
    {Painting::theEyeSeesTheEnd, {TileID::painting6x4, 0, 0}},
    {Painting::thePersistencyOfEyes, {TileID::painting6x4, 0, 648}},
    {Painting::theScreamer, {TileID::painting6x4, 0, 216}},
    {Painting::theTwinsHaveAwoken, {TileID::painting6x4, 0, 144}},
    {Painting::trioSuperHeroes, {TileID::painting6x4, 0, 1080}},
    {Painting::unicornCrossingTheHallows, {TileID::painting6x4, 0, 720}},
};

void World::placePainting(int x, int y, Painting painting)
{
    auto itr = paintingData.find(painting);
    if (itr == paintingData.end()) {
        std::cout << "Failed to find painting data\n";
        return;
    }
    auto [blockID, offsetX, offsetY] = itr->second;
    auto [frameWidth, frameHeight] = framedTileToDims(blockID);
    if (painting == Painting::strangeGrowth) {
        offsetX += 36 * (fnv1a32pt(x, y) % 4);
    }
    for (int i = 0; i < frameWidth; ++i) {
        for (int j = 0; j < frameHeight; ++j) {
            Tile &tile = getTile(x + i, y + j);
            tile.blockID = blockID;
            tile.frameX = 18 * i + offsetX;
            tile.frameY = 18 * j + offsetY;
        }
    }
}

Point World::getPaintingDims(Painting painting)
{
    auto itr = paintingData.find(painting);
    if (itr == paintingData.end()) {
        return {0, 0};
    }
    return framedTileToDims(itr->second.blockID);
}

Chest &World::placeChest(int x, int y, Variant type)
{
    placeFramedTile(x, y, TileID::chest, type);
    return chests.emplace_back(x, y);
}

Chest &World::registerStorage(int x, int y)
{
    return chests.emplace_back(x, y);
}

bool World::isExposed(int x, int y) const
{
    if (x < 1 || x >= width - 1 || y < 1 || y >= height - 1) {
        return false;
    }
    for (int i = -1; i < 2; ++i) {
        for (int j = -1; j < 2; ++j) {
            int tileId = tiles[(y + j) + (x + i) * height].blockID;
            if (tileId == TileID::empty || tileId == TileID::minecartTrack) {
                return true;
            }
        }
    }
    return false;
}

bool World::isIsolated(int x, int y) const
{
    if (x < 1 || x >= width - 1 || y < 1 || y >= height - 1) {
        return false;
    }
    for (int i = -1; i < 2; ++i) {
        for (int j = -1; j < 2; ++j) {
            if (i == 0 && j == 0) {
                continue;
            }
            if (tiles[(y + j) + (x + i) * height].blockID != TileID::empty) {
                return false;
            }
        }
    }
    return true;
}

void World::planBiomes(Random &rnd)
{
    std::cout << "Planning biomes\n";
    for (int tries = 0; tries < 1000; ++tries) {
        if (conf.spawn == SpawnPoint::ashen) {
            desertCenter = rnd.getDouble(0.09, 0.41);
            if (rnd.getBool()) {
                desertCenter = 1 - desertCenter;
            }
        } else {
            desertCenter = rnd.getDouble(0.09, 0.91);
        }
        if (conf.hiveQueen) {
            jungleCenter = rnd.getDouble(0.39, 0.61);
        } else {
            jungleCenter = rnd.getDouble(0.12, 0.39);
            if (rnd.getBool()) {
                jungleCenter = 1 - jungleCenter;
            }
        }
        if (conf.spawn == SpawnPoint::ashen) {
            snowCenter = rnd.getDouble(0.12, 0.41);
            if (rnd.getBool()) {
                snowCenter = 1 - snowCenter;
            }
        } else {
            snowCenter = rnd.getDouble(0.12, 0.88);
        }

        if (std::abs(desertCenter - jungleCenter) >
                0.075 * std::lerp(
                            conf.desertSize + conf.jungleSize,
                            2.0,
                            tries / 1000.0) &&
            std::abs(desertCenter - snowCenter) >
                0.075 * std::lerp(
                            conf.desertSize + conf.snowSize,
                            2.0,
                            tries / 1000.0) &&
            std::abs(snowCenter - jungleCenter) >
                0.075 * std::lerp(
                            conf.snowSize + conf.jungleSize,
                            2.0,
                            tries / 1000.0)) {
            break;
        }
    }
    desertCenter *= width;
    jungleCenter *= width;
    snowCenter *= width;
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/World.h`
```
#ifndef WORLD_H
#define WORLD_H

#include "Chest.h"
#include "Point.h"
#include "Tile.h"
#include "ids/Biome.h"
#include "ids/TileVariant.h"
#include <cstdint>
#include <functional>
#include <vector>

struct Config;
class Random;
class TileBuffer;

enum class Blend { normal, blockOnly };

uint32_t fnv1a32pt(uint32_t x, uint32_t y);

struct BiomeData {
    Biome active;
    double forest;
    double snow;
    double desert;
    double jungle;
    double underworld;
};

class World
{
private:
    int width;
    int height;
    Tile scratchTile;
    std::vector<Tile> tiles;
    std::vector<Chest> chests;
    std::vector<bool> framedTiles;
    std::vector<int> surface;
    std::vector<BiomeData> biomeMap;

public:
    World(const Config &c);

    int getWidth() const;
    int getHeight() const;
    int &getSurfaceLevel(int x);
    int getUndergroundLevel() const;
    int getCavernLevel() const;
    int getUnderworldLevel() const;
    Tile &getTile(int x, int y);
    Tile &getTile(Point pt)
    {
        return getTile(pt.x, pt.y);
    }
    BiomeData &getBiome(int x, int y);
    std::vector<Point> placeBuffer(
        int x,
        int y,
        const TileBuffer &data,
        Blend blendMode = Blend::normal);
    void placeFramedTile(
        int x,
        int y,
        int blockID,
        Variant type = Variant::none,
        int paint = 0);
    void placePainting(int x, int y, Painting painting);
    Point getPaintingDims(Painting painting);
    Chest &placeChest(int x, int y, Variant type);
    Chest &registerStorage(int x, int y);

    std::vector<Chest> &getChests()
    {
        return chests;
    }

    const std::vector<bool> &getFramedTiles() const
    {
        return framedTiles;
    }

    /**
     * Check if all tiles in the area pass a predicate.
     */
    template <typename Func>
    bool regionPasses(int x, int y, int width, int height, Func f)
    {
        for (int i = 0; i < width; ++i) {
            for (int j = 0; j < height; ++j) {
                if (!f(getTile(x + i, y + j))) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Check if the given location is not solidly surrounded by tiles.
     */
    bool isExposed(int x, int y) const;
    /**
     * Check if the given location is surrounded exclusively by empty tiles.
     */
    bool isIsolated(int x, int y) const;
    /**
     * Select desert, jungle, and snow locations.
     */
    void planBiomes(Random &rnd);

    const Config &conf;

    bool isCrimson;
    int copperVariant;
    int ironVariant;
    int silverVariant;
    int goldVariant;
    int cobaltVariant;
    int mythrilVariant;
    int adamantiteVariant;

    Point spawn;

    double desertCenter;
    double jungleCenter;
    double snowCenter;
    int surfaceEvilCenter;
    int oceanCaveCenter;
    Point aether;
    Point dungeon;
    Point gemGrove;
    int gemGroveSize;
    std::vector<Point> mushroomCenter;

    std::vector<std::function<void(Random &, World &)>> queuedEvil;
    std::vector<std::function<void(Random &, World &)>> queuedDeco;
    std::vector<std::function<void(Random &, World &)>> queuedTraps;
    std::vector<std::function<void(Random &, World &)>> queuedTreasures;
};

#endif // WORLD_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Writer.cpp`
```
#include "Writer.h"

#include <bit>

namespace
{

template <typename NumberType, size_t byteCount>
void writeLittleEndian(std::ostream &out, NumberType val)
{
    for (size_t i = 0; i < byteCount; ++i) {
        out.put(0xff & val);
        val >>= 8;
    }
}

} // namespace

Writer::Writer(const std::string &filename) : out(filename, std::ios::binary) {}

void Writer::putBitVec(const std::vector<bool> &vec)
{
    uint8_t buf = 0;
    int offset = 0;
    for (bool val : vec) {
        if (val) {
            buf |= (1 << offset);
        }
        ++offset;
        if (offset >= 8) {
            out.put(buf);
            buf = 0;
            offset = 0;
        }
    }
    if (offset != 0) {
        out.put(buf);
    }
}

void Writer::putBool(bool val)
{
    out.put(val ? 1 : 0);
}

void Writer::putFloat32(float32_t val)
{
    if constexpr (std::endian::native == std::endian::big) {
        putUint32(std::bit_cast<std::uint32_t>(val));
    } else {
        out.write(reinterpret_cast<const char *>(&val), sizeof(float32_t));
    }
}

void Writer::putFloat64(float64_t val)
{
    if constexpr (std::endian::native == std::endian::big) {
        putUint64(std::bit_cast<std::uint64_t>(val));
    } else {
        out.write(reinterpret_cast<const char *>(&val), sizeof(float64_t));
    }
}

void Writer::putString(const std::string &val)
{
    // LEB128 encoded length prefix.
    size_t len = val.size();
    do {
        uint8_t b = len & 0x7f;
        len >>= 7;
        if (len != 0) {
            b |= 0x80;
        }
        out.put(b);
    } while (len != 0);
    out.write(val.c_str(), val.size());
}

void Writer::putUint8(uint8_t val)
{
    out.put(val);
}

void Writer::putUint16(uint16_t val)
{
    writeLittleEndian<uint16_t, 2>(out, val);
}

void Writer::putUint32(uint32_t val)
{
    writeLittleEndian<uint32_t, 4>(out, val);
}

void Writer::putUint64(uint64_t val)
{
    writeLittleEndian<uint64_t, 8>(out, val);
}

void Writer::skipBytes(size_t len)
{
    for (size_t i = 0; i < len; ++i) {
        out.put(0);
    }
}

void Writer::seekp(uint32_t pos)
{
    out.seekp(pos);
}

uint32_t Writer::tellp()
{
    return out.tellp();
}

void Writer::write(const char *val, size_t len)
{
    out.write(val, len);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/Writer.h`
```
#ifndef WRITER_H
#define WRITER_H

#include "vendor/ieee754_types.hpp"
#include <cstdint>
#include <fstream>
#include <vector>

typedef IEEE_754::_2008::Binary<32> float32_t;
typedef IEEE_754::_2008::Binary<64> float64_t;

class Writer
{
private:
    std::ofstream out;

public:
    Writer(const std::string &filename);

    void putBitVec(const std::vector<bool> &vec);
    void putBool(bool val);
    void putFloat32(float32_t val);
    void putFloat64(float64_t val);
    void putString(const std::string &val);
    void putUint8(uint8_t val);
    void putUint16(uint16_t val);
    void putUint32(uint32_t val);
    void putUint64(uint64_t val);
    void skipBytes(size_t len);
    void seekp(uint32_t pos);
    uint32_t tellp();
    void write(const char *val, size_t len);
};

#endif // WRITER_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/biomes`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Aether.cpp`
```
#include "Aether.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <iostream>

/**
 * Distort nearby tiles in a wave pattern.
 */
void applyAetherDistortion(int centerX, int centerY, double size, World &world)
{
    int maxX = std::min<int>(centerX + size, world.getWidth());
    int minY = std::max<int>(centerY - size, 1);
    int maxY = std::min<int>(centerY + size, world.getHeight() - 1);
    for (int x = std::max<int>(centerX - size, 0); x < maxX; ++x) {
        double distortion = 23 * std::sin(0.11 * x);
        if (distortion > 0) {
            for (int y = minY; y < maxY; ++y) {
                int delta = distortion *
                            std::min(
                                1 - std::hypot(x - centerX, y - centerY) / size,
                                0.5);
                if (delta > 0) {
                    world.getTile(x, y) = world.getTile(
                        x,
                        std::min(y + delta, world.getHeight() - 1));
                }
            }
        } else {
            for (int y = maxY - 1; y > minY; --y) {
                int delta = distortion *
                            std::min(
                                1 - std::hypot(x - centerX, y - centerY) / size,
                                0.5);
                if (delta < 0) {
                    world.getTile(x, y) =
                        world.getTile(x, std::max(y + delta, 0));
                }
            }
        }
    }
}

void genAether(Random &rnd, World &world)
{
    std::cout << "Bridging realities\n";
    rnd.shuffleNoise();
    int centerX = world.getWidth() * rnd.getDouble(0.08, 0.30);
    if (rnd.getBool()) {
        centerX = world.getWidth() - centerX;
    }
    int centerY = rnd.getInt(
        (world.getUndergroundLevel() + 2 * world.getCavernLevel()) / 3,
        (world.getCavernLevel() + 5 * world.getUnderworldLevel()) / 6);
    double size =
        world.conf.aetherSize * (25 + world.getWidth() * world.getHeight() /
                                          rnd.getDouble(274000, 384000));
    applyAetherDistortion(centerX, centerY, size * 3.2, world);
    int maxBubblePos = centerY;
    int maxEditPos = centerY;
    std::vector<Point> mossLocations;
    for (int x = centerX - size; x < centerX + size; ++x) {
        for (int y = centerY - size; y < centerY + size; ++y) {
            double centralPropo = std::hypot(x - centerX, y - centerY) / size;
            double noiseVal =
                std::max(
                    std::abs(rnd.getBlurNoise(4 * x, 4 * y)),
                    std::abs(
                        rnd.getBlurNoise(4 * x + centerX, 4 * y + centerY))) *
                std::min(1.0, 3 * (1 - centralPropo));
            Tile &tile = world.getTile(x, y);
            if (noiseVal > 0.45) {
                // Solid bubbles.
                tile.blockID = TileID::bubble;
                maxBubblePos = std::max(maxBubblePos, y);
            } else if (noiseVal > 0.09) {
                tile.blockID = TileID::empty;
            } else if (noiseVal > 0.02) {
                // Seal entrances with aetherium.
                tile.blockID = tile.blockID == TileID::empty ? TileID::aetherium
                               : centralPropo < 0.6 ? TileID::heliumMossStone
                                                    : TileID::stone;
                mossLocations.emplace_back(x, y);
            }
            if (noiseVal > 0.019) {
                tile.wallID = WallID::empty;
                maxEditPos = std::max(maxEditPos, y);
            }
        }
    }
    world.queuedDeco.emplace_back([mossLocations](Random &, World &world) {
        for (auto [x, y] : mossLocations) {
            growMossOn(x, y, world);
        }
    });
    fillAetherShimmer(
        centerX,
        centerY,
        size,
        maxBubblePos,
        maxEditPos,
        rnd,
        world);
}

void fillAetherShimmer(
    int centerX,
    int centerY,
    double size,
    int maxBubblePos,
    int maxEditPos,
    Random &rnd,
    World &world)
{
    world.aether = {centerX, centerY};
    for (int x = centerX - size; x < centerX + size; ++x) {
        for (int y = centerY - size; y < centerY + size; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::bubble && world.isExposed(x, y)) {
                // Find bubble edges.
                tile.echoCoatBlock = true;
            } else if (
                tile.blockID == TileID::heliumMossStone &&
                !world.isExposed(x, y)) {
                // Remove interior moss tiles.
                tile.blockID = TileID::stone;
            }
        }
    }
    for (int x = centerX - size; x < centerX + size; ++x) {
        for (int y = centerY - size; y < centerY + size; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::bubble && !tile.echoCoatBlock) {
                // Replace bubble interiors with shimmer.
                tile.blockID = TileID::empty;
                tile.liquid = Liquid::shimmer;
            }
        }
    }
    for (int x = centerX - size; x < centerX + size; ++x) {
        for (int y = maxBubblePos + 1; y < maxEditPos + 1; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::empty) {
                if (std::hypot(x - centerX, y - centerY) < size - 2) {
                    // Shimmer pool adjacent to the lowest bubble.
                    tile.liquid = Liquid::shimmer;
                } else {
                    Tile &prevTile = world.getTile(x, y - 1);
                    if (prevTile.liquid == Liquid::shimmer) {
                        prevTile.liquid = Liquid::none;
                        prevTile.blockID = TileID::aetherium;
                    }
                }
            }
        }
    }
    embedWaterfalls(
        {centerX - size, centerY - size},
        {centerX + size, centerY + size},
        {TileID::aetherium},
        Liquid::shimmer,
        16,
        rnd,
        world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Aether.h`
```
#ifndef AETHER_H
#define AETHER_H

class World;
class Random;

void genAether(Random &rnd, World &world);
void fillAetherShimmer(
    int centerX,
    int centerY,
    double size,
    int maxBubblePos,
    int maxEditPos,
    Random &rnd,
    World &world);

#endif // AETHER_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/AshenField.cpp`
```
#include "AshenField.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

void genAshenField(Random &rnd, World &world)
{
    if (world.conf.spawn != SpawnPoint::ashen &&
        (world.conf.spawn != SpawnPoint::surface ||
         rnd.getDouble(0, 1) > 0.7)) {
        return;
    }
    double width = 100 + world.getWidth() / rnd.getInt(64, 85);
    if (world.conf.shattered) {
        width *= 0.82;
    }
    int minX = world.spawn.x - width;
    int maxX = world.spawn.x + width;
    int minY = std::min(
                   {world.spawn.y,
                    world.getSurfaceLevel(minX),
                    world.getSurfaceLevel(maxX)}) -
               20;
    int maxY = std::midpoint<double>(minY + width, world.getUndergroundLevel());
    constexpr auto avoidTiles = frozen::make_set<int>({
        TileID::snow,
        TileID::sandstone,
        TileID::granite,
        TileID::marble,
        TileID::jungleGrass,
        TileID::livingWood,
    });
    if (!world.regionPasses(
            minX,
            minY,
            maxX - minX,
            maxY - minY,
            [&avoidTiles](Tile &tile) {
                return !avoidTiles.contains(tile.blockID);
            })) {
        return;
    }
    std::cout << "Managing wildfire\n";
    rnd.shuffleNoise();
    std::map<int, int> underworldWalls;
    for (int wallId : WallVariants::dirt) {
        underworldWalls[wallId] = rnd.select(WallVariants::underworld);
    }
    std::map<int, int> stoneWalls;
    for (int wallId : WallVariants::dirt) {
        stoneWalls[wallId] = rnd.select(WallVariants::stone);
    }
    double height = maxY - world.spawn.y;
    for (int x = minX; x < maxX; ++x) {
        int surface = scanWhileEmpty({x, minY}, {0, 1}, world).y;
        surface = std::lerp(
            world.spawn.y,
            surface < world.getUndergroundLevel() ? surface
                                                  : world.getSurfaceLevel(x),
            std::abs(x - world.spawn.x) / width);
        for (int y = minY; y < maxY; ++y) {
            double threshold = std::hypot(
                (x - world.spawn.x) / width,
                (y - world.spawn.y) / height);
            if (rnd.getFineNoise(x, y) < 9 * threshold - 8) {
                continue;
            }
            Tile &tile = world.getTile(x, y);
            if (y <= surface) {
                tile.blockID = TileID::empty;
                tile.wallID = WallID::empty;
                continue;
            }
            if (threshold > 0.2 && std::abs(rnd.getCoarseNoise(3 * x, 3 * y)) <
                                       std::min(1.0, 5.8 - 7 * threshold) *
                                           (0.05 + 0.3 * (y - minY) / height)) {
                tile.blockID = TileID::empty;
                tile.wallID = y > surface + 2 ? underworldWalls[tile.wallID]
                                              : WallID::empty;
                if (y > surface + 1) {
                    tile.liquid = Liquid::lava;
                }
                continue;
            }
            switch (tile.blockID) {
            case TileID::dirt:
            case TileID::grass:
                tile.blockID = TileID::ash;
                break;
            case TileID::empty:
            case TileID::stone:
            case TileID::mud:
            case TileID::sand:
            case TileID::clay:
                tile.blockID =
                    y > world.spawn.y + 10 ? TileID::obsidian : TileID::ash;
                break;
            default:
                break;
            }
            if (tile.blockID == TileID::ash) {
                if (y - 3 < surface &&
                    world.getTile(x, y - 1).blockID == TileID::empty) {
                    tile.blockID = TileID::ashGrass;
                } else {
                    tile.wallID = underworldWalls[tile.wallID];
                }
            } else if (tile.blockID == TileID::obsidian) {
                tile.wallID = stoneWalls[tile.wallID];
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/AshenField.h`
```
#ifndef ASHENFIELD_H
#define ASHENFIELD_H

class World;
class Random;

void genAshenField(Random &rnd, World &world);

#endif // ASHENFIELD_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/AsteroidField.cpp`
```
#include "biomes/AsteroidField.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include <iostream>

std::pair<int, int>
selectAsteroidFieldLocation(int &width, int height, Random &rnd, World &world)
{
    int y = 40;
    double widthF = width;
    double widthDelta = widthF / 2500;
    while (true) {
        int x =
            rnd.getInt(40, std::max<int>(0.3 * world.getWidth() - widthF, 45));
        if (rnd.getBool()) {
            x = world.getWidth() - x - widthF;
        }
        if (world.regionPasses(
                x + 0.1 * widthF,
                y,
                0.8 * widthF,
                height,
                [](Tile &tile) {
                    return tile.blockID == TileID::empty ||
                           tile.flag == Flag::border;
                })) {
            width = std::midpoint<int>(width, widthF);
            return {x, y};
        }
        widthF -= widthDelta;
    }
}

void genAsteroidField(Random &rnd, World &world)
{
    doGenAsteroidField(
        [&rnd](int x, int y, double radius, std::function<void(int, int)> f) {
            for (int i = -radius; i < radius; ++i) {
                for (int j = -radius; j < radius; ++j) {
                    if (std::hypot(i, j) / radius <
                        0.6 + 0.6 * rnd.getFineNoise(x + i, y + j)) {
                        f(i, j);
                    }
                }
            }
        },
        rnd,
        world);
}

void doGenAsteroidField(
    std::function<void(int, int, double, std::function<void(int, int)>)>
        iterateAsteroid,
    Random &rnd,
    World &world)
{
    std::cout << "Suspending asteroids\n";
    int width =
        world.conf.asteroids * rnd.getDouble(0.06, 0.07) * world.getWidth();
    int height = rnd.getDouble(0.18, 0.21) * world.getUndergroundLevel();
    auto [fieldX, fieldY] =
        selectAsteroidFieldLocation(width, height, rnd, world);
    int numAsteroids = width * height / 220;
    for (int tries = 10 * numAsteroids; numAsteroids > 0 && tries > 0;
         --tries) {
        double radius = rnd.getDouble(2, 9);
        int x = rnd.getInt(fieldX + radius, fieldX + width - radius);
        int y = rnd.getInt(fieldY + radius, fieldY + height - radius);
        double centerDist = std::hypot(
            (fieldX + 0.5 * width - x) / width,
            (fieldY + 0.5 * height - y) / height);
        if ((centerDist > 0.48 && fnv1a32pt(x, y) % 11 != 0) ||
            !world.regionPasses(
                x - radius,
                y - radius,
                2 * radius + 0.5,
                2 * radius + 0.5,
                [](Tile &tile) { return tile.blockID == TileID::empty; })) {
            continue;
        }
        int paint = rnd.select({Paint::brown, Paint::black});
        iterateAsteroid(
            x,
            y,
            radius,
            [x, y, radius, paint, &rnd, &world](int i, int j) {
                Tile &tile = world.getTile(x + i, y + j);
                tile.blockID =
                    std::min(
                        std::abs(rnd.getFineNoise(x + i, j + radius)),
                        std::abs(rnd.getFineNoise(i + radius, y + j))) < 0.03
                        ? TileID::meteorite
                        : TileID::stone;
                tile.blockPaint = paint;
            });
        --numAsteroids;
    }
    for (int i = 0; i < width; ++i) {
        for (int j = 0; j < height; ++j) {
            Tile &tile = world.getTile(fieldX + i, fieldY + j);
            if ((tile.blockID == TileID::stone ||
                 tile.blockID == TileID::meteorite) &&
                world.isExposed(fieldX + i, fieldY + j)) {
                tile.actuated = true;
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/AsteroidField.h`
```
#ifndef ASTEROIDFIELD_H
#define ASTEROIDFIELD_H

#include <functional>

class World;
class Random;

std::pair<int, int>
selectAsteroidFieldLocation(int &width, int height, Random &rnd, World &world);

void genAsteroidField(Random &rnd, World &world);

void doGenAsteroidField(
    std::function<void(int, int, double, std::function<void(int, int)>)>
        iterateAsteroid,
    Random &rnd,
    World &world);

#endif // ASTEROIDFIELD_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Base.cpp`
```
#include "Base.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <algorithm>
#include <iostream>

void computeSurfaceLevel(Random &rnd, World &world)
{
    double surfaceLevel = rnd.getDouble(
        0.7 * world.getUndergroundLevel(),
        0.8 * world.getUndergroundLevel());
    int center = world.getWidth() / 2;
    int delta = 0;
    int deltaLen = 1;
    int prevY = surfaceLevel;
    // Keep surface terrain mostly level near spawn and oceans.
    for (int x = 0; x < world.getWidth(); ++x) {
        double drop =
            world.conf.sunken && !world.conf.shattered
                ? 120 * (1 / (1 + std::exp(0.057 * (180 + center - x))) +
                         1 / (1 + std::exp(0.057 * (180 + x - center)))) -
                      90
                : 0;
        int curY = surfaceLevel + drop +
                   std::min(
                       {0.1 * std::abs(center - x) + 15,
                        0.08 * std::min(x, world.getWidth() - x) + 5,
                        world.conf.surfaceAmplitude * 50.0}) *
                       rnd.getCoarseNoise(x, 0);
        world.getSurfaceLevel(x) = curY;
        if (delta == curY - prevY) {
            ++deltaLen;
        } else {
            if (deltaLen > 4 && (delta == 1 || delta == -1)) {
                // Break up boring slopes.
                for (int i = 0; i < deltaLen; ++i) {
                    world.getSurfaceLevel(x - i) +=
                        9 * (0.5 - std::abs(i - 0.5 * deltaLen) / deltaLen) *
                        rnd.getFineNoise(x - 2 * i, 0);
                }
            }
            delta = curY - prevY;
            deltaLen = 1;
        }
        prevY = curY;
    }
}

inline std::array const snowTiles{
    TileID::snow,
    TileID::snow,
    TileID::ice,
    TileID::stone,
    TileID::thinIce,
    TileID::slush};
inline std::array const desertTiles{
    TileID::sand,
    TileID::sand,
    TileID::sandstone,
    TileID::desertFossil,
    TileID::desertFossil,
    TileID::desertFossil};
inline std::array const jungleTiles{
    TileID::mud,
    TileID::jungleGrass,
    TileID::mud,
    TileID::clay,
    TileID::silt,
    TileID::stone};
inline std::array const forestTiles{
    TileID::dirt,
    TileID::grass,
    TileID::stone,
    TileID::clay,
    TileID::sand,
    TileID::mud};

int getWallVarIndex(
    int x,
    int y,
    const std::vector<std::pair<int, int>> &wallVarNoise,
    Random &rnd)
{
    for (size_t idx = 0; idx < wallVarNoise.size(); ++idx) {
        auto [i, j] = wallVarNoise[idx];
        if (std::abs(rnd.getCoarseNoise(x + i, y + j)) < 0.07) {
            return idx;
        }
    }
    return -1;
}

void registerSnow(Random &rnd, World &world)
{
    std::cout << "Freezing land\n";
    rnd.shuffleNoise();
    double center = world.snowCenter;
    double scanDist = world.conf.snowSize * 0.08 * world.getWidth();
    double snowFloor =
        (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    parallelFor(
        std::views::iota(
            std::max<int>(center - scanDist, 0),
            std::min<int>(center + scanDist, world.getWidth())),
        [center, snowFloor, &rnd, &world](int x) {
            for (int y = 0; y < world.getUnderworldLevel(); ++y) {
                double threshold = std::max(
                    std::abs(x - center) / 100.0 -
                        (world.conf.snowSize * world.getWidth() / 1700.0),
                    15 * (y - snowFloor) / world.getHeight());
                BiomeData &biome = world.getBiome(x, y);
                biome.snow = std::clamp(0.45 - 0.75 * threshold, 0.0, 1.0);
                if (rnd.getCoarseNoise(x, y) > threshold) {
                    biome.active = Biome::snow;
                }
            }
        });
}

void registerDesert(Random &rnd, World &world)
{
    std::cout << "Desertification\n";
    rnd.shuffleNoise();
    double center = world.desertCenter;
    double scanDist = world.conf.desertSize * 0.08 * world.getWidth();
    double desertFloor =
        (world.getCavernLevel() + 4 * world.getUnderworldLevel()) / 5;
    parallelFor(
        std::views::iota(
            std::max<int>(center - scanDist, 0),
            std::min<int>(center + scanDist, world.getWidth())),
        [center, desertFloor, &rnd, &world](int x) {
            for (int y = 0; y < world.getUnderworldLevel(); ++y) {
                double threshold = std::max(
                    std::abs(x - center) / 100.0 -
                        (world.conf.desertSize * world.getWidth() / 1700.0),
                    15 * (y - desertFloor) / world.getHeight());
                BiomeData &biome = world.getBiome(x, y);
                biome.desert = std::clamp(0.45 - 0.75 * threshold, 0.0, 1.0);
                if (rnd.getCoarseNoise(x, y) > threshold) {
                    biome.active = Biome::desert;
                }
            }
        });
}

void registerJungle(Random &rnd, World &world)
{
    rnd.shuffleNoise();
    double center = world.jungleCenter;
    double scanDist = world.conf.jungleSize * 0.11 * world.getWidth();
    parallelFor(
        std::views::iota(
            std::max<int>(center - scanDist, 0),
            std::min<int>(center + scanDist, world.getWidth())),
        [center, &rnd, &world](int x) {
            double threshold =
                std::abs(x - center) / 100.0 -
                (world.conf.jungleSize * world.getWidth() / 1050.0);
            for (int y = 0; y < world.getHeight(); ++y) {
                BiomeData &biome = world.getBiome(x, y);
                biome.jungle = std::clamp(0.25 - 0.45 * threshold, 0.0, 1.0);
                if (rnd.getCoarseNoise(x, y) > threshold &&
                    rnd.getFineNoise(x, y) > std::abs(x - center) / 260.0 -
                                                 (world.conf.jungleSize *
                                                  world.getWidth() / 2700.0)) {
                    biome.active = Biome::jungle;
                }
            }
        });
}

void registerUnderworld(Random &rnd, World &world)
{
    rnd.shuffleNoise();
    parallelFor(std::views::iota(0, world.getWidth()), [&rnd, &world](int x) {
        int underworldLevel =
            world.getUnderworldLevel() + 20 * rnd.getCoarseNoise(x, 0);
        for (int y = 0; y < underworldLevel; ++y) {
            BiomeData &biome = world.getBiome(x, y);
            biome.forest = std::clamp(
                1 - biome.snow - biome.desert - biome.jungle,
                0.0,
                1.0);
        }
        for (int y = underworldLevel; y < world.getHeight(); ++y) {
            world.getBiome(x, y) = {Biome::underworld, 0.0, 0.0, 0.0, 0.0, 1.0};
        }
    });
}

double computeStoneThreshold(int y, World &world)
{
    std::array<std::pair<int, double>, 5> steps{{
        {0, -3},
        {world.getUndergroundLevel(), 0},
        {std::midpoint(world.getUndergroundLevel(), world.getCavernLevel()),
         world.conf.dontDigUp ? 0.8225 : 0.0918},
        {world.getCavernLevel(), world.conf.dontDigUp ? 0.1127 : 0.1836},
        {world.getUnderworldLevel(), world.conf.dontDigUp ? -0.6413 : 0.8225},
    }};
    std::pair<int, double> from;
    std::pair<int, double> to;
    for (auto step : steps) {
        from = to;
        to = step;
        if (y < to.first) {
            break;
        }
    }
    return std::lerp(
        from.second,
        to.second,
        static_cast<double>(y - from.first) / (to.first - from.first));
}

std::vector<std::tuple<int, int, int, int>> getOreLayers(World &world)
{
    if (world.conf.dontDigUp) {
        return {
            {3,
             (3 * world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 5,
             world.getUnderworldLevel(),
             world.copperVariant},
            {4,
             (world.getUndergroundLevel() + world.getCavernLevel()) / 2,
             (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3,
             world.ironVariant},
            {5,
             (4 * world.getUndergroundLevel() + world.getCavernLevel()) / 5,
             (4 * world.getCavernLevel() + world.getUnderworldLevel()) / 5,
             world.silverVariant},
            {6,
             0.6 * world.getUndergroundLevel(),
             (3 * world.getUndergroundLevel() + 5 * world.getCavernLevel()) / 8,
             world.goldVariant}};
    }
    return {
        {3,
         0.6 * world.getUndergroundLevel(),
         (world.getUndergroundLevel() + world.getCavernLevel()) / 2,
         world.copperVariant},
        {4,
         0.85 * world.getUndergroundLevel(),
         (2 * world.getCavernLevel() + world.getUnderworldLevel()) / 3,
         world.ironVariant},
        {5,
         (world.getUndergroundLevel() + world.getCavernLevel()) / 2,
         (world.getCavernLevel() + world.getUnderworldLevel()) / 2,
         world.silverVariant},
        {6,
         (2 * world.getCavernLevel() + world.getUnderworldLevel()) / 3,
         world.getUnderworldLevel(),
         world.goldVariant}};
}

void applyBaseTerrain(Random &rnd, World &world)
{
    rnd.shuffleNoise();
    // Save so later generators can match cave structures.
    rnd.saveShuffleState();
    std::vector<std::pair<int, int>> depositNoise;
    for (int iter = 0; iter < 7; ++iter) {
        depositNoise.emplace_back(
            rnd.getInt(0, world.getWidth()),
            rnd.getInt(0, world.getHeight()));
    }
    std::vector<std::pair<int, int>> wallVarNoise;
    for (size_t iter = 0; iter < WallVariants::dirt.size(); ++iter) {
        wallVarNoise.emplace_back(
            rnd.getInt(0, world.getWidth()),
            rnd.getInt(0, world.getHeight()));
    }
    computeSurfaceLevel(rnd, world);
    world.spawn = {
        world.getWidth() / 2,
        world.getSurfaceLevel(world.getWidth() / 2) - 1};
    double oreThreshold = computeOreThreshold(world.conf.ore);
    double goldThreshold = world.conf.forTheWorthy
                               ? computeOreThreshold(1.35 * world.conf.ore)
                               : oreThreshold;
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [oreThreshold,
         goldThreshold,
         underworldHeight = world.getHeight() - world.getUnderworldLevel(),
         hellstoneThreshold = -computeOreThreshold(4.24492 * world.conf.ore),
         &depositNoise,
         &wallVarNoise,
         &rnd,
         &world](int x) {
            bool nearEdge = x < 350 || x > world.getWidth() - 350;
            int underworldRoof =
                world.getUnderworldLevel() + 0.22 * underworldHeight +
                19 * rnd.getCoarseNoise(x, 0.33 * world.getHeight());
            int underworldFloor =
                world.getUnderworldLevel() + 0.42 * underworldHeight +
                35 * rnd.getCoarseNoise(x, 0.66 * world.getHeight());
            for (int y = world.getSurfaceLevel(x); y < world.getHeight(); ++y) {
                BiomeData &biome = world.getBiome(x, y);
                double threshold = computeStoneThreshold(y, world);
                int tileType = rnd.getFineNoise(
                                   x + depositNoise[0].first,
                                   y + depositNoise[1].second) > threshold
                                   ? 0
                                   : 2;
                for (int iter = 0; iter < 3; ++iter) {
                    if (rnd.getFineNoise(
                            x + depositNoise[iter].first,
                            y + depositNoise[iter].second) > 0.7) {
                        tileType = iter + 3;
                        break;
                    }
                }
                if (tileType == 0 && y < world.getUndergroundLevel() &&
                    static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) %
                            100 ==
                        0) {
                    tileType = 1;
                }
                Tile &tile = world.getTile(x, y);
                switch (biome.active) {
                case Biome::snow: {
                    tile.blockID = snowTiles[tileType];
                    int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                    if (index != -1 &&
                        fnv1a32pt(index, wallVarNoise[0].second) % 5 == 0) {
                        tile.wallID = WallVariants::stone
                            [wallVarNoise[0].first %
                             WallVariants::stone.size()];
                    } else if (index != -1 || y < world.getUndergroundLevel()) {
                        tile.wallID = tile.blockID == TileID::snow
                                          ? WallID::Unsafe::snow
                                          : WallID::Unsafe::ice;
                    }
                    break;
                }
                case Biome::desert:
                    tile.blockID = desertTiles[tileType];
                    if (y > (world.conf.dontDigUp ? world.getUndergroundLevel()
                                                  : world.getCavernLevel()) &&
                        tile.blockID == TileID::sandstone) {
                        if (std::abs(
                                rnd.getCoarseNoise(
                                    x + depositNoise[2].first,
                                    y + depositNoise[3].second) +
                                0.23) < 0.04) {
                            tile.blockID = TileID::sand;
                        } else if (
                            std::abs(
                                rnd.getCoarseNoise(
                                    x + depositNoise[2].first,
                                    y + depositNoise[3].second) -
                                0.23) < 0.04) {
                            tile.blockID = TileID::hardenedSand;
                        }
                    }
                    tile.wallID = tile.blockID == TileID::sandstone
                                      ? WallID::Unsafe::sandstone
                                      : WallID::Unsafe::hardenedSand;
                    break;
                case Biome::jungle:
                    tile.blockID = jungleTiles[tileType];
                    if (y < world.getUndergroundLevel()) {
                        tile.wallID = WallID::Unsafe::mud;
                    } else {
                        int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                        if (index != -1) {
                            tile.wallID = WallVariants::jungle
                                [fnv1a32pt(index, wallVarNoise[1].first) %
                                 WallVariants::jungle.size()];
                        }
                    }
                    break;
                case Biome::forest: {
                    tile.blockID = forestTiles[tileType];
                    int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                    if (index != -1) {
                        tile.wallID = WallVariants::dirt[index];
                    } else if (y < world.getUndergroundLevel()) {
                        tile.wallID = tile.blockID == TileID::stone
                                          ? WallID::Unsafe::rockyDirt
                                          : WallID::Unsafe::dirt;
                    }
                    break;
                }
                case Biome::underworld: {
                    if (y > underworldFloor) {
                        tile.blockID = std::abs(rnd.getFineNoise(x, y)) >
                                               hellstoneThreshold
                                           ? TileID::hellstone
                                           : TileID::ash;
                    } else if (y < underworldRoof) {
                        tile.blockID = TileID::ash;
                    }
                    int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                    if (index != -1) {
                        tile.wallID = WallVariants::underworld
                            [fnv1a32pt(index, wallVarNoise[2].first) %
                             WallVariants::underworld.size()];
                    }
                    break;
                }
                }
                threshold = 0.4 + 0.03 * rnd.getFineNoise(x, y);
                if ((biome.desert > threshold && biome.snow > threshold) ||
                    (biome.snow > 0.57 && biome.active == Biome::desert) ||
                    (biome.desert > 0.57 && biome.active == Biome::snow)) {
                    tile.blockID = TileID::marble;
                    tile.wallID = WallID::Unsafe::marble;
                }
                for (auto [idx, oreRoof, oreFloor, ore] : getOreLayers(world)) {
                    if (y > oreRoof && y < oreFloor &&
                        rnd.getFineNoise(
                            x + depositNoise[idx].first,
                            y + depositNoise[idx].second) <
                            (ore == world.goldVariant ? goldThreshold
                                                      : oreThreshold)) {
                        tile.blockID = ore;
                        break;
                    }
                }
                if (nearEdge && y < 0.9 * world.getUndergroundLevel()) {
                    continue;
                }
                threshold = y < world.getUndergroundLevel()
                                ? 2.94 - 3.1 * y / world.getUndergroundLevel()
                            : y > world.getUnderworldLevel()
                                ? 3.1 * (y - world.getUnderworldLevel()) /
                                          underworldHeight -
                                      0.16
                                : -0.16;
                if (std::abs(rnd.getCoarseNoise(x, 2 * y) + 0.1) < 0.15 &&
                    rnd.getFineNoise(x, y) > threshold) {
                    // Strings of nearly connected caves, with horizontal bias.
                    tile.blockID = TileID::empty;
                }
                threshold =
                    y > world.getUnderworldLevel()
                        ? (world.getUnderworldLevel() - y) / 10.0
                        : static_cast<double>(y - world.getUndergroundLevel()) /
                                  (world.getUnderworldLevel() -
                                   world.getUndergroundLevel()) -
                              1;
                if (std::abs(rnd.getCoarseNoise(x, 2 * y)) > 0.55 &&
                    rnd.getFineNoise(x, y) < threshold + 0.1) {
                    // Increasingly large isolated deep caves.
                    tile.blockID = TileID::empty;
                }
                if (y > world.getCavernLevel() && biome.jungle > 0.01) {
                    threshold =
                        2.0 * (y - world.getCavernLevel()) *
                            (y - world.getHeight()) /
                            std::pow(
                                world.getHeight() - world.getCavernLevel(),
                                2) +
                        0.75;
                    threshold = std::lerp(1.0, threshold, biome.jungle);
                    if (y > world.getCavernLevel() &&
                        rnd.getCoarseNoise(2 * x, 2 * y) > threshold) {
                        tile.blockID = TileID::empty;
                    }
                }
                if (biome.snow > 0.01) {
                    threshold = std::max(
                        -0.1,
                        1 + 15.0 *
                                ((world.conf.dontDigUp
                                      ? world.getUndergroundLevel()
                                      : world.getCavernLevel()) -
                                 y) /
                                world.getHeight());
                    threshold = std::lerp(1.0, threshold, biome.snow);
                    if (std::abs(rnd.getCoarseNoise(2 * x, y) + 0.1) < 0.12 &&
                        rnd.getFineNoise(x, y) > threshold) {
                        tile.blockID = tile.blockID == TileID::snow
                                           ? TileID::thinIce
                                           : TileID::empty;
                    }
                }
                if (biome.desert > 0.01) {
                    threshold = std::max(
                        1.2 + 3.0 * (world.getUndergroundLevel() - y) /
                                  world.getHeight(),
                        0.4);
                    threshold = std::lerp(1.0, threshold, biome.desert);
                    if (std::abs(rnd.getBlurNoise(x, 5 * y)) > threshold &&
                        rnd.getFineNoise(
                            x + depositNoise[4].first,
                            y + depositNoise[5].second) > -0.3 &&
                        (tile.blockID == TileID::sandstone ||
                         ((tile.blockID == TileID::sand ||
                           tile.blockID == TileID::hardenedSand) &&
                          rnd.getFineNoise(
                              x + depositNoise[2].first,
                              y + depositNoise[3].second) > 0))) {
                        tile.blockID = TileID::empty;
                    }
                }
                if (tile.blockID == TileID::empty &&
                    y < world.getUndergroundLevel()) {
                    if (biome.active == Biome::jungle) {
                        int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                        if (fnv1a32pt(index, wallVarNoise[3].second) % 3 == 0) {
                            tile.wallID = WallVariants::stone
                                [fnv1a32pt(index, wallVarNoise[3].first) %
                                 WallVariants::stone.size()];
                        } else {
                            tile.wallID = WallID::Unsafe::jungle;
                        }
                    } else if (
                        biome.active == Biome::forest &&
                        getWallVarIndex(x, y, wallVarNoise, rnd) < 1) {
                        tile.wallID = rnd.getFineNoise(
                                          x + wallVarNoise[4].first,
                                          y + wallVarNoise[4].second) > 0
                                          ? WallID::Unsafe::grass
                                          : WallID::Unsafe::flower;
                    }
                }
            }
        });

    parallelFor(std::views::iota(0, world.getWidth()), [&rnd, &world](int x) {
        int stalactiteLen = 0;
        int stalacIter = 0;
        int cavernGrassLevel =
            world.conf.dontDigUp
                ? 25 * rnd.getCoarseNoise(x, world.getCavernLevel()) +
                      world.getCavernLevel()
                : world.getHeight();
        for (int y = 0; y < world.getHeight(); ++y) {
            if (y % 500 == 0) {
                stalacIter = y / 35;
            }
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::empty) {
                if (y > cavernGrassLevel &&
                    world.getBiome(x, y).active != Biome::underworld &&
                    rnd.getCoarseNoise(x, y) > 0) {
                    tile.wallID = WallID::empty;
                }
                if (stalactiteLen > 0 &&
                    world.getTile(x, y + 1).blockID == TileID::empty) {
                    tile.blockID = TileID::marble;
                    if (tile.wallID != WallID::Unsafe::marble) {
                        stalactiteLen /= 2;
                    }
                    --stalactiteLen;
                }
                continue;
            }
            if (!world.isExposed(x, y)) {
                continue;
            }
            if (world.isIsolated(x, y)) {
                tile.blockID = TileID::empty;
                continue;
            }
            if (tile.blockID == TileID::marble &&
                world.getTile(x, y + 1).blockID == TileID::empty) {
                stalactiteLen = std::max(
                    0.0,
                    16 * rnd.getFineNoise(4 * x, 100 * stalacIter));
                ++stalacIter;
            }
            BiomeData &biome = world.getBiome(x, y);
            if (biome.active == Biome::forest &&
                (y < world.getUndergroundLevel() || y > cavernGrassLevel)) {
                if (tile.blockID == TileID::dirt) {
                    tile.blockID = TileID::grass;
                }
            } else if (biome.active == Biome::jungle) {
                if (tile.blockID == TileID::mud) {
                    tile.blockID = TileID::jungleGrass;
                }
            } else if (
                biome.active == Biome::underworld &&
                y < world.getSurfaceLevel(x) + 10 &&
                std::abs(x - world.getWidth() / 2) < 100) {
                if (tile.blockID == TileID::ash) {
                    tile.blockID = TileID::ashGrass;
                }
            }
        }
    });
}

void genWorldBase(Random &rnd, World &world)
{
    registerSnow(rnd, world);
    registerDesert(rnd, world);
    registerJungle(rnd, world);
    registerUnderworld(rnd, world);

    std::cout << "Generating base terrain\n";
    applyBaseTerrain(rnd, world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Base.h`
```
#ifndef BASE_H
#define BASE_H

class World;
class Random;

void computeSurfaceLevel(Random &rnd, World &world);
void applyBaseTerrain(Random &rnd, World &world);
void genWorldBase(Random &rnd, World &world);

#endif // BASE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/BiomeUtil.cpp`
```
#include "BiomeUtil.h"

#include "Random.h"
#include "World.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include "vendor/frozen/map.h"
#include <algorithm>
#include <set>

double computeOreThreshold(double oreMultiplier)
{
    return (std::pow(std::max(0.0, oreMultiplier), 0.172) - 2.25614064334831) /
           1.9476581743693;
}

Point getEmbeddedPos(
    int x,
    int y,
    int deltaX,
    const std::set<int> &blocks,
    World &world)
{
    x += deltaX;
    for (int dist = 0; dist < 3 && blocks.contains(world.getTile(x, y).blockID);
         ++dist, x += deltaX) {
        if (world.regionPasses(x - 1, y - 1, 3, 3, [&blocks](Tile &tile) {
                return blocks.contains(tile.blockID);
            })) {
            if (world.regionPasses(
                    x + deltaX - 1,
                    y - 2,
                    3,
                    5,
                    [&blocks](Tile &tile) {
                        return blocks.contains(tile.blockID);
                    })) {
                return {x + deltaX, y};
            }
            return {x, y};
        }
    }
    return {-1, -1};
}

void embedWaterfalls(
    Point from,
    Point to,
    std::initializer_list<int> allowedBlocks,
    Liquid liquid,
    int proximity,
    Random &rnd,
    World &world)
{
    std::set<int> blocks{allowedBlocks.begin(), allowedBlocks.end()};
    std::vector<std::tuple<int, int, int>> waterSources;
    for (int y = from.y; y < to.y; ++y) {
        int state = 0;
        for (int x = from.x; x < to.x; ++x) {
            Tile &tile = world.getTile(x, y);
            int nextState = tile.blockID != TileID::empty ? -1
                            : tile.liquid != Liquid::none ? 0
                                                          : 1;
            if (state != 0 && nextState != 0 && state != nextState) {
                auto [sourceX, sourceY] =
                    getEmbeddedPos(x, y, state, blocks, world);
                if (sourceX != -1) {
                    waterSources.emplace_back(sourceX, sourceY, nextState);
                }
            }
            state = nextState;
        }
    }
    std::shuffle(waterSources.begin(), waterSources.end(), rnd.getPRNG());
    std::vector<Point> usedLocations;
    std::vector<Point> waterStream;
    for (auto [x, y, deltaX] : waterSources) {
        if (isLocationUsed(x, y, proximity, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        Tile &sourceTile = world.getTile(x, y);
        sourceTile.blockID = TileID::empty;
        sourceTile.liquid = liquid;
        for (int i = deltaX; world.getTile(x + i, y).blockID != TileID::empty;
             i += deltaX) {
            waterStream.emplace_back(x + i, y);
        }
    }
    world.queuedDeco.emplace_back(
        [blocks, waterStream](Random &, World &world) {
            for (auto [x, y] : waterStream) {
                Tile &tile = world.getTile(x, y);
                Tile &aboveTile = world.getTile(x, y - 1);
                if (blocks.contains(tile.blockID) &&
                    (aboveTile.blockID == TileID::empty ||
                     isSolidBlock(aboveTile.blockID))) {
                    tile.slope = Slope::half;
                }
            }
        });
}

void fillLargeWallGaps(Point from, Point to, Random &rnd, World &world)
{
    int maxY = std::min(to.y, world.getUnderworldLevel());
    for (int x = from.x; x < to.x; ++x) {
        for (int y = from.y; y < maxY; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.wallID == WallID::empty && rnd.getFineNoise(x, y) < 0.55) {
                // Most biome generation code coverts dirt walls to biome
                // specific variants.
                tile.wallID = WallID::Unsafe::dirt;
            }
        }
    }
}

Point findStoneCave(int yMin, int yMax, Random &rnd, World &world, int minSize)
{
    return findCave(yMin, yMax, rnd, world, minSize, {TileID::stone});
}

Point findCave(
    int yMin,
    int yMax,
    Random &rnd,
    World &world,
    int minSize,
    std::initializer_list<int> allowedBlocks)
{
    std::set<int> blocks{allowedBlocks.begin(), allowedBlocks.end()};
    for (int numTries = 0; numTries < 5000; ++numTries) {
        if (numTries % 100 == 99 && minSize > 3) {
            // Slowly reduce size requirements if finding a cave is taking too
            // long.
            --minSize;
        }
        ++numTries;
        int x = rnd.getInt(50, world.getWidth() - 50);
        int y = rnd.getInt(yMin, yMax);
        if (world.getTile(x, y).blockID != TileID::empty) {
            continue;
        }
        // Scan up.
        int caveRoof = y - 1;
        while (caveRoof > 0 &&
               world.getTile(x, caveRoof).blockID == TileID::empty) {
            --caveRoof;
        }
        if (!blocks.contains(world.getTile(x, caveRoof).blockID)) {
            continue;
        }
        // Scan down.
        int caveFloor = y + 1;
        while (caveFloor < world.getHeight() &&
               world.getTile(x, caveFloor).blockID == TileID::empty) {
            ++caveFloor;
        }
        if (!blocks.contains(world.getTile(x, caveFloor).blockID) ||
            caveFloor - caveRoof < minSize ||
            caveFloor - caveRoof > minSize + 50) {
            continue;
        }
        // Scan left.
        int left = x - 1;
        while (left > 0 && world.getTile(left, y).blockID == TileID::empty) {
            --left;
        }
        if (!blocks.contains(world.getTile(left, y).blockID)) {
            continue;
        }
        // Scan right.
        int right = x + 1;
        while (right < world.getWidth() &&
               world.getTile(right, y).blockID == TileID::empty) {
            ++right;
        }
        if (!blocks.contains(world.getTile(right, y).blockID) ||
            right - left < minSize || right - left > minSize + 50) {
            continue;
        }
        // Success.
        return {(left + right) / 2, (caveFloor + caveRoof) / 2};
    }
    return {-1, -1};
}

Point getHexCentroid(Point pt, int scale)
{
    return getHexCentroid(pt.x, pt.y, scale);
}

Point getHexCentroid(int x, int y, int scale)
{
    int targetX = x;
    int targetY = y;
    int minDist = std::numeric_limits<int>::max();
    double centralDist = scale * 2 / std::sqrt(3);
    double startRow = std::floor(y / centralDist);
    for (int col : {x / scale, x / scale + 1}) {
        for (double row : {startRow, startRow + 1}) {
            if (col % 2 == 0) {
                row += 0.5;
            }
            int testX = col * scale;
            int testY = row * centralDist;
            int testDist = std::pow(x - testX, 2) + std::pow(y - testY, 2);
            if (testDist < minDist) {
                targetX = testX;
                targetY = testY;
                minDist = testDist;
            }
        }
    }
    return {targetX, targetY};
}

inline constexpr auto mossFrameX = frozen::make_map<int, int>(
    {{TileID::greenMossStone, 0},
     {TileID::brownMossStone, 22},
     {TileID::redMossStone, 44},
     {TileID::blueMossStone, 66},
     {TileID::purpleMossStone, 88},
     {TileID::lavaMossStone, 110},
     {TileID::kryptonMossStone, 132},
     {TileID::xenonMossStone, 154},
     {TileID::argonMossStone, 176},
     {TileID::neonMossStone, 198},
     {TileID::heliumMossStone, 220}});

void growMossOn(int x, int y, World &world)
{
    Tile &baseTile = world.getTile(x, y);
    auto itr = mossFrameX.find(baseTile.blockID);
    if (itr == mossFrameX.end() || baseTile.slope != Slope::none) {
        return;
    }
    for (auto [i, j, frameY] :
         {std::tuple{0, -1, 0}, {0, 1, 54}, {1, 0, 108}, {-1, 0, 162}}) {
        Tile &tile = world.getTile(x + i, y + j);
        if (tile.blockID == TileID::empty && tile.liquid != Liquid::lava) {
            tile.blockID = TileID::mossPlant;
            tile.frameX = itr->second;
            tile.frameY = frameY + 18 * (fnv1a32pt(x + i, y + j) % 3);
        }
    }
}

bool isInBiome(int x, int y, int scanDist, Biome biome, World &world)
{
    double threshold = 2 * scanDist;
    threshold *= threshold;
    threshold *= 0.05;
    for (int i = -scanDist; i < scanDist; ++i) {
        for (int j = -scanDist; j < scanDist; ++j) {
            switch (biome) {
            case Biome::forest:
                threshold += world.getBiome(x + i, y + j).forest;
                break;
            case Biome::snow:
                threshold += world.getBiome(x + i, y + j).snow;
                break;
            case Biome::desert:
                threshold += world.getBiome(x + i, y + j).desert;
                break;
            case Biome::jungle:
                threshold += world.getBiome(x + i, y + j).jungle;
                break;
            case Biome::underworld:
                threshold += world.getBiome(x + i, y + j).underworld;
                break;
            }
            threshold -= 1;
            if (threshold < 0) {
                return false;
            }
        }
    }
    return true;
}

void iterateZone(
    Point start,
    World &world,
    std::function<bool(Point)> isValid,
    std::function<void(Point)> f)
{
    std::set<Point> border;
    std::set<Point> visited;
    std::vector<Point> locations{start};
    while (!locations.empty()) {
        Point loc = locations.back();
        locations.pop_back();
        if (loc.x < 0 || loc.y < 0 || loc.x >= world.getWidth() ||
            loc.y >= world.getHeight() || visited.contains(loc) ||
            border.contains(loc)) {
            continue;
        }
        if (isValid(loc)) {
            visited.insert(loc);
            for (auto delta : {Point{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {
                locations.push_back(loc + delta);
            }
        } else {
            border.insert(loc);
        }
    }
    for (Point loc : visited) {
        f(loc);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/BiomeUtil.h`
```
#ifndef BIOMEUTIL_H
#define BIOMEUTIL_H

#include "Point.h"
#include "Tile.h"
#include "ids/Biome.h"
#include <functional>

class World;
class Random;

double computeOreThreshold(double oreMultiplier);

void embedWaterfalls(
    Point from,
    Point to,
    std::initializer_list<int> allowedBlocks,
    Liquid liquid,
    int proximity,
    Random &rnd,
    World &world);

/**
 * Cover most (but not all) gaps in between walls in a zone.
 */
void fillLargeWallGaps(Point from, Point to, Random &rnd, World &world);

/**
 * Find an open stone surrounded space. May reduce size restriction if searching
 * takes too long.
 */
Point findStoneCave(
    int yMin,
    int yMax,
    Random &rnd,
    World &world,
    int minSize = 6);

Point findCave(
    int yMin,
    int yMax,
    Random &rnd,
    World &world,
    int minSize,
    std::initializer_list<int> allowedBlocks);

Point getHexCentroid(Point pt, int scale);
Point getHexCentroid(int x, int y, int scale);

void growMossOn(int x, int y, World &world);

bool isInBiome(int x, int y, int scanDist, Biome biome, World &world);

void iterateZone(
    Point start,
    World &world,
    std::function<bool(Point)> isValid,
    std::function<void(Point)> f);

#endif // BIOMEUTIL_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Cloud.cpp`
```
#include "Cloud.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include "structures/data/SkyBoxes.h"
#include "vendor/frozen/map.h"
#include <algorithm>
#include <iostream>
#include <numbers>

bool isRowZoneEmpty(int x, int y, World &world)
{
    return world.regionPasses(x - 2, y, 5, 1, [](Tile &tile) {
        return tile.blockID == TileID::empty;
    });
}

void makeFishingCloud(
    int startX,
    int startY,
    int width,
    int height,
    Random &rnd,
    World &world)
{
    int minX = startX + 0.2 * width;
    int maxX = startX + 0.8 * width;
    int waterLevel = startY;
    while (isRowZoneEmpty(minX, waterLevel, world) ||
           isRowZoneEmpty(maxX, waterLevel, world)) {
        ++waterLevel;
    }
    ++waterLevel;
    for (int x = minX; x < maxX; ++x) {
        int depth = 0.45 * height *
                    std::sin(std::numbers::pi * (x - minX) / (0.6 * width));
        int y = startY;
        while (depth > 0) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID != TileID::empty) {
                tile.blockID = TileID::empty;
                tile.wallID = WallID::empty;
                if (y > waterLevel) {
                    tile.liquid = Liquid::water;
                }
                --depth;
            }
            ++y;
        }
    }
    embedWaterfalls(
        {startX, startY},
        {startX + width, startY + height},
        {TileID::cloud,
         TileID::rainCloud,
         TileID::snowCloud,
         TileID::lesion,
         TileID::flesh},
        Liquid::water,
        14,
        rnd,
        world);
}

void makeResourceCloud(
    int startX,
    int startY,
    int width,
    int height,
    Random &rnd,
    World &world)
{
    int minX = startX + 0.2 * width;
    int maxX = startX + 0.8 * width;
    for (int x = minX; x < maxX; ++x) {
        int depth = 0.45 * height *
                    std::sin(std::numbers::pi * (x - minX) / (0.6 * width));
        int y = startY;
        bool prevWasEmpty = true;
        while (depth > 0) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID != TileID::empty && tile.blockID != TileID::hive) {
                tile.blockID = TileID::dirt;
                if (prevWasEmpty) {
                    tile.wallID = WallID::empty;
                    prevWasEmpty = false;
                } else {
                    tile.wallID = WallID::Unsafe::dirt;
                }
                --depth;
            }
            ++y;
        }
    }
    for (int x = startX; x < startX + width; ++x) {
        for (int y = startY; y < startY + height; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID != TileID::empty && tile.blockID != TileID::hive &&
                (std::abs(rnd.getFineNoise(x, y + startY)) > 0.65 ||
                 std::abs(rnd.getFineNoise(x + startX, y)) > 0.65)) {
                tile.blockID = world.goldVariant;
            }
        }
    }
}

void makeGraveCloud(
    int startX,
    int startY,
    int width,
    int height,
    Random &rnd,
    World &world)
{
    int radius = width / 2;
    int centerX = startX + radius;
    int centerY = startY + height / 2;
    radius = 2 + 0.9 * radius;
    double delta =
        2 * std::numbers::pi / std::ceil(0.1 * std::numbers::pi * radius);
    double offset = rnd.getDouble(0, delta);
    std::vector<Point> locations;
    for (double t = 0.0001; t < 2 * std::numbers::pi; t += delta) {
        locations.emplace_back(
            centerX + radius * std::cos(t + offset),
            centerY + radius * std::sin(t + offset));
    }
    world.queuedDeco.emplace_back([locations](Random &, World &world) {
        for (auto [x, y] : locations) {
            if (world.regionPasses(x - 2, y - 2, 6, 6, [](Tile &tile) {
                    return tile.blockID == TileID::empty &&
                           tile.wallID == WallID::empty;
                })) {
                world.placeFramedTile(x, y, TileID::tombstone);
                for (int i = 0; i < 2; ++i) {
                    for (int j = 0; j < 2; ++j) {
                        world.getTile(x + i, y + j).echoCoatBlock = true;
                    }
                }
            }
        }
    });
}

void addCloudStructure(
    int startX,
    int startY,
    int width,
    int roomId,
    int fillTile,
    World &world)
{
    TileBuffer room = Data::getSkyBox(roomId, world.getFramedTiles());
    int x = startX + (width - room.getWidth()) / 2;
    int surfaceLeft = scanWhileEmpty({x, startY}, {0, 1}, world).y + 1;
    int surfaceRight =
        scanWhileEmpty({x + room.getWidth() - 1, startY}, {0, 1}, world).y + 1;
    int y = std::max(surfaceLeft, surfaceRight) - room.getHeight();
    for (int j = 0; j < room.getHeight(); ++j) {
        int jLeft = surfaceLeft - y - j;
        int jRight = surfaceRight - y - j;
        if (jLeft >= 0 && jRight >= 0 && jLeft < room.getHeight() &&
            jRight < room.getHeight() &&
            room.getTile(0, jLeft).blockPaint == Paint::red &&
            room.getTile(room.getWidth() - 1, jRight).blockPaint ==
                Paint::red) {
            y += j;
            break;
        }
    }
    for (int i = 0; i < room.getWidth(); ++i) {
        for (int j = 0; j < room.getHeight(); ++j) {
            Tile &roomTile = room.getTile(i, j);
            if (roomTile.blockID == TileID::cloud) {
                continue;
            }
            Tile &tile = world.getTile(x + i, y + j);
            if (roomTile.blockID != TileID::empty) {
                tile.blockID = TileID::cloud;
            }
        }
    }
    for (int i = 1; i < room.getWidth() - 1; ++i) {
        for (int j = -1; j < 4; ++j) {
            Tile &tile = world.getTile(x + i, y + room.getHeight() + j);
            if (tile.blockID == TileID::empty) {
                tile.blockID = fillTile;
            }
        }
    }
    world.queuedTreasures.emplace_back(
        [x, y, roomId](Random &rnd, World &world) {
            TileBuffer room = Data::getSkyBox(roomId, world.getFramedTiles());
            std::vector<Point> chests;
            for (int i = 0; i < room.getWidth(); ++i) {
                for (int j = 0; j < room.getHeight(); ++j) {
                    Tile &roomTile = room.getTile(i, j);
                    if (roomTile.blockID == TileID::cloud) {
                        continue;
                    }
                    roomTile.guarded = roomTile.blockID != TileID::empty ||
                                       roomTile.wallID != WallID::empty;
                    Tile &tile = world.getTile(x + i, y + j);
                    if (!roomTile.guarded &&
                        (tile.blockID == TileID::livingMahogany ||
                         tile.blockID == TileID::mahoganyLeaf)) {
                        roomTile.blockID = tile.blockID;
                    }
                    tile = roomTile;
                    if (tile.blockID == TileID::chest &&
                        tile.frameX % 36 == 0 && tile.frameY == 0) {
                        chests.emplace_back(x + i, y + j);
                    } else if (
                        tile.blockID == TileID::dresser &&
                        tile.frameX % 54 == 0 && tile.frameY == 0) {
                        fillDresser(world.registerStorage(x + i, y + j), rnd);
                    }
                }
            }
            for (auto [chestX, chestY] : chests) {
                fillSkywareChest(
                    world.conf.forTheWorthy
                        ? world.placeChest(chestX, chestY, Variant::goldLocked)
                        : world.registerStorage(chestX, chestY),
                    rnd,
                    world);
            }
        });
}

Point selectCloudSpawn(int width, int height, Random &rnd, World &world)
{
    int maxY = 0.45 * world.getUndergroundLevel();
    int x = world.conf.celebration && !world.conf.forTheWorthy
                ? (world.oceanCaveCenter < 400 ? 350 : world.getWidth() - 350)
                : world.getWidth() / 2;
    int y = std::max(std::midpoint<int>(50 + height, maxY), maxY - 85);
    for (int tries = 0; tries < 10000; ++tries) {
        int i = rnd.getInt(-190, 190);
        int j = rnd.getInt(-80, 80);
        int buffer = 10 - tries / 110;
        if (y + j > 90 && y + j + 2 * height < maxY &&
            world.regionPasses(
                x + i + buffer / 2 - width,
                y + j + buffer / 4 - 20 - height,
                2 * width + buffer,
                2 * height + buffer / 2 + 20,
                [](Tile &tile) { return tile.blockID == TileID::empty; })) {
            return {x + i, y + j};
        }
    }
    return {-1, -1};
}

void setCloudSpawn(Random &rnd, World &world)
{
    int width = rnd.getInt(75, 85);
    int height = rnd.getInt(22, 28);
    auto [x, y] = selectCloudSpawn(width, height, rnd, world);
    if (x == -1) {
        return;
    }
    for (int i = -width; i < width; ++i) {
        for (int j = -height; j < height; ++j) {
            auto [hX, hY] = world.conf.hiveQueen
                                ? getHexCentroid(x + i, y + j, 8)
                                : Point{x + i, y + j};
            double threshold = 4 * std::hypot(
                                       static_cast<double>(hX - x) / width,
                                       static_cast<double>(hY - y) / height) -
                               3;
            if (rnd.getFineNoise(hX, hY) < threshold) {
                continue;
            }
            Tile &tile = world.getTile(x + i, y + j);
            tile.blockID = TileID::cloud;
            tile.wallID = WallID::Safe::cloud;
        }
    }
    makeResourceCloud(x - width, y - height, 2 * width, 2 * height, rnd, world);
    for (int i = -width; i < width; ++i) {
        for (int j = -height; j < height; ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            if (tile.blockID == world.goldVariant) {
                tile.blockID = tile.wallID == WallID::Safe::cloud
                                   ? world.copperVariant
                                   : TileID::stone;
            }
        }
    }
    while (!world.regionPasses(x - 1, y - 2, 3, 3, [](Tile &tile) {
        return tile.blockID == TileID::empty || tile.blockID == TileID::hive;
    }) && y > 60) {
        --y;
    }
    world.spawn = {x, y};
}

void genCloud(Random &rnd, World &world)
{
    std::cout << "Condensing clouds\n";
    rnd.shuffleNoise();
    if (world.conf.spawn == SpawnPoint::cloud) {
        setCloudSpawn(rnd, world);
    }
    int numClouds =
        world.conf.clouds * world.getWidth() / rnd.getInt(600, 1250);
    std::vector<int> rooms(Data::skyBoxes.begin(), Data::skyBoxes.end());
    std::shuffle(rooms.begin(), rooms.end(), rnd.getPRNG());
    auto roomItr = rooms.begin();
    double cloudScale = std::min(0.1 + world.getHeight() / 1400.0, 1.0);
    int hSpacingBuffer = world.conf.hiveQueen ? -10 : 50;
    for (int tries = 500 * numClouds; numClouds > 0 && tries > 0; --tries) {
        int width = cloudScale * rnd.getInt(90, 160);
        int height = cloudScale * rnd.getInt(35, 50);
        int x = rnd.getInt(
            cloudScale * 200,
            world.getWidth() - cloudScale * 200 - width);
        int maxY =
            std::max<int>(0.45 * world.getUndergroundLevel() - height, 50);
        int y = rnd.getInt(
            std::min<int>(
                numClouds == 3 ? std::midpoint<int>(cloudScale * 100, maxY)
                               : cloudScale * 100,
                maxY - 1),
            maxY);
        if (!world.regionPasses(
                x - hSpacingBuffer / 2,
                y - 25,
                width + hSpacingBuffer,
                height + 50,
                [](Tile &tile) { return tile.blockID == TileID::empty; })) {
            continue;
        }
        for (int i = 0; i < width; ++i) {
            for (int j = 0; j < height; ++j) {
                auto [hI, hJ] = world.conf.hiveQueen ? getHexCentroid(i, j, 8)
                                                     : Point{i, j};
                double threshold =
                    8 * std::hypot(
                            static_cast<double>(hI) / width - 0.5,
                            static_cast<double>(hJ) / height - 0.5) -
                    3;
                if (rnd.getFineNoise(x + hI, y + hJ) < threshold) {
                    continue;
                }
                Tile &tile = world.getTile(x + i, y + j);
                tile.blockID = TileID::cloud;
                tile.wallID = WallID::Safe::cloud;
            }
        }
        switch (numClouds % 3) {
        case 1:
            makeFishingCloud(x, y, width, height, rnd, world);
            break;
        case 2:
            makeResourceCloud(x, y, width, height, rnd, world);
            addCloudStructure(x, y, width, *roomItr, TileID::dirt, world);
            ++roomItr;
            break;
        default:
            if (numClouds == 3) {
                makeGraveCloud(x, y, width, height, rnd, world);
            }
            addCloudStructure(x, y, width, *roomItr, TileID::cloud, world);
            ++roomItr;
            break;
        }
        --numClouds;
        if (roomItr == rooms.end()) {
            roomItr = rooms.begin();
        }
    }

    constexpr auto tileConversion =
        frozen::make_map<std::pair<Biome, int>, int>({
            {{Biome::snow, TileID::dirt}, TileID::snow},
            {{Biome::snow, TileID::cloud}, TileID::snowCloud},
            {{Biome::desert, TileID::dirt}, TileID::sand},
            {{Biome::jungle, TileID::dirt}, TileID::mud},
            {{Biome::jungle, TileID::cloud}, TileID::rainCloud},
        });
    constexpr auto wallConversion = frozen::make_map<Biome, int>({
        {Biome::snow, WallID::Unsafe::snow},
        {Biome::desert, WallID::Unsafe::hardenedSand},
        {Biome::jungle, WallID::Unsafe::mud},
    });
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [&tileConversion, &wallConversion, &world](int x) {
            int maxY = 0.45 * world.getUndergroundLevel() + 10;
            for (int y = 0; y < maxY; ++y) {
                Tile &tile = world.getTile(x, y);
                Biome biome = world.getBiome(x, y).active;
                auto tileItr =
                    tileConversion.find(std::pair{biome, tile.blockID});
                if (tileItr != tileConversion.end()) {
                    tile.blockID = tileItr->second;
                }
                if ((tile.blockID == TileID::dirt ||
                     tile.blockID == TileID::mud) &&
                    world.isExposed(x, y)) {
                    tile.blockID = tile.blockID == TileID::dirt
                                       ? TileID::grass
                                       : TileID::jungleGrass;
                }
                if (tile.wallID == WallID::Unsafe::dirt) {
                    auto wallItr = wallConversion.find(biome);
                    if (wallItr != wallConversion.end()) {
                        tile.wallID = wallItr->second;
                    }
                }
            }
        });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Cloud.h`
```
#ifndef CLOUD_H
#define CLOUD_H

class World;
class Random;

void genCloud(Random &rnd, World &world);

#endif // CLOUD_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Corruption.cpp`
```
#include "Corruption.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "vendor/frozen/map.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>
#include <map>

void genCloudCorruption(Random &rnd, World &world)
{
    int maxY = 0.45 * world.getUndergroundLevel();
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [maxY, &rnd, &world](int x) {
            for (int y = 0; y < maxY; ++y) {
                Tile &tile = world.getTile(x, y);
                int corruptBlock = TileID::empty;
                switch (tile.blockID) {
                case TileID::grass:
                    tile.blockID = TileID::corruptGrass;
                    break;
                case TileID::jungleGrass:
                    tile.blockID = TileID::corruptJungleGrass;
                    break;
                case TileID::sand:
                    tile.blockID = TileID::ebonsand;
                    break;
                case TileID::cloud:
                case TileID::rainCloud:
                case TileID::snowCloud:
                    corruptBlock = TileID::lesion;
                    break;
                case TileID::snow:
                    corruptBlock = TileID::corruptIce;
                    break;
                case TileID::goldOre:
                case TileID::platinumOre:
                    corruptBlock = TileID::demonite;
                    break;
                }
                if (corruptBlock != TileID::empty &&
                    std::abs(rnd.getCoarseNoise(3 * x, 3 * y)) < 0.1) {
                    tile.blockID = corruptBlock;
                    if (tile.wallID != WallID::empty) {
                        tile.wallID = WallID::Unsafe::corruptTendril;
                    }
                }
            }
        });
}

std::pair<int, int> baseSelectEvilLocations(Random &rnd, World &world)
{
    // Avoid selecting too near spawn.
    int surfaceX = world.getWidth() * rnd.getDouble(0.12, 0.39);
    if (rnd.getBool()) {
        surfaceX = world.getWidth() - surfaceX;
    }
    int undergroundX;
    if (world.conf.hiveQueen) {
        undergroundX = world.getWidth() * rnd.getDouble(0.08, 0.42);
        if (rnd.getBool()) {
            undergroundX = world.getWidth() - undergroundX;
        }
    } else {
        undergroundX = world.getWidth() * rnd.getDouble(0.08, 0.92);
    }
    return {surfaceX, undergroundX};
}

std::pair<int, int> selectAvoidantEvilLocations(Random &rnd, World &world)
{
    int scanDist = 0.06 * world.getWidth();
    double maxForest = 0;
    int bestSurface = -1;
    int betUnderground = -1;
    int undergroundY =
        std::midpoint(world.getCavernLevel(), world.getUnderworldLevel());
    for (int tries = 0; tries < 10; ++tries) {
        auto [surfaceX, undergroundX] = baseSelectEvilLocations(rnd, world);
        double forestScore = 0;
        for (int i = -scanDist; i < scanDist; ++i) {
            for (int j = -scanDist; j < scanDist; ++j) {
                forestScore +=
                    world
                        .getBiome(surfaceX + i, world.getUndergroundLevel() + j)
                        .forest;
                forestScore +=
                    world.getBiome(undergroundX + i, undergroundY + j).forest;
            }
        }
        if (forestScore > maxForest) {
            maxForest = forestScore;
            bestSurface = surfaceX;
            betUnderground = undergroundX;
        }
    }
    return {bestSurface, betUnderground};
}

std::vector<std::pair<int, int>> selectEvilLocations(Random &rnd, World &world)
{
    if (world.conf.dontDigUp) {
        auto partitions =
            rnd.partitionRange(rnd.getInt(20, 24), world.getWidth());
        std::vector<std::pair<int, int>> locations;
        for (int partition : partitions) {
            locations.emplace_back(partition, -1);
        }
        locations[0].second = world.getWidth() * rnd.getDouble(0.02, 0.06);
        locations[1].second = world.getWidth() * rnd.getDouble(0.05, 0.09);
        locations[2].second = world.getWidth() * rnd.getDouble(0.08, 0.12);
        locations[locations.size() - 3].second =
            world.getWidth() * rnd.getDouble(0.88, 0.92);
        locations[locations.size() - 2].second =
            world.getWidth() * rnd.getDouble(0.91, 0.95);
        locations[locations.size() - 1].second =
            world.getWidth() * rnd.getDouble(0.94, 0.98);
        return locations;
    }
    return {
        world.conf.avoidantEvil ? selectAvoidantEvilLocations(rnd, world)
                                : baseSelectEvilLocations(rnd, world)};
}

void genCorruption(Random &rnd, World &world)
{
    std::cout << "Corrupting the world\n";
    rnd.shuffleNoise();
    int minX = 0;
    int maxX = world.getWidth();
    if (world.conf.dontDigUp && world.conf.doubleTrouble) {
        if (rnd.getBool()) {
            minX = world.getWidth() / 2;
        } else {
            maxX = world.getWidth() / 2;
        }
    }
    for (auto [surfaceX, undergroundX] : selectEvilLocations(rnd, world)) {
        if (surfaceX < minX || surfaceX > maxX) {
            continue;
        }
        // Register location for use in other generators.
        world.surfaceEvilCenter = surfaceX;
        genCorruptionAt(surfaceX, undergroundX, rnd, world);
    }
    if (world.conf.forTheWorthy || world.conf.dontDigUp) {
        genCloudCorruption(rnd, world);
    }
}

void genCorruptionAt(int surfaceX, int undergroundX, Random &rnd, World &world)
{
    int surfaceY =
        world.conf.dontDigUp
            ? rnd.getInt(
                  0.7 * world.getUndergroundLevel(),
                  0.9 * world.getUndergroundLevel())
            : rnd.getInt(
                  0.95 * world.getUndergroundLevel(),
                  (2 * world.getUndergroundLevel() + world.getCavernLevel()) /
                      3);
    int scanDist = world.conf.evilSize * 0.08 * world.getWidth();
    // Conversion mappings.
    constexpr auto corruptBlocks = frozen::make_map<int, int>(
        {{TileID::stone, TileID::ebonstone},
         {TileID::grass, TileID::corruptGrass},
         {TileID::ironOre, TileID::ebonstone},
         {TileID::leadOre, TileID::ebonstone},
         {TileID::silverOre, TileID::demonite},
         {TileID::tungstenOre, TileID::demonite},
         {TileID::goldOre, TileID::demonite},
         {TileID::platinumOre, TileID::demonite},
         {TileID::leaf, TileID::empty},
         {TileID::mahoganyLeaf, TileID::empty},
         {TileID::sand, TileID::ebonsand},
         {TileID::jungleGrass, TileID::corruptJungleGrass},
         {TileID::mushroomGrass, TileID::corruptJungleGrass},
         {TileID::hive, TileID::ebonstone},
         {TileID::silt, TileID::ebonstone},
         {TileID::slime, TileID::ebonstone},
         {TileID::ice, TileID::corruptIce},
         {TileID::slush, TileID::ebonstone},
         {TileID::sandstone, TileID::ebonsandstone},
         {TileID::hardenedSand, TileID::hardenedEbonsand}});
    std::map<int, int> corruptWalls{
        {WallID::Safe::livingLeaf, WallID::empty},
        {WallID::Unsafe::grass, WallID::Unsafe::corruptGrass},
        {WallID::Unsafe::flower, WallID::Unsafe::corruptGrass},
        {WallID::Unsafe::jungle, WallID::Unsafe::corruptGrass},
        {WallID::Unsafe::sandstone, WallID::Unsafe::ebonsandstone},
        {WallID::Unsafe::hardenedSand, WallID::Unsafe::hardenedEbonsand}};
    for (int wallId : WallVariants::dirt) {
        corruptWalls[wallId] = rnd.select(WallVariants::corruption);
    }
    for (int wallId : WallVariants::stone) {
        corruptWalls[wallId] = rnd.select(WallVariants::corruption);
    }
    for (int wallId : WallVariants::jungle) {
        corruptWalls[wallId] = rnd.select(WallVariants::corruption);
    }
    for (int wallId :
         {WallID::Unsafe::snow,
          WallID::Unsafe::ice,
          WallID::Unsafe::mushroom,
          WallID::Unsafe::marble,
          WallID::Unsafe::granite}) {
        corruptWalls[wallId] = rnd.select(WallVariants::corruption);
    }
    constexpr auto chasmSkipTiles = frozen::make_set<int>(
        {TileID::livingWood,
         TileID::leaf,
         TileID::livingMahogany,
         TileID::mahoganyLeaf});
    int halfWidth = world.getWidth() / 2;
    int scaleFactor =
        world.conf.evilSize *
        std::midpoint<double>(world.getWidth(), 3.5 * world.getHeight()) *
        (world.conf.dontDigUp ? std::abs(surfaceX - halfWidth) < halfWidth / 2
                                    ? rnd.getDouble(0.45, 0.65)
                                    : rnd.getDouble(0.7, 1)
                              : 1);
    // Dig surface chasms, edged with ebonstone.
    if (!world.conf.dontDigUp || rnd.getInt(0, 4) == 0) {
        int maxY = world.conf.dontDigUp ? std::midpoint(
                                              world.getUndergroundLevel(),
                                              world.getCavernLevel())
                                        : world.getCavernLevel();
        for (int x = std::max(surfaceX - scanDist, 0);
             x < std::min(surfaceX + scanDist, world.getWidth());
             ++x) {
            for (int y = 0.45 * world.getUndergroundLevel(); y < maxY; ++y) {
                double threshold = std::min(
                    {2 - 50.0 * std::abs(x - surfaceX) / scaleFactor,
                     0.01 * (maxY - y),
                     0.16});
                if (std::abs(rnd.getCoarseNoise(3 * x, y) + 0.1) < threshold) {
                    Tile &tile = world.getTile(x, y);
                    if (chasmSkipTiles.contains(tile.blockID) ||
                        tile.wallID == WallID::Unsafe::livingWood) {
                        continue;
                    }
                    if (std::abs(rnd.getCoarseNoise(3 * x, y) + 0.1) <
                        threshold - 0.07) {
                        tile.blockID = TileID::empty;
                    } else if (tile.blockID != TileID::empty) {
                        tile.blockID = TileID::ebonstone;
                    }
                }
            }
        }
    }
    auto applyCorruption = [&](int sourceX, int sourceY) {
        if (sourceX == -1) {
            return;
        }
        parallelFor(
            std::views::iota(
                std::max(sourceX - scanDist, 0),
                std::min(sourceX + scanDist, world.getWidth())),
            [&, scanDist, sourceX, sourceY](int x) {
                int tendrilMinY = world.conf.trimEvilTendrils
                                      ? world.getSurfaceLevel(x) - 20 +
                                            10 * rnd.getFineNoise(x, 0)
                                      : 0;
                for (int y = std::max(sourceY - scanDist, 0);
                     y < sourceY + scanDist;
                     ++y) {
                    double threshold =
                        1 - std::sqrt(
                                18 * std::hypot(x - sourceX, y - sourceY) /
                                scaleFactor);
                    if (std::abs(rnd.getCoarseNoise(x, y)) < threshold) {
                        Tile &tile = world.getTile(x, y);
                        threshold =
                            1 - std::pow(
                                    21 * std::hypot(x - sourceX, y - sourceY) /
                                        scaleFactor,
                                    0.04);
                        if (std::abs(rnd.getCoarseNoise(x, y)) < threshold) {
                            // Corruption spreads from tendrils of lesion
                            // blocks. Fill the core of central tendrils with
                            // demonite.
                            if (tile.blockID != TileID::empty ||
                                tile.wallID != WallID::empty ||
                                y > tendrilMinY) {
                                tile.blockID =
                                    std::abs(rnd.getCoarseNoise(x, y)) <
                                            threshold - 0.065
                                        ? y > world.getUndergroundLevel()
                                              ? TileID::demonite
                                              : TileID::ebonstone
                                        : TileID::lesion;
                                if (tile.wallID != WallID::empty) {
                                    tile.wallID =
                                        WallID::Unsafe::corruptTendril;
                                }
                                // Handle aether bubble.
                                tile.echoCoatBlock = false;
                            }
                        } else {
                            auto blockItr = corruptBlocks.find(tile.blockID);
                            if (blockItr != corruptBlocks.end()) {
                                if (y > world.getUndergroundLevel() ||
                                    blockItr->second != TileID::demonite) {
                                    tile.blockID = blockItr->second;
                                }
                            } else if (
                                tile.blockID == TileID::livingWood ||
                                tile.blockID == TileID::livingMahogany) {
                                tile.blockPaint = Paint::purple;
                            } else if (
                                tile.blockID == TileID::ash &&
                                y < world.getUnderworldLevel() +
                                        10 * rnd.getFineNoise(x, y) - 20) {
                                tile.blockID = TileID::ebonstone;
                            }
                            auto wallItr = corruptWalls.find(tile.wallID);
                            if (wallItr != corruptWalls.end()) {
                                tile.wallID = wallItr->second;
                            } else if (
                                tile.wallID == WallID::Unsafe::livingWood) {
                                tile.wallPaint = Paint::purple;
                            }
                        }
                    }
                }
            });
    };
    // Surface corruption.
    applyCorruption(surfaceX, surfaceY);
    // Underground corruption.
    applyCorruption(
        undergroundX,
        rnd.getInt(
            world.conf.dontDigUp
                ? (world.getUndergroundLevel() + 2 * world.getCavernLevel()) / 3
                : (2 * world.getCavernLevel() + world.getUnderworldLevel()) / 3,
            world.getUnderworldLevel()));
    // Remove high above surface unconnected tendrils.
    bool clearFloating = false;
    for (int y = 0.8 * world.getUndergroundLevel(); y > 0; --y) {
        bool foundBlock = false;
        for (int x = surfaceX - scanDist; x < surfaceX + scanDist; ++x) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::lesion) {
                if (clearFloating) {
                    tile.blockID = TileID::empty;
                } else {
                    foundBlock = true;
                    break;
                }
            }
        }
        if (!foundBlock) {
            clearFloating = true;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Corruption.h`
```
#ifndef CORRUPTION_H
#define CORRUPTION_H

#include <vector>

class World;
class Random;

std::vector<std::pair<int, int>> selectEvilLocations(Random &rnd, World &world);

void genCorruption(Random &rnd, World &world);
void genCorruptionAt(int surfaceX, int undergroundX, Random &rnd, World &world);

#endif // CORRUPTION_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Crimson.cpp`
```
#include "Crimson.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "biomes/Corruption.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "vendor/frozen/map.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>
#include <map>

void genCloudCrimson(Random &rnd, World &world)
{
    int maxY = 0.45 * world.getUndergroundLevel();
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [maxY, &rnd, &world](int x) {
            for (int y = 0; y < maxY; ++y) {
                Tile &tile = world.getTile(x, y);
                int crimsonBlock = TileID::empty;
                switch (tile.blockID) {
                case TileID::grass:
                    tile.blockID = TileID::crimsonGrass;
                    break;
                case TileID::jungleGrass:
                    tile.blockID = TileID::crimsonJungleGrass;
                    break;
                case TileID::sand:
                    tile.blockID = TileID::crimsand;
                    break;
                case TileID::cloud:
                case TileID::rainCloud:
                case TileID::snowCloud:
                    crimsonBlock = TileID::flesh;
                    break;
                case TileID::snow:
                    crimsonBlock = TileID::crimsonIce;
                    break;
                case TileID::goldOre:
                case TileID::platinumOre:
                    crimsonBlock = TileID::crimtane;
                    break;
                }
                if (crimsonBlock != TileID::empty &&
                    std::abs(rnd.getBlurNoise(3 * x, 3 * y)) < 0.1) {
                    tile.blockID = crimsonBlock;
                    if (tile.wallID != WallID::empty) {
                        tile.wallID = WallID::Unsafe::crimsonBlister;
                    }
                }
            }
        });
}

void genCrimson(Random &rnd, World &world)
{
    std::cout << "Infecting the world\n";
    rnd.shuffleNoise();
    int minX = 0;
    int maxX = world.getWidth();
    if (world.conf.dontDigUp && world.conf.doubleTrouble) {
        if (rnd.getBool()) {
            minX = world.getWidth() / 2;
        } else {
            maxX = world.getWidth() / 2;
        }
    }
    for (auto [surfaceX, undergroundX] : selectEvilLocations(rnd, world)) {
        if (surfaceX < minX || surfaceX > maxX) {
            continue;
        }
        // Register location for use in other generators.
        world.surfaceEvilCenter = surfaceX;
        genCrimsonAt(surfaceX, undergroundX, rnd, world);
    }
    if (world.conf.forTheWorthy || world.conf.dontDigUp) {
        genCloudCrimson(rnd, world);
    }
}

void genCrimsonAt(int surfaceX, int undergroundX, Random &rnd, World &world)
{
    int surfaceY =
        world.conf.dontDigUp
            ? rnd.getInt(
                  0.7 * world.getUndergroundLevel(),
                  0.9 * world.getUndergroundLevel())
            : rnd.getInt(
                  0.95 * world.getUndergroundLevel(),
                  (2 * world.getUndergroundLevel() + world.getCavernLevel()) /
                      3);
    int scanDist = world.conf.evilSize * 0.08 * world.getWidth();
    // Conversion mappings.
    constexpr auto crimsonBlocks = frozen::make_map<int, int>(
        {{TileID::stone, TileID::crimstone},
         {TileID::grass, TileID::crimsonGrass},
         {TileID::ironOre, TileID::crimstone},
         {TileID::leadOre, TileID::crimstone},
         {TileID::silverOre, TileID::crimtane},
         {TileID::tungstenOre, TileID::crimtane},
         {TileID::goldOre, TileID::crimtane},
         {TileID::platinumOre, TileID::crimtane},
         {TileID::leaf, TileID::empty},
         {TileID::mahoganyLeaf, TileID::empty},
         {TileID::sand, TileID::crimsand},
         {TileID::jungleGrass, TileID::crimsonJungleGrass},
         {TileID::mushroomGrass, TileID::crimsonJungleGrass},
         {TileID::hive, TileID::crimstone},
         {TileID::silt, TileID::crimstone},
         {TileID::slime, TileID::crimstone},
         {TileID::ice, TileID::crimsonIce},
         {TileID::slush, TileID::crimstone},
         {TileID::sandstone, TileID::crimsandstone},
         {TileID::hardenedSand, TileID::hardenedCrimsand}});
    std::map<int, int> crimsonWalls{
        {WallID::Safe::livingLeaf, WallID::empty},
        {WallID::Unsafe::grass, WallID::Unsafe::crimsonGrass},
        {WallID::Unsafe::flower, WallID::Unsafe::crimsonGrass},
        {WallID::Unsafe::jungle, WallID::Unsafe::crimsonGrass},
        {WallID::Unsafe::sandstone, WallID::Unsafe::crimsandstone},
        {WallID::Unsafe::hardenedSand, WallID::Unsafe::hardenedCrimsand}};
    for (int wallId : WallVariants::dirt) {
        crimsonWalls[wallId] = rnd.select(WallVariants::crimson);
    }
    for (int wallId : WallVariants::stone) {
        crimsonWalls[wallId] = rnd.select(WallVariants::crimson);
    }
    for (int wallId : WallVariants::jungle) {
        crimsonWalls[wallId] = rnd.select(WallVariants::crimson);
    }
    for (int wallId :
         {WallID::Unsafe::snow,
          WallID::Unsafe::ice,
          WallID::Unsafe::mushroom,
          WallID::Unsafe::marble,
          WallID::Unsafe::granite}) {
        crimsonWalls[wallId] = rnd.select(WallVariants::crimson);
    }
    constexpr auto tunnelBorderExclusions = frozen::make_set<int>(
        {TileID::empty,
         TileID::ironOre,
         TileID::leadOre,
         TileID::silverOre,
         TileID::tungstenOre});
    constexpr auto tunnelSkipTiles = frozen::make_set<int>(
        {TileID::livingWood,
         TileID::leaf,
         TileID::livingMahogany,
         TileID::mahoganyLeaf});
    int halfWidth = world.getWidth() / 2;
    int scaleFactor =
        world.conf.evilSize *
        std::midpoint<double>(world.getWidth(), 3.5 * world.getHeight()) *
        (world.conf.dontDigUp ? std::abs(surfaceX - halfWidth) < halfWidth / 2
                                    ? rnd.getDouble(0.45, 0.65)
                                    : rnd.getDouble(0.7, 1)
                              : 1);
    // Dig surface smooth tunnel network, edged with crimstone.
    if (!world.conf.dontDigUp || rnd.getInt(0, 4) == 0) {
        int maxY = world.conf.dontDigUp ? std::midpoint(
                                              world.getUndergroundLevel(),
                                              world.getCavernLevel())
                                        : world.getCavernLevel();
        for (int x = std::max(surfaceX - scanDist, 0);
             x < std::min(surfaceX + scanDist, world.getWidth());
             ++x) {
            for (int y = 0.45 * world.getUndergroundLevel(); y < maxY; ++y) {
                double threshold = std::min(
                    {2 - 50.0 * std::abs(x - surfaceX) / scaleFactor,
                     0.01 * (maxY - y),
                     0.16});
                if (std::abs(rnd.getBlurNoise(2 * x, 2 * y) + 0.1) <
                    threshold) {
                    Tile &tile = world.getTile(x, y);
                    if (tunnelSkipTiles.contains(tile.blockID) ||
                        tile.wallID == WallID::Unsafe::livingWood) {
                        continue;
                    }
                    if (std::abs(rnd.getBlurNoise(2 * x, 2 * y) + 0.1) <
                        threshold - 0.07) {
                        tile.blockID = TileID::empty;
                    } else if (!tunnelBorderExclusions.contains(tile.blockID)) {
                        tile.blockID = TileID::crimstone;
                    }
                }
            }
        }
    }
    auto applyCrimson = [&](int sourceX, int sourceY) {
        if (sourceX == -1) {
            return;
        }
        parallelFor(
            std::views::iota(
                std::max(sourceX - scanDist, 0),
                std::min(sourceX + scanDist, world.getWidth())),
            [&, scanDist, sourceX, sourceY](int x) {
                int tendrilMinY = world.conf.trimEvilTendrils
                                      ? world.getSurfaceLevel(x) - 20 +
                                            10 * rnd.getFineNoise(x, 0)
                                      : 0;
                for (int y = std::max(sourceY - scanDist, 0);
                     y < sourceY + scanDist;
                     ++y) {
                    double threshold =
                        1 - std::sqrt(
                                18 * std::hypot(x - sourceX, y - sourceY) /
                                scaleFactor);
                    if (std::abs(rnd.getBlurNoise(x, y)) < threshold) {
                        Tile &tile = world.getTile(x, y);
                        threshold =
                            1 - std::pow(
                                    21 * std::hypot(x - sourceX, y - sourceY) /
                                        scaleFactor,
                                    0.028);
                        if (std::abs(rnd.getBlurNoise(x, y)) < threshold) {
                            // Crimson spreads from tendrils of flesh blocks.
                            // Fill the core of central tendrils with crimtane.
                            if (tile.blockID != TileID::empty ||
                                tile.wallID != WallID::empty ||
                                y > tendrilMinY) {
                                tile.blockID =
                                    std::abs(rnd.getBlurNoise(x, y)) <
                                            threshold - 0.045
                                        ? y > world.getUndergroundLevel()
                                              ? TileID::crimtane
                                              : TileID::crimstone
                                        : TileID::flesh;
                                if (tile.wallID != WallID::empty) {
                                    tile.wallID =
                                        WallID::Unsafe::crimsonBlister;
                                }
                                // Handle aether bubble.
                                tile.echoCoatBlock = false;
                            }
                        } else {
                            auto blockItr = crimsonBlocks.find(tile.blockID);
                            if (blockItr != crimsonBlocks.end()) {
                                if (y > world.getUndergroundLevel() ||
                                    blockItr->second != TileID::crimtane) {
                                    tile.blockID = blockItr->second;
                                }
                            } else if (
                                tile.blockID == TileID::livingWood ||
                                tile.blockID == TileID::livingMahogany) {
                                tile.blockPaint = Paint::gray;
                            } else if (
                                tile.blockID == TileID::ash &&
                                y < world.getUnderworldLevel() +
                                        10 * rnd.getFineNoise(x, y) - 20) {
                                tile.blockID = TileID::crimstone;
                            }
                            auto wallItr = crimsonWalls.find(tile.wallID);
                            if (wallItr != crimsonWalls.end()) {
                                tile.wallID = wallItr->second;
                            } else if (
                                tile.wallID == WallID::Unsafe::livingWood) {
                                tile.wallPaint = Paint::gray;
                            }
                        }
                    }
                }
            });
    };
    // Surface crimson.
    applyCrimson(surfaceX, surfaceY);
    // Underground crimson.
    applyCrimson(
        undergroundX,
        rnd.getInt(
            world.conf.dontDigUp
                ? (world.getUndergroundLevel() + 2 * world.getCavernLevel()) / 3
                : (2 * world.getCavernLevel() + world.getUnderworldLevel()) / 3,
            world.getUnderworldLevel()));
    // Remove high above surface unconnected tendrils.
    bool clearFloating = false;
    for (int y = 0.8 * world.getUndergroundLevel(); y > 0; --y) {
        bool foundBlock = false;
        for (int x = surfaceX - scanDist; x < surfaceX + scanDist; ++x) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::flesh) {
                if (clearFloating) {
                    tile.blockID = TileID::empty;
                } else {
                    foundBlock = true;
                    break;
                }
            }
        }
        if (!foundBlock) {
            clearFloating = true;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Crimson.h`
```
#ifndef CRIMSON_H
#define CRIMSON_H

class World;
class Random;

void genCrimson(Random &rnd, World &world);
void genCrimsonAt(int surfaceX, int undergroundX, Random &rnd, World &world);

#endif // CRIMSON_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Forest.cpp`
```
#include "Forest.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include "structures/data/Rooms.h"
#include "structures/data/SwordShrines.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>
#include <numbers>

void drawRect(
    Pointf topLeft,
    Pointf bottomRight,
    double skewX,
    double skewY,
    std::vector<Point> &treeTiles,
    World &world)
{
    int width = bottomRight.x - topLeft.x;
    int height = bottomRight.y - topLeft.y;
    for (int i = 0; i < width; ++i) {
        for (int j = 0; j < height; ++j) {
            int x = topLeft.x + i + skewX * j;
            int y = topLeft.y + j + skewY * i;
            Tile &tile = world.getTile(x, y);
            tile.blockID = TileID::livingWood;
            tile.wallID = WallID::Unsafe::livingWood;
            treeTiles.emplace_back(x, y);
        }
    }
}

void drawLine(
    Pointf from,
    Pointf to,
    double width,
    std::vector<Point> &treeTiles,
    World &world)
{
    double deltaX = std::abs(to.x - from.x);
    double deltaY = std::abs(to.y - from.y);
    if (deltaY > deltaX) {
        if (from.y > to.y) {
            std::swap(from, to);
        }
        drawRect(
            {std::floor(from.x - width), std::floor(from.y)},
            {std::ceil(from.x + width), std::ceil(to.y)},
            (to.x - from.x) / deltaY,
            0,
            treeTiles,
            world);
    } else {
        if (from.x > to.x) {
            std::swap(from, to);
        }
        drawRect(
            {std::floor(from.x), std::floor(from.y - width)},
            {std::ceil(to.x), std::ceil(from.y + width)},
            0,
            (to.y - from.y) / deltaX,
            treeTiles,
            world);
    }
}

void growLeaves(
    Pointf from,
    Pointf to,
    double leafSpan,
    std::vector<Point> &treeTiles,
    World &world)
{
    int minX = std::floor(std::min(from.x, to.x) - leafSpan);
    int maxX = std::ceil(std::max(from.x, to.x) + leafSpan);
    int minY = std::floor(std::min(from.y, to.y) - leafSpan);
    int maxY = std::ceil(std::max(from.y, to.y) + leafSpan);
    for (int x = minX; x < maxX; ++x) {
        for (int y = minY; y < maxY; ++y) {
            if (hypot(from, {x, y}) + hypot(to, {x, y}) < 2 * leafSpan) {
                Tile &tile = world.getTile(x, y);
                if (tile.blockID == TileID::empty) {
                    tile.blockID = TileID::leaf;
                    tile.wallID = WallID::Safe::livingLeaf;
                    treeTiles.emplace_back(x, y);
                }
            }
        }
    }
}

void growBranch(
    Pointf from,
    double weight,
    double stretch,
    double angle,
    std::vector<Point> &treeTiles,
    Random &rnd,
    World &world)
{
    if (weight < 0.5) {
        return;
    }
    angle = (3 * angle - std::numbers::pi / 2) / 4;
    Pointf to{
        from.x + stretch * weight * std::cos(angle),
        from.y + stretch * weight * std::sin(angle)};
    drawLine(from, to, weight / 2, treeTiles, world);
    if (weight < 2.3) {
        growLeaves(from, to, std::max(5.5, 4 * weight), treeTiles, world);
    }
    double threshold = rnd.getDouble(0, 1);
    if (threshold < 0.45) {
        growBranch(
            to,
            rnd.getDouble(0.75, 0.88) * weight,
            stretch,
            angle + rnd.getDouble(-std::numbers::pi / 8, std::numbers::pi / 8),
            treeTiles,
            rnd,
            world);
        if (threshold < 0.32) {
            growBranch(
                to,
                rnd.getDouble(0.3, 0.5) * weight,
                stretch,
                angle + (threshold < 0.16 ? std::numbers::pi / 2
                                          : -std::numbers::pi / 2),
                treeTiles,
                rnd,
                world);
        }
    } else {
        double branchDistr = rnd.getDouble(0.55, 0.75);
        growBranch(
            to,
            branchDistr * weight,
            stretch,
            angle + rnd.getDouble(-std::numbers::pi / 2, -std::numbers::pi / 4),
            treeTiles,
            rnd,
            world);
        growBranch(
            to,
            (1.3 - branchDistr) * weight,
            stretch,
            angle + rnd.getDouble(std::numbers::pi / 4, std::numbers::pi / 2),
            treeTiles,
            rnd,
            world);
    }
}

void growRoot(
    Pointf from,
    double weight,
    double angle,
    Random &rnd,
    World &world)
{
    if (weight < 0.5) {
        return;
    }
    angle = (4 * angle + std::numbers::pi / 2) / 5;
    Pointf to{
        from.x + 1.8 * weight * std::cos(angle),
        from.y + 1.8 * weight * std::sin(angle)};
    std::vector<Point> ignored;
    drawLine(from, to, weight / 2, ignored, world);
    if (rnd.getDouble(0, 1) < 0.6) {
        growRoot(
            to,
            rnd.getDouble(0.9, 0.99) * weight,
            angle + rnd.getDouble(-std::numbers::pi / 8, std::numbers::pi / 8),
            rnd,
            world);
    } else {
        double rootDistr = rnd.getDouble(0.5, 0.8);
        growRoot(
            to,
            rootDistr * weight,
            angle + rnd.getDouble(-std::numbers::pi / 2, -std::numbers::pi / 4),
            rnd,
            world);
        growRoot(
            to,
            (1.3 - rootDistr) * weight,
            angle + rnd.getDouble(std::numbers::pi / 4, std::numbers::pi / 2),
            rnd,
            world);
    }
}

Point findDoor(TileBuffer &room)
{
    for (int i = 0; i < room.getWidth(); ++i) {
        for (int j = 0; j < room.getHeight(); ++j) {
            if (room.getTile(i, j).blockID == TileID::door) {
                return {i, j};
            }
        }
    }
    return {0, 0};
}

void growTapRoot(double x, double y, int roomId, Random &rnd, World &world)
{
    if (world.regionPasses(x - 3, y - 5, 6, 5, [](Tile &tile) {
            return tile.blockID == TileID::livingWood;
        })) {
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                if (j == 0 && (i == 0 || i == 3)) {
                    continue;
                }
                Tile &tile = world.getTile(x - 2 + i, y - 5 + j);
                tile.blockID = TileID::empty;
            }
        }
    }
    int tunnelDepth = 150;
    while (world.getTile(x, y + tunnelDepth).blockID != TileID::empty) {
        ++tunnelDepth;
    }
    int anchorX;
    int anchorY;
    for (int numTries = 0; numTries < 100; ++numTries) {
        anchorY = y + tunnelDepth * rnd.getDouble(0.4, 0.7);
        anchorX = x + 2.8 * rnd.getFineNoise(x, anchorY - y);
        int scanX = numTries < 50 ? 12 : 8;
        if (world.regionPasses(
                anchorX - scanX,
                anchorY,
                2 * scanX,
                numTries < 50 ? 8 : 6,
                [](Tile &tile) { return tile.blockID != TileID::empty; })) {
            break;
        }
    }
    for (int j = 0; j < tunnelDepth; ++j) {
        int iMin = 2 * rnd.getFineNoise(x + 100, j) - 4;
        int iMax = 2 * rnd.getFineNoise(x + 200, j) + 5;
        for (int i = iMin; i < iMax; ++i) {
            Tile &tile =
                world.getTile(x + i + 2.8 * rnd.getFineNoise(x, j), y + j);
            if (tile.blockID == TileID::livingWood ||
                (tile.blockID == TileID::empty &&
                 (tile.wallID != WallID::empty ||
                  y + j - 3 + 3 * rnd.getFineNoise(x + i, y + j) >
                      world.getUndergroundLevel()))) {
                continue;
            }
            tile.wallID = WallID::Unsafe::livingWood;
            if (i < iMin + 2 || i > iMax - 3) {
                tile.blockID = tile.blockID == TileID::grass ||
                                       tile.blockID == TileID::jungleGrass
                                   ? TileID::leaf
                                   : TileID::livingWood;
            } else {
                tile.blockID = TileID::empty;
            }
        }
    }
    world.queuedTreasures.emplace_back([anchorX,
                                        anchorY,
                                        roomId](Random &rnd, World &world) {
        if (world.getTile(anchorX, anchorY).wallID !=
            WallID::Unsafe::livingWood) {
            return;
        }
        TileBuffer room = Data::getRoom(roomId, world.getFramedTiles());
        auto [doorI, doorJ] = findDoor(room);
        bool placeOnRight = doorI < room.getWidth() / 2;
        int x = anchorX;
        while (world.getTile(x, anchorY).wallID == WallID::Unsafe::livingWood) {
            if (placeOnRight) {
                ++x;
            } else {
                --x;
            }
        }
        if (!placeOnRight) {
            x -= room.getWidth();
        }
        constexpr auto clearableTiles = frozen::make_set<int>(
            {TileID::dirt,
             TileID::grass,
             TileID::stone,
             TileID::livingWood,
             TileID::leaf,
             TileID::corruptGrass,
             TileID::corruptJungleGrass,
             TileID::crimsonGrass,
             TileID::crimsonJungleGrass,
             TileID::mud,
             TileID::jungleGrass,
             TileID::clay,
             TileID::sand,
             TileID::sandstone,
             TileID::hardenedSand,
             TileID::snow,
             TileID::ice,
             TileID::hallowedGrass,
             TileID::pearlstone,
             TileID::pearlsand,
             TileID::aetherium,
             TileID::copperOre,
             TileID::tinOre,
             TileID::ironOre,
             TileID::leadOre,
             TileID::cobaltOre,
             TileID::palladiumOre});
        if (!world.regionPasses(
                x,
                anchorY,
                room.getWidth(),
                room.getHeight(),
                [&clearableTiles](Tile &tile) {
                    return !tile.guarded &&
                           clearableTiles.contains(tile.blockID);
                })) {
            return;
        }
        bool isHallow = !world.regionPasses(
            x,
            anchorY,
            room.getWidth(),
            room.getHeight(),
            [](Tile &tile) { return tile.blockID != TileID::pearlstone; });
        for (int hallX = std::min(x + doorI, anchorX);
             hallX < std::max(x + doorI, anchorX);
             ++hallX) {
            for (int hallY = anchorY + doorJ; hallY < anchorY + doorJ + 3;
                 ++hallY) {
                Tile &tile = world.getTile(hallX, hallY);
                tile.blockID = TileID::empty;
                tile.wallID = WallID::Unsafe::livingWood;
            }
        }
        for (auto [chestX, chestY] : world.placeBuffer(x, anchorY, room)) {
            fillLivingWoodChest(
                world.registerStorage(chestX, chestY),
                rnd,
                world);
        }
        if (isHallow) {
            for (int i = 0; i < room.getWidth(); ++i) {
                for (int j = 0; j < room.getHeight(); ++j) {
                    Tile &tile = world.getTile(x + i, anchorY + j);
                    if (tile.blockID == TileID::livingWood) {
                        tile.blockID = TileID::pearlstone;
                    } else if (tile.blockID == TileID::leaf) {
                        tile.blockID = TileID::aetherium;
                    }
                }
            }
        }
    });
}

void expireLivingTree(
    double weight,
    std::vector<Point> &&treeTiles,
    World &world)
{
    int baseScan = weight * 5;
    std::partial_sort(
        treeTiles.begin(),
        treeTiles.begin() + baseScan,
        treeTiles.end(),
        [](auto &a, auto &b) { return a.y > b.y; });
    world.queuedEvil.emplace_back(
        [baseScan, treeTiles = std::move(treeTiles)](Random &, World &world) {
            int numCorrupt = 0;
            int numCrimson = 0;
            for (auto itr = treeTiles.begin();
                 itr != treeTiles.begin() + baseScan && itr != treeTiles.end();
                 ++itr) {
                Tile &tile = world.getTile(*itr);
                if (tile.blockID == TileID::lesion ||
                    tile.blockPaint == Paint::purple ||
                    tile.wallPaint == Paint::purple) {
                    ++numCorrupt;
                } else if (
                    tile.blockID == TileID::flesh ||
                    tile.blockPaint == Paint::gray ||
                    tile.wallPaint == Paint::gray) {
                    ++numCrimson;
                }
            }
            if (2 * (numCorrupt + numCrimson) < baseScan) {
                return;
            }
            // Tree base is mostly dead? Kill the tree.
            int paint = numCorrupt > numCrimson ? Paint::purple : Paint::gray;
            for (auto [x, y] : treeTiles) {
                Tile &tile = world.getTile(x, y);
                if (tile.blockID == TileID::livingWood) {
                    tile.blockPaint = paint;
                } else if (tile.blockID == TileID::leaf) {
                    tile.blockID = TileID::empty;
                }
                if (tile.wallID == WallID::Unsafe::livingWood) {
                    tile.wallPaint = paint;
                } else if (tile.wallID == WallID::Safe::livingLeaf) {
                    tile.wallID = WallID::empty;
                }
            }
        });
}

void growLivingTree(double x, double y, int roomId, Random &rnd, World &world)
{
    double weight = rnd.getDouble(5, 10);
    std::vector<Point> treeTiles;
    growBranch(
        {x, y},
        weight,
        rnd.getDouble(2.1, 2.7),
        rnd.getDouble(-std::numbers::pi / 8, std::numbers::pi / 8) -
            std::numbers::pi / 2,
        treeTiles,
        rnd,
        world);
    growRoot(
        {x - 0.18 * weight, y},
        0.58 * weight,
        rnd.getDouble(std::numbers::pi / 8, std::numbers::pi / 4) +
            std::numbers::pi / 2,
        rnd,
        world);
    growRoot(
        {x + 0.18 * weight, y},
        0.58 * weight,
        rnd.getDouble(-std::numbers::pi / 4, -std::numbers::pi / 8) +
            std::numbers::pi / 2,
        rnd,
        world);
    growTapRoot(x, y, roomId, rnd, world);
    expireLivingTree(weight, std::move(treeTiles), world);
}

void growLivingTrees(Random &rnd, World &world)
{
    auto partitions = rnd.partitionRange(
        std::max(world.getWidth() / (world.conf.doubleTrouble ? 750 : 1280), 2),
        world.getWidth());
    std::vector<int> rooms(Data::treeRooms.begin(), Data::treeRooms.end());
    std::shuffle(rooms.begin(), rooms.end(), rnd.getPRNG());
    int spawnBuffer = world.conf.spawn == SpawnPoint::surface ? 25
                      : world.conf.spawn == SpawnPoint::ashen
                          ? 120 + world.getWidth() / 64
                          : 0;
    for (int partition : partitions) {
        int numTrees = world.conf.livingTrees * rnd.getDouble(3, 7);
        for (int x = partition - 25 * numTrees; numTrees > 0;
             x += rnd.getInt(45, 55), --numTrees) {
            if (std::abs(x - world.spawn.x) < spawnBuffer) {
                continue;
            }
            int y = world.getSurfaceLevel(x);
            while (world.getTile(x, y).blockID == TileID::empty &&
                   y < world.getUndergroundLevel()) {
                ++y;
            }
            if (world.getTile(x, y).blockID == TileID::grass) {
                growLivingTree(x, y, rnd.pool(rooms), rnd, world);
            }
        }
    }
}

void buryEnchantedSwords(Random &rnd, World &world)
{
    double numSwords = world.getWidth() / rnd.getInt(1800, 3800);
    std::vector<Point> usedLocations;
    constexpr auto avoidTiles = frozen::make_set<int>(
        {TileID::empty,
         TileID::snow,
         TileID::sand,
         TileID::jungleGrass,
         TileID::hive});
    while (numSwords > 0) {
        int x = rnd.getInt(400, 0.36 * world.getWidth());
        if (rnd.getBool()) {
            x = world.getWidth() - x;
        }
        int y = world.getSurfaceLevel(x) + rnd.getInt(25, 45);
        if (!world.regionPasses(
                x - 16,
                y,
                32,
                20,
                [&avoidTiles](Tile &tile) {
                    return !avoidTiles.contains(tile.blockID);
                }) ||
            isLocationUsed(x, y, 100, usedLocations)) {
            numSwords -= 0.002;
            continue;
        }
        usedLocations.emplace_back(x, y);
        for (int i = -15; i < 15; ++i) {
            for (int j = 3; j < 17; ++j) {
                if (std::hypot(i, 17 - j) + 2 * rnd.getFineNoise(x + i, y + j) <
                    13.5) {
                    Tile &tile = world.getTile(x + i, y + j);
                    tile.blockID = TileID::empty;
                    if (i == 0) {
                        tile.wallID = WallID::empty;
                    } else {
                        tile.wallID = WallID::Unsafe::flower;
                    }
                }
            }
        }
        for (int i = -15; i < 15; ++i) {
            for (int j = 2; j < 18; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID == TileID::dirt &&
                    world.isExposed(x + i, y + j)) {
                    tile.blockID = TileID::grass;
                }
            }
        }
        world.queuedTreasures.emplace_back([x, y](Random &, World &world) {
            TileBuffer shrine = Data::getSwordShrine(world.getFramedTiles());
            if (!world.regionPasses(
                    x - shrine.getWidth() / 2,
                    y + 13,
                    shrine.getWidth(),
                    shrine.getHeight(),
                    [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
                !world.regionPasses(
                    x - shrine.getWidth() / 2,
                    y + 13 + shrine.getHeight(),
                    shrine.getWidth(),
                    1,
                    [](Tile &tile) { return tile.blockID != TileID::empty; })) {
                return;
            }
            for (int i = 0; i < shrine.getWidth(); ++i) {
                for (int j = 0; j < shrine.getHeight(); ++j) {
                    Tile &shrineTile = shrine.getTile(i, j);
                    if (shrineTile.blockID == TileID::empty) {
                        continue;
                    }
                    Tile &tile = world.getTile(
                        x - shrine.getWidth() / 2 + i,
                        y + 13 + j);
                    shrineTile.wallID = tile.wallID;
                    tile = shrineTile;
                    tile.guarded = true;
                }
                Tile &base = world.getTile(
                    x - shrine.getWidth() / 2 + i,
                    y + 13 + shrine.getHeight());
                if (base.blockID == TileID::grass) {
                    base.blockID = TileID::dirt;
                }
            }
        });
        --numSwords;
    }
}

void genForest(Random &rnd, World &world)
{
    std::cout << "Nurturing forests\n";
    rnd.shuffleNoise();
    // Add living tree clumps.
    growLivingTrees(rnd, world);
    buryEnchantedSwords(rnd, world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Forest.h`
```
#ifndef FOREST_H
#define FOREST_H

class World;
class Random;

void genForest(Random &rnd, World &world);

#endif // FOREST_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GemCave.cpp`
```
#include "GemCave.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <algorithm>
#include <iostream>

/**
 * Concentrated deposits of two gem types, and associated gem walls for added
 * visibility.
 */
void fillGemCave(
    int x,
    int y,
    int blockA,
    int wallA,
    int blockB,
    int wallB,
    Random &rnd,
    World &world)
{
    int caveSize = rnd.getInt(20, 35);
    for (int i = -caveSize; i < caveSize; ++i) {
        for (int j = -caveSize; j < caveSize; ++j) {
            double threshold = std::max(std::hypot(i, j) / caveSize, 0.35);
            Tile &tile = world.getTile(x + i, y + j);
            // Intermix regular stone within gem deposits.
            int dispersal =
                static_cast<int>(99999 * (1 + rnd.getFineNoise(x + i, y + j))) %
                5;
            if (rnd.getFineNoise(x + i, y + j) > threshold) {
                if (dispersal > 1 && tile.blockID == TileID::stone) {
                    tile.blockID = world.conf.hiveQueen && dispersal < 4
                                       ? TileID::crispyHoney
                                       : blockA;
                }
                if (tile.wallID != WallID::empty) {
                    tile.wallID = wallA;
                }
            } else if (rnd.getFineNoise(x + i, y + j) < -threshold) {
                if (dispersal > 1 && tile.blockID == TileID::stone) {
                    tile.blockID = world.conf.hiveQueen && dispersal < 4
                                       ? TileID::crispyHoney
                                       : blockB;
                }
                if (tile.wallID != WallID::empty) {
                    tile.wallID = wallB;
                }
            }
        }
    }
}

void genGemCave(Random &rnd, World &world)
{
    std::cout << "Burying gems\n";
    rnd.shuffleNoise();
    // Place higher value gems deeper. Excludes amber.
    std::vector<std::pair<int, int>> gemTypes{
        {TileID::amethystStone, WallID::Unsafe::amethystStone},
        {TileID::amethystStone, WallID::Unsafe::amethystStone},
        {TileID::topazStone, WallID::Unsafe::topazStone},
        {TileID::sapphireStone, WallID::Unsafe::sapphireStone},
        {TileID::emeraldStone, WallID::Unsafe::emeraldStone},
        {TileID::rubyStone, WallID::Unsafe::rubyStone},
        {TileID::diamondStone, WallID::Unsafe::diamondStone},
        {TileID::diamondStone, WallID::Unsafe::diamondStone}};
    if (world.conf.dontDigUp) {
        std::reverse(gemTypes.begin(), gemTypes.end());
    }
    int bandHeight =
        ((world.conf.dontDigUp
              ? (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3
              : world.getUnderworldLevel()) -
         world.getUndergroundLevel()) /
        gemTypes.size();
    int numCaves =
        world.conf.gems * world.getWidth() * world.getHeight() / 900000;
    for (size_t band = 0; band + 1 < gemTypes.size(); ++band) {
        for (int i = 0; i < numCaves; ++i) {
            auto [x, y] = findStoneCave(
                world.getUndergroundLevel() + bandHeight * band,
                world.getUndergroundLevel() + bandHeight * (band + 1),
                rnd,
                world);
            if (x != -1) {
                fillGemCave(
                    x,
                    y,
                    gemTypes[band].first,
                    gemTypes[band].second,
                    gemTypes[band + 1].first,
                    gemTypes[band + 1].second,
                    rnd,
                    world);
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GemCave.h`
```
#ifndef GEMCAVE_H
#define GEMCAVE_H

class World;
class Random;

void genGemCave(Random &rnd, World &world);

#endif // GEMCAVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GemGrove.cpp`
```
#include "GemGrove.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include "structures/data/DecoGems.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>
#include <set>

typedef std::array<std::pair<int, int>, 5> GemSwatch;

inline const std::array gemSwatches = std::to_array<GemSwatch>({
    {{{TileID::amethystGemspark, Paint::pink},
      {TileID::amethystGemspark, Paint::violet},
      {TileID::amethystGemspark, Paint::none},
      {TileID::amethystGemspark, Paint::purple},
      {TileID::amethystGemspark, Paint::deepPurple}}},
    {{{TileID::diamondGemspark, Paint::none},
      {TileID::topazGemspark, Paint::yellow},
      {TileID::topazGemspark, Paint::none},
      {TileID::topazGemspark, Paint::brown},
      {TileID::topazGemspark, Paint::orange}}},
    {{{TileID::sapphireGemspark, Paint::skyBlue},
      {TileID::sapphireGemspark, Paint::deepSkyBlue},
      {TileID::sapphireGemspark, Paint::none},
      {TileID::sapphireGemspark, Paint::blue},
      {TileID::sapphireGemspark, Paint::deepBlue}}},
    {{{TileID::emeraldGemspark, Paint::yellow},
      {TileID::emeraldGemspark, Paint::teal},
      {TileID::emeraldGemspark, Paint::lime},
      {TileID::emeraldGemspark, Paint::none},
      {TileID::emeraldGemspark, Paint::green}}},
    {{{TileID::rubyGemspark, Paint::deepViolet},
      {TileID::rubyGemspark, Paint::pink},
      {TileID::rubyGemspark, Paint::deepPink},
      {TileID::rubyGemspark, Paint::none},
      {TileID::rubyGemspark, Paint::deepRed}}},
    {{{TileID::amberGemspark, Paint::yellow},
      {TileID::amberGemspark, Paint::brown},
      {TileID::amberGemspark, Paint::orange},
      {TileID::amberGemspark, Paint::deepOrange},
      {TileID::amberGemspark, Paint::none}}},
    {{{TileID::diamondGemspark, Paint::white},
      {TileID::diamondGemspark, Paint::gray},
      {TileID::diamondGemspark, Paint::none},
      {TileID::diamondGemspark, Paint::black},
      {TileID::diamondGemspark, Paint::shadow}}},
});

TileBuffer getDecoGem(Random &rnd, World &world)
{
    TileBuffer gem =
        Data::getDecoGem(rnd.select(Data::gems), world.getFramedTiles());
    const GemSwatch &swatch = rnd.pool(gemSwatches);
    int offset = rnd.getInt(0, 6 - gem.getWidth() - gem.getHeight());
    for (int i = 0; i < gem.getWidth(); ++i) {
        for (int j = 0; j < gem.getHeight(); ++j) {
            Tile &tile = gem.getTile(i, j);
            if (tile.blockID != TileID::empty) {
                int idx = offset + i + j;
                tile.blockID = swatch[idx].first;
                tile.blockPaint = swatch[idx].second;
            }
        }
    }
    return gem;
}

void placeGroveDecoGems(Random &rnd, World &world)
{
    int groveSize = world.gemGroveSize;
    std::vector<Point> rawLocations;
    for (int i = -groveSize; i < groveSize; ++i) {
        for (int j = -groveSize; j < groveSize; ++j) {
            if (world.getTile(world.gemGrove + Point{i, j}).blockID ==
                    TileID::empty &&
                std::hypot(i, j) < groveSize) {
                rawLocations.push_back(world.gemGrove + Point{i, j});
            }
        }
    }
    std::vector<Point> locations;
    std::sample(
        rawLocations.begin(),
        rawLocations.end(),
        std::back_inserter(locations),
        rawLocations.size() / 70,
        rnd.getPRNG());
    for (auto [x, y] : locations) {
        if (world.regionPasses(
                x - 2,
                y - 2,
                7,
                7,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
            world.regionPasses(x, y, 3, 3, [](Tile &tile) {
                return tile.wallID != WallID::empty &&
                       tile.liquid == Liquid::none && !tile.wireRed;
            })) {
            world.placeBuffer(x, y, getDecoGem(rnd, world));
        }
    }
}

void placeGemChest(Random &rnd, World &world)
{
    int scanDist = 1.5 * world.gemGroveSize;
    for (int iSwap = 0; iSwap < scanDist; ++iSwap) {
        int i = iSwap / 2;
        if (iSwap % 2 == 0) {
            i = -i;
        }
        for (int jSwap = 0; jSwap < scanDist; ++jSwap) {
            int j = jSwap / 2;
            if (jSwap % 2 == 0) {
                j = -j;
            }
            if (world.regionPasses(
                    world.gemGrove.x + i,
                    world.gemGrove.y + j - 1,
                    2,
                    3,
                    [](Tile &tile) {
                        return tile.blockID == TileID::empty &&
                               tile.liquid == Liquid::none;
                    }) &&
                world.regionPasses(
                    world.gemGrove.x + i,
                    world.gemGrove.y + j + 2,
                    2,
                    1,
                    [](Tile &tile) { return tile.blockID == TileID::stone; })) {
                Chest &chest = world.placeChest(
                    world.gemGrove.x + i,
                    world.gemGrove.y + j,
                    Variant::crystal);
                fillCrystalChest(chest, rnd, world);
                return;
            }
        }
    }
}

Point selectGemGroveLocation(double &groveSize, Random &rnd, World &world)
{
    constexpr auto allowedTiles = frozen::make_set<int>(
        {TileID::empty,
         TileID::dirt,
         TileID::stone,
         TileID::clay,
         TileID::mud,
         TileID::sand,
         TileID::ironOre,
         TileID::leadOre,
         TileID::silverOre,
         TileID::tungstenOre,
         TileID::goldOre,
         TileID::platinumOre,
         TileID::cobaltOre,
         TileID::palladiumOre,
         TileID::mythrilOre,
         TileID::orichalcumOre,
         TileID::adamantiteOre,
         TileID::titaniumOre});
    std::set<int> allowedWalls{
        WallVariants::dirt.begin(),
        WallVariants::dirt.end()};
    allowedWalls.insert(WallID::empty);
    if (world.conf.hiveQueen) {
        allowedWalls.insert(WallID::Unsafe::hive);
    }
    constexpr auto partialTiles = frozen::make_set<int>(
        {TileID::snow,
         TileID::ice,
         TileID::thinIce,
         TileID::slush,
         TileID::hardenedSand,
         TileID::sandstone,
         TileID::desertFossil,
         TileID::jungleGrass,
         TileID::silt,
         TileID::ash,
         TileID::ashGrass,
         TileID::marble,
         TileID::granite});
    std::set<int> partialWalls{
        WallID::Unsafe::snow,
        WallID::Unsafe::ice,
        WallID::Unsafe::hardenedSand,
        WallID::Unsafe::sandstone,
        WallID::Unsafe::marble,
        WallID::Unsafe::granite};
    partialWalls.insert(
        WallVariants::jungle.begin(),
        WallVariants::jungle.end());
    partialWalls.insert(WallVariants::stone.begin(), WallVariants::stone.end());
    partialWalls.insert(
        WallVariants::underworld.begin(),
        WallVariants::underworld.end());
    int safeMinY =
        world.conf.dontDigUp
            ? (4 * world.getUndergroundLevel() + world.getCavernLevel()) / 5
            : (2 * world.getCavernLevel() + world.getUnderworldLevel()) / 3;
    int safeMaxY =
        (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    double shrink = groveSize / 10000.0;
    for (int numTries = 0; numTries < 5000; ++numTries, groveSize -= shrink) {
        auto [x, y] = findStoneCave(
            std::min<int>(
                (world.conf.dontDigUp ? world.getUndergroundLevel()
                                      : world.getCavernLevel()) +
                    groveSize,
                safeMinY),
            std::max<int>(world.getUnderworldLevel() - groveSize, safeMaxY),
            rnd,
            world);
        if (x < 75 + groveSize || x > world.getWidth() - 75 - groveSize) {
            continue;
        }
        int threshold = groveSize * groveSize *
                        (world.conf.biomes == BiomeLayout::patches ? 0.8 : 0.1);
        if (world.regionPasses(
                x - groveSize,
                y - groveSize,
                2 * groveSize,
                2 * groveSize,
                [&threshold,
                 &allowedTiles,
                 &allowedWalls,
                 &partialTiles,
                 &partialWalls](Tile &tile) {
                    if (partialTiles.contains(tile.blockID) ||
                        (tile.blockID == TileID::empty &&
                         partialWalls.contains(tile.wallID))) {
                        --threshold;
                        return threshold > 0;
                    }
                    return (allowedTiles.contains(tile.blockID) ||
                            (tile.flag == Flag::border &&
                             tile.blockID == TileID::hive)) &&
                           allowedWalls.contains(tile.wallID);
                })) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void genGemGrove(Random &rnd, World &world)
{
    std::cout << "Imbuing gems\n";
    rnd.restoreShuffleState();
    int noiseShuffleX = rnd.getInt(0, world.getWidth());
    int noiseShuffleY = rnd.getInt(0, world.getHeight());
    double groveSize =
        world.getWidth() * world.getHeight() / 329000 + rnd.getInt(60, 75);
    auto [x, y] = selectGemGroveLocation(groveSize, rnd, world);
    if (x == -1) {
        return;
    }
    for (int i = -groveSize; i < groveSize; ++i) {
        for (int j = -groveSize; j < groveSize; ++j) {
            double threshold = std::min(std::hypot(i, j) / groveSize, 1.0);
            bool shouldClear =
                std::abs(rnd.getCoarseNoise(x + i, 2 * (y + j)) + 0.1) <
                    0.45 - 0.3 * threshold &&
                rnd.getFineNoise(x + i, y + j) > 4.5 * threshold - 4.66;
            bool shouldFill =
                std::max(
                    std::abs(rnd.getBlurNoise(x + i, 5 * (y + j))),
                    std::abs(rnd.getBlurNoise(
                        noiseShuffleX + x + i,
                        noiseShuffleY + 5 * (y + j)))) > 0.4;
            Tile &tile = world.getTile(x + i, y + j);
            if (shouldClear && tile.blockID != TileID::empty) {
                tile.blockID = shouldFill ? TileID::stone : TileID::empty;
            }
        }
    }
    world.gemGrove = {x, y};
    world.gemGroveSize = groveSize;
    world.queuedDeco.emplace_back(placeGroveDecoGems);
    world.queuedTreasures.emplace_back(placeGemChest);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GemGrove.h`
```
#ifndef GEMGROVE_H
#define GEMGROVE_H

#include "Point.h"

class World;
class Random;

void genGemGrove(Random &rnd, World &world);
Point selectGemGroveLocation(double &groveSize, Random &rnd, World &world);
void placeGroveDecoGems(Random &rnd, World &world);
void placeGemChest(Random &rnd, World &world);

#endif // GEMGROVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GlowingMoss.cpp`
```
#include "GlowingMoss.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include "vendor/frozen/set.h"
#include <iostream>

bool isSolidArea(int x, int y, int size, World &world)
{
    constexpr auto allowedTiles =
        frozen::make_set<int>({TileID::dirt, TileID::stone, TileID::clay});
    return world.regionPasses(x, y, size, size, [&allowedTiles](Tile &tile) {
        return allowedTiles.contains(tile.blockID);
    });
}

Point findSolidArea(int minY, int maxY, Random &rnd, World &world)
{
    int size = 8;
    for (int tries = 0; tries < 100; ++tries) {
        int x = rnd.getInt(0, world.getWidth() - size);
        int y = rnd.getInt(minY, maxY - size);
        if (isSolidArea(x, y, size, world)) {
            return {x + size / 2, y + size / 2};
        }
    }
    return {-1, -1};
}

void fillGlowingMossCave(Random &rnd, World &world)
{
    rnd.shuffleNoise();
    auto [centerX, centerY] = findSolidArea(
        world.conf.dontDigUp ? world.getUndergroundLevel()
                             : world.getCavernLevel(),
        world.conf.dontDigUp ? world.getCavernLevel()
                             : world.getUnderworldLevel(),
        rnd,
        world);
    if (centerX == -1) {
        return;
    }
    double size = world.conf.glowingMossSize * world.getWidth() *
                  world.getHeight() / rnd.getDouble(95000, 210000);
    for (int x = centerX - size; x < centerX + size; ++x) {
        for (int y = centerY - size; y < centerY + size; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::dirt || tile.blockID == TileID::stone) {
                double threshold = std::hypot(x - centerX, y - centerY) / size;
                if (std::max(
                        std::abs(rnd.getBlurNoise(5 * x, 5 * y)),
                        std::abs(rnd.getBlurNoise(7 * x, 7 * y))) >
                    std::max(threshold, 0.53)) {
                    // Dig small pockets in the stone for more moss edge
                    // targets.
                    tile.blockID = TileID::empty;
                }
            }
        }
    }
    int mossType = rnd.select(
        {TileID::kryptonMossStone,
         TileID::xenonMossStone,
         TileID::argonMossStone,
         TileID::neonMossStone});
    if (centerY >
        (world.getCavernLevel() + 4 * world.getUnderworldLevel()) / 5) {
        mossType = rnd.select({mossType, (int)TileID::lavaMossStone});
    }
    std::map<int, int> wallRepl;
    for (int wallId : WallVariants::dirt) {
        wallRepl[wallId] = mossType == TileID::lavaMossStone
                               ? rnd.select(WallVariants::underworld)
                               : rnd.select(WallVariants::stone);
    }
    std::vector<Point> mossLocations;
    for (int x = centerX - size; x < centerX + size; ++x) {
        for (int y = centerY - size; y < centerY + size; ++y) {
            double threshold =
                4 * std::hypot(x - centerX, y - centerY) / size - 3;
            if (rnd.getFineNoise(x, y) > threshold) {
                Tile &tile = world.getTile(x, y);
                auto itr = wallRepl.find(tile.wallID);
                if (itr != wallRepl.end()) {
                    tile.wallID = itr->second;
                }
                if (tile.blockID == TileID::stone && world.isExposed(x, y)) {
                    // Coat edges in moss.
                    tile.blockID = mossType;
                    mossLocations.emplace_back(x, y);
                }
            }
        }
    }
    world.queuedDeco.emplace_back([mossLocations](Random &, World &world) {
        for (auto [x, y] : mossLocations) {
            growMossOn(x, y, world);
        }
    });
}

void genGlowingMoss(Random &rnd, World &world)
{
    std::cout << "Energizing moss\n";
    int numCaves = world.conf.glowingMossFreq * rnd.getDouble(2, 9);
    for (int i = 0; i < numCaves; ++i) {
        fillGlowingMossCave(rnd, world);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GlowingMoss.h`
```
#ifndef GLOWINGMOSS_H
#define GLOWINGMOSS_H

class World;
class Random;

void genGlowingMoss(Random &rnd, World &world);

#endif // GLOWINGMOSS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GlowingMushroom.cpp`
```
#include "GlowingMushroom.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/WallID.h"
#include <iostream>

void fillMushroomField(
    int centerX,
    int fieldFloor,
    int fieldSize,
    Random &rnd,
    World &world)
{
    rnd.shuffleNoise();
    int centerY = fieldFloor - 0.35 * fieldSize;
    world.mushroomCenter.emplace_back(centerX, centerY);
    int secondaryBlock = rnd.select({TileID::silt, TileID::slime});
    for (int x = centerX - 1.4 * fieldSize; x < centerX + 1.4 * fieldSize;
         ++x) {
        for (int y = fieldFloor - fieldSize; y < fieldFloor + fieldSize / 2;
             ++y) {
            double threshold =
                4 * std::hypot(x - centerX, 2.1 * (y - centerY)) / fieldSize -
                5;
            if (rnd.getFineNoise(x, y) < threshold) {
                continue;
            }
            Tile &tile = world.getTile(x, y);
            if (std::abs(rnd.getCoarseNoise(x, y)) > 0.07 &&
                std::abs(rnd.getCoarseNoise(x + centerX, y + centerY)) > 0.07 &&
                y > fieldFloor +
                        5 * rnd.getFineNoise(x, world.getUndergroundLevel()) -
                        0.7 * std::sqrt(std::max(
                                  fieldSize * fieldSize -
                                      std::pow(centerX - x, 2),
                                  0.0)) &&
                y < fieldFloor + 10 * rnd.getCoarseNoise(x, 0)) {
                tile.blockID = TileID::empty;
                tile.wallID = WallID::empty;
                for (auto [i, j] : {std::pair{-1, -1}, {-1, 0}, {0, -1}}) {
                    Tile &prevTile = world.getTile(x + i, y + j);
                    if (prevTile.blockID == TileID::mud ||
                        (prevTile.blockID == TileID::marble &&
                         fnv1a32pt(x + i, y + j) % 11 > 4)) {
                        prevTile.blockID = TileID::mushroomGrass;
                    }
                }
            } else {
                switch (tile.blockID) {
                case TileID::marble:
                    if (world.isExposed(x, y) && fnv1a32pt(x, y) % 11 > 4) {
                        tile.blockID = TileID::mushroomGrass;
                        tile.wallID = WallID::Unsafe::mushroom;
                    }
                    break;
                case TileID::grass:
                    tile.blockID = TileID::mushroomGrass;
                    if (tile.wallID != WallID::empty) {
                        tile.wallID = WallID::Unsafe::mushroom;
                    }
                    break;
                case TileID::stone:
                case TileID::clay:
                case TileID::sand:
                case TileID::mud:
                case TileID::jungleGrass:
                case TileID::ice:
                case TileID::sandstone:
                    tile.blockID =
                        world.isExposed(x, y) || rnd.getInt(0, 35) == 0
                            ? TileID::mushroomGrass
                            : TileID::mud;
                    [[fallthrough]];
                case TileID::empty:
                    if (tile.wallID != WallID::empty) {
                        tile.wallID = WallID::Unsafe::mushroom;
                    }
                    break;
                case TileID::dirt:
                    tile.blockID = secondaryBlock;
                default:
                    break;
                }
            }
        }
    }
}

void fillMushroomLayer(Random &rnd, World &world)
{
    parallelFor(std::views::iota(0, world.getWidth()), [&rnd, &world](int x) {
        for (int y =
                 world.getHeight() * (0.84 + 0.05 * rnd.getCoarseNoise(x, 0));
             y < world.getHeight();
             ++y) {
            if (world.getBiome(x, y).active != Biome::jungle) {
                continue;
            }
            Tile &tile = world.getTile(x, y);
            switch (tile.blockID) {
            case TileID::mud:
            case TileID::jungleGrass:
                tile.blockID =
                    world.isExposed(x, y) ||
                            static_cast<int>(
                                99999 * (1 + rnd.getFineNoise(x, y))) %
                                    35 ==
                                0
                        ? TileID::mushroomGrass
                        : TileID::mud;
                [[fallthrough]];
            case TileID::empty:
                if (tile.wallID != WallID::empty) {
                    tile.wallID = WallID::Unsafe::mushroom;
                }
                break;
            }
        }
    });
}

void fillForestMushroomLayer(Random &rnd, World &world)
{
    parallelFor(std::views::iota(0, world.getWidth()), [&rnd, &world](int x) {
        for (int y = world.getUnderworldLevel() *
                     (0.9 + 0.03 * rnd.getCoarseNoise(x, 0));
             y < world.getHeight();
             ++y) {
            if (world.getBiome(x, y).active != Biome::forest) {
                continue;
            }
            Tile &tile = world.getTile(x, y);
            switch (tile.blockID) {
            case TileID::stone:
                tile.blockID = TileID::silt;
                break;
            case TileID::clay:
            case TileID::sand:
                tile.blockID = TileID::slime;
                tile.wallID = WallID::Unsafe::mushroom;
                break;
            case TileID::dirt:
            case TileID::grass:
                tile.blockID =
                    world.isExposed(x, y) ||
                            static_cast<int>(
                                99999 * (1 + rnd.getFineNoise(x, y))) %
                                    35 ==
                                0
                        ? TileID::mushroomGrass
                        : TileID::mud;
                [[fallthrough]];
            case TileID::empty:
                if (tile.wallID != WallID::empty) {
                    tile.wallID = WallID::Unsafe::mushroom;
                }
                break;
            }
        }
    });
}

void genGlowingMushroom(Random &rnd, World &world)
{
    std::cout << "Fertilizing glowing mushrooms\n";
    int numFields = std::max<int>(
        world.conf.glowingMushroomFreq * world.getWidth() * world.getHeight() /
            3388000,
        2);
    int maxTries = numFields * 2500;
    for (int tries = 0; numFields > 0 && tries < maxTries; ++tries) {
        int buffer = (world.conf.glowingMushroomSize > 1.0
                          ? std::lerp(
                                world.conf.glowingMushroomSize,
                                1.0,
                                static_cast<double>(tries) / maxTries)
                          : world.conf.glowingMushroomSize) *
                     0.06 * world.getWidth();
        int centerX = world.getWidth() * rnd.getDouble(0.05, 0.95);
        int fieldFloor = world.conf.dontDigUp
                             ? rnd.getInt(
                                   world.getUndergroundLevel() + buffer,
                                   world.getCavernLevel())
                             : rnd.getInt(
                                   world.getCavernLevel(),
                                   world.getUnderworldLevel() - 50);
        if (world.getBiome(centerX, fieldFloor).forest < 0.99) {
            continue;
        }
        fillMushroomField(
            centerX,
            fieldFloor,
            rnd.getInt(buffer / 4, buffer / 2),
            rnd,
            world);
        --numFields;
    }
    if (world.conf.biomes == BiomeLayout::layers) {
        fillMushroomLayer(rnd, world);
    }
    if (world.conf.dontDigUp) {
        fillForestMushroomLayer(rnd, world);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GlowingMushroom.h`
```
#ifndef GLOWINGMUSHROOM_H
#define GLOWINGMUSHROOM_H

class World;
class Random;

void genGlowingMushroom(Random &rnd, World &world);

#endif // GLOWINGMUSHROOM_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GraniteCave.cpp`
```
#include "GraniteCave.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include "vendor/frozen/set.h"
#include <iostream>

void fillGraniteCave(int centerX, int centerY, Random &rnd, World &world)
{
    double caveSize = world.conf.graniteSize * rnd.getDouble(70, 150);
    int noiseShuffleX = rnd.getInt(0, world.getWidth());
    int noiseShuffleY = rnd.getInt(0, world.getHeight());
    constexpr auto bgOverrideExcl = frozen::make_set<int>(
        {TileID::sand,
         TileID::hardenedSand,
         TileID::sandstone,
         TileID::ice,
         TileID::snow,
         TileID::marble,
         TileID::mud,
         TileID::mushroomGrass,
         TileID::jungleGrass});
    if (!world.conf.shattered) {
        fillLargeWallGaps(
            {centerX - 0.71 * caveSize, centerY - 0.71 * caveSize},
            {centerX + 0.71 * caveSize, centerY + 0.71 * caveSize},
            rnd,
            world);
    }
    for (int x = std::max(centerX - caveSize, 0.0); x < centerX + caveSize;
         ++x) {
        for (int y = std::max(centerY - caveSize, 0.0); y < centerY + caveSize;
             ++y) {
            double threshold = std::hypot(x - centerX, y - centerY) / caveSize;
            if (rnd.getFineNoise(x + noiseShuffleX, y + noiseShuffleY) <
                6 * threshold - 5) {
                continue;
            }
            bool shouldClear =
                std::abs(rnd.getCoarseNoise(x, 2 * y) + 0.1) <
                    0.2 - 0.05 * threshold &&
                rnd.getFineNoise(x, y) > std::min(-0.16, 4 * threshold - 4.16);
            Tile &tile = world.getTile(x, y);
            switch (tile.blockID) {
            case TileID::dirt:
            case TileID::grass:
            case TileID::stone:
                tile.blockID = shouldClear ? TileID::empty : TileID::granite;
                break;
            case TileID::sand:
            case TileID::clay:
                tile.blockID =
                    shouldClear ? TileID::empty : TileID::smoothGranite;
                break;
            case TileID::ice:
            case TileID::sandstone:
            case TileID::mud:
            case TileID::jungleGrass:
            case TileID::mushroomGrass:
            case TileID::marble:
                if (rnd.getFineNoise(x + noiseShuffleX, y + noiseShuffleY) >
                    0) {
                    tile.blockID =
                        shouldClear ? TileID::empty : TileID::granite;
                }
                break;
            default:
                break;
            }
            if ((tile.wallID != WallID::empty || shouldClear) &&
                y < world.getUnderworldLevel() &&
                !bgOverrideExcl.contains(tile.blockID) &&
                (tile.wallID != WallID::Unsafe::marble ||
                 rnd.getFineNoise(x + noiseShuffleX, y + noiseShuffleY) > 0)) {
                tile.wallID = WallID::Unsafe::granite;
            }
        }
    }
    caveSize += 60;
    if (centerY - caveSize < world.getCavernLevel() || world.conf.dontDigUp) {
        return;
    }
    for (int x = std::max(centerX - caveSize, 0.0); x < centerX + caveSize;
         ++x) {
        for (int y = std::max(centerY - caveSize, 0.0); y < centerY + caveSize;
             ++y) {
            if (std::hypot(x - centerX, y - centerY) < caveSize) {
                Tile &tile = world.getTile(x, y);
                if (tile.blockID == TileID::dirt) {
                    tile.blockID = TileID::granite;
                }
            }
        }
    }
}

void genGraniteCave(Random &rnd, World &world)
{
    std::cout << "Smoothing granite\n";
    int numCaves =
        world.conf.graniteFreq * world.getWidth() * world.getHeight() / 2000000;
    rnd.restoreShuffleState();
    int minY = world.conf.biomes == BiomeLayout::layers && !world.conf.hiveQueen
                   ? 0.526 * world.getHeight()
                   : std::midpoint(
                         world.getUndergroundLevel(),
                         world.getCavernLevel());
    for (int i = 0; i < numCaves; ++i) {
        auto [x, y] =
            findStoneCave(minY, world.getUnderworldLevel(), rnd, world, 30);
        if (x != -1) {
            fillGraniteCave(x, y, rnd, world);
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/GraniteCave.h`
```
#ifndef GRANITECAVE_H
#define GRANITECAVE_H

class World;
class Random;

void genGraniteCave(Random &rnd, World &world);

#endif // GRANITECAVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Hive.cpp`
```
#include "Hive.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include <iostream>

bool isHiveEdge(int x, int y, World &world)
{
    Tile &centerTile = world.getTile(x, y);
    if (centerTile.wallID != WallID::Unsafe::hive ||
        centerTile.flag == Flag::border) {
        return false;
    }
    return !world.regionPasses(x - 1, y - 1, 3, 3, [](Tile &tile) {
        return tile.wallID == WallID::Unsafe::hive && tile.flag != Flag::border;
    });
}

Point selectLarvaeLocation(
    int hiveX,
    int hiveY,
    int size,
    std::vector<Point> &usedLocations,
    Random &rnd,
    World &world)
{
    for (int numTries = 0; numTries < 100; ++numTries) {
        int x = rnd.getInt(hiveX - size, hiveX + size);
        int y = rnd.getInt(hiveY - size, hiveY + size);
        if (world.getTile(x, y).blockID == TileID::empty) {
            y = scanWhileEmpty({x, y}, {0, 1}, world).y;
        }
        if (world.getTile(x + 1, y).wallID == WallID::Unsafe::hive &&
            world.regionPasses(
                x,
                y - 2,
                3,
                3,
                [](Tile &tile) {
                    return tile.blockID == TileID::empty &&
                           tile.liquid == Liquid::none;
                }) &&
            world.regionPasses(
                x,
                y + 1,
                3,
                1,
                [](Tile &tile) { return tile.blockID == TileID::hive; }) &&
            !isLocationUsed(x, y, 35, usedLocations)) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void fillHive(int hiveX, int hiveY, Random &rnd, World &world)
{
    fillHive(
        hiveX,
        hiveY,
        world.conf.hiveSize * (15 + world.getWidth() / rnd.getDouble(84, 166)),
        rnd,
        world);
}

void fillHive(int hiveX, int hiveY, double size, Random &rnd, World &world)
{
    rnd.shuffleNoise();
    for (int x = hiveX - size; x < hiveX + size; ++x) {
        for (int y = hiveY - size; y < hiveY + size; ++y) {
            auto [centroidX, centroidY] = getHexCentroid(x, y, 10);
            double threshold =
                3 * std::hypot(hiveX - centroidX, hiveY - centroidY) / size - 2;
            Tile &tile = world.getTile(x, y);
            if (rnd.getFineNoise(centroidX, centroidY) > threshold) {
                tile.blockID = std::abs(rnd.getFineNoise(
                                   centroidX + hiveX,
                                   centroidY + hiveY)) > 0.31
                                   ? TileID::hive
                                   : TileID::empty;
                tile.wallID = WallID::Unsafe::hive;
                tile.flag = Flag::none;
            } else if (
                rnd.getFineNoise(x + hiveX, y + hiveY) >
                    std::max(0.5, threshold) &&
                (tile.blockID == TileID::mud ||
                 tile.blockID == TileID::jungleGrass ||
                 tile.blockID == TileID::mushroomGrass ||
                 tile.blockID == TileID::marble)) {
                tile.blockID = TileID::honey;
            }
        }
    }
    std::vector<Point> hiveEdges;
    for (int x = hiveX - size; x < hiveX + size; ++x) {
        for (int y = hiveY - size; y < hiveY + size; ++y) {
            if (isHiveEdge(x, y, world) &&
                std::hypot(x - hiveX, y - hiveY) < size) {
                hiveEdges.emplace_back(x, y);
            }
        }
    }
    if (size > 200) {
        for (auto [x, y] : hiveEdges) {
            for (int i = -2; i < 3; ++i) {
                for (int j = -2; j < 3; ++j) {
                    Tile &tile = world.getTile(x + i, y + j);
                    tile.blockID = TileID::hive;
                    tile.wallID = WallID::Unsafe::hive;
                }
            }
        }
    } else {
        for (auto [x, y] : hiveEdges) {
            for (int i = -2; i < 3; ++i) {
                for (int j = -2; j < 3; ++j) {
                    Tile &tile = world.getTile(x + i, y + j);
                    if (tile.wallID == WallID::Unsafe::hive) {
                        tile.blockID = TileID::hive;
                    }
                }
            }
        }
    }
    world.queuedTreasures.emplace_back([hiveX,
                                        hiveY,
                                        size](Random &rnd, World &world) {
        std::vector<Point> usedLocations;
        for (int x = hiveX - size; x < hiveX + size; ++x) {
            for (int y = hiveY - size; y < hiveY + size; ++y) {
                Tile &tile = world.getTile(x, y);
                if (tile.blockID == TileID::larva && tile.frameX == 0 &&
                    tile.frameY == 0) {
                    usedLocations.emplace_back(x, y);
                }
            }
        }
        double area = size * size;
        for (int larvaCount = 1 + area / rnd.getInt(2500, 7000); larvaCount > 0;
             --larvaCount) {
            auto [x, y] = selectLarvaeLocation(
                hiveX,
                hiveY,
                size,
                usedLocations,
                rnd,
                world);
            if (x != -1) {
                usedLocations.emplace_back(x, y);
                world.placeFramedTile(x, y - 2, TileID::larva);
            }
        }
        if (rnd.getDouble(0, 1) > std::min(0.4, 1 - area / 15000)) {
            auto [x, y] = selectLarvaeLocation(
                hiveX,
                hiveY,
                size,
                usedLocations,
                rnd,
                world);
            if (x != -1) {
                Chest &chest = world.placeChest(x, y - 1, Variant::honey);
                fillHoneyChest(chest, getChestDepth(x, y, world), rnd, world);
            }
        }
        embedWaterfalls(
            {hiveX - size, hiveY - size / 2.5},
            {hiveX + size, hiveY + size / 3.5},
            {TileID::hive},
            Liquid::honey,
            35,
            rnd,
            world);
    });
}

Point selectHiveLocation(Random &rnd, World &world)
{
    if (world.conf.biomes == BiomeLayout::columns && !world.conf.hiveQueen) {
        return {
            rnd.getInt(
                std::max<int>(
                    world.jungleCenter -
                        world.conf.jungleSize * 0.075 * world.getWidth(),
                    100),
                std::min<int>(
                    world.jungleCenter +
                        world.conf.jungleSize * 0.075 * world.getWidth(),
                    world.getWidth() - 100)),
            rnd.getInt(
                (world.getUndergroundLevel() + world.getCavernLevel()) / 2,
                (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3)};
    }
    for (int numTries = 0; numTries < 100; ++numTries) {
        int x = rnd.getInt(350, world.getWidth() - 350);
        int y = rnd.getInt(
            (world.getUndergroundLevel() + world.getCavernLevel()) / 2,
            (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3);
        int borderScan = 90 - numTries / 2;
        if (isInBiome(
                x,
                y,
                15 + world.getWidth() / 120,
                Biome::jungle,
                world) &&
            (!world.conf.hiveQueen ||
             world.regionPasses(
                 x - borderScan / 2,
                 y - borderScan / 2,
                 borderScan,
                 borderScan,
                 [](Tile &tile) { return tile.flag != Flag::border; }))) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void genHive(Random &rnd, World &world)
{
    std::cout << "Importing bees\n";
    int numHives =
        world.conf.hiveFreq * std::max(0.4 * world.conf.jungleSize, 1.0) *
        (2.1 +
         rnd.getDouble(0, world.getWidth() * world.getHeight() / 5750000.0));
    for (int tries = 5 * numHives; tries > 0 && numHives > 0; --tries) {
        auto [x, y] = selectHiveLocation(rnd, world);
        if (x != -1) {
            fillHive(x, y, rnd, world);
            --numHives;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Hive.h`
```
#ifndef HIVE_H
#define HIVE_H

class World;
class Random;

void fillHive(int hiveX, int hiveY, Random &rnd, World &world);
void fillHive(int hiveX, int hiveY, double size, Random &rnd, World &world);
void genHive(Random &rnd, World &world);

#endif // HIVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Jungle.cpp`
```
#include "Jungle.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include <algorithm>
#include <iostream>
#include <map>
#include <numbers>
#include <set>

int levitateIsland(int center, int width, Random &rnd, World &world)
{
    int yMin = 0.45 * world.getUndergroundLevel();
    int xMin = center - width;
    int xMax = center + width;
    int minSurface = world.getHeight();
    for (int x = xMin; x < xMax; ++x) {
        minSurface = std::min(world.getSurfaceLevel(x), minSurface);
    }
    int floatHeight = rnd.getDouble(0.07, 0.2) * world.getUndergroundLevel();
    yMin = minSurface - floatHeight - 5;
    for (int x = xMin; x < xMax; ++x) {
        int yMax = yMin - 1.9 * (x - xMin) * (x - xMax) / width +
                   37 * rnd.getFineNoise(x, 0);
        if (world.conf.hiveQueen) {
            for (int y = yMin; y < yMax; ++y) {
                Tile &a = world.getTile(x, y);
                Tile &b = world.getTile(x, y + floatHeight);
                if (a.flag == Flag::border) {
                    if (b.flag != Flag::border) {
                        b = {};
                    }
                } else if (b.flag == Flag::border) {
                    if (y + floatHeight > world.getSurfaceLevel(x)) {
                        a.blockID = TileID::mud;
                    }
                } else {
                    std::swap(a, b);
                }
            }
        } else {
            for (int y = yMin; y < yMax; ++y) {
                std::swap(
                    world.getTile(x, y),
                    world.getTile(x, y + floatHeight));
            }
        }
    }
    return minSurface;
}

bool drawMahoganySegment(Pointf from, Pointf to, double width, World &world)
{
    std::set<Point> fillTiles;
    for (double t = 0; t <= 1; t += 0.1) {
        double centerX = std::lerp(from.x, to.x, t);
        double centerY = std::lerp(from.y, to.y, t);
        for (int x = centerX - width; x < centerX + width; ++x) {
            for (int y = centerY - width; y < centerY + width; ++y) {
                if (std::hypot(x - centerX, y - centerY) < width) {
                    fillTiles.emplace(x, y);
                }
            }
        }
    }
    size_t numCrossed = 0;
    for (auto [x, y] : fillTiles) {
        Tile &tile = world.getTile(x, y);
        if (tile.blockID == TileID::livingMahogany) {
            ++numCrossed;
        } else {
            tile.blockID = TileID::livingMahogany;
            tile.wallID = WallID::Unsafe::livingWood;
        }
    }
    return 2 * numCrossed > fillTiles.size();
}

void growMahoganyVine(
    Pointf from,
    double weight,
    double angle,
    Random &rnd,
    World &world)
{
    if (weight < 0.6) {
        return;
    }
    angle += std::clamp(
        1.8 * rnd.getFineNoise(from.x, from.y),
        -std::numbers::pi / 3,
        std::numbers::pi / 3);
    Pointf to{
        from.x + 3.9 * weight * std::cos(angle),
        from.y + 3.9 * weight * std::sin(angle)};
    bool crossedSegment = drawMahoganySegment(from, to, weight, world);
    if (crossedSegment && weight < 1.9) {
        return;
    }
    growMahoganyVine(to, rnd.getDouble(0.97, 0.98) * weight, angle, rnd, world);
    switch (static_cast<int>(99999 * (1 + rnd.getFineNoise(from.x, from.y))) %
            11) {
    case 0:
        growMahoganyVine(
            to,
            0.65 * weight,
            angle - std::numbers::pi / 2,
            rnd,
            world);
        break;
    case 1:
        growMahoganyVine(
            to,
            0.65 * weight,
            angle + std::numbers::pi / 2,
            rnd,
            world);
        break;
    case 2:
    case 3:
    case 4:
        for (int x = from.x - 6; x < from.x + 6; ++x) {
            for (int y = from.y - 6; y < from.y + 6; ++y) {
                Tile &tile = world.getTile(x, y);
                double threshold = hypot(from, {x, y}) / 3 - 1;
                if (tile.blockID == TileID::empty &&
                    rnd.getFineNoise(x, y) > threshold) {
                    tile.blockID = TileID::mahoganyLeaf;
                    tile.wallID = WallID::Safe::livingLeaf;
                }
            }
        }
        break;
    }
}

void growMahoganyVines(
    int minX,
    int maxX,
    int minY,
    int maxY,
    Random &rnd,
    World &world)
{
    int numVines = (maxY - minY) * (maxX - minX) / rnd.getInt(6910, 8640);
    while (numVines > 0) {
        int x = rnd.getInt(minX, maxX);
        int y = rnd.getInt(minY, maxY);
        if (!world.regionPasses(x - 4, y - 4, 8, 8, [](Tile &tile) {
                return tile.blockID != TileID::empty &&
                       tile.blockID != TileID::livingMahogany &&
                       tile.blockID != TileID::mahoganyLeaf;
            })) {
            continue;
        }
        growMahoganyVine(
            {x, y},
            rnd.getDouble(2.1, 2.5),
            rnd.getDouble(-std::numbers::pi, std::numbers::pi),
            rnd,
            world);
        --numVines;
    }
}

void connectSurfaceCaves(int xMin, int xMax, Random &rnd, World &world)
{
    rnd.restoreShuffleState();
    for (int x = xMin; x < xMax; ++x) {
        int surface = world.getSurfaceLevel(x);
        for (int y = surface; y < world.getUndergroundLevel(); ++y) {
            double t = std::min(
                std::min({y - surface, x - xMin, xMax - x}) / 75.0,
                1.0);
            double threshold = std::lerp(
                2.94 - 3.1 * y / world.getUndergroundLevel(),
                -0.16,
                t);
            if (std::abs(rnd.getCoarseNoise(x, 2 * y) + 0.1) < 0.15 &&
                rnd.getFineNoise(x, y) > threshold) {
                Tile &tile = world.getTile(x, y);
                if (tile.blockID != TileID::hive) {
                    tile.blockID = TileID::empty;
                }
            }
        }
    }
    rnd.shuffleNoise();
}

void levitateIslands(int lb, int ub, Random &rnd, World &world)
{
    if (world.conf.shattered) {
        growMahoganyVines(
            lb,
            ub,
            0.7 * world.getUndergroundLevel(),
            std::midpoint(world.getUndergroundLevel(), world.getCavernLevel()),
            rnd,
            world);
        return;
    }
    int minSurface = world.getUndergroundLevel();
    int xMin = lb;
    int xMax = lb;
    while (xMax < ub) {
        int width = rnd.getInt(20, 35);
        xMax += width;
        minSurface =
            std::min(levitateIsland(xMax, width, rnd, world), minSurface);
        xMax += width;
    }
    connectSurfaceCaves(xMin, xMax, rnd, world);
    int yMin = minSurface - 0.22 * world.getUndergroundLevel();
    int yMax = minSurface + 0.1 * world.getUndergroundLevel();
    growMahoganyVines(xMin, xMax, yMin, yMax, rnd, world);
    for (int x = xMin - 100; x < xMax + 100; ++x) {
        for (int y = yMin - 100; y < yMax + 100; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID != TileID::livingMahogany ||
                static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) % 7 !=
                    0) {
                continue;
            }
            std::map<int, int> neighbors;
            for (auto [i, j] : {std::pair{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) {
                ++neighbors[world.getTile(x + i, y + j).blockID];
            }
            if (neighbors[TileID::empty] == 1 &&
                neighbors[TileID::livingMahogany] == 3) {
                tile.blockID = TileID::jungleGrass;
            }
        }
    }
}

void genJungle(Random &rnd, World &world)
{
    std::cout << "Generating jungle\n";
    rnd.shuffleNoise();
    int minX;
    int maxX;
    if (world.conf.biomes == BiomeLayout::columns && !world.conf.hiveQueen) {
        double islandScale = world.conf.jungleSize > 1
                                 ? std::sqrt(world.conf.jungleSize)
                                 : world.conf.jungleSize;
        double center = world.jungleCenter + islandScale *
                                                 rnd.getDouble(-0.05, 0.05) *
                                                 world.getWidth();
        double scanDist =
            islandScale * rnd.getDouble(0.03, 0.035) * world.getWidth();
        minX = center - scanDist;
        maxX = center + scanDist;
    } else {
        int scanDist = rnd.getDouble(0.03, 0.035) * world.getWidth();
        int jungleCenter = world.jungleCenter;
        if (world.conf.hiveQueen) {
            if (jungleCenter > world.getWidth() / 2) {
                jungleCenter += 0.018 * world.getWidth();
            } else {
                jungleCenter -= 0.018 * world.getWidth();
            }
        }
        minX = jungleCenter;
        while (minX > 350 && minX > jungleCenter - scanDist &&
               world.getBiome(minX, world.getSurfaceLevel(minX)).jungle > 0.8) {
            --minX;
        }
        maxX = jungleCenter;
        while (
            maxX < world.getWidth() - 350 && maxX < jungleCenter + scanDist &&
            world.getBiome(maxX + 25, world.getSurfaceLevel(maxX + 25)).jungle >
                0.8) {
            ++maxX;
        }
    }
    levitateIslands(minX, maxX, rnd, world);
    for (int x = minX; x < maxX + 45; ++x) {
        for (int y = 0.45 * world.getUndergroundLevel();
             y < world.getUndergroundLevel();
             ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::mud && world.isExposed(x, y)) {
                tile.blockID = TileID::jungleGrass;
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Jungle.h`
```
#ifndef JUNGLE_H
#define JUNGLE_H

class World;
class Random;

void levitateIslands(int lb, int ub, Random &rnd, World &world);
void genJungle(Random &rnd, World &world);

#endif // JUNGLE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/MarbleCave.cpp`
```
#include "MarbleCave.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <iostream>

void fillMarbleCave(int x, int y, Random &rnd, World &world)
{
    double caveWidth = world.conf.marbleSize * rnd.getDouble(70, 150);
    double caveHeight = world.conf.marbleSize * rnd.getDouble(40, 70);
    rnd.shuffleNoise();
    if (!world.conf.shattered) {
        fillLargeWallGaps(
            {x - 0.7 * caveWidth, y - 0.7 * caveHeight},
            {x + 0.7 * caveWidth, y + 0.7 * caveHeight},
            rnd,
            world);
    }
    for (int i = std::max<int>(-caveWidth, -x); i < caveWidth; ++i) {
        int stalactiteLen = 0;
        int stalacIter = 0;
        for (int j = std::max<int>(-caveHeight, -y); j < caveHeight; ++j) {
            double threshold =
                4 * std::hypot(i / caveWidth, j / caveHeight) - 3;
            if (rnd.getFineNoise(x + i, y + j) < threshold) {
                continue;
            }
            Tile &tile = world.getTile(x + i, y + j);
            bool nextTileIsEmpty =
                world.getTile(x + i, y + j + 1).blockID == TileID::empty;
            switch (tile.blockID) {
            case TileID::dirt:
            case TileID::grass:
            case TileID::stone:
            case TileID::ice:
            case TileID::sandstone:
            case TileID::mud:
            case TileID::jungleGrass:
                tile.blockID = TileID::marble;
                if (nextTileIsEmpty) {
                    stalactiteLen = std::max(
                        0.0,
                        16 * rnd.getFineNoise(4 * (x + i), 100 * stalacIter));
                    ++stalacIter;
                }
                break;
            case TileID::clay:
            case TileID::sand:
                if (world.getBiome(x + i, y + j).active != Biome::desert) {
                    tile.blockID = TileID::smoothMarble;
                }
                break;
            case TileID::empty:
                if (nextTileIsEmpty && stalactiteLen > 0) {
                    tile.blockID = TileID::marble;
                    --stalactiteLen;
                }
            default:
                break;
            }
            if (tile.wallID != WallID::empty) {
                tile.wallID = WallID::Unsafe::marble;
            }
        }
    }
}

void genMarbleCave(Random &rnd, World &world)
{
    std::cout << "Excavating marble\n";
    int numCaves =
        world.conf.marbleFreq * world.getWidth() * world.getHeight() / 1200000;
    int minY =
        std::midpoint(world.getUndergroundLevel(), world.getCavernLevel());
    int maxY = world.conf.biomes == BiomeLayout::layers && !world.conf.hiveQueen
                   ? 0.526 * world.getHeight()
                   : world.getUnderworldLevel();
    for (int i = 0; i < numCaves; ++i) {
        auto [x, y] = i % 3 == 0 ? findStoneCave(minY, maxY, rnd, world, 30)
                                 : findCave(
                                       minY,
                                       maxY,
                                       rnd,
                                       world,
                                       30,
                                       {TileID::stone,
                                        TileID::snow,
                                        TileID::ice,
                                        TileID::sandstone,
                                        i % 2 == 0 ? TileID::jungleGrass
                                                   : TileID::hardenedSand});
        if (x != -1) {
            fillMarbleCave(x, y, rnd, world);
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/MarbleCave.h`
```
#ifndef MARBLECAVE_H
#define MARBLECAVE_H

class World;
class Random;

void genMarbleCave(Random &rnd, World &world);

#endif // MARBLECAVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Meteorite.cpp`
```
#include "biomes/Meteorite.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/WallID.h"
#include "structures/Dungeon.h"
#include "structures/StructureUtil.h"
#include "vendor/frozen/set.h"
#include <iostream>

inline constexpr auto emptyBlocks = frozen::make_set<int>(
    {TileID::empty,
     TileID::livingWood,
     TileID::leaf,
     TileID::livingMahogany,
     TileID::mahoganyLeaf,
     TileID::meteorite});

void placeMeteorite(int x, int y, Random &rnd, World &world)
{
    int size = world.conf.meteoriteSize * rnd.getDouble(26, 30);
    int wallID = rnd.select(WallVariants::underworld);
    for (int i = -size; i < size; ++i) {
        for (int j = -size; j < size; ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            double dist = std::hypot(i, j) / size;
            double threshold = 1.8 * (dist - 0.2) * (0.97 - dist);
            if ((std::abs(i) > 4 || j > 0) &&
                std::abs(rnd.getFineNoise(x + 2 * i, y + 2 * j)) < threshold) {
                if (tile.blockID != TileID::empty &&
                    (dist < 0.7 || fnv1a32pt(x + i, y + j) % 13 < 4)) {
                    if (j < 2 && emptyBlocks.contains(tile.blockID)) {
                        tile = {};
                    } else {
                        tile.blockID = TileID::meteorite;
                        tile.wallID = wallID;
                    }
                }
            } else if (dist < 0.6) {
                if (tile.blockID != TileID::empty &&
                    (dist < 0.35 || fnv1a32pt(x + i, y + j) % 13 < 8)) {
                    tile.blockID = TileID::empty;
                    if (j > size / 4) {
                        tile.liquid = Liquid::lava;
                    }
                }
                if (tile.wallID != WallID::empty) {
                    tile.wallID =
                        (tile.blockID != TileID::empty ||
                         std::abs(rnd.getFineNoise(3 * (x + i), 3 * (y + j))) >
                             0.06)
                            ? wallID
                            : WallID::empty;
                }
            }
        }
    }
    world.queuedTreasures.emplace_back([x, y, size](Random &, World &world) {
        double threshold = 0.85 * size;
        for (int i = -size; i < size; ++i) {
            for (int j = -size; j < size; ++j) {
                if (std::hypot(i, j) < threshold) {
                    Tile &tile = world.getTile(x + i, y + j);
                    if (tile.liquid == Liquid::water) {
                        tile.liquid = Liquid::none;
                    }
                }
            }
        }
    });
}

void genMeteorite(Random &rnd, World &world)
{
    if (world.conf.meteorites <= 0) {
        return;
    }
    std::cout << "Bombarding surface\n";
    rnd.shuffleNoise();
    std::array avoidPoints{
        world.spawn.x,
        world.surfaceEvilCenter,
        computeDungeonCenter(world),
    };
    int buffer = 0.04 * world.getWidth();
    for (int placed = 0, tries = 100 * world.conf.meteorites;
         placed < world.conf.meteorites && tries > 0;
         --tries) {
        int x = rnd.getInt(375, world.getWidth() - 375);
        for (int col : avoidPoints) {
            if (std::abs(col - x) < buffer) {
                x = -1;
                break;
            }
        }
        if (x == -1) {
            continue;
        }
        int y = scanWhileEmpty({x, world.getSurfaceLevel(x)}, {0, 1}, world).y +
                rnd.getInt(-1, 5);
        int numEmpty = 0;
        if (y < world.getUndergroundLevel() &&
            world.regionPasses(
                x - 15,
                y - 8,
                30,
                23,
                [&numEmpty, &world](Tile &tile) {
                    if (emptyBlocks.contains(tile.blockID) ||
                        (world.conf.hiveQueen && tile.flag == Flag::none)) {
                        ++numEmpty;
                    }
                    return numEmpty < 90;
                })) {
            placeMeteorite(x, y, rnd, world);
            ++placed;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Meteorite.h`
```
#ifndef METEORITE_H
#define METEORITE_H

class World;
class Random;

void genMeteorite(Random &rnd, World &world);

#endif // METEORITE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Ocean.cpp`
```
#include "Ocean.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include <algorithm>
#include <iostream>

bool canPlaceReefChest(int x, int y, World &world)
{
    return world.regionPasses(x, y - 1, 2, 3, [](Tile &tile) {
        return tile.blockID == TileID::empty && tile.liquid == Liquid::water;
    }) && world.regionPasses(x, y + 2, 2, 1, [](Tile &tile) {
        return tile.blockID == TileID::sand ||
               tile.blockID == TileID::coralstone;
    });
}

void addGlowRocks(std::vector<Point> &locations, Random &rnd, World &world)
{
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    locations.resize(locations.size() / 150);
    for (auto [x, y] : locations) {
        double radius = rnd.getDouble(2, 3.2);
        if (!world.regionPasses(
                x - radius - 3,
                y - radius - 3,
                6 + 2 * radius,
                6 + 2 * radius,
                [](Tile &tile) { return tile.blockID == TileID::empty; })) {
            continue;
        }
        for (int i = -radius; i < radius; ++i) {
            for (int j = -radius; j < radius; ++j) {
                if (std::hypot(i, j) / radius <
                    0.6 + 0.6 * rnd.getFineNoise(x + i, y + j)) {
                    Tile &tile = world.getTile(x + i, y + j);
                    tile.blockID = TileID::stone;
                }
            }
        }
        int mossType = rnd.select(
            {TileID::kryptonMossStone,
             TileID::xenonMossStone,
             TileID::argonMossStone,
             TileID::neonMossStone});
        std::vector<Point> mossLocations;
        for (int i = -radius; i < radius; ++i) {
            for (int j = -radius; j < radius; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID == TileID::stone &&
                    world.isExposed(x + i, y + j)) {
                    tile.blockID = mossType;
                    mossLocations.emplace_back(x + i, y + j);
                }
            }
        }
        world.queuedDeco.emplace_back([mossLocations](Random &, World &world) {
            for (auto [x, y] : mossLocations) {
                growMossOn(x, y, world);
            }
        });
    }
}

void selectOceanCave(Random &rnd, World &world)
{
    int centerOpt1 = 105;
    int centerOpt2 = world.getWidth() - 105;
    world.oceanCaveCenter =
        centerOpt1 > world.jungleCenter - 0.11 * world.getWidth() - 220
            ? centerOpt2
        : centerOpt2 < world.jungleCenter + 0.11 * world.getWidth() + 220
            ? centerOpt1
            : rnd.select({centerOpt1, centerOpt2});
}

void addOceanCave(int waterTable, Random &rnd, World &world)
{
    int shuffleX = rnd.getInt(0, world.getWidth());
    int shuffleY = rnd.getInt(0, world.getHeight());
    std::vector<Point> locations;
    int centerX = world.oceanCaveCenter;
    int oceanFloor =
        scanWhileEmpty({centerX - 90, waterTable}, {0, 1}, world).y;
    int minY = scanWhileEmpty({centerX + 90, waterTable}, {0, 1}, world).y;
    if (minY > oceanFloor) {
        std::swap(minY, oceanFloor);
    }
    int maxY = std::min<int>(
        oceanFloor + world.conf.oceanCaveSize * 0.2262 * world.getHeight(),
        world.getUnderworldLevel() - 10);
    for (int x = centerX - 100; x < centerX + 100; ++x) {
        for (int y = minY; y < maxY; ++y) {
            double threshold =
                std::max(std::abs(x - centerX), y + 100 - maxY) / 25.0 - 3;
            if (rnd.getFineNoise(x, y) < threshold - 0.5 ||
                std::abs(rnd.getCoarseNoise(2 * x, 2 * y)) > 0.51) {
                continue;
            }
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::stone ||
                tile.blockID == TileID::sandstone ||
                tile.blockID == TileID::ice || tile.blockID == TileID::clay ||
                tile.blockID == TileID::silt) {
                tile.blockID = fnv1a32pt(x, y) % 7 == 0 ? TileID::sand
                                                        : TileID::coralstone;
            } else if (
                tile.blockID == TileID::dirt || tile.blockID == TileID::grass ||
                tile.blockID == TileID::mud ||
                tile.blockID == TileID::jungleGrass ||
                (tile.blockID == TileID::empty &&
                 tile.liquid == Liquid::none)) {
                tile.blockID = fnv1a32pt(x, y) % 5 == 0 ? TileID::hardenedSand
                                                        : TileID::sand;
            }
            if (std::abs(rnd.getBlurNoise(2 * x, 2 * y)) < 0.18 &&
                (rnd.getFineNoise(x, y) > std::max(threshold, -0.14) ||
                 rnd.getFineNoise(x, y) < -0.5 ||
                 rnd.getFineNoise(x + shuffleX, y + shuffleY) <
                     std::min(-threshold - 0.5, -0.4))) {
                tile.blockID = TileID::empty;
                tile.wallID = WallID::empty;
                tile.liquid = Liquid::water;
                if (y > oceanFloor) {
                    locations.emplace_back(x, y);
                }
            }
        }
    }
    addGlowRocks(locations, rnd, world);
    locations.clear();
    for (int x = centerX - 50; x < centerX + 50; ++x) {
        for (int y = world.getUndergroundLevel(); y < maxY; ++y) {
            if (canPlaceReefChest(x, y, world)) {
                locations.emplace_back(x, y);
            }
        }
    }
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    world.queuedTreasures.emplace_back(
        [locs = std::move(locations)](Random &rnd, World &world) {
            int numChests = std::max<int>(locs.size() / 100, 2);
            std::vector<Point> usedLocations;
            for (auto [x, y] : locs) {
                if (canPlaceReefChest(x, y, world) &&
                    !isLocationUsed(x, y, 50, usedLocations)) {
                    usedLocations.emplace_back(x, y);
                    Chest &chest = world.placeChest(x, y, Variant::reef);
                    if (y < world.getCavernLevel()) {
                        fillWaterChest(chest, Depth::underground, rnd, world);
                    } else {
                        fillWaterChest(chest, Depth::cavern, rnd, world);
                    }
                    --numChests;
                    if (numChests <= 0) {
                        break;
                    }
                }
            }
        });
}

void setOceanSpawn(Random &rnd, World &world)
{
    std::vector<Point> opts;
    std::vector<Point> opts4;
    auto addSpawnOpt = [&opts, &opts4, &world](int x, int y) {
        if (world.regionPasses(
                x - 1,
                y - 4,
                3,
                5,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
            world.regionPasses(x - 1, y + 1, 3, 1, [](Tile &tile) {
                return tile.blockID != TileID::empty;
            })) {
            opts.emplace_back(x, y);
            if (world.regionPasses(
                    x - 2,
                    y - 4,
                    1,
                    5,
                    [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
                world.regionPasses(x - 2, y + 1, 1, 1, [](Tile &tile) {
                    return tile.blockID != TileID::empty;
                })) {
                opts4.emplace_back(x, y);
            }
        }
    };
    std::vector<int> centers;
    if (world.conf.celebration || world.conf.hiveQueen) {
        centers.push_back(
            world.oceanCaveCenter < 400 ? 300 : world.getWidth() - 300);
    } else {
        centers.insert(centers.end(), {300, world.getWidth() - 300});
    }
    for (int x : centers) {
        int y = world.getSurfaceLevel(x);
        for (int i = -50; i < 50; ++i) {
            for (int j = -20; j < 20; ++j) {
                addSpawnOpt(x + i, y + j);
            }
        }
    }
    if (!opts4.empty()) {
        opts = opts4;
    } else if (opts.empty()) {
        return;
    }
    std::shuffle(opts.begin(), opts.end(), rnd.getPRNG());
    world.spawn = *std::min_element(
        opts.begin(),
        opts.end(),
        [](const Point &a, const Point &b) { return a.y < b.y; });
}

void genOceans(Random &rnd, World &world)
{
    std::cout << "Filling oceans\n";
    rnd.shuffleNoise();
    int waterTable = std::max(
                         world.getSurfaceLevel(300),
                         world.getSurfaceLevel(world.getWidth() - 300)) +
                     rnd.getInt(4, 12);
    selectOceanCave(rnd, world);
    for (int x = 0; x < 390; ++x) {
        double drop = world.conf.oceanSize * 90 *
                      (1 - 1 / (1 + std::exp(0.041 * (200 - x))));
        double sandDepth = (40 + 9 * rnd.getCoarseNoise(x, 0)) *
                           std::min(1.0, (400.0 - x) / 160);
        auto fillColumn = [&](int effectiveX) {
            int sandTile = TileID::sand;
            int shellPileTile = TileID::shellPile;
            int siltTile = TileID::silt;
            if (world.conf.hiveQueen &&
                ((world.oceanCaveCenter < 400) != (effectiveX < 400))) {
                sandTile = TileID::honey;
                shellPileTile = TileID::hive;
                siltTile = TileID::honey;
            }
            for (int y = world.getSurfaceLevel(effectiveX) - 10;
                 y < world.getUndergroundLevel();
                 ++y) {
                if (world.getTile(effectiveX, y).blockID != TileID::empty &&
                    (y > waterTable ||
                     world.getTile(effectiveX, y).blockID != TileID::hive)) {
                    for (int i = 0; i < drop; ++i) {
                        Tile &tile = world.getTile(effectiveX, y + i);
                        tile.wallID = WallID::empty;
                        tile.blockID = TileID::empty;
                        if (y + i > waterTable) {
                            tile.liquid = Liquid::water;
                        }
                    }
                    for (int i = drop + 1; i < drop + sandDepth; ++i) {
                        Tile &tile = world.getTile(effectiveX, y + i);
                        if (tile.wallID == WallID::Unsafe::dirt) {
                            tile.wallID = WallID::Unsafe::wornStone;
                        } else {
                            tile.wallID = WallID::empty;
                        }
                        if (tile.blockID == TileID::mud ||
                            tile.blockID == TileID::jungleGrass) {
                            tile.blockID = siltTile;
                        } else if (y + i > waterTable + 20) {
                            if (tile.blockID == TileID::stone ||
                                tile.blockID == TileID::sandstone ||
                                tile.blockID == TileID::ice) {
                                tile.blockID = TileID::coralstone;
                            } else {
                                tile.blockID = sandTile;
                            }
                        } else if (
                            tile.blockID != TileID::dirt &&
                            tile.blockID != TileID::grass &&
                            tile.blockID != TileID::sand &&
                            tile.blockID != TileID::snow) {
                            tile.blockID = shellPileTile;
                        } else {
                            tile.blockID = sandTile;
                        }
                    }
                    break;
                }
            }
        };
        fillColumn(x);
        fillColumn(world.getWidth() - x - 1);
    }
    addOceanCave(waterTable, rnd, world);
    if (world.conf.spawn == SpawnPoint::ocean) {
        setOceanSpawn(rnd, world);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Ocean.h`
```
#ifndef OCEAN_H
#define OCEAN_H

class World;
class Random;

void genOceans(Random &rnd, World &world);

#endif // OCEAN_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/SpiderNest.cpp`
```
#include "SpiderNest.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <iostream>

void fillSpiderNest(int x, int y, Random &rnd, World &world)
{
    int nestSize = world.conf.spiderNestSize * rnd.getInt(15, 50);
    for (int i = -nestSize; i < nestSize; ++i) {
        for (int j = -nestSize; j < nestSize; ++j) {
            double threshold = 2 * std::hypot(i, j) / nestSize - 1;
            if (rnd.getFineNoise(x + i, y + j) > threshold) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID == TileID::empty) {
                    tile.wallID = WallID::Unsafe::spider;
                }
            }
        }
    }
}

void genSpiderNest(Random &rnd, World &world)
{
    std::cout << "Hatching spiders\n";
    rnd.shuffleNoise();
    int numNests = world.conf.spiderNestFreq * world.getWidth() *
                   world.getHeight() / 900000;
    int minY = world.conf.dontDigUp ? world.getUndergroundLevel()
                                    : world.getCavernLevel();
    int maxY = world.conf.dontDigUp ? world.getCavernLevel()
                                    : world.getUnderworldLevel() - 20;
    for (int i = 0; i < numNests; ++i) {
        auto [x, y] = findStoneCave(minY, maxY, rnd, world);
        if (x != -1) {
            fillSpiderNest(x, y, rnd, world);
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/SpiderNest.h`
```
#ifndef SPIDERNEST_H
#define SPIDERNEST_H

class World;
class Random;

void genSpiderNest(Random &rnd, World &world);

#endif // SPIDERNEST_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Underworld.cpp`
```
#include "Underworld.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include "structures/data/Bridges.h"
#include <algorithm>
#include <iostream>
#include <map>
#include <set>

void copyTemplateTile(const Tile &from, Tile &to, int x, int y, Random &rnd)
{
    if (from.wallID != WallID::empty) {
        to.wallID =
            from.wallID == WallID::Safe::cloud ? WallID::empty : from.wallID;
        to.wallPaint = from.wallPaint;
    }
    if (from.blockID != TileID::empty) {
        to.blockID = from.blockID;
        if (to.blockID == TileID::obsidianBrick &&
            static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) % 7 == 0) {
            to.blockID = TileID::hellstoneBrick;
        }
        to.blockPaint = from.blockPaint;
        to.frameX = from.frameX;
        to.frameY = from.frameY;
        to.slope = from.slope;
        to.liquid = from.liquid;
    }
}

void identifyGroup(
    Point dest,
    int group,
    std::set<int> &groundedGroups,
    std::map<Point, std::pair<Point, int>> &bridgeData,
    World &world)
{
    auto itr = bridgeData.find(dest);
    if (itr == bridgeData.end()) {
        if (world.getTile(dest).blockID != TileID::empty) {
            groundedGroups.insert(group);
        }
        return;
    } else if (itr->second.second != -1) {
        return;
    }
    itr->second.second = group;
    for (auto delta : {Point{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) {
        identifyGroup(dest + delta, group, groundedGroups, bridgeData, world);
    }
}

void addBridges(int centerLevel, int lavaLevel, Random &rnd, World &world)
{
    rnd.shuffleNoise();
    TileBuffer bridge = Data::getBridge(world.getFramedTiles());
    int bridgeLevel = std::midpoint(centerLevel, lavaLevel);
    auto shouldIncludePt = [&rnd](int x, int y) {
        double threshold = rnd.getCoarseNoise(x, y) > -0.15 ? -0.3 : 0.25;
        return rnd.getFineNoise(x, y) < threshold;
    };
    std::map<Point, std::pair<Point, int>> bridgeData;
    int skipFrom =
        world.conf.dontDigUp
            ? makeCongruent(0.39 * world.getWidth() - 10, bridge.getWidth())
            : -1;
    int skipTo =
        world.conf.dontDigUp
            ? makeCongruent(0.61 * world.getWidth() + 10, bridge.getWidth())
            : -1;
    for (int x = 0; x < world.getWidth(); x += bridge.getWidth()) {
        if (x == skipFrom) {
            x = skipTo;
        }
        for (int i = 0; i < bridge.getWidth(); ++i) {
            for (int j = 0; j < bridge.getHeight(); ++j) {
                Tile &bridgeTile = bridge.getTile(i, j);
                if (bridgeTile.blockID == TileID::empty &&
                    bridgeTile.wallID == WallID::empty) {
                    continue;
                }
                if (j < bridge.getHeight() - 1) {
                    Tile &tile = world.getTile(x + i, bridgeLevel + j);
                    if ((tile.blockID == TileID::empty ||
                         (world.conf.hiveQueen && tile.flag == Flag::border)) &&
                        shouldIncludePt(x + i, bridgeLevel + j)) {
                        bridgeData[{x + i, bridgeLevel + j}] = {{i, j}, -1};
                    }
                } else {
                    for (int y = bridgeLevel + j; y < world.getHeight(); ++y) {
                        Tile &tile = world.getTile(x + i, y);
                        if (tile.blockID != TileID::empty) {
                            if (y < lavaLevel) {
                                continue;
                            } else {
                                break;
                            }
                        }
                        if (shouldIncludePt(x + i, y)) {
                            bridgeData[{x + i, y}] = {{i, j}, -1};
                        }
                    }
                }
            }
        }
    }
    std::set<int> groundedGroups;
    int nextGroup = 0;
    for (auto &[dest, source] : bridgeData) {
        if (source.second == -1) {
            identifyGroup(dest, nextGroup, groundedGroups, bridgeData, world);
            ++nextGroup;
        }
        if (!groundedGroups.contains(source.second)) {
            continue;
        }
        Tile &tile = world.getTile(dest);
        Tile &bridgeTile = bridge.getTile(source.first.x, source.first.y);
        copyTemplateTile(bridgeTile, tile, dest.x, dest.y, rnd);
        tile.guarded = dest.y < lavaLevel;
        if (bridgeTile.blockID == TileID::lamp) {
            int offset = (bridgeTile.frameY % 54) / 18;
            for (int j = 0; j < 4; ++j) {
                if (!bridgeData.contains({dest.x, dest.y + j - offset})) {
                    tile.blockID = TileID::empty;
                    tile.frameX = 0;
                    tile.frameY = 0;
                    break;
                }
            }
        }
    }
}

void genUnderworld(Random &rnd, World &world)
{
    std::cout << "Igniting the depths\n";
    rnd.shuffleNoise();
    int underworldHeight = world.getHeight() - world.getUnderworldLevel();
    int centerLevel = world.getUnderworldLevel() + 0.32 * underworldHeight;
    double upperDist = centerLevel - world.getUnderworldLevel();
    double lowerDist = world.getHeight() - centerLevel;
    int lavaLevel = world.getUnderworldLevel() + 0.46 * underworldHeight;
    double aspectRatio = std::min(
        static_cast<double>(world.getHeight()) / world.getWidth(),
        0.5);
    auto getIslandSurface = [lavaLevel, &rnd, &world](int x) {
        if (!world.conf.dontDigUp) {
            return world.getHeight();
        }
        double threshold = std::clamp(
            100 * std::abs(x - 0.5 * world.getWidth()) / world.getWidth() - 10,
            0.0,
            1.0);
        return static_cast<int>(std::lerp(
            lavaLevel - 10 + 5 * rnd.getFineNoise(x, 0),
            world.getHeight(),
            threshold));
    };
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [aspectRatio,
         centerLevel,
         lavaLevel,
         upperDist,
         lowerDist,
         &getIslandSurface,
         &rnd,
         &world](int x) {
            int stalactiteLen =
                std::max(0.0, 16 * rnd.getFineNoise(4 * x, aspectRatio * x));
            bool foundRoof = false;
            for (int y = centerLevel;
                 y > world.getUnderworldLevel() && stalactiteLen < 10;
                 --y) {
                Tile &tile = world.getTile(x, y);
                if (tile.blockID == TileID::ash) {
                    foundRoof = true;
                }
                if (foundRoof) {
                    if (tile.blockID == TileID::ash) {
                        tile.blockID = TileID::empty;
                        ++stalactiteLen;
                    } else {
                        break;
                    }
                }
            }
            int islandSurface = getIslandSurface(x);
            for (int y = world.getUnderworldLevel(); y < world.getHeight();
                 ++y) {
                Tile &tile = world.getTile(x, y);
                if (y > islandSurface) {
                    tile.blockID = TileID::ash;
                    continue;
                } else if (
                    islandSurface < lavaLevel &&
                    tile.blockID == TileID::hellstone) {
                    tile.blockID = TileID::ash;
                }
                double threshold =
                    0.25 - 0.25 * (y < centerLevel
                                       ? (centerLevel - y) / upperDist
                                       : (y - centerLevel) / lowerDist);
                if (tile.blockID == TileID::hive &&
                    static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) %
                            7 ==
                        0) {
                    tile.blockID = TileID::crispyHoney;
                }
                if (std::abs(rnd.getCoarseNoise(2 * x, y + aspectRatio * x)) <
                    threshold) {
                    for (auto [i, j] : {std::pair{-1, -1}, {-1, 0}, {0, -1}}) {
                        Tile &prevTile = world.getTile(x + i, y + j);
                        if (prevTile.blockID == TileID::mud) {
                            prevTile.blockID = TileID::jungleGrass;
                        }
                    }
                    tile.blockID = TileID::empty;
                    tile.wallID = WallID::empty;
                } else if (
                    std::abs(rnd.getFineNoise(2 * x, 2 * y + aspectRatio * x)) <
                        0.12 ||
                    std::abs(rnd.getFineNoise(3 * x, 3 * y + aspectRatio * x)) <
                        0.06) {
                    tile.wallID = WallID::empty;
                }
                if (y > lavaLevel) {
                    if (tile.blockID == TileID::empty) {
                        tile.liquid = Liquid::lava;
                    }
                } else if (
                    tile.blockID == TileID::mud && world.isExposed(x, y)) {
                    tile.blockID = TileID::jungleGrass;
                }
            }
        });
    addBridges(centerLevel, lavaLevel, rnd, world);
    int skipFrom = 0.15 * world.getWidth();
    int skipTo = 0.85 * world.getWidth();
    int minX = world.conf.dontDigUp ? 0.39 * world.getWidth() : 0;
    int maxX =
        world.conf.dontDigUp ? 0.61 * world.getWidth() : world.getWidth();
    std::vector<Point> spawnOpts;
    for (int x = minX; x < maxX; ++x) {
        if (x == skipFrom) {
            x = skipTo;
        }
        for (int y = world.getUnderworldLevel() - 50; y < lavaLevel; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::ash && world.isExposed(x, y)) {
                tile.blockID = TileID::ashGrass;
                if (world.conf.spawn == SpawnPoint::underworld &&
                    y > centerLevel && x > 150 && x < world.getWidth() - 150) {
                    spawnOpts.emplace_back(x, y - 1);
                }
            }
        }
    }
    if (world.conf.dontDigUp && spawnOpts.size() > 1002) {
        spawnOpts.erase(
            spawnOpts.begin(),
            spawnOpts.begin() + (spawnOpts.size() / 2 - 500));
        spawnOpts.resize(1000);
    }
    std::shuffle(spawnOpts.begin(), spawnOpts.end(), rnd.getPRNG());
    for (auto [x, y] : spawnOpts) {
        int numEmpty = 0;
        if (world.regionPasses(
                x - 7,
                y - 4,
                15,
                1,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
            world.regionPasses(
                x - 3,
                y - 3,
                7,
                4,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
            world.regionPasses(x - 5, y + 1, 11, 2, [&numEmpty](Tile &tile) {
                if (tile.blockID == TileID::empty) {
                    ++numEmpty;
                }
                return numEmpty < 4;
            })) {
            world.spawn = {x, y};
            break;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/Underworld.h`
```
#ifndef UNDERWORLD_H
#define UNDERWORLD_H

class World;
class Random;

void genUnderworld(Random &rnd, World &world);

#endif // UNDERWORLD_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/celebration`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/celebration/AsteroidField.cpp`
```
#include "biomes/celebration/AsteroidField.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/AsteroidField.h"
#include "ids/Paint.h"
#include "structures/data/Balloons.h"
#include <iostream>

void genAsteroidFieldCelebration(Random &rnd, World &world)
{
    std::cout << "Inflating asteroids\n";
    int width =
        world.conf.asteroids * rnd.getDouble(0.06, 0.07) * world.getWidth();
    int height = rnd.getDouble(0.18, 0.21) * world.getUndergroundLevel();
    auto [fieldX, fieldY] =
        selectAsteroidFieldLocation(width, height, rnd, world);
    int numAsteroids = width * height / 375;
    for (int tries = 10 * numAsteroids; numAsteroids > 0 && tries > 0;
         --tries) {
        int tileId, paint;
        switch (rnd.getInt(0, 2)) {
        case 0:
            tileId = TileID::sillyPinkBalloon;
            paint = rnd.select(
                {Paint::none, Paint::pink, Paint::red, Paint::violet});
            break;
        case 1:
            tileId = TileID::sillyPurpleBalloon;
            paint = rnd.select(
                {Paint::none, Paint::purple, Paint::blue, Paint::skyBlue});
            break;
        default:
            tileId = TileID::sillyGreenBalloon;
            paint = rnd.select(
                {Paint::none, Paint::green, Paint::lime, Paint::teal});
            break;
        }
        TileBuffer balloon = Data::getBalloon(
            rnd.select(Data::balloons),
            tileId,
            paint,
            world.getFramedTiles());
        int x = rnd.getInt(fieldX, fieldX + width - balloon.getWidth());
        int y = rnd.getInt(fieldY, fieldY + height - balloon.getHeight());
        double centerDist = std::hypot(
            (fieldX + 0.5 * width - x) / width,
            (fieldY + 0.5 * height - y) / height);
        if ((centerDist > 0.48 && fnv1a32pt(x, y) % 11 != 0) ||
            !world.regionPasses(
                x - 1,
                y - 1,
                balloon.getWidth() + 2,
                balloon.getHeight() + 1,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            !world.regionPasses(
                x + balloon.getWidth() / 2 - 1,
                y + balloon.getHeight(),
                3,
                3,
                [](Tile &tile) { return tile.blockID == TileID::empty; })) {
            continue;
        }
        world.placeBuffer(x, y, balloon);
        int ropeLen = rnd.getInt(
            std::midpoint(4, balloon.getWidth()),
            4 + balloon.getHeight());
        for (int j = 0; j < ropeLen; ++j) {
            Tile &tile = world.getTile(
                x + balloon.getWidth() / 2,
                y + balloon.getHeight() + j);
            if (tile.blockID != TileID::empty) {
                break;
            }
            tile.blockID = TileID::rope;
        }
        --numAsteroids;
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/celebration/AsteroidField.h`
```
#ifndef CELEBRATION_ASTEROIDFIELD_H
#define CELEBRATION_ASTEROIDFIELD_H

class World;
class Random;

void genAsteroidFieldCelebration(Random &rnd, World &world);

#endif // CELEBRATION_ASTEROIDFIELD_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/doubleTrouble`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/doubleTrouble/Corruption.cpp`
```
#include "biomes/doubleTrouble/Corruption.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "biomes/Corruption.h"
#include "vendor/frozen/set.h"
#include <iostream>

void genSecondaryCorruption(Random &rnd, World &world)
{
    std::cout << "Corrupting the world\n";
    rnd.shuffleNoise();
    if (world.conf.dontDigUp) {
        int minX = 0;
        int maxX = world.getWidth();
        if (world.surfaceEvilCenter < world.getWidth() / 2) {
            minX = world.getWidth() / 2;
        } else {
            maxX = world.getWidth() / 2;
        }
        for (auto [surfaceX, undergroundX] : selectEvilLocations(rnd, world)) {
            if (surfaceX < minX || surfaceX > maxX) {
                continue;
            }
            genCorruptionAt(surfaceX, undergroundX, rnd, world);
        }
        return;
    }

    int scanDist = 0.08 * world.getWidth();
    int surfaceX = world.surfaceEvilCenter;
    while (std::abs(surfaceX - world.surfaceEvilCenter) < scanDist ||
           (world.conf.avoidantEvil && !isInBiome(
                                           surfaceX,
                                           world.getUndergroundLevel(),
                                           scanDist / 3,
                                           Biome::forest,
                                           world))) {
        surfaceX = world.getWidth() * rnd.getDouble(0.12, 0.39);
        if (rnd.getBool()) {
            surfaceX = world.getWidth() - surfaceX;
        }
    }
    constexpr auto avoidTiles = frozen::make_set<int>({
        TileID::ebonstone,
        TileID::corruptGrass,
        TileID::corruptJungleGrass,
        TileID::corruptIce,
        TileID::ebonsand,
        TileID::ebonsandstone,
        TileID::hardenedEbonsand,
        TileID::lesion,
        TileID::crimstone,
        TileID::crimsonGrass,
        TileID::crimsonJungleGrass,
        TileID::crimsonIce,
        TileID::crimsand,
        TileID::crimsandstone,
        TileID::hardenedCrimsand,
        TileID::flesh,
    });
    while (true) {
        int undergroundX = world.getWidth() * rnd.getDouble(0.08, 0.92);
        if (world.regionPasses(
                undergroundX - scanDist,
                std::midpoint(
                    world.getCavernLevel(),
                    world.getUnderworldLevel()),
                2 * scanDist,
                1,
                [&avoidTiles](Tile &tile) {
                    return !avoidTiles.contains(tile.blockID);
                })) {
            genCorruptionAt(surfaceX, undergroundX, rnd, world);
            return;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/doubleTrouble/Corruption.h`
```
#ifndef DOUBLETROUBLE_CORRUPTION_H
#define DOUBLETROUBLE_CORRUPTION_H

class World;
class Random;

void genSecondaryCorruption(Random &rnd, World &world);

#endif // DOUBLETROUBLE_CORRUPTION_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/doubleTrouble/Crimson.cpp`
```
#include "biomes/doubleTrouble/Crimson.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "biomes/Corruption.h"
#include "biomes/Crimson.h"
#include "vendor/frozen/set.h"
#include <iostream>

void genSecondaryCrimson(Random &rnd, World &world)
{
    std::cout << "Infecting the world\n";
    rnd.shuffleNoise();
    if (world.conf.dontDigUp) {
        int minX = 0;
        int maxX = world.getWidth();
        if (world.surfaceEvilCenter < world.getWidth() / 2) {
            minX = world.getWidth() / 2;
        } else {
            maxX = world.getWidth() / 2;
        }
        for (auto [surfaceX, undergroundX] : selectEvilLocations(rnd, world)) {
            if (surfaceX < minX || surfaceX > maxX) {
                continue;
            }
            genCrimsonAt(surfaceX, undergroundX, rnd, world);
        }
        return;
    }

    int scanDist = 0.08 * world.getWidth();
    int surfaceX = world.surfaceEvilCenter;
    while (std::abs(surfaceX - world.surfaceEvilCenter) < scanDist ||
           (world.conf.avoidantEvil && !isInBiome(
                                           surfaceX,
                                           world.getUndergroundLevel(),
                                           scanDist / 3,
                                           Biome::forest,
                                           world))) {
        surfaceX = world.getWidth() * rnd.getDouble(0.12, 0.39);
        if (rnd.getBool()) {
            surfaceX = world.getWidth() - surfaceX;
        }
    }
    constexpr auto avoidTiles = frozen::make_set<int>({
        TileID::ebonstone,
        TileID::corruptGrass,
        TileID::corruptJungleGrass,
        TileID::corruptIce,
        TileID::ebonsand,
        TileID::ebonsandstone,
        TileID::hardenedEbonsand,
        TileID::lesion,
        TileID::crimstone,
        TileID::crimsonGrass,
        TileID::crimsonJungleGrass,
        TileID::crimsonIce,
        TileID::crimsand,
        TileID::crimsandstone,
        TileID::hardenedCrimsand,
        TileID::flesh,
    });
    while (true) {
        int undergroundX = world.getWidth() * rnd.getDouble(0.08, 0.92);
        if (world.regionPasses(
                undergroundX - scanDist,
                std::midpoint(
                    world.getCavernLevel(),
                    world.getUnderworldLevel()),
                2 * scanDist,
                1,
                [&avoidTiles](Tile &tile) {
                    return !avoidTiles.contains(tile.blockID);
                })) {
            genCrimsonAt(surfaceX, undergroundX, rnd, world);
            return;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/doubleTrouble/Crimson.h`
```
#ifndef DOUBLETROUBLE_CRIMSON_H
#define DOUBLETROUBLE_CRIMSON_H

class World;
class Random;

void genSecondaryCrimson(Random &rnd, World &world);

#endif // DOUBLETROUBLE_CRIMSON_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/doubleTrouble/ResourceSwap.cpp`
```
#include "biomes/doubleTrouble/ResourceSwap.h"

#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/WallID.h"
#include "vendor/frozen/map.h"
#include <iostream>

void swapResources(Random &rnd, World &world)
{
    std::cout << "Shuffling ores\n";
    rnd.restoreShuffleState();
    constexpr auto oreSwap = frozen::make_map<int, int>({
        {TileID::copperOre, TileID::tinOre},
        {TileID::tinOre, TileID::copperOre},
        {TileID::ironOre, TileID::leadOre},
        {TileID::leadOre, TileID::ironOre},
        {TileID::silverOre, TileID::tungstenOre},
        {TileID::tungstenOre, TileID::silverOre},
        {TileID::goldOre, TileID::platinumOre},
        {TileID::platinumOre, TileID::goldOre},
        {TileID::cobaltOre, TileID::palladiumOre},
        {TileID::palladiumOre, TileID::cobaltOre},
        {TileID::mythrilOre, TileID::orichalcumOre},
        {TileID::orichalcumOre, TileID::mythrilOre},
        {TileID::adamantiteOre, TileID::titaniumOre},
        {TileID::titaniumOre, TileID::adamantiteOre},
    });
    constexpr auto blockSwap = frozen::make_map<int, int>({
        {TileID::marble, TileID::granite},
        {TileID::granite, TileID::marble},
        {TileID::smoothMarble, TileID::smoothGranite},
        {TileID::smoothGranite, TileID::smoothMarble},
    });
    constexpr auto wallSwap = frozen::make_map<int, int>({
        {WallID::Unsafe::marble, WallID::Unsafe::granite},
        {WallID::Unsafe::granite, WallID::Unsafe::marble},
    });
    parallelFor(std::views::iota(0, world.getWidth()), [&](int x) {
        for (int y = 0; y < world.getHeight(); ++y) {
            Tile &tile = world.getTile(x, y);
            auto blockItr = blockSwap.find(tile.blockID);
            if (blockItr != blockSwap.end()) {
                tile.blockID = blockItr->second;
            } else if (rnd.getCoarseNoise(x, y) > 0) {
                auto oreItr = oreSwap.find(tile.blockID);
                if (oreItr != oreSwap.end()) {
                    tile.blockID = oreItr->second;
                }
            }
            auto wallItr = wallSwap.find(tile.wallID);
            if (wallItr != wallSwap.end()) {
                tile.wallID = wallItr->second;
            }
        }
    });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/doubleTrouble/ResourceSwap.h`
```
#ifndef DOUBLETROUBLE_RESOURCESWAP_H
#define DOUBLETROUBLE_RESOURCESWAP_H

class World;
class Random;

void swapResources(Random &rnd, World &world);

#endif // DOUBLETROUBLE_RESOURCESWAP_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hardmode`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hardmode/Hallow.cpp`
```
#include "biomes/hardmode/Hallow.h"

#include "Cleanup.h"
#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/Dungeon.h"
#include "vendor/frozen/map.h"
#include "vendor/frozen/set.h"
#include <iostream>

template <typename Func>
void iterateDiamond(int topHeight, int centerHeight, Func f)
{
    for (int i = 0; i < 2 * topHeight; ++i) {
        for (int j = std::abs(topHeight - i - 0.5); j < topHeight; ++j) {
            f(i, j);
        }
        for (int j = 0; j < centerHeight; ++j) {
            f(i, j + topHeight);
        }
        int maxJ = topHeight - std::abs(topHeight - i - 0.5);
        for (int j = 0; j < maxJ; ++j) {
            f(i, j + topHeight + centerHeight);
        }
    }
}

int selectHallowLocation(Random &rnd, World &world)
{
    constexpr auto avoidTiles = frozen::make_set<int>({
        TileID::corruptIce,
        TileID::corruptJungleGrass,
        TileID::crimsand,
        TileID::crimsandstone,
        TileID::crimsonIce,
        TileID::crimsonJungleGrass,
        TileID::crimstone,
        TileID::ebonsand,
        TileID::ebonsandstone,
        TileID::ebonstone,
        TileID::flesh,
        TileID::hardenedCrimsand,
        TileID::hardenedEbonsand,
        TileID::hardenedSand,
        TileID::lesion,
    });
    std::array avoidPoints{
        100,
        world.getWidth() - 100,
        world.spawn.x,
        static_cast<int>(world.desertCenter),
        static_cast<int>(world.jungleCenter),
        static_cast<int>(world.snowCenter),
        world.surfaceEvilCenter,
        computeDungeonCenter(world),
    };
    int scanDist = 0.12 * world.getWidth();
    while (true) {
        int x = rnd.getInt(300, world.getWidth() - 300);
        for (int col : avoidPoints) {
            if (std::abs(col - x) < scanDist / 2) {
                x = -1;
                break;
            }
        }
        if (x != -1) {
            int surface = world.getSurfaceLevel(x);
            if (world.regionPasses(
                    x - scanDist,
                    surface / 2,
                    scanDist,
                    world.getUnderworldLevel() - surface,
                    [&avoidTiles](Tile &tile) {
                        return !avoidTiles.contains(tile.blockID);
                    })) {
                return x;
            }
        }
        --scanDist;
    }
}

void markForHallow(int centerX, Random &rnd, World &world)
{
    int scanDist = 0.07 * world.getWidth();
    int numDiamonds = rnd.getInt(27, 31);
    for (int iter = 0; iter < numDiamonds; ++iter) {
        int topHeight = 25 + world.getWidth() * world.getHeight() /
                                 rnd.getInt(76800, 230400);
        int centerHeight = rnd.getInt(0.5 * topHeight, 1.5 * topHeight);
        int x =
            rnd.getInt(centerX - scanDist, centerX + scanDist - 2 * topHeight);
        int y = rnd.getInt(
            0.1 * world.getUndergroundLevel(),
            world.getUnderworldLevel());
        iterateDiamond(topHeight, centerHeight, [x, y, &world](int i, int j) {
            world.getTile(x + i, y + j).wireRed = true;
        });
        x += 0.9 * topHeight;
        y += 0.9 * topHeight + 0.45 * centerHeight;
        if (y > world.getSurfaceLevel(x) - 50 && y < world.getHeight() - 100) {
            iterateDiamond(
                topHeight / 10,
                centerHeight / 10,
                [x, y, &world](int i, int j) {
                    world.getTile(x + i, y + j).wireBlue = true;
                });
        }
    }
}

void genHallow(Random &rnd, World &world)
{
    std::cout << "Illuminating the world\n";
    int centerX = selectHallowLocation(rnd, world);
    constexpr auto paintedBlocks = frozen::make_set<int>({
        TileID::cloud,
        TileID::rainCloud,
        TileID::snowCloud,
        TileID::jungleGrass,
        TileID::mushroomGrass,
        TileID::hive,
    });
    constexpr auto hallowBlocks = frozen::make_map<int, int>({
        {TileID::grass, TileID::hallowedGrass},
        {TileID::corruptGrass, TileID::hallowedGrass},
        {TileID::crimsonGrass, TileID::hallowedGrass},
        {TileID::stone, TileID::pearlstone},
        {TileID::ebonstone, TileID::pearlstone},
        {TileID::crimstone, TileID::pearlstone},
        {TileID::smoothMarble, TileID::pearlstone},
        {TileID::smoothGranite, TileID::pearlstone},
        {TileID::ice, TileID::hallowedIce},
        {TileID::corruptIce, TileID::hallowedIce},
        {TileID::crimsonIce, TileID::hallowedIce},
        {TileID::sand, TileID::pearlsand},
        {TileID::ebonsand, TileID::pearlsand},
        {TileID::crimsand, TileID::pearlsand},
        {TileID::hardenedSand, TileID::hardenedPearlsand},
        {TileID::hardenedEbonsand, TileID::hardenedPearlsand},
        {TileID::hardenedCrimsand, TileID::hardenedPearlsand},
        {TileID::sandstone, TileID::pearlsandstone},
        {TileID::ebonsandstone, TileID::pearlsandstone},
        {TileID::crimsandstone, TileID::pearlsandstone},
        {TileID::corruptJungleGrass, TileID::jungleGrass},
        {TileID::crimsonJungleGrass, TileID::jungleGrass},
        {TileID::leaf, TileID::aetherium},
        {TileID::mahoganyLeaf, TileID::aetherium},
        {TileID::livingWood, TileID::pearlstone},
        {TileID::livingMahogany, TileID::pearlstone},
        {TileID::slime, TileID::pinkSlime},
        {TileID::lesion, TileID::crystalBlock},
        {TileID::flesh, TileID::crystalBlock},
    });
    std::map<int, int> hallowWalls{
        {WallID::Safe::livingLeaf, WallID::Safe::aetherium},
        {WallID::Unsafe::grass, WallID::Unsafe::hallowedGrass},
        {WallID::Unsafe::flower, WallID::Unsafe::hallowedGrass},
        {WallID::Unsafe::jungle, WallID::Unsafe::hallowedGrass},
        {WallID::Unsafe::corruptGrass, WallID::Unsafe::hallowedGrass},
        {WallID::Unsafe::crimsonGrass, WallID::Unsafe::hallowedGrass},
        {WallID::Unsafe::sandstone, WallID::Unsafe::pearlsandstone},
        {WallID::Unsafe::ebonsandstone, WallID::Unsafe::pearlsandstone},
        {WallID::Unsafe::crimsandstone, WallID::Unsafe::pearlsandstone},
        {WallID::Unsafe::hardenedSand, WallID::Unsafe::hardenedPearlsand},
        {WallID::Unsafe::hardenedEbonsand, WallID::Unsafe::hardenedPearlsand},
        {WallID::Unsafe::hardenedCrimsand, WallID::Unsafe::hardenedPearlsand},
    };
    for (int wallId : WallVariants::dirt) {
        hallowWalls[wallId] = rnd.select(WallVariants::hallow);
    }
    for (int wallId : WallVariants::stone) {
        hallowWalls[wallId] = rnd.select(WallVariants::hallow);
    }
    for (int wallId : WallVariants::jungle) {
        hallowWalls[wallId] = rnd.select(WallVariants::hallow);
    }
    for (int wallId : WallVariants::corruption) {
        hallowWalls[wallId] = rnd.select(WallVariants::hallow);
    }
    for (int wallId : WallVariants::crimson) {
        hallowWalls[wallId] = rnd.select(WallVariants::hallow);
    }
    for (int wallId :
         {WallID::Unsafe::snow,
          WallID::Unsafe::ice,
          WallID::Unsafe::mushroom,
          WallID::Unsafe::marble,
          WallID::Unsafe::granite,
          WallID::Unsafe::corruptTendril,
          WallID::Unsafe::crimsonBlister}) {
        hallowWalls[wallId] = rnd.select(WallVariants::hallow);
    }
    constexpr auto erodeBlocks = frozen::make_set<int>({
        TileID::pearlstone,
        TileID::hallowedIce,
        TileID::pearlsandstone,
    });
    constexpr auto erodeSkipBlocks = frozen::make_set<int>({
        TileID::livingWood,
        TileID::livingMahogany,
    });
    int scanDist = 0.07 * world.getWidth();
    std::vector<std::pair<int, int>> erosion;
    std::vector<std::pair<int, int>> hallowCores;
    markForHallow(centerX, rnd, world);
    for (int x = centerX - scanDist; x < centerX + scanDist; ++x) {
        for (int y = 0; y < world.getHeight(); ++y) {
            Tile &tile = world.getTile(x, y);
            if (!tile.wireRed) {
                continue;
            }
            tile.wireRed = false;
            if (tile.wireBlue) {
                tile.wireBlue = false;
                tile.blockID = TileID::crystalBlock;
                tile.slope = Slope::none;
                tile.guarded = false;
                hallowCores.emplace_back(x, y);
            }
            auto blockItr = hallowBlocks.find(tile.blockID);
            if (blockItr != hallowBlocks.end()) {
                tile.blockID = blockItr->second;
                if (erodeBlocks.contains(tile.blockID) &&
                    !erodeSkipBlocks.contains(blockItr->first) &&
                    world.isExposed(x, y)) {
                    erosion.emplace_back(x, y);
                }
            }
            auto wallItr = hallowWalls.find(tile.wallID);
            if (wallItr != hallowWalls.end()) {
                tile.wallID = wallItr->second;
            }
            if (!world.conf.unpainted && paintedBlocks.contains(tile.blockID)) {
                tile.blockPaint = tile.blockID == TileID::jungleGrass
                                      ? Paint::cyan
                                      : Paint::pink;
            }
        }
    }
    for (auto [x, y] : erosion) {
        Tile &tile = world.getTile(x, y);
        if (tile.wallID != WallID::empty) {
            std::tie(tile.wallID, tile.wallPaint) =
                getAttachedOpenWall(world, x, y);
        }
    }
    for (auto [x, y] : erosion) {
        world.getTile(x, y).blockID = TileID::empty;
    }
    erosion.clear();
    for (auto [x, y] : hallowCores) {
        if (std::abs(rnd.getFineNoise(2 * x, 2 * y)) > 0.09 &&
            world.regionPasses(x - 1, y - 1, 3, 3, [](Tile &tile) {
                return tile.blockID == TileID::crystalBlock;
            })) {
            erosion.emplace_back(x, y);
        }
    }
    for (auto [x, y] : erosion) {
        Tile &tile = world.getTile(x, y);
        tile.blockID = TileID::pearlstone;
        tile.wallID = WallID::Safe::amethystGemspark;
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hardmode/Hallow.h`
```
#ifndef HALLOW_H
#define HALLOW_H

class World;
class Random;

void genHallow(Random &rnd, World &world);

#endif // HALLOW_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hardmode/HmOres.cpp`
```
#include "biomes/hardmode/HmOres.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "vendor/frozen/set.h"
#include <iostream>

bool canSpawnChlorophyte(int x, int y, World &world)
{
    int radius = 8;
    for (int i = -radius; i < radius; ++i) {
        for (int j = -radius; j < radius; ++j) {
            if (std::hypot(i, j) < radius) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID == TileID::jungleGrass ||
                    tile.blockID == TileID::chlorophyteOre) {
                    return true;
                }
            }
        }
    }
    return false;
}

struct DepositDef {
    int ore;
    int minY;
    int maxY;
    int noiseX;
    int noiseY;
};

std::array<DepositDef, 3> getHmOreLayers(Random &rnd, World &world)
{
    if (world.conf.dontDigUp) {
        return {{
            {world.cobaltVariant,
             static_cast<int>(std::lerp(
                 world.getUndergroundLevel(),
                 world.getCavernLevel(),
                 0.52)),
             world.getHeight(),
             rnd.getInt(0, world.getWidth()),
             rnd.getInt(0, world.getHeight())},
            {world.mythrilVariant,
             static_cast<int>(std::lerp(
                 world.getUndergroundLevel(),
                 world.getCavernLevel(),
                 0.31)),
             static_cast<int>(std::lerp(
                 world.getCavernLevel(),
                 world.getUnderworldLevel(),
                 0.15)),
             rnd.getInt(0, world.getWidth()),
             rnd.getInt(0, world.getHeight())},
            {world.adamantiteVariant,
             0,
             static_cast<int>(std::lerp(
                 world.getUndergroundLevel(),
                 world.getCavernLevel(),
                 0.44)),
             rnd.getInt(0, world.getWidth()),
             rnd.getInt(0, world.getHeight())},
        }};
    }
    return {{
        {world.cobaltVariant,
         0,
         static_cast<int>(std::lerp(
             world.getCavernLevel(),
             world.getUnderworldLevel(),
             0.48)),
         rnd.getInt(0, world.getWidth()),
         rnd.getInt(0, world.getHeight())},
        {world.mythrilVariant,
         static_cast<int>(std::lerp(
             world.getCavernLevel(),
             world.getUnderworldLevel(),
             0.12)),
         static_cast<int>(std::lerp(
             world.getCavernLevel(),
             world.getUnderworldLevel(),
             0.73)),
         rnd.getInt(0, world.getWidth()),
         rnd.getInt(0, world.getHeight())},
        {world.adamantiteVariant,
         static_cast<int>(std::lerp(
             world.getCavernLevel(),
             world.getUnderworldLevel(),
             0.61)),
         world.getHeight(),
         rnd.getInt(0, world.getWidth()),
         rnd.getInt(0, world.getHeight())},
    }};
}

void genHardmodeOres(Random &rnd, World &world)
{
    std::cout << "Blessing ore\n";
    rnd.shuffleNoise();
    constexpr auto clearableTiles = frozen::make_set<int>({
        TileID::ash,
        TileID::clay,
        TileID::corruptIce,
        TileID::corruptJungleGrass,
        TileID::crimsand,
        TileID::crimsandstone,
        TileID::crimsonIce,
        TileID::crimsonJungleGrass,
        TileID::crimstone,
        TileID::dirt,
        TileID::ebonsand,
        TileID::ebonsandstone,
        TileID::ebonstone,
        TileID::granite,
        TileID::hardenedCrimsand,
        TileID::hardenedEbonsand,
        TileID::hardenedSand,
        TileID::ice,
        TileID::jungleGrass,
        TileID::marble,
        TileID::mud,
        TileID::mushroomGrass,
        TileID::sand,
        TileID::sandstone,
        TileID::snow,
        TileID::stone,
    });
    std::array<DepositDef, 3> depositNoise = getHmOreLayers(rnd, world);
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [chlorophyteThreshold = computeOreThreshold(0.7 * world.conf.ore),
         oreThreshold = computeOreThreshold(0.9 * world.conf.ore),
         &clearableTiles,
         &depositNoise,
         &rnd,
         &world](int x) {
            for (int y = 0; y < world.getHeight(); ++y) {
                Tile &tile = world.getTile(x, y);
                if (!clearableTiles.contains(tile.blockID) ||
                    (y > world.getUnderworldLevel() &&
                     tile.blockID == TileID::ash)) {
                    continue;
                }
                if (y > world.getUndergroundLevel() &&
                    rnd.getFineNoise(x, y) < chlorophyteThreshold) {
                    if (tile.blockID == TileID::jungleGrass ||
                        (tile.blockID == TileID::mud &&
                         canSpawnChlorophyte(x, y, world))) {
                        tile.blockID = TileID::chlorophyteOre;
                        continue;
                    }
                }
                if (rnd.getCoarseNoise(x, y) < 0.13) {
                    continue;
                }
                for (const auto &row : depositNoise) {
                    if (y > row.minY && y < row.maxY &&
                        rnd.getFineNoise(x + row.noiseX, y + row.noiseY) <
                            oreThreshold) {
                        tile.blockID = row.ore;
                        break;
                    }
                }
            }
        });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hardmode/HmOres.h`
```
#ifndef HMORES_H
#define HMORES_H

class World;
class Random;

void genHardmodeOres(Random &rnd, World &world);

#endif // HMORES_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/Aether.cpp`
```
#include "biomes/hiveQueen/Aether.h"

#include "Random.h"
#include "World.h"
#include "biomes/Aether.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include <iostream>

Point selectAetherLocation(Random &rnd, World &world)
{
    while (true) {
        int x = world.getWidth() * rnd.getDouble(0.08, 0.30);
        if (rnd.getBool()) {
            x = world.getWidth() - x;
        }
        int y = rnd.getInt(
            (world.getUndergroundLevel() + 2 * world.getCavernLevel()) / 3,
            (world.getCavernLevel() + 5 * world.getUnderworldLevel()) / 6);
        if (world.regionPasses(x - 50, y - 50, 100, 100, [](Tile &tile) {
                return tile.flag != Flag::border;
            })) {
            return {x, y};
        }
    }
}

void genAetherHiveQueen(Random &rnd, World &world)
{
    std::cout << "Bridging realities\n";
    rnd.shuffleNoise();
    auto [x, y] = selectAetherLocation(rnd, world);
    int maxBubblePos = y;
    int maxEditPos = y;
    std::vector<Point> mossLocations;
    iterateZone(
        {x, y},
        world,
        [&world](Point pt) { return world.getTile(pt).flag != Flag::border; },
        [x, y, &maxBubblePos, &maxEditPos, &mossLocations, &rnd, &world](
            Point pt) {
            double centralPropo = hypot(pt, {x, y}) / 75;
            auto blurHexNoise = [&rnd](int a, int b) {
                Point centroid = getHexCentroid(a, b, 10);
                return rnd.getBlurNoise(4 * centroid.x, 4 * centroid.y);
            };
            double noiseVal = std::max(
                                  std::abs(blurHexNoise(pt.x, pt.y)),
                                  std::abs(blurHexNoise(pt.x + x, pt.y + y))) *
                              std::min(1.0, 3 * (1 - centralPropo));
            Tile &tile = world.getTile(pt);
            if (tile.flag == Flag::yellow || tile.flag == Flag::orange) {
                tile.flag = Flag::none;
            }
            if (noiseVal > 0.45) {
                tile.blockID = TileID::bubble;
                maxBubblePos = std::max(maxBubblePos, pt.y);
            } else if (noiseVal > 0.09) {
                tile.blockID = TileID::empty;
            } else if (noiseVal > 0.02) {
                tile.blockID = tile.blockID == TileID::empty ? TileID::aetherium
                               : centralPropo < 0.6 ? TileID::heliumMossStone
                                                    : TileID::stone;
                mossLocations.push_back(pt);
            }
            if (noiseVal > 0.019) {
                tile.wallID = WallID::empty;
                maxEditPos = std::max(maxEditPos, pt.y);
            }
        });
    world.queuedDeco.emplace_back([mossLocations](Random &, World &world) {
        for (auto [x, y] : mossLocations) {
            growMossOn(x, y, world);
        }
    });
    fillAetherShimmer(x, y, 75, maxBubblePos, maxEditPos, rnd, world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/Aether.h`
```
#ifndef HIVEQUEEN_AETHER_H
#define HIVEQUEEN_AETHER_H

class World;
class Random;

void genAetherHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_AETHER_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/AsteroidField.cpp`
```
#include "biomes/hiveQueen/AsteroidField.h"

#include "biomes/AsteroidField.h"
#include "biomes/BiomeUtil.h"

void genAsteroidFieldHiveQueen(Random &rnd, World &world)
{
    doGenAsteroidField(
        [&world](int x, int y, double radius, std::function<void(int, int)> f) {
            int scale = 1.2 * radius;
            Point centroid = getHexCentroid(x, y, scale);
            iterateZone(
                {x, y},
                world,
                [centroid, scale](Point pt) {
                    return getHexCentroid(pt, scale) == centroid;
                },
                [centroid, &f](Point pt) {
                    f(pt.x - centroid.x, pt.y - centroid.y);
                });
        },
        rnd,
        world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/AsteroidField.h`
```
#ifndef HIVEQUEEN_ASTEROIDFIELD_H
#define HIVEQUEEN_ASTEROIDFIELD_H

class World;
class Random;

void genAsteroidFieldHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_ASTEROIDFIELD_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/Base.cpp`
```
#include "biomes/hiveQueen/Base.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "biomes/Base.h"
#include "biomes/BiomeUtil.h"
#include "biomes/patches/Base.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include <algorithm>
#include <iostream>
#include <map>
#include <mutex>
#include <unordered_set>

inline std::array const snowTiles{
    TileID::snow,
    TileID::ice,
    TileID::stone,
    TileID::thinIce,
    TileID::slush};
inline std::array const desertTiles{
    TileID::sand,
    TileID::sandstone,
    TileID::desertFossil,
    TileID::desertFossil,
    TileID::desertFossil};
inline std::array const jungleTiles{
    TileID::mud,
    TileID::mud,
    TileID::clay,
    TileID::silt,
    TileID::stone};
inline std::array const forestTiles{
    TileID::dirt,
    TileID::stone,
    TileID::clay,
    TileID::sand,
    TileID::mud};
inline std::array const underworldTiles{
    TileID::ash,
    TileID::ash,
    TileID::ash,
    TileID::ash,
    TileID::ash};

inline auto hashPoint = [](const Point &pt) { return fnv1a32pt(pt.x, pt.y); };

std::vector<Point>
iterateHex(Point start, int scale, std::function<void(Point)> f)
{
    std::unordered_set<Point, decltype(hashPoint)> visited(
        scale * scale,
        hashPoint);
    std::vector<Point> locations{start};
    Point centroid = getHexCentroid(start, scale);
    std::vector<Point> border;
    while (!locations.empty()) {
        Point loc = locations.back();
        locations.pop_back();
        if (visited.contains(loc)) {
            continue;
        }
        visited.insert(loc);
        if (centroid == getHexCentroid(loc, scale)) {
            f(loc);
            for (auto delta : {Point{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {
                locations.push_back(loc + delta);
            }
        } else {
            border.push_back(loc);
        }
    }
    return border;
}

int getWallVarIndex(
    int x,
    int y,
    const std::vector<std::pair<int, int>> &wallVarNoise,
    Random &rnd);

Biome getBiomeAt(int x, int y, Random &rnd, World &world)
{
    if (world.conf.biomes != BiomeLayout::columns) {
        return computeBiomeData(x, y, rnd).active;
    }
    if (y >= world.getUnderworldLevel() + 20 * rnd.getCoarseNoise(x, 0)) {
        return Biome::underworld;
    } else if (
        std::abs(x - world.jungleCenter) <
        world.conf.jungleSize * 0.09 * world.getWidth()) {
        return Biome::jungle;
    } else if (
        y < 0.7917 * world.getHeight() &&
        std::abs(x - world.desertCenter) <
            world.conf.desertSize * 0.0584 * world.getWidth()) {
        return Biome::desert;
    } else if (
        y < 0.7244 * world.getHeight() &&
        std::abs(x - world.snowCenter) <
            world.conf.snowSize * 0.0584 * world.getWidth()) {
        return Biome::snow;
    }
    return Biome::forest;
}

std::vector<Point> planHiveQueenBiomes(Random &rnd, World &world)
{
    std::mutex ptMtx;
    std::vector<Point> borders;
    Point hexShift{rnd.getInt(0, 99999), rnd.getInt(0, 99999)};
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [hexShift, &ptMtx, &borders, &rnd, &world](int x) {
            auto valueLess = [](const std::pair<Biome, int> &a,
                                const std::pair<Biome, int> &b) {
                return a.second < b.second;
            };
            std::vector<Point> queuedBorders;
            for (int y = 0; y < world.getHeight(); ++y) {
                if (world.getBiome(x, y).forest > 0) {
                    continue;
                }
                std::vector<Point> locations;
                std::map<Biome, int> biomes;
                std::vector<Point> hexBorder = iterateHex(
                    hexShift + Point{x, y},
                    131,
                    [hexShift, &locations, &biomes, &rnd, &world](Point pt) {
                        pt -= hexShift;
                        if (pt.x < 0 || pt.y < 0 || pt.x >= world.getWidth() ||
                            pt.y >= world.getHeight()) {
                            return;
                        }
                        locations.push_back(pt);
                        biomes[getBiomeAt(pt.x, pt.y, rnd, world)] += 1;
                    });
                for (Point pt : hexBorder) {
                    queuedBorders.push_back(pt - hexShift);
                }
                auto targBiome =
                    std::max_element(biomes.begin(), biomes.end(), valueLess);
                for (auto [ptX, ptY] : locations) {
                    BiomeData &biome = world.getBiome(ptX, ptY);
                    biome.active = targBiome->first;
                    biome.forest = 1;
                }
            }
            if (!queuedBorders.empty()) {
                std::lock_guard lock{ptMtx};
                borders.insert(
                    borders.end(),
                    queuedBorders.begin(),
                    queuedBorders.end());
            }
        });
    parallelFor(std::views::iota(0, world.getWidth()), [&world](int x) {
        for (int y = 0; y < world.getHeight(); ++y) {
            BiomeData &biome = world.getBiome(x, y);
            biome.forest = 0;
            switch (biome.active) {
            case Biome::forest:
                biome.forest = 1;
                break;
            case Biome::snow:
                biome.snow = 1;
                break;
            case Biome::desert:
                biome.desert = 1;
                break;
            case Biome::jungle:
                biome.jungle = 1;
                break;
            case Biome::underworld:
                biome.underworld = 1;
                break;
            }
        }
    });
    if (world.conf.biomes != BiomeLayout::columns) {
        identifySurfaceBiomes(world);
    }
    return borders;
}

void genWorldBaseHiveQueen(Random &rnd, World &world)
{
    std::cout << "Generating base terrain\n";
    rnd.shuffleNoise();
    rnd.saveShuffleState();
    std::vector<std::pair<int, int>> depositNoise;
    for (int iter = 0; iter < 7; ++iter) {
        depositNoise.emplace_back(
            rnd.getInt(0, world.getWidth()),
            rnd.getInt(0, world.getHeight()));
    }
    std::vector<std::pair<int, int>> wallVarNoise;
    for (size_t iter = 0; iter < WallVariants::dirt.size(); ++iter) {
        wallVarNoise.emplace_back(
            rnd.getInt(0, world.getWidth()),
            rnd.getInt(0, world.getHeight()));
    }
    computeSurfaceLevel(rnd, world);
    std::vector<Point> hexBorders = planHiveQueenBiomes(rnd, world);
    double oreThreshold = computeOreThreshold(1.35 * world.conf.ore);
    double goldThreshold = world.conf.forTheWorthy
                               ? computeOreThreshold(1.82 * world.conf.ore)
                               : oreThreshold;
    int lavaLevel =
        (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [lavaLevel,
         oreThreshold,
         goldThreshold,
         &depositNoise,
         &wallVarNoise,
         &rnd,
         &world](int x) {
            bool nearEdge = x < 350 || x > world.getWidth() - 350;
            for (int y = 0; y < world.getHeight(); ++y) {
                BiomeData &biome = world.getBiome(x, y);
                if (y < world.getSurfaceLevel(x)) {
                    continue;
                }
                double threshold =
                    y < world.getUndergroundLevel()
                        ? 3.0 * y / world.getUndergroundLevel() - 3
                        : static_cast<double>(y - world.getUndergroundLevel()) /
                              (world.getHeight() - world.getUndergroundLevel());
                int tileType = rnd.getFineNoise(
                                   x + depositNoise[0].first,
                                   y + depositNoise[1].second) > threshold
                                   ? 0
                                   : 1;
                for (int iter = 0; iter < 3; ++iter) {
                    if (rnd.getFineNoise(
                            x + depositNoise[iter].first,
                            y + depositNoise[iter].second) > 0.7) {
                        tileType = iter + 2;
                        break;
                    }
                }
                Tile &tile = world.getTile(x, y);
                switch (biome.active) {
                case Biome::snow: {
                    tile.blockID = snowTiles[tileType];
                    int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                    if (index != -1 &&
                        fnv1a32pt(index, wallVarNoise[0].second) % 5 == 0) {
                        tile.wallID = WallVariants::stone
                            [wallVarNoise[0].first %
                             WallVariants::stone.size()];
                    } else if (index != -1 || y < world.getUndergroundLevel()) {
                        tile.wallID = tile.blockID == TileID::snow
                                          ? WallID::Unsafe::snow
                                          : WallID::Unsafe::ice;
                    }
                    break;
                }
                case Biome::desert:
                    tile.blockID = desertTiles[tileType];
                    if (y > world.getCavernLevel() &&
                        tile.blockID == TileID::sandstone) {
                        if (std::abs(
                                rnd.getCoarseNoise(
                                    x + depositNoise[2].first,
                                    y + depositNoise[3].second) +
                                0.23) < 0.04) {
                            tile.blockID = TileID::sand;
                        } else if (
                            std::abs(
                                rnd.getCoarseNoise(
                                    x + depositNoise[2].first,
                                    y + depositNoise[3].second) -
                                0.23) < 0.04) {
                            tile.blockID = TileID::hardenedSand;
                        }
                    }
                    tile.wallID = tile.blockID == TileID::sandstone
                                      ? WallID::Unsafe::sandstone
                                      : WallID::Unsafe::hardenedSand;
                    break;
                case Biome::jungle:
                    tile.blockID = jungleTiles
                        [y > lavaLevel && tileType == 0 ? 3 : tileType];
                    if (y < world.getUndergroundLevel()) {
                        tile.wallID = WallID::Unsafe::mud;
                    } else {
                        int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                        if (index != -1) {
                            tile.wallID = WallVariants::jungle
                                [fnv1a32pt(index, wallVarNoise[1].first) %
                                 WallVariants::jungle.size()];
                        }
                    }
                    break;
                case Biome::forest: {
                    tile.blockID = forestTiles[tileType];
                    int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                    if (index != -1) {
                        tile.wallID = WallVariants::dirt[index];
                    } else if (y < world.getUndergroundLevel()) {
                        tile.wallID = tile.blockID == TileID::stone
                                          ? WallID::Unsafe::rockyDirt
                                          : WallID::Unsafe::dirt;
                    }
                    break;
                }
                case Biome::underworld: {
                    tile.blockID = underworldTiles[tileType];
                    int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                    if (index != -1) {
                        tile.wallID = WallVariants::underworld
                            [fnv1a32pt(index, wallVarNoise[2].first) %
                             WallVariants::underworld.size()];
                    }
                    break;
                }
                }
                threshold = 0.4 + 0.03 * rnd.getFineNoise(x, y);
                if ((biome.desert > threshold && biome.snow > threshold) ||
                    (biome.snow > 0.57 && biome.active == Biome::desert) ||
                    (biome.desert > 0.57 && biome.active == Biome::snow)) {
                    tile.blockID = TileID::marble;
                    tile.wallID = WallID::Unsafe::marble;
                }
                for (auto [idx, oreRoof, oreFloor, ore] :
                     {std::tuple{
                          3,
                          0.6 * world.getUndergroundLevel(),
                          (world.getUndergroundLevel() +
                           world.getCavernLevel()) /
                              2,
                          world.copperVariant},
                      {4,
                       0.85 * world.getUndergroundLevel(),
                       (2 * world.getCavernLevel() +
                        world.getUnderworldLevel()) /
                           3,
                       world.ironVariant},
                      {5,
                       (world.getUndergroundLevel() + world.getCavernLevel()) /
                           2,
                       (world.getCavernLevel() + world.getUnderworldLevel()) /
                           2,
                       world.silverVariant},
                      {6,
                       (2 * world.getCavernLevel() +
                        world.getUnderworldLevel()) /
                           3,
                       world.getUnderworldLevel(),
                       world.goldVariant}}) {
                    if (y > oreRoof && y < oreFloor &&
                        rnd.getFineNoise(
                            x + depositNoise[idx].first,
                            y + depositNoise[idx].second) <
                            (ore == world.goldVariant ? goldThreshold
                                                      : oreThreshold)) {
                        tile.blockID = ore;
                        break;
                    }
                }
                if (nearEdge && y < 0.9 * world.getUndergroundLevel()) {
                    continue;
                }
                threshold =
                    y < world.getUndergroundLevel()
                        ? 2.94 - 3.1 * y / world.getUndergroundLevel()
                    : y > world.getUnderworldLevel()
                        ? 3.1 * (y - world.getUnderworldLevel()) / 230 - 0.16
                        : -0.16;
                if (std::abs(rnd.getCoarseNoise(x, 2 * y) + 0.1) < 0.15 &&
                    rnd.getFineNoise(x, y) > threshold) {
                    tile.wireRed = true;
                }
                threshold =
                    y > world.getUnderworldLevel()
                        ? (world.getUnderworldLevel() - y) / 10.0
                        : static_cast<double>(y - world.getUndergroundLevel()) /
                                  (world.getUnderworldLevel() -
                                   world.getUndergroundLevel()) -
                              1;
                if (std::abs(rnd.getCoarseNoise(x, 2 * y)) > 0.55 &&
                    rnd.getFineNoise(x, y) < threshold + 0.1) {
                    tile.wireRed = true;
                }
                if (y > world.getCavernLevel() && biome.jungle > 0.01) {
                    threshold =
                        2.0 * (y - world.getCavernLevel()) *
                            (y - world.getHeight()) /
                            std::pow(
                                world.getHeight() - world.getCavernLevel(),
                                2) +
                        0.75;
                    threshold = std::lerp(1.0, threshold, biome.jungle);
                    if (y > world.getCavernLevel() &&
                        rnd.getCoarseNoise(2 * x, 2 * y) > threshold) {
                        tile.wireRed = true;
                    }
                }
                if (biome.snow > 0.01) {
                    threshold = std::max(
                        -0.1,
                        1 + 15.0 * (world.getCavernLevel() - y) /
                                world.getHeight());
                    threshold = std::lerp(1.0, threshold, biome.snow);
                    if (std::abs(rnd.getCoarseNoise(2 * x, y) + 0.1) < 0.12 &&
                        rnd.getFineNoise(x, y) > threshold) {
                        if (tile.blockID == TileID::snow) {
                            tile.blockID = TileID::thinIce;
                        } else {
                            tile.wireRed = true;
                        }
                    }
                }
                if (tile.wireRed && y < world.getUndergroundLevel()) {
                    if (biome.active == Biome::jungle) {
                        int index = getWallVarIndex(x, y, wallVarNoise, rnd);
                        if (fnv1a32pt(index, wallVarNoise[3].second) % 3 == 0) {
                            tile.wallID = WallVariants::stone
                                [fnv1a32pt(index, wallVarNoise[3].first) %
                                 WallVariants::stone.size()];
                        } else {
                            tile.wallID = WallID::Unsafe::jungle;
                        }
                    } else if (
                        biome.active == Biome::forest &&
                        getWallVarIndex(x, y, wallVarNoise, rnd) < 1) {
                        tile.wallID = rnd.getFineNoise(
                                          x + wallVarNoise[4].first,
                                          y + wallVarNoise[4].second) > 0
                                          ? WallID::Unsafe::grass
                                          : WallID::Unsafe::flower;
                    }
                }
            }
        });

    parallelFor(
        std::views::iota(0, world.getWidth()),
        [underworldHeight = world.getHeight() - world.getUnderworldLevel(),
         hellstoneThreshold = -computeOreThreshold(4.24492 * world.conf.ore),
         &rnd,
         &world](int x) {
            int underworldRoof =
                world.getUnderworldLevel() + 0.22 * underworldHeight +
                19 * rnd.getCoarseNoise(x, 0.33 * world.getHeight());
            int underworldFloor =
                world.getUnderworldLevel() + 0.42 * underworldHeight +
                35 * rnd.getCoarseNoise(x, 0.66 * world.getHeight());
            for (int y =
                     world.getUnderworldLevel() + 20 * rnd.getCoarseNoise(x, 0);
                 y < world.getHeight();
                 ++y) {
                Tile &tile = world.getTile(x, y);
                if (y > underworldFloor) {
                    if (std::abs(rnd.getFineNoise(x, y)) > hellstoneThreshold) {
                        tile.blockID = TileID::hellstone;
                    }
                } else if (y > underworldRoof && tile.blockID == TileID::ash) {
                    tile.wireRed = true;
                }
            }
        });

    std::cout << "Generating honeycomb\n";
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [lavaLevel, &rnd, &world](int x) {
            auto valueLess = [](const std::pair<int, int> &a,
                                const std::pair<int, int> &b) {
                return a.second < b.second;
            };
            for (int y = 0; y < world.getHeight(); ++y) {
                if (world.getTile(x, y).wireBlue) {
                    continue;
                }
                std::vector<Point> locations;
                std::map<int, int> tiles;
                std::map<int, int> walls;
                iterateHex(
                    {x, y},
                    10,
                    [&locations, &tiles, &walls, &world](Point pt) {
                        if (pt.x < 0 || pt.y < 0 || pt.x >= world.getWidth() ||
                            pt.y >= world.getHeight()) {
                            return;
                        }
                        locations.push_back(pt);
                        Tile &tile = world.getTile(pt);
                        tiles[tile.wireRed ? TileID::empty : tile.blockID] += 1;
                        walls[tile.wallID] += 1;
                    });
                tiles[TileID::empty] *= 1.3;
                if (y < world.getUndergroundLevel()) {
                    walls[WallID::empty] *= 1.3;
                }
                auto targTile =
                    std::max_element(tiles.begin(), tiles.end(), valueLess);
                auto targWall =
                    std::max_element(walls.begin(), walls.end(), valueLess);
                int threshold = std::max<int>(0.6 * locations.size(), 2);
                if (targTile->second < threshold) {
                    targTile->second = -1;
                } else {
                    int oreCount = 0;
                    for (auto ore :
                         {TileID::copperOre,
                          TileID::tinOre,
                          TileID::ironOre,
                          TileID::leadOre,
                          TileID::silverOre,
                          TileID::tungstenOre,
                          TileID::goldOre,
                          TileID::platinumOre,
                          TileID::hellstone,
                          TileID::desertFossil}) {
                        oreCount += tiles[ore];
                    }
                    if (oreCount < threshold &&
                        oreCount > std::max(threshold / 4, 5)) {
                        targTile->second = -1;
                    }
                }
                if (targWall->second < threshold) {
                    targWall->second = -1;
                }
                Point centroid = getHexCentroid(x, y, 10);
                int rndFlag =
                    static_cast<int>(
                        99999 *
                        (1 + rnd.getFineNoise(centroid.x, centroid.y))) %
                    13;
                Flag hexFlag = rndFlag > 5              ? Flag::orange
                               : rndFlag > 1            ? Flag::yellow
                               : centroid.y > lavaLevel ? Flag::crispyHoney
                                                        : Flag::hive;
                for (auto pt : locations) {
                    Tile &tile = world.getTile(pt);
                    tile.wireRed = false;
                    tile.wireBlue = true;
                    if (targTile->second > 0) {
                        tile.blockID = targTile->first;
                    }
                    if (targWall->second > 0) {
                        tile.wallID = targWall->first;
                    }
                    tile.flag = hexFlag;
                }
            }
        });

    parallelFor(std::views::iota(0, world.getWidth()), [&rnd, &world](int x) {
        int surfaceLevel =
            scanWhileEmpty({x, world.getSurfaceLevel(x) - 10}, {0, 1}, world)
                .y +
            1;
        world.getSurfaceLevel(x) = surfaceLevel;
        for (int y = 0; y < world.getHeight(); ++y) {
            Tile &tile = world.getTile(x, y);
            if (y <= surfaceLevel) {
                tile.wallID = WallID::empty;
            }
            BiomeData &biome = world.getBiome(x, y);
            tile.wireBlue = false;
            if (!world.isExposed(x, y)) {

                if (y < world.getUndergroundLevel() &&
                    ((biome.active == Biome::forest &&
                      tile.blockID == TileID::dirt) ||
                     (biome.active == Biome::jungle &&
                      tile.blockID == TileID::mud)) &&
                    static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) %
                            100 ==
                        0) {
                    tile.blockID = biome.active == Biome::forest
                                       ? TileID::grass
                                       : TileID::jungleGrass;
                }

                continue;
            }
            if (biome.active == Biome::forest &&
                y < world.getUndergroundLevel()) {
                if (tile.blockID == TileID::dirt) {
                    tile.blockID = TileID::grass;
                }
            } else if (biome.active == Biome::jungle) {
                if (tile.blockID == TileID::mud) {
                    tile.blockID = TileID::jungleGrass;
                }
            } else if (
                biome.active == Biome::underworld &&
                y < world.getSurfaceLevel(x) + 10 &&
                std::abs(x - world.getWidth() / 2) < 100) {
                if (tile.blockID == TileID::ash) {
                    tile.blockID = TileID::ashGrass;
                }
            }
        }
    });
    world.spawn = {
        world.getWidth() / 2,
        world.getSurfaceLevel(world.getWidth() / 2) - 1};

    parallelFor(hexBorders, [&world](Point pt) {
        for (int i = -3; i < 3; ++i) {
            for (int j = -3; j < 3; ++j) {
                Tile &tile = world.getTile(pt + Point{i, j});
                tile.blockID = TileID::hive;
                tile.wallID = WallID::Unsafe::hive;
                tile.flag = Flag::border;
            }
        }
    });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/Base.h`
```
#ifndef HIVEQUEEN_BASE_H
#define HIVEQUEEN_BASE_H

class World;
class Random;

void genWorldBaseHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_BASE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/GemGrove.cpp`
```
#include "biomes/hiveQueen/GemGrove.h"

#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "biomes/GemGrove.h"
#include <iostream>

void genGemGroveHiveQueen(Random &rnd, World &world)
{
    std::cout << "Imbuing gems\n";
    rnd.restoreShuffleState();
    int noiseShuffleX = rnd.getInt(0, world.getWidth());
    int noiseShuffleY = rnd.getInt(0, world.getHeight());
    double groveSize =
        world.getWidth() * world.getHeight() / 260000 + rnd.getInt(60, 75);
    auto [x, y] = selectGemGroveLocation(groveSize, rnd, world);
    if (x == -1) {
        return;
    }
    for (int aI = -groveSize; aI < groveSize; ++aI) {
        for (int aJ = -groveSize; aJ < groveSize; ++aJ) {
            Tile &tile = world.getTile(x + aI, y + aJ);
            if (tile.flag == Flag::border) {
                continue;
            }
            auto [i, j] = getHexCentroid({x + aI, y + aJ}, 10) - Point{x, y};
            double threshold = std::min(std::hypot(i, j) / groveSize, 1.0);
            bool shouldClear =
                std::abs(rnd.getCoarseNoise(x + i, 2 * (y + j)) + 0.1) <
                    0.45 - 0.3 * threshold &&
                rnd.getFineNoise(x + i, y + j) > 4.5 * threshold - 4.66;
            bool shouldFill =
                std::max(
                    std::abs(rnd.getBlurNoise(x + i, 5 * (y + j))),
                    std::abs(rnd.getBlurNoise(
                        noiseShuffleX + x + i,
                        noiseShuffleY + 5 * (y + j)))) > 0.4;
            if (shouldClear && tile.blockID != TileID::empty) {
                tile.blockID = shouldFill ? TileID::stone : TileID::empty;
            }
        }
    }
    world.gemGrove = {x, y};
    world.gemGroveSize = groveSize;
    world.queuedDeco.emplace_back(placeGroveDecoGems);
    world.queuedTreasures.emplace_back(placeGemChest);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/GemGrove.h`
```
#ifndef HIVEQUEEN_GEMGROVE_H
#define HIVEQUEEN_GEMGROVE_H

class World;
class Random;

void genGemGroveHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_GEMGROVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/GlowingMoss.cpp`
```
#include "biomes/hiveQueen/GlowingMoss.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <iostream>
#include <set>

Point selectGlowingMossLocation(
    std::set<Point> &visited,
    Random &rnd,
    World &world)
{
    for (int tries = 0; tries < 500; ++tries) {
        int x = rnd.getInt(75, world.getWidth() - 75);
        int y = rnd.getInt(
            std::midpoint(world.getUndergroundLevel(), world.getCavernLevel()),
            world.getUnderworldLevel());
        if (!visited.contains({x, y}) &&
            world.getBiome(x, y).active == Biome::forest &&
            world.regionPasses(x - 4, y - 4, 8, 8, [](Tile &tile) {
                return tile.blockID == TileID::stone;
            })) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void fillGlowingMossHex(
    int x,
    int y,
    int mossType,
    std::set<Point> &visited,
    Random &rnd,
    World &world)
{
    iterateZone(
        {x, y},
        world,
        [&world](Point pt) { return world.getTile(pt).flag != Flag::border; },
        [&visited, &rnd, &world](Point pt) {
            visited.insert(pt);
            Tile &tile = world.getTile(pt);
            if (tile.blockID == TileID::dirt || tile.blockID == TileID::stone) {
                Point centroid = getHexCentroid(pt, 6);
                if (std::max(
                        std::abs(
                            rnd.getBlurNoise(5 * centroid.x, 5 * centroid.y)),
                        std::abs(
                            rnd.getBlurNoise(7 * centroid.x, 7 * centroid.y))) >
                    0.6) {
                    tile.blockID = TileID::empty;
                }
            }
        });
    std::map<int, int> wallRepl;
    for (int wallId : WallVariants::dirt) {
        wallRepl[wallId] = mossType == TileID::lavaMossStone
                               ? rnd.select(WallVariants::underworld)
                               : rnd.select(WallVariants::stone);
    }
    std::vector<Point> mossLocations;
    iterateZone(
        {x, y},
        world,
        [&world](Point pt) { return world.getTile(pt).flag != Flag::border; },
        [mossType, &wallRepl, &mossLocations, &world](Point pt) {
            Tile &tile = world.getTile(pt);
            auto itr = wallRepl.find(tile.wallID);
            if (itr != wallRepl.end()) {
                tile.wallID = itr->second;
            }
            if (tile.blockID == TileID::stone && tile.flag != Flag::hive &&
                tile.flag != Flag::crispyHoney && world.isExposed(pt.x, pt.y)) {
                tile.blockID = mossType;
                mossLocations.push_back(pt);
            }
        });
    world.queuedDeco.emplace_back([mossLocations](Random &, World &world) {
        for (auto [x, y] : mossLocations) {
            growMossOn(x, y, world);
        }
    });
}

void genGlowingMossHiveQueen(Random &rnd, World &world)
{
    std::cout << "Energizing moss\n";
    int numCaves = world.conf.glowingMossFreq * rnd.getDouble(2, 9);
    int scanDist = world.conf.glowingMossSize * 48;
    std::set<Point> visited;
    for (int iter = 0; iter < numCaves; ++iter) {
        auto [x, y] = selectGlowingMossLocation(visited, rnd, world);
        if (x == -1) {
            continue;
        }
        int mossType = rnd.select(
            {TileID::kryptonMossStone,
             TileID::xenonMossStone,
             TileID::argonMossStone,
             TileID::neonMossStone});
        if (y > (world.getCavernLevel() + 4 * world.getUnderworldLevel()) / 5) {
            mossType = rnd.select({mossType, (int)TileID::lavaMossStone});
        }
        rnd.shuffleNoise();
        fillGlowingMossHex(x, y, mossType, visited, rnd, world);
        for (int probes = world.conf.glowingMossSize * 10; probes > 0;
             --probes) {
            int i = rnd.getInt(-scanDist, scanDist);
            int j = rnd.getInt(-scanDist, scanDist);
            if (!visited.contains({x + i, y + j}) &&
                world.getBiome(x + i, y + j).active == Biome::forest &&
                world.getTile(x + i, y + j).blockID == TileID::stone) {
                fillGlowingMossHex(x + i, y + j, mossType, visited, rnd, world);
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/GlowingMoss.h`
```
#ifndef HIVEQUEEN_GLOWINGMOSS_H
#define HIVEQUEEN_GLOWINGMOSS_H

class World;
class Random;

void genGlowingMossHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_GLOWINGMOSS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/GlowingMushroom.cpp`
```
#include "biomes/hiveQueen/GlowingMushroom.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <iostream>

void fillMushroomFieldHex(
    int centerX,
    int fieldFloor,
    Random &rnd,
    World &world)
{
    rnd.shuffleNoise();
    int fieldSize = rnd.getInt(75, 100);
    int centerY = fieldFloor - 0.35 * fieldSize;
    world.mushroomCenter.emplace_back(centerX, centerY);
    int secondaryBlock = rnd.select({TileID::silt, TileID::slime});
    iterateZone(
        {centerX, fieldFloor},
        world,
        [&world](Point pt) { return world.getTile(pt).flag != Flag::border; },
        [&](Point pt) {
            auto coarseHexNoise = [&rnd](int x, int y) {
                Point centroid = getHexCentroid(x, y, 10);
                return rnd.getCoarseNoise(centroid.x, centroid.y);
            };
            auto [x, y] = pt;
            Tile &tile = world.getTile(x, y);
            if (std::abs(coarseHexNoise(x, y)) > 0.07 &&
                std::abs(coarseHexNoise(x + centerX, y + centerY)) > 0.07 &&
                y > fieldFloor +
                        5 * rnd.getFineNoise(x, world.getUndergroundLevel()) -
                        0.7 * std::sqrt(std::max(
                                  fieldSize * fieldSize -
                                      std::pow(centerX - x, 2),
                                  0.0)) &&
                y < fieldFloor + 10 * coarseHexNoise(x, 0)) {
                tile.blockID = TileID::empty;
                tile.wallID = WallID::empty;
                for (auto [i, j] : {std::pair{-1, -1}, {-1, 0}, {0, -1}}) {
                    Tile &prevTile = world.getTile(x + i, y + j);
                    if (prevTile.blockID == TileID::mud) {
                        prevTile.blockID = TileID::mushroomGrass;
                    }
                }
            } else {
                switch (tile.blockID) {
                case TileID::grass:
                    tile.blockID = TileID::mushroomGrass;
                    if (tile.wallID != WallID::empty) {
                        tile.wallID = WallID::Unsafe::mushroom;
                    }
                    break;
                case TileID::stone:
                case TileID::clay:
                case TileID::sand:
                case TileID::mud:
                    tile.blockID =
                        world.isExposed(x, y) || rnd.getInt(0, 35) == 0
                            ? TileID::mushroomGrass
                            : TileID::mud;
                    [[fallthrough]];
                case TileID::empty:
                    if (tile.wallID != WallID::empty) {
                        tile.wallID = WallID::Unsafe::mushroom;
                    }
                    break;
                case TileID::dirt:
                    tile.blockID = secondaryBlock;
                    break;
                }
            }
        });
}

void genGlowingMushroomHiveQueen(Random &rnd, World &world)
{
    std::cout << "Fertilizing glowing mushrooms\n";
    int numFields = std::max<int>(
        world.conf.glowingMushroomFreq * world.getWidth() * world.getHeight() /
            3388000,
        2);
    for (int tries = 100 * numFields; numFields > 0 && tries > 0; --tries) {
        int centerX = world.getWidth() * rnd.getDouble(0.05, 0.95);
        int fieldFloor =
            rnd.getInt(world.getCavernLevel(), world.getUnderworldLevel() - 50);
        if (world.getBiome(centerX, fieldFloor).active != Biome::forest ||
            !world.regionPasses(
                centerX - 25,
                fieldFloor - 55,
                50,
                60,
                [](Tile &tile) {
                    return tile.blockID != TileID::marble &&
                           tile.flag != Flag::border;
                })) {
            continue;
        }
        fillMushroomFieldHex(centerX, fieldFloor, rnd, world);
        --numFields;
    }
    int mushroomLevel =
        (world.getCavernLevel() + 3 * world.getUnderworldLevel()) / 4;
    for (int x = 0; x < world.getWidth(); x += 50) {
        for (int y = mushroomLevel; y < world.getUnderworldLevel() + 20;
             y += 50) {
            if (world.getBiome(x, y).active == Biome::jungle &&
                rnd.getInt(0, 5) == 0 &&
                world.regionPasses(x - 8, y - 8, 16, 16, [](Tile &tile) {
                    return tile.wallID != WallID::Unsafe::mushroom;
                })) {
                iterateZone(
                    {x, y},
                    world,
                    [&world](Point pt) {
                        return world.getTile(pt).flag != Flag::border;
                    },
                    [&](Point pt) {
                        Tile &tile = world.getTile(pt);
                        switch (tile.blockID) {
                        case TileID::jungleGrass:
                        case TileID::mud:
                            tile.blockID =
                                tile.flag == Flag::crispyHoney
                                    ? TileID::crispyHoney
                                : tile.blockID == TileID::jungleGrass ||
                                        rnd.getInt(0, 35) == 0
                                    ? TileID::mushroomGrass
                                    : TileID::mud;
                            break;
                        case TileID::silt:
                            tile.blockID = TileID::slime;
                            break;
                        }
                        if (tile.wallID != WallID::empty) {
                            tile.wallID = WallID::Unsafe::mushroom;
                        }
                    });
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/GlowingMushroom.h`
```
#ifndef HIVEQUEEN_GLOWINGMUSHROOM_H
#define HIVEQUEEN_GLOWINGMUSHROOM_H

class World;
class Random;

void genGlowingMushroomHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_GLOWINGMUSHROOM_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/GraniteCave.cpp`
```
#include "biomes/hiveQueen/GraniteCave.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <iostream>
#include <set>

void fillGraniteCaveHex(int x, int y, World &world)
{
    std::set<Point> clearCenters;
    iterateZone(
        {x, y},
        world,
        [&world](Point pt) { return world.getTile(pt).flag != Flag::border; },
        [&clearCenters, &world](Point pt) {
            Point centroid = getHexCentroid(pt, 12);
            if (world.getTile(pt).blockID == TileID::empty ||
                world.getTile(centroid).blockID == TileID::empty) {
                clearCenters.insert(centroid);
            }
        });
    iterateZone(
        {x, y},
        world,
        [&world](Point pt) { return world.getTile(pt).flag != Flag::border; },
        [&clearCenters, &world](Point pt) {
            Tile &tile = world.getTile(pt);
            switch (tile.blockID) {
            case TileID::dirt:
            case TileID::grass:
            case TileID::stone:
            case TileID::mud:
                tile.blockID = clearCenters.contains(getHexCentroid(pt, 12))
                                   ? TileID::empty
                                   : TileID::granite;
                break;
            case TileID::sand:
            case TileID::clay:
                tile.blockID = clearCenters.contains(getHexCentroid(pt, 12))
                                   ? TileID::empty
                                   : TileID::smoothGranite;
                break;
            }
            if ((!world.conf.shattered && pt.y < world.getUnderworldLevel()) ||
                tile.wallID != WallID::empty) {
                tile.wallID = WallID::Unsafe::granite;
            }
        });
}

void genGraniteCaveHiveQueen(Random &rnd, World &world)
{
    std::cout << "Smoothing granite\n";
    int numCaves =
        world.conf.graniteFreq * world.getWidth() * world.getHeight() / 2000000;
    int scanDist = world.conf.graniteSize * 90;
    for (int iter = 0; iter < numCaves; ++iter) {
        auto [x, y] = findStoneCave(
            std::midpoint(world.getUndergroundLevel(), world.getCavernLevel()),
            world.getUnderworldLevel(),
            rnd,
            world,
            30);
        if (x != -1 && world.getTile(x, y).flag != Flag::border) {
            fillGraniteCaveHex(x, y, world);
            for (int probes = world.conf.graniteSize * 20; probes > 0;
                 --probes) {
                int i = rnd.getInt(-scanDist, scanDist);
                int j = rnd.getInt(-scanDist, scanDist);
                if (world.getBiome(x + i, y + j).active == Biome::forest &&
                    world.getTile(x + i, y + j).blockID == TileID::stone) {
                    fillGraniteCaveHex(x + i, y + j, world);
                }
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/GraniteCave.h`
```
#ifndef HIVEQUEEN_GRANITECAVE_H
#define HIVEQUEEN_GRANITECAVE_H

class World;
class Random;

void genGraniteCaveHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_GRANITECAVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/Hive.cpp`
```
#include "biomes/hiveQueen/Hive.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/Hive.h"

void genHiveHiveQueen(Random &rnd, World &world)
{
    genHive(rnd, world);
    fillHive(
        (0.5 + rnd.getDouble(-0.05, 0.05)) * world.getWidth(),
        std::midpoint(
            world.getSurfaceLevel(world.getWidth() / 2),
            world.getUnderworldLevel()) +
            rnd.getDouble(-0.05, 0.05) * world.getHeight(),
        std::midpoint(world.conf.hiveSize, 1.0) *
            std::midpoint<double>(world.getWidth(), 3.56 * world.getHeight()) /
            rnd.getDouble(19, 22),
        rnd,
        world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/Hive.h`
```
#ifndef HIVEQUEEN_HIVE_H
#define HIVEQUEEN_HIVE_H

class World;
class Random;

void genHiveHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_HIVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/MarbleCave.cpp`
```
#include "biomes/hiveQueen/MarbleCave.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <iostream>

void fillMarbleCaveHex(int x, int y, Random &rnd, World &world)
{
    int lastX = -1;
    int stalactiteLen = 0;
    int stalacIter = 0;
    iterateZone(
        {x, y},
        world,
        [&world](Point pt) { return world.getTile(pt).flag != Flag::border; },
        [&](Point pt) {
            if (pt.x != lastX) {
                lastX = pt.x;
                stalactiteLen = 0;
                stalacIter = 0;
            }
            Tile &tile = world.getTile(pt);
            bool nextTileIsEmpty =
                world.getTile(pt.x, pt.y + 1).blockID == TileID::empty;
            switch (tile.blockID) {
            case TileID::dirt:
            case TileID::stone:
            case TileID::mud:
                tile.blockID = TileID::marble;
                if (nextTileIsEmpty) {
                    stalactiteLen = std::max(
                        0.0,
                        16 * rnd.getFineNoise(4 * pt.x, 100 * stalacIter));
                    ++stalacIter;
                }
                break;
            case TileID::clay:
            case TileID::sand:
                tile.blockID = TileID::smoothMarble;
                break;
            case TileID::empty:
                if (nextTileIsEmpty && stalactiteLen > 0) {
                    tile.blockID = TileID::marble;
                    --stalactiteLen;
                }
            }
            if (!world.conf.shattered || tile.wallID != WallID::empty) {
                tile.wallID = WallID::Unsafe::marble;
            }
        });
}

void genMarbleCaveHiveQueen(Random &rnd, World &world)
{
    std::cout << "Excavating marble\n";
    int numCaves =
        world.conf.marbleFreq * world.getWidth() * world.getHeight() / 1200000;
    for (int i = 0; i < numCaves; ++i) {
        auto [x, y] = findStoneCave(
            std::midpoint(world.getUndergroundLevel(), world.getCavernLevel()),
            world.getUnderworldLevel(),
            rnd,
            world,
            30);
        if (x != -1 && world.getTile(x, y).flag != Flag::border) {
            fillMarbleCaveHex(x, y, rnd, world);
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/hiveQueen/MarbleCave.h`
```
#ifndef HIVEQUEEN_MARBLECAVE_H
#define HIVEQUEEN_MARBLECAVE_H

class World;
class Random;

void genMarbleCaveHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_MARBLECAVE_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/patches`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/patches/Base.cpp`
```
#include "biomes/patches/Base.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "biomes/Base.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include <algorithm>
#include <iostream>

BiomeData computeBiomeData(int x, int y, Random &rnd)
{
    double snow = std::clamp(
        std::min(
            -10.31 * rnd.getTemperature(x, y) - 4.712,
            6.67 * rnd.getHumidity(x, y) + 4.67),
        0.0,
        1.0);
    double desert = std::clamp(
        std::min(
            -10.31 * rnd.getHumidity(x, y) - 4.712,
            6.67 * rnd.getTemperature(x, y) + 4.67),
        0.0,
        1.0);
    double jungle = std::clamp(
        14.706 * std::min(rnd.getTemperature(x, y), rnd.getHumidity(x, y)) -
            0.206,
        0.0,
        1.0);
    double underworld =
        std::clamp(14.286 * rnd.getTemperature(x, y) - 14.5, 0.0, 1.0);
    if (underworld > 0.5) {
        double mult = 2 - 2 * underworld;
        snow *= mult;
        desert *= mult;
        jungle *= mult;
    }
    double total = snow + desert + jungle + underworld;
    double forest = std::clamp(1 - total, 0.0, 1.0);
    total += forest;
    total = 1 / total;
    snow *= total;
    desert *= total;
    jungle *= total;
    forest *= total;
    underworld *= total;

    std::array biomes = std::to_array({
        std::pair{forest, Biome::forest},
        {desert, Biome::desert},
        {jungle, Biome::jungle},
        {snow, Biome::snow},
        {underworld, Biome::underworld},
    });
    std::vector<std::pair<double, Biome>> activeBiomes;
    if (fnv1a32pt(x, y) % 37 > 4) {
        std::vector<std::pair<double, Biome>> looseActiveBiomes;
        for (auto [prob, biome] : biomes) {
            if (prob > 0.02) {
                activeBiomes.emplace_back(prob, biome);
            }
            if (prob > 0.1) {
                looseActiveBiomes.emplace_back(prob, biome);
            }
        }
        if (looseActiveBiomes.size() == 2) {
            activeBiomes = looseActiveBiomes;
        }
    }
    Biome active = Biome::forest;
    if (activeBiomes.size() == 2) {
        int offset =
            static_cast<int>(99999 * (1 + rnd.getFineNoise(0, 0))) % 997;
        active = activeBiomes[0].first +
                             0.6 * rnd.getFineNoise(x + offset, y + offset) >
                         0.5
                     ? activeBiomes[0].second
                     : activeBiomes[1].second;
    } else {
        int quantFactor = 1400;
        int target = fnv1a32pt(x, y) % (quantFactor - 1);
        int accu = 0;
        for (auto [prob, biome] : biomes) {
            accu += prob * quantFactor;
            if (accu > target) {
                active = biome;
                break;
            }
        }
    }
    return {active, forest, snow, desert, jungle, underworld};
}

void identifySurfaceBiomes(World &world)
{
    double maxDesert = 0;
    double maxJungle = 0;
    double maxSnow = 0;
    double curDesert = 0;
    double curJungle = 0;
    double curSnow = 0;
    int desertCenter = 0;
    int jungleCenter = 0;
    int snowCenter = 0;
    auto scanColumn = [&](int x, bool apply) {
        curDesert *= 0.99;
        curJungle *= 0.99;
        curSnow *= 0.99;
        int surface = world.getSurfaceLevel(x);
        for (int y = surface; y < surface + 30; ++y) {
            const BiomeData &biome = world.getBiome(x, y);
            curDesert += 0.01 * biome.desert;
            curJungle += 0.01 * biome.jungle;
            curSnow += 0.01 * biome.snow;
        }
        if (!apply) {
            return;
        }
        if (curDesert > maxDesert) {
            maxDesert = curDesert;
            desertCenter = x;
        }
        if (curJungle > maxJungle) {
            maxJungle = curJungle;
            jungleCenter = x;
        }
        if (curSnow > maxSnow) {
            maxSnow = curSnow;
            snowCenter = x;
        }
    };
    for (int x = 50; x < world.getWidth() - 200; ++x) {
        scanColumn(x, x > 350);
    }
    world.desertCenter = desertCenter;
    world.jungleCenter = jungleCenter;
    world.snowCenter = snowCenter;

    maxDesert = 0;
    maxJungle = 0;
    maxSnow = 0;
    curDesert = 0;
    curJungle = 0;
    curSnow = 0;
    for (int x = world.getWidth() - 50; x > 200; --x) {
        scanColumn(x, x < world.getWidth() - 350);
    }

    auto mergeResults =
        [threshold =
             std::min<int>(0.22 * world.getWidth(), 1200)](double a, double b) {
            return std::abs(a - b) < threshold ? std::midpoint(a, b)
                                               : std::max(a - 150, 0.0);
        };
    world.desertCenter = mergeResults(world.desertCenter, desertCenter);
    world.jungleCenter = mergeResults(world.jungleCenter, jungleCenter);
    world.snowCenter = mergeResults(world.snowCenter, snowCenter);
}

void genWorldBasePatches(Random &rnd, World &world)
{
    std::cout << "Generating base terrain\n";
    parallelFor(std::views::iota(0, world.getWidth()), [&rnd, &world](int x) {
        for (int y = 0; y < world.getHeight(); ++y) {
            world.getBiome(x, y) = computeBiomeData(x, y, rnd);
        }
    });
    applyBaseTerrain(rnd, world);
    identifySurfaceBiomes(world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/patches/Base.h`
```
#ifndef PATCHES_BASE_H
#define PATCHES_BASE_H

#include "World.h"

class Random;

void genWorldBasePatches(Random &rnd, World &world);
BiomeData computeBiomeData(int x, int y, Random &rnd);
void identifySurfaceBiomes(World &world);

#endif // PATCHES_BASE_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/shattered`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/shattered/ShatteredLand.cpp`
```
#include "biomes/shattered/ShatteredLand.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include <iostream>

std::pair<int, double>
distToBasin(int x, int y, int guessX, const std::vector<double> &basin)
{
    int minDistAt = guessX;
    double dist = basin.size();
    for (int basinX = guessX; basinX < static_cast<int>(basin.size());
         ++basinX) {
        double curDist = std::hypot(x - basinX, y - basin[basinX]);
        if (curDist < dist) {
            minDistAt = basinX;
            dist = curDist;
        } else {
            break;
        }
    }
    for (int basinX = guessX - 1; basinX >= 0; --basinX) {
        double curDist = std::hypot(x - basinX, y - basin[basinX]);
        if (curDist < dist) {
            minDistAt = basinX;
            dist = curDist;
        } else {
            break;
        }
    }
    return {minDistAt, dist};
}

bool markIslandAt(int x, int y, int size, Random &rnd, World &world)
{
    if (!world.regionPasses(
            x + 0.15 * size,
            y,
            0.7 * size,
            0.4 * size,
            [](Tile &tile) { return !tile.wireRed; })) {
        return false;
    }
    double surfaceScale = world.conf.surfaceAmplitude * rnd.getDouble(28, 35);
    double dropScale =
        size < 99 ? rnd.getDouble(18, 26) : rnd.getDouble(30, 42);
    for (int i = 0; i < size; ++i) {
        int surface = y + surfaceScale * rnd.getCoarseNoise(x + i, y);
        int maxJ = 1.9 * i * (size - i) / size +
                   dropScale * rnd.getFineNoise(x + i, y);
        for (int j = 0; j < maxJ; ++j) {
            world.getTile(x + i, surface + j).wireRed = true;
        }
    }
    return true;
}

void genShatteredLand(Random &rnd, World &world)
{
    std::cout << "Observing cataclysm\n";
    rnd.shuffleNoise();
    int centerSurface = world.getSurfaceLevel(world.getWidth() / 2) - 10;
    double totalDrop = 0.99 * world.getUnderworldLevel() - centerSurface;
    std::vector<double> basin;
    basin.reserve(world.getWidth());
    for (int x = 0; x < world.getWidth(); ++x) {
        basin.push_back(
            centerSurface +
            totalDrop *
                (1 / (1 + std::exp(0.017 * (600 - x))) +
                 1 / (1 + std::exp(0.017 * (600 + x - world.getWidth())))) -
            totalDrop);
    }
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [&basin, &rnd, &world](int x) {
            int guessX = x;
            double dist;
            for (int y = 0; y < world.getHeight(); ++y) {
                std::tie(guessX, dist) = distToBasin(x, y, guessX, basin);
                if (y > basin[x]) {
                    dist = -dist;
                }
                if (dist > 10 * (std::midpoint(rnd.getFineNoise(x, y), 0.0) +
                                 rnd.getCoarseNoise(x, y))) {
                    continue;
                }
                world.getTile(x, y).wireRed = true;
            }
        });
    int centerIslandWidth = rnd.getInt(250, 350);
    markIslandAt(
        (world.getWidth() - centerIslandWidth) / 2,
        centerSurface,
        centerIslandWidth,
        rnd,
        world);
    int numFails = 0;
    while (numFails < 5000) {
        if (!markIslandAt(
                rnd.getInt(400, world.getWidth() - 400),
                rnd.getInt(centerSurface, world.getUnderworldLevel() - 120),
                rnd.getInt(100, 400),
                rnd,
                world)) {
            ++numFails;
        }
    }
    double numSmall = world.getWidth() * world.getHeight() / 115200;
    while (numSmall > 0) {
        if (markIslandAt(
                rnd.getInt(400, world.getWidth() - 400),
                rnd.getInt(centerSurface, world.getUnderworldLevel() - 120),
                rnd.getInt(20, 80),
                rnd,
                world)) {
            numSmall -= 1;
        } else {
            numSmall -= 0.1;
        }
    }
    parallelFor(std::views::iota(0, world.getWidth()), [&world](int x) {
        bool foundSurface = false;
        for (int y = 0.5 * world.getUndergroundLevel(); y < world.getHeight();
             ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.wireRed) {
                tile.wireRed = false;
                if (!foundSurface) {
                    foundSurface = true;
                    if (y < world.getUndergroundLevel()) {
                        world.getSurfaceLevel(x) =
                            std::max(world.getSurfaceLevel(x), y - 1);
                    } else {
                        world.getSurfaceLevel(x) = std::max(
                            world.getSurfaceLevel(x),
                            world.getSurfaceLevel(x - 1));
                    }
                }
            } else if (
                foundSurface || tile.blockID != TileID::hive ||
                y >= world.getUndergroundLevel()) {
                Flag flag = tile.flag;
                tile = {};
                tile.flag = flag;
            }
        }
        if (x != 0) {
            for (int y = 0.5 * world.getUndergroundLevel();
                 y < world.getUnderworldLevel();
                 ++y) {
                Tile &tile = world.getTile(x - 1, y);
                if (tile.blockID == TileID::mud &&
                    world.getBiome(x - 1, y).active == Biome::jungle &&
                    world.isExposed(x - 1, y)) {
                    tile.blockID = TileID::jungleGrass;
                } else if (
                    tile.blockID == TileID::dirt &&
                    y < world.getUndergroundLevel() &&
                    world.getBiome(x - 1, y).active == Biome::forest &&
                    world.isExposed(x - 1, y)) {
                    tile.blockID = TileID::grass;
                }
            }
        }
    });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/biomes/shattered/ShatteredLand.h`
```
#ifndef SHATTEREDLAND_H
#define SHATTEREDLAND_H

class World;
class Random;

void genShatteredLand(Random &rnd, World &world);

#endif // SHATTEREDLAND_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/ids`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/ids/Biome.h`
```
#ifndef BIOME_H
#define BIOME_H

enum class Biome { forest, snow, desert, jungle, underworld };

#endif // BIOME_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/ids/ItemID.h`
```
#ifndef ITEMID_H
#define ITEMID_H

namespace ItemID
{
enum {
    torch = 8,
    wood = 9,
    goldBar = 19,
    copperBar = 20,
    silverBar = 21,
    ironBar = 22,
    lesserHealingPotion = 28,
    lifeCrystal = 29,
    bottle = 31,
    ironAnvil = 35,
    woodenArrow = 40,
    flamingArrow = 41,
    shuriken = 42,
    suspiciousLookingEye = 43,
    unholyArrow = 47,
    bandOfRegeneration = 49,
    magicMirror = 50,
    jestersArrow = 51,
    angelStatue = 52,
    cloudInABottle = 53,
    hermesBoots = 54,
    enchantedBoomerang = 55,
    demoniteBar = 57,
    starfury = 65,
    silverCoin = 72,
    goldCoin = 73,
    fallenStar = 75,
    ironGreaves = 77,
    ironChainmail = 81,
    grapplingHook = 84,
    ironHelmet = 90,
    flowerOfFire = 112,
    magicMissile = 113,
    meteoriteBar = 117,
    blueBrick = 134,
    greenBrick = 137,
    pinkBrick = 139,
    book = 149,
    cobweb = 150,
    muramasa = 155,
    cobaltShield = 156,
    aquaScepter = 157,
    luckyHorseshoe = 158,
    shinyRedBalloon = 159,
    ballOHurt = 162,
    blueMoon = 163,
    handgun = 164,
    bomb = 166,
    dynamite = 167,
    grenade = 168,
    hellstoneBar = 175,
    sapphire = 177,
    ruby = 178,
    emerald = 179,
    topaz = 180,
    amethyst = 181,
    diamond = 182,
    glowingMushroom = 183,
    breathingReed = 186,
    flipper = 187,
    healingPotion = 188,
    feralClaws = 211,
    ankletOfTheWind = 212,
    staffOfRegrowth = 213,
    flamelash = 218,
    sunfury = 220,
    restorationPotion = 227,
    moltenHelmet = 231,
    moltenBreastplate = 232,
    moltenGreaves = 233,
    tuxedoShirt = 240,
    tuxedoPants = 241,
    summerHat = 242,
    robe = 262,
    goldCrown = 264,
    hellfireArrow = 265,
    darkLance = 274,
    coral = 275,
    trident = 277,
    silverBullet = 278,
    throwingKnife = 279,
    spear = 280,
    blowpipe = 281,
    glowstick = 282,
    woodenBoomerang = 284,
    aglet = 285,
    poisonedKnife = 287,
    obsidianSkinPotion = 288,
    regenerationPotion = 289,
    swiftnessPotion = 290,
    gillsPotion = 291,
    ironskinPotion = 292,
    manaRegenerationPotion = 293,
    magicPowerPotion = 294,
    featherfallPotion = 295,
    spelunkerPotion = 296,
    invisibilityPotion = 297,
    shinePotion = 298,
    nightOwlPotion = 299,
    battlePotion = 300,
    thornsPotion = 301,
    waterWalkingPotion = 302,
    archeryPotion = 303,
    hunterPotion = 304,
    gravitationPotion = 305,
    shadowKey = 329,
    mythrilHood = 376,
    mythrilHelmet = 377,
    mythrilHat = 378,
    mythrilChainmail = 379,
    mythrilGreaves = 380,
    cobaltBar = 381,
    mythrilBar = 382,
    adamantiteBar = 391,
    blueTorch = 427,
    redTorch = 428,
    greenTorch = 429,
    purpleTorch = 430,
    whiteTorch = 431,
    yellowTorch = 432,
    demonTorch = 433,
    greaterHealingPotion = 499,
    crystalBullet = 515,
    holyArrow = 516,
    mechanicalEye = 544,
    cursedArrow = 545,
    mechanicalWorm = 556,
    mechanicalSkull = 557,
    slimeCrown = 560,
    richMahogany = 620,
    pearlwood = 621,
    fish = 669,
    iceBoomerang = 670,
    redPotion = 678,
    leadHelmet = 690,
    leadChainmail = 691,
    leadGreaves = 692,
    platinumHelmet = 696,
    platinumChainmail = 697,
    platinumGreaves = 698,
    tinBar = 703,
    leadBar = 704,
    tungstenBar = 705,
    platinumBar = 706,
    platinumCrown = 715,
    leadAnvil = 716,
    iceBlade = 724,
    cloud = 751,
    theMeatball = 801,
    livingWoodWand = 832,
    pharaohsMask = 848,
    sandstormInABottle = 857,
    beachBall = 859,
    waterWalkingBoots = 863,
    pharaohsRobe = 866,
    lavaCharm = 906,
    flareGun = 930,
    flare = 931,
    leafWand = 933,
    flyingCarpet = 934,
    webSlinger = 939,
    umbrella = 946,
    iceSkates = 950,
    climbingClaws = 953,
    boomstick = 964,
    rope = 965,
    iceTorch = 974,
    shoeSpikes = 975,
    blowgun = 986,
    blizzardInABottle = 987,
    frostburnArrow = 988,
    extractinator = 997,
    amber = 999,
    chlorophyteBar = 1006,
    greenAndBlackDye = 1023,
    rainbowDye = 1066,
    lihzahrdBrick = 1101,
    hiveWand = 1129,
    abeemination = 1133,
    bottledHoney = 1134,
    piranhaGun = 1156,
    chlorophyteBullet = 1179,
    palladiumBar = 1184,
    orichalcumBar = 1191,
    titaniumBar = 1198,
    orichalcumMask = 1210,
    orichalcumHelmet = 1211,
    orichalcumHeadgear = 1212,
    orichalcumBreastplate = 1213,
    orichalcumLeggings = 1214,
    chlorophyteArrow = 1235,
    orangeTorch = 1245,
    crimtaneBar = 1257,
    rainbowGun = 1260,
    lifeFruit = 1291,
    lihzahrdPowerCell = 1293,
    picksaw = 1294,
    snowballCannon = 1319,
    ichorArrow = 1334,
    explodingBullet = 1351,
    shroomiteBar = 1552,
    vampireKnives = 1569,
    scourgeOfTheCorruptor = 1571,
    staffOfTheFrostHydra = 1572,
    flurryBoots = 1579,
    starAnise = 1913,
    bugNet = 1991,
    boneWelder = 2192,
    lihzahrdFurnace = 2195,
    skyMill = 2197,
    iceMachine = 2198,
    honeyDispenser = 2204,
    celestialMagnet = 2219,
    crimsonCloak = 2284,
    redCape = 2286,
    winterCape = 2287,
    bass = 2290,
    fiberglassFishingPole = 2292,
    trout = 2297,
    salmon = 2298,
    atlanticCod = 2299,
    tuna = 2300,
    redSnapper = 2301,
    neonTetra = 2302,
    honeyfin = 2314,
    shrimp = 2316,
    miningPotion = 2322,
    heartreachPotion = 2323,
    builderPotion = 2325,
    titanPotion = 2326,
    summoningPotion = 2328,
    dangersensePotion = 2329,
    swordfish = 2332,
    ammoReservationPotion = 2344,
    lifeforcePotion = 2345,
    endurancePotion = 2346,
    ragePotion = 2347,
    infernoPotion = 2348,
    wrathPotion = 2349,
    recallPotion = 2350,
    teleportationPotion = 2351,
    warmthPotion = 2359,
    borealWood = 2503,
    palmWood = 2504,
    solarTabletFragment = 2766,
    solarTablet = 2767,
    brownAndSilverDye = 2877,
    chlorophyteDye = 2883,
    vineRope = 2996,
    wormholePotion = 2997,
    spelunkerGlowstick = 3002,
    boneTorch = 3004,
    crystalDart = 3009,
    flowerBoots = 3017,
    hellwingBow = 3019,
    hadesDye = 3038,
    guideToPlantFiberCordage = 3068,
    wandOfSparking = 3069,
    silkRope = 3077,
    webRope = 3078,
    radar = 3084,
    herbBag = 3093,
    bouncyGlowstick = 3112,
    frostDaggerfish = 3197,
    iceMirror = 3199,
    spectreBar = 3261,
    greenString = 3297,
    valor = 3317,
    livingMahoganyWand = 3360,
    richMahoganyLeafWand = 3361,
    boneThrowingKnife = 3379,
    shiftingSandsDye = 3533,
    happyGrenade = 3548,
    reflectiveObsidianDye = 3554,
    theGrandDesign = 3611,
    blueStreamer = 3739,
    greenStreamer = 3740,
    pinkStreamer = 3741,
    valhallaKnightsHelm = 3871,
    valhallaKnightsBreastplate = 3872,
    valhallaKnightsGreaves = 3873,
    duneriderBoots = 4055,
    ancientChisel = 4056,
    stormSpear = 4061,
    thunderZapper = 4062,
    desertMinecart = 4066,
    snakeCharmersFlute = 4262,
    magicConch = 4263,
    bastStatue = 4276,
    finchStaff = 4281,
    stepStool = 4341,
    canOfWorms = 4345,
    encumberingStone = 4346,
    desertTorch = 4383,
    coralTorch = 4384,
    corruptTorch = 4385,
    crimsonTorch = 4386,
    hallowedTorch = 4387,
    jungleTorch = 4388,
    flounder = 4401,
    rockLobster = 4402,
    innerTube = 4404,
    whitePearl = 4412,
    blackPearl = 4413,
    pinkPearl = 4414,
    scarabBomb = 4423,
    sharkBait = 4425,
    beeMinecart = 4426,
    ladybugMinecart = 4427,
    sunflowerMinecart = 4429,
    demonicHellcart = 4443,
    witchsBroom = 4444,
    shroomMinecart = 4450,
    miniNukeII = 4458,
    sandcastleBucket = 4460,
    lesserLuckPotion = 4477,
    luckPotion = 4478,
    sliceOfHellCake = 4551,
    desertTigerStaff = 4607,
    bloodbathDye = 4663,
    quadBarrelShotgun = 4703,
    ornateShadowKey = 4737,
    shroomerang = 4764,
    fairyGlowstick = 4776,
    mushroomHat = 4779,
    mushroomVest = 4780,
    mushroomPants = 4781,
    honeyBomb = 4826,
    topazGemcorn = 4851,
    amethystGemcorn = 4852,
    sapphireGemcorn = 4853,
    emeraldGemcorn = 4854,
    rubyGemcorn = 4855,
    diamondGemcorn = 4856,
    amberGemcorn = 4857,
    potionOfReturn = 4870,
    hellfireTreads = 4874,
    tungstenBullet = 4915,
    zenith = 4956,
    fledglingWings = 4978,
    moonLordLegs = 5001,
    deadMansSweater = 5007,
    treasureMagnet = 5010,
    mace = 5011,
    ashWood = 5215,
    highPitch = 5226,
    remnantsOfDevotion = 5234,
    constellation = 5238,
    blessingFromTheHeavens = 5254,
    loveIsInTheTrashSlot = 5255,
    seeTheWorldForWhatItIs = 5258,
    mushroomTorch = 5293,
    gasTrap = 5346,
    aetherTorch = 5353,
    eyeOfTheSun = 5388,
};
}

#endif // ITEMID_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/ids/Paint.h`
```
#ifndef PAINT_H
#define PAINT_H

namespace Paint
{
enum {
    none = 0,
    red = 1,
    orange = 2,
    yellow = 3,
    lime = 4,
    green = 5,
    teal = 6,
    cyan = 7,
    skyBlue = 8,
    blue = 9,
    purple = 10,
    violet = 11,
    pink = 12,
    deepRed = 13,
    deepOrange = 14,
    deepYellow = 15,
    deepLime = 16,
    deepGreen = 17,
    deepTeal = 18,
    deepCyan = 19,
    deepSkyBlue = 20,
    deepBlue = 21,
    deepPurple = 22,
    deepViolet = 23,
    deepPink = 24,
    black = 25,
    white = 26,
    gray = 27,
    brown = 28,
    shadow = 29,
};
}

#endif // PAINT_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/ids/Prefix.cpp`
```
#include "ids/Prefix.h"

namespace PrefixSet
{
std::vector<int> accessory{
    Prefix::none,
    Prefix::hard,
    Prefix::guarding,
    Prefix::armored,
    Prefix::warding,
    Prefix::precise,
    Prefix::lucky,
    Prefix::jagged,
    Prefix::spiked,
    Prefix::angry,
    Prefix::menacing,
    Prefix::brisk,
    Prefix::fleeting,
    Prefix::hasty_accessory,
    Prefix::quick_accessory,
    Prefix::wild,
    Prefix::rash,
    Prefix::intrepid,
    Prefix::violent,
    Prefix::arcane,
};

std::vector<int> universal{
    Prefix::none,
    Prefix::keen,
    Prefix::superior,
    Prefix::forceful,
    Prefix::hurtful,
    Prefix::strong,
    Prefix::unpleasant,
    Prefix::ruthless,
    Prefix::godly,
    Prefix::demonic,
    Prefix::zealous,
};

std::vector<int> common{
    Prefix::none,
    Prefix::keen,
    Prefix::superior,
    Prefix::forceful,
    Prefix::hurtful,
    Prefix::strong,
    Prefix::unpleasant,
    Prefix::ruthless,
    Prefix::godly,
    Prefix::demonic,
    Prefix::zealous,
    Prefix::quick_common,
    Prefix::deadly_common,
    Prefix::agile,
    Prefix::nimble,
    Prefix::murderous,
    Prefix::nasty,
};

std::vector<int> melee{
    Prefix::none,          Prefix::keen,      Prefix::superior,
    Prefix::forceful,      Prefix::hurtful,   Prefix::strong,
    Prefix::unpleasant,    Prefix::ruthless,  Prefix::godly,
    Prefix::demonic,       Prefix::zealous,   Prefix::quick_common,
    Prefix::deadly_common, Prefix::agile,     Prefix::nimble,
    Prefix::murderous,     Prefix::nasty,     Prefix::large,
    Prefix::massive,       Prefix::dangerous, Prefix::savage,
    Prefix::sharp,         Prefix::pointy,    Prefix::bulky,
    Prefix::heavy,         Prefix::light,     Prefix::legendary,
};

std::vector<int> ranged{
    Prefix::none,         Prefix::keen,         Prefix::superior,
    Prefix::forceful,     Prefix::hurtful,      Prefix::strong,
    Prefix::unpleasant,   Prefix::ruthless,     Prefix::godly,
    Prefix::demonic,      Prefix::zealous,      Prefix::quick_common,
    Prefix::agile,        Prefix::nimble,       Prefix::murderous,
    Prefix::nasty,        Prefix::sighted,      Prefix::rapid,
    Prefix::hasty_ranged, Prefix::intimidating, Prefix::deadly_ranged,
    Prefix::staunch,      Prefix::powerful,     Prefix::frenzying,
    Prefix::unreal,
};

std::vector<int> magic{
    Prefix::none,          Prefix::keen,      Prefix::superior,
    Prefix::forceful,      Prefix::hurtful,   Prefix::strong,
    Prefix::unpleasant,    Prefix::ruthless,  Prefix::godly,
    Prefix::demonic,       Prefix::zealous,   Prefix::quick_common,
    Prefix::deadly_common, Prefix::agile,     Prefix::nimble,
    Prefix::murderous,     Prefix::nasty,     Prefix::mystic,
    Prefix::adept,         Prefix::masterful, Prefix::intense,
    Prefix::taboo,         Prefix::celestial, Prefix::furious,
    Prefix::manic,         Prefix::mythical,
};

std::vector<int> magiclownokb{
    Prefix::none,
    Prefix::keen,
    Prefix::hurtful,
    Prefix::demonic,
    Prefix::zealous,
    Prefix::quick_common,
    Prefix::deadly_common,
    Prefix::agile,
    Prefix::nimble,
    Prefix::murderous,
};

void initCelebration()
{
    accessory = {
        Prefix::armored,
        Prefix::warding,
        Prefix::lucky,
        Prefix::angry,
        Prefix::menacing,
        Prefix::hasty_accessory,
        Prefix::quick_accessory,
        Prefix::intrepid,
        Prefix::violent,
        Prefix::arcane,
    };
    universal = {Prefix::superior, Prefix::godly, Prefix::demonic};
    common = {Prefix::superior, Prefix::godly, Prefix::demonic};
    melee = {Prefix::godly, Prefix::savage, Prefix::legendary};
    ranged = {Prefix::godly, Prefix::deadly_ranged, Prefix::unreal};
    magic = {Prefix::godly, Prefix::masterful, Prefix::mythical};
    magiclownokb = {Prefix::demonic, Prefix::deadly_common, Prefix::murderous};
}
} // namespace PrefixSet

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/ids/Prefix.h`
```
#ifndef PREFIX_H
#define PREFIX_H

#include <vector>

namespace Prefix
{
enum {
    none = 0,
    large = 1,
    massive = 2,
    dangerous = 3,
    savage = 4,
    sharp = 5,
    pointy = 6,
    bulky = 12,
    heavy = 14,
    light = 15,
    sighted = 16,
    rapid = 17,
    hasty_ranged = 18,
    intimidating = 19,
    deadly_ranged = 20,
    staunch = 21,
    powerful = 25,
    mystic = 26,
    adept = 27,
    masterful = 28,
    intense = 32,
    taboo = 33,
    celestial = 34,
    furious = 35,
    keen = 36,
    superior = 37,
    forceful = 38,
    quick_common = 42,
    deadly_common = 43,
    agile = 44,
    nimble = 45,
    murderous = 46,
    nasty = 51,
    manic = 52,
    hurtful = 53,
    strong = 54,
    unpleasant = 55,
    ruthless = 57,
    frenzying = 58,
    godly = 59,
    demonic = 60,
    zealous = 61,
    hard = 62,
    guarding = 63,
    armored = 64,
    warding = 65,
    arcane = 66,
    precise = 67,
    lucky = 68,
    jagged = 69,
    spiked = 70,
    angry = 71,
    menacing = 72,
    brisk = 73,
    fleeting = 74,
    hasty_accessory = 75,
    quick_accessory = 76,
    wild = 77,
    rash = 78,
    intrepid = 79,
    violent = 80,
    legendary = 81,
    unreal = 82,
    mythical = 83
};
}

namespace PrefixSet
{
void initCelebration();

extern std::vector<int> accessory;
extern std::vector<int> universal;
extern std::vector<int> common;
extern std::vector<int> melee;
extern std::vector<int> ranged;
extern std::vector<int> magic;
extern std::vector<int> magiclownokb;
} // namespace PrefixSet

#endif // PREFIX_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/ids/TileID.h`
```
#ifndef TILEID_H
#define TILEID_H

namespace TileID
{
enum {
    empty = -1,
    dirt = 0,
    stone = 1,
    grass = 2,
    grassPlant = 3,
    torch = 4,
    tree = 5,
    ironOre = 6,
    copperOre = 7,
    goldOre = 8,
    silverOre = 9,
    door = 10,
    lifeCrystal = 12,
    bottle = 13,
    table = 14,
    chair = 15,
    workBench = 18,
    platform = 19,
    chest = 21,
    demonite = 22,
    corruptGrass = 23,
    corruptPlant = 24,
    ebonstone = 25,
    altar = 26,
    sunflower = 27,
    pot = 28,
    wood = 30,
    orbHeart = 31,
    candle = 33,
    chandelier = 34,
    meteorite = 37,
    grayBrick = 38,
    redBrick = 39,
    clay = 40,
    blueBrick = 41,
    lantern = 42,
    greenBrick = 43,
    pinkBrick = 44,
    spike = 48,
    waterCandle = 49,
    book = 50,
    cobweb = 51,
    vines = 52,
    sand = 53,
    obsidian = 56,
    ash = 57,
    hellstone = 58,
    mud = 59,
    jungleGrass = 60,
    junglePlant = 61,
    jungleVines = 62,
    sapphireStone = 63,
    rubyStone = 64,
    emeraldStone = 65,
    topazStone = 66,
    amethystStone = 67,
    diamondStone = 68,
    mushroomGrass = 70,
    mushroomPlant = 71,
    tallGrassPlant = 73,
    tallJunglePlant = 74,
    obsidianBrick = 75,
    hellstoneBrick = 76,
    hellforge = 77,
    bed = 79,
    cactusPlant = 80,
    coral = 81,
    herb = 83,
    tombstone = 85,
    loom = 86,
    piano = 87,
    dresser = 88,
    bench = 89,
    bathtub = 90,
    banner = 91,
    lamp = 93,
    candelabra = 100,
    bookcase = 101,
    clock = 104,
    statue = 105,
    cobaltOre = 107,
    mythrilOre = 108,
    hallowedGrass = 109,
    adamantiteOre = 111,
    ebonsand = 112,
    hallowedVines = 115,
    pearlsand = 116,
    pearlstone = 117,
    pearlstoneBrick = 118,
    iridescentBrick = 119,
    mudstoneBrick = 120,
    silt = 123,
    woodenBeam = 124,
    trap = 137,
    boulder = 138,
    explosives = 141,
    snow = 147,
    snowBrick = 148,
    sandstoneBrick = 151,
    ebonstoneBrick = 152,
    redStucco = 153,
    grayStucco = 156,
    richMahogany = 158,
    rainbowBrick = 160,
    ice = 161,
    thinIce = 162,
    corruptIce = 163,
    hallowedIce = 164,
    stalactite = 165,
    tinOre = 166,
    leadOre = 167,
    tungstenOre = 168,
    platinumOre = 169,
    sink = 172,
    gem = 178,
    greenMossStone = 179,
    brownMossStone = 180,
    redMossStone = 181,
    blueMossStone = 182,
    purpleMossStone = 183,
    mossPlant = 184,
    smallPile = 185,
    largePile = 186,
    largePileGroup2 = 187,
    cloud = 189,
    glowingMushroom = 190,
    livingWood = 191,
    leaf = 192,
    slime = 193,
    flesh = 195,
    rainCloud = 196,
    asphalt = 198,
    crimsonGrass = 199,
    crimsonIce = 200,
    crimsonPlant = 201,
    sunplate = 202,
    crimstone = 203,
    crimtane = 204,
    crimsonVines = 205,
    iceBrick = 206,
    chlorophyteOre = 211,
    rope = 213,
    chain = 214,
    campfire = 215,
    palladiumOre = 221,
    orichalcumOre = 222,
    titaniumOre = 223,
    slush = 224,
    hive = 225,
    lihzahrdBrick = 226,
    honey = 229,
    crispyHoney = 230,
    larva = 231,
    woodenSpike = 232,
    largeJunglePlant = 233,
    crimsand = 234,
    lihzahrdAltar = 237,
    painting3x3 = 240,
    catacomb = 241,
    painting6x4 = 242,
    painting2x3 = 245,
    painting3x2 = 246,
    titanstone = 250,
    offlineAmethystGemspark = 255,
    offlineSapphireGemspark = 257,
    offlineRubyGemspark = 259,
    amethystGemspark = 262,
    topazGemspark = 263,
    sapphireGemspark = 264,
    emeraldGemspark = 265,
    rubyGemspark = 266,
    diamondGemspark = 267,
    amberGemspark = 268,
    stoneSlab = 273,
    sandstoneSlab = 274,
    boneWelder = 300,
    minecartTrack = 314,
    coralstone = 315,
    borealWood = 321,
    palmWood = 322,
    palmTree = 323,
    waterfall = 326,
    silverCoin = 331,
    goldCoin = 332,
    pressurePlate = 135,
    tinBrick = 175,
    vineRope = 353,
    bewitchingTable = 354,
    alchemyTable = 355,
    smoothMarble = 357,
    marble = 367,
    granite = 368,
    smoothGranite = 369,
    pinkSlime = 371,
    waterDrip = 373,
    lavaDrip = 374,
    honeyDrip = 375,
    sharpeningStation = 377,
    bubble = 379,
    lavaMossStone = 381,
    flowerVines = 382,
    livingMahogany = 383,
    mahoganyLeaf = 384,
    crystalBlock = 385,
    sandstone = 396,
    hardenedSand = 397,
    hardenedEbonsand = 398,
    hardenedCrimsand = 399,
    ebonsandstone = 400,
    crimsandstone = 401,
    hardenedPearlsand = 402,
    pearlsandstone = 403,
    desertFossil = 404,
    fireplace = 405,
    chimney = 406,
    detonator = 411,
    sensor = 423,
    geyser = 443,
    sillyPinkBalloon = 446,
    sillyPurpleBalloon = 447,
    sillyGreenBalloon = 448,
    snowCloud = 460,
    sandDrip = 461,
    chestGroup2 = 467,
    tableGroup2 = 469,
    ironBrick = 472,
    lesion = 474,
    crimstoneBrick = 478,
    crackedBlueBrick = 481,
    crackedGreenBrick = 482,
    crackedPinkBrick = 483,
    rollingCactus = 484,
    fallenLog = 488,
    weatherVane = 490,
    shellPile = 495,
    toilet = 497,
    spiderNest = 498,
    bastStatue = 506,
    mushroomVines = 528,
    kryptonMossStone = 534,
    xenonMossStone = 536,
    argonMossStone = 539,
    grate = 546,
    marbleColumn = 561,
    bambooStalk = 571,
    borealBeam = 574,
    richMahoganyBeam = 575,
    graniteColumn = 576,
    sandstoneColumn = 577,
    topazTree = 583,
    amethystTree = 584,
    sapphireTree = 585,
    emeraldTree = 586,
    rubyTree = 587,
    diamondTree = 588,
    amberTree = 589,
    sakuraTree = 596,
    yellowWillowTree = 616,
    neonMossStone = 625,
    heliumMossStone = 627,
    ashGrass = 633,
    ashTree = 634,
    ashWood = 635,
    corruptVines = 636,
    ashPlant = 637,
    ashVines = 638,
    manaCrystal = 639,
    TNTBarrel = 654,
    aetherium = 659,
    corruptJungleGrass = 661,
    crimsonJungleGrass = 662,
    bouncyBoulder = 664,
    lifeCrystalBoulder = 665,
    dirtiestBlock = 668,
    argonMossBrick = 688,
    kryptonMossBrick = 689,
    neonMossBrick = 691,
};
}

#endif // TILEID_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/ids/TileVariant.h`
```
#ifndef TILEVARIANT_H
#define TILEVARIANT_H

enum class Variant {
    none,
    alchemy,
    ankh,
    ash,
    ashWood,
    barrel,
    bone,
    corruption,
    crimson,
    crystal,
    dartLeft,
    dartRight,
    deadMans,
    desert,
    dirt,
    dryBone,
    dungeon,
    dynasty,
    flameLeft,
    flameRight,
    flesh,
    forest,
    frozen,
    furniture,
    gold,
    goldLocked,
    granite,
    hallowed,
    health,
    honey,
    ice,
    ivy,
    jungle,
    lesion,
    lihzahrd,
    livingWood,
    livingLeaf,
    mana,
    marble,
    meteorite,
    mushroom,
    obsidian,
    oilRagSconce,
    omega,
    palmWood,
    pearlwood,
    pyramid,
    reef,
    richMahogany,
    sandstone,
    shadow,
    skyware,
    snake,
    spear,
    spider,
    spikyBall,
    stone,
    superDartLeft,
    superDartRight,
    tundra,
    underworld,
    water
};

enum class Painting {
    // 2x3
    americanExplosive,
    darkness,
    darkSoulReaper,
    gloriousNight,
    happyLittleTree,
    land,
    secrets,
    strangeDeadFellows,
    strangeGrowth,
    sufficientlyAdvanced,
    trappedGhost,
    // 3x2
    auroraBorealis,
    bifrost,
    bioluminescence,
    demonsEye,
    livingGore,
    findingGold,
    flowingMagma,
    forestTroll,
    heartlands,
    vikingVoyage,
    wildflowers,
    // 3x3
    aHorribleNightForAlchemy,
    bloodMoonRising,
    boneWarp,
    catSword,
    crownoDevoursHisLunch,
    discover,
    fairyGuides,
    fatherOfSomeone,
    gloryOfTheFire,
    guidePicasso,
    handEarth,
    hangingSkeleton,
    impFace,
    morningHunt,
    nurseLisa,
    oldMiner,
    ominousPresence,
    outcast,
    rareEnchantment,
    shiningMoon,
    skelehead,
    skellingtonJSkellingsworth,
    sunflowers,
    terrarianGothic,
    theCursedMan,
    theGuardiansGaze,
    theHangedMan,
    theMerchant,
    wallSkeleton,
    // 4x3
    catacomb1,
    catacomb2,
    catacomb3,
    catacomb4,
    catacomb5,
    catacomb6,
    catacomb7,
    catacomb8,
    catacomb9,
    // 6x4
    ancientTablet,
    dryadisque,
    facingTheCerebralMastermind,
    goblinsPlayingPoker,
    greatWave,
    impact,
    lakeOfFire,
    lifeAboveTheSand,
    oasis,
    poweredByBirds,
    somethingEvilIsWatchingYou,
    sparky,
    starryNight,
    theCreationOfTheGuide,
    theDestroyer,
    theEyeSeesTheEnd,
    thePersistencyOfEyes,
    theScreamer,
    theTwinsHaveAwoken,
    trioSuperHeroes,
    unicornCrossingTheHallows,
};

#endif // TILEVARIANT_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/ids/WallID.h`
```
#ifndef WALLID_H
#define WALLID_H

#include <array>

namespace WallID
{
enum { empty = 0 };

namespace Safe
{
enum {
    stone = 1,
    wood = 4,
    grayBrick = 5,
    redBrick = 6,
    goldBrick = 10,
    obsidianBrick = 20,
    pearlstoneBrick = 22,
    iridescentBrick = 23,
    mudstoneBrick = 24,
    planked = 27,
    snowBrick = 31,
    demoniteBrick = 33,
    sandstoneBrick = 34,
    ebonstoneBrick = 35,
    richMahogany = 42,
    rainbowBrick = 44,
    tinBrick = 45,
    platinumBrick = 47,
    livingLeaf = 60,
    cloud = 73,
    livingWood = 78,
    disc = 82,
    iceBrick = 84,
    shadewood = 85,
    redStainedGlass = 92,
    multicoloredStainedGlass = 93,
    leadFence = 107,
    hive = 108,
    titanstone = 111,
    hay = 114,
    spookyWood = 115,
    fancyGrayWallpaper = 126,
    richMahoganyFence = 139,
    whiteDynasty = 142,
    blueDynasty = 143,
    stoneSlab = 147,
    sail = 148,
    borealWood = 149,
    palmWood = 151,
    palmWoodFence = 152,
    amberGemspark = 153,
    amethystGemspark = 154,
    emeraldGemspark = 156,
    rubyGemspark = 164,
    sapphireGemspark = 165,
    topazGemspark = 166,
    honeyfall = 172,
    crimtaneBrick = 174,
    smoothMarble = 179,
    smoothGranite = 181,
    marble = 183,
    granite = 184,
    crystalBlock = 186,
    sillyPinkBalloon = 228,
    sillyPurpleBalloon = 229,
    sillyGreenBalloon = 230,
    ironBrick = 231,
    crimstoneBrick = 234,
    smoothSandstone = 235,
    snow = 249,
    ice = 266,
    obsidian = 267,
    sandstone = 275,
    hallowedPrism = 288,
    hallowedCrystalline = 291,
    lichenStone = 292,
    leafyJungle = 293,
    ember = 296,
    wornStone = 300,
    stalactiteStone = 301,
    hardenedSand = 304,
    bamboo = 312,
    largeBamboo = 313,
    ashWood = 316,
    aetherium = 321,
    aetheriumBrick = 322,
    lunarRustBrick = 323,
    darkCelestialBrick = 324,
    cryocoreBrick = 327,
    argonMossBrick = 342,
    kryptonMossBrick = 343,
    neonMossBrick = 345,
};
}

namespace Unsafe
{
enum {
    dirt = 2,
    ebonstone = 3,
    blueBrick = 7,
    greenBrick = 8,
    pinkBrick = 9,
    hellstoneBrick = 13,
    obsidianBrick = 14,
    mud = 15,
    snow = 40,
    amethystStone = 48,
    topazStone = 49,
    sapphireStone = 50,
    emeraldStone = 51,
    rubyStone = 52,
    diamondStone = 53,
    greenMossy = 54,
    brownMossy = 55,
    redMossy = 56,
    blueMossy = 57,
    purpleMossy = 58,
    rockyDirt = 59,
    oldStone = 61,
    spider = 62,
    grass = 63,
    jungle = 64,
    flower = 65,
    corruptGrass = 69,
    hallowedGrass = 70,
    ice = 71,
    mushroom = 80,
    crimsonGrass = 81,
    crimstone = 83,
    hive = 86,
    lihzahrdBrick = 87,
    blueSlab = 94,
    blueTiled = 95,
    pinkSlab = 96,
    pinkTiled = 97,
    greenSlab = 98,
    greenTiled = 99,
    caveDirt = 170,
    roughDirt = 171,
    marble = 178,
    granite = 180,
    craggyStone = 185,
    sandstone = 187,
    corruptGrowth = 188,
    corruptMass = 189,
    corruptPustule = 190,
    corruptTendril = 191,
    crimsonCrust = 192,
    crimsonScab = 193,
    crimsonTeeth = 194,
    crimsonBlister = 195,
    layeredDirt = 196,
    crumblingDirt = 197,
    crackedDirt = 198,
    wavyDirt = 199,
    hallowedPrism = 200,
    hallowedCavern = 201,
    hallowedShard = 202,
    hallowedCrystalline = 203,
    lichenStone = 204,
    leafyJungle = 205,
    ivyStone = 206,
    jungleVine = 207,
    ember = 208,
    cinder = 209,
    magma = 210,
    smoulderingStone = 211,
    wornStone = 212,
    stalactiteStone = 213,
    mottledStone = 214,
    fracturedStone = 215,
    hardenedSand = 216,
    hardenedEbonsand = 217,
    hardenedCrimsand = 218,
    hardenedPearlsand = 219,
    ebonsandstone = 220,
    crimsandstone = 221,
    pearlsandstone = 222,
    livingWood = 244,
};
}
} // namespace WallID

namespace WallVariants
{
inline std::array const dirt = {
    WallID::Unsafe::dirt,
    WallID::Unsafe::rockyDirt,
    WallID::Unsafe::caveDirt,
    WallID::Unsafe::roughDirt,
    WallID::Unsafe::layeredDirt,
    WallID::Unsafe::crumblingDirt,
    WallID::Unsafe::crackedDirt,
    WallID::Unsafe::wavyDirt};

// Excludes: oldStone
inline std::array const stone = {
    WallID::Unsafe::craggyStone,
    WallID::Unsafe::wornStone,
    WallID::Unsafe::stalactiteStone,
    WallID::Unsafe::mottledStone,
    WallID::Unsafe::fracturedStone};

inline std::array const jungle = {
    WallID::Unsafe::mud,
    WallID::Unsafe::lichenStone,
    WallID::Unsafe::leafyJungle,
    WallID::Unsafe::ivyStone,
    WallID::Unsafe::jungleVine};

// Excludes: crimsonBlister
inline std::array const crimson = {
    WallID::Unsafe::crimstone,
    WallID::Unsafe::crimsonCrust,
    WallID::Unsafe::crimsonScab,
    WallID::Unsafe::crimsonTeeth};

// Excludes: corruptTendril
inline std::array const corruption = {
    WallID::Unsafe::ebonstone,
    WallID::Unsafe::corruptGrowth,
    WallID::Unsafe::corruptMass,
    WallID::Unsafe::corruptPustule};

inline std::array const hallow = {
    WallID::Unsafe::hallowedPrism,
    WallID::Unsafe::hallowedCavern,
    WallID::Unsafe::hallowedShard,
    WallID::Unsafe::hallowedCrystalline};

inline std::array const dungeon = {
    WallID::Unsafe::blueBrick,
    WallID::Unsafe::greenBrick,
    WallID::Unsafe::pinkBrick,
    WallID::Unsafe::blueSlab,
    WallID::Unsafe::greenSlab,
    WallID::Unsafe::pinkSlab,
    WallID::Unsafe::blueTiled,
    WallID::Unsafe::greenTiled,
    WallID::Unsafe::pinkTiled};

inline std::array const underworld = {
    WallID::Unsafe::ember,
    WallID::Unsafe::cinder,
    WallID::Unsafe::magma,
    WallID::Unsafe::smoulderingStone};
} // namespace WallVariants

#endif // WALLID_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/main.cpp`
```
#include "Config.h"
#include "GenRules.h"
#include "Random.h"
#include "World.h"
#include "Writer.h"
#include "ids/Prefix.h"
#include "map/ImgWriter.h"
#include "structures/StructureUtil.h"
#include <array>
#include <chrono>
#include <iostream>

#define FOREST_BACKGROUNDS 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 31, 51, 71, 72, 73
#define SNOW_BACKGROUNDS 0, 1, 2, 3, 4, 5, 6, 7, 21, 22, 31, 32, 41, 42

namespace NPC
{
enum {
    guide = 22,
    merchant = 17,
    nurse = 18,
    painter = 227,
    dyeTrader = 207,
    zoologist = 633,
    golfer = 588,
    partyGirl = 208,
    angler = 369,
    stylist = 353,
    demolitionist = 38,
    dryad = 20,
    tavernkeep = 550,
    armsDealer = 19,
    goblinTinkerer = 107,
    witchDoctor = 228,
    clothier = 54,
    mechanic = 124,
    taxCollector = 441,
    pirate = 229,
    truffle = 160,
    wizard = 108,
    steampunker = 178,
    cyborg = 209,
    santaClaus = 142,
    princess = 663,
    travelingMerchant = 368,
    oldMan = 37,
    skeletonMerchant = 453,
    townBunny = 656,
};
}

std::array townNPCs{
    NPC::guide,        NPC::merchant,        NPC::nurse,
    NPC::painter,      NPC::dyeTrader,       NPC::zoologist,
    NPC::golfer,       NPC::partyGirl,       NPC::angler,
    NPC::stylist,      NPC::demolitionist,   NPC::dryad,
    NPC::tavernkeep,   NPC::armsDealer,      NPC::goblinTinkerer,
    NPC::witchDoctor,  NPC::clothier,        NPC::mechanic,
    NPC::taxCollector, NPC::pirate,          NPC::truffle,
    NPC::wizard,       NPC::steampunker,     NPC::cyborg,
    NPC::santaClaus,   NPC::princess,        NPC::travelingMerchant,
    NPC::oldMan,       NPC::skeletonMerchant};

/**
 * Compatible with C# DateTime binary format.
 */
uint64_t getBinaryTime()
{
    uint64_t ms = std::chrono::duration_cast<std::chrono::milliseconds>(
                      std::chrono::system_clock::now().time_since_epoch())
                      .count();
    return ms * 10000 + 621355968000000000ull;
}

enum class Seed {
    normal,
    drunkWorld,
    forTheWorthy,
    celebrationmk10,
    theConstant,
    notTheBees,
    dontDigUp,
    noTraps,
    getFixedBoi
};

Seed determineSeed(Config &conf)
{
    if (conf.forTheWorthy) {
        return Seed::forTheWorthy;
    } else if (conf.dontDigUp) {
        return Seed::dontDigUp;
    } else if (conf.hiveQueen) {
        return Seed::notTheBees;
    } else if (conf.celebration) {
        return Seed::celebrationmk10;
    } else if (conf.doubleTrouble) {
        return Seed::drunkWorld;
    } else if (conf.traps > 14) {
        return Seed::noTraps;
    }
    return Seed::normal;
}

void writeNPC(
    int npcId,
    const std::string &npcName,
    Writer &w,
    Random &rnd,
    World &world,
    int npcVariation = 0)
{
    std::vector<Point> options;
    for (int i = -6; i < 6; ++i) {
        for (int j = -3; j < 3; ++j) {
            if (world.regionPasses(
                    world.spawn.x + i,
                    world.spawn.y - 2 + j,
                    2,
                    3,
                    [](Tile &tile) { return !isSolidBlock(tile.blockID); }) &&
                !world.regionPasses(
                    world.spawn.x + i,
                    world.spawn.y + 1 + j,
                    2,
                    1,
                    [](Tile &tile) { return !isSolidBlock(tile.blockID); })) {
                options.emplace_back(world.spawn.x + i, world.spawn.y + j);
            }
        }
    }
    Point pos = options.empty() ? world.spawn : rnd.select(options);
    w.putBool(true);                // Begin town NPC record.
    w.putUint32(npcId);             // NPC ID.
    w.putString(npcName);           // NPC name.
    w.putFloat32(16 * pos.x - 8);   // NPC position X.
    w.putFloat32(16 * (pos.y - 2)); // NPC position Y.
    w.putBool(true);                // NPC is homeless.
    w.putUint32(pos.x);             // NPC home X.
    w.putUint32(pos.y);             // NPC home Y.
    w.putBool(true);                // Has variation field.
    w.putUint32(npcVariation);      // NPC variation.
}

void saveWorldFile(Config &conf, Random &rnd, World &world)
{
    Seed special = determineSeed(conf);

    Writer w(conf.getFilename() + ".wld");
    w.putUint32(279); // File format version.
    w.write("relogic", 7);
    w.putUint8(2);    // File type "world".
    w.putUint32(1);   // Save revision.
    w.putBool(false); // Is favorite.
    w.skipBytes(7);   // Unused currently.
    w.putUint16(11);  // File section count.
    uint32_t sectionTablePos = w.tellp();
    w.skipBytes(44); // Reserve space for section pointers.
    w.putUint16(world.getFramedTiles().size());
    w.putBitVec(world.getFramedTiles());
    std::vector<uint32_t> sectionPointers{w.tellp()};

    w.putString(conf.name);     // Map name.
    w.putString(conf.seed);     // Seed.
    w.putUint64(1198295875585); // Generator version.
    for (int i = 0; i < 16; ++i) {
        w.putUint8(rnd.getByte()); // GUID.
    }
    int worldID = rnd.getInt(0, std::numeric_limits<int32_t>::max());
    w.putUint32(worldID);                          // World ID.
    w.putUint32(0);                                // Map left pixel.
    w.putUint32(16 * world.getWidth());            // Map right pixel.
    w.putUint32(0);                                // Map top pixel.
    w.putUint32(16 * world.getHeight());           // Map bottom pixel.
    w.putUint32(world.getHeight());                // Vertical tiles.
    w.putUint32(world.getWidth());                 // Horizontal tiles.
    w.putUint32(static_cast<uint32_t>(conf.mode)); // Game mode.
    w.putBool(special == Seed::drunkWorld);        // Drunk world.
    w.putBool(special == Seed::forTheWorthy);      // For the worthy.
    w.putBool(special == Seed::celebrationmk10);   // Celebrationmk10.
    w.putBool(special == Seed::theConstant);       // The constant.
    w.putBool(special == Seed::notTheBees);        // Not the bees.
    w.putBool(special == Seed::dontDigUp);         // Don't dig up.
    w.putBool(special == Seed::noTraps);           // No traps.
    w.putBool(special == Seed::getFixedBoi);       // Get fixed boi.
    w.putUint64(getBinaryTime());                  // Creation time.
    w.putUint8(rnd.getInt(0, 8));                  // Moon type.
    for (auto part : rnd.partitionRange(4, world.getWidth())) {
        w.putUint32(part); // Tree style change locations.
    }
    for (int i = 0; i < 4; ++i) {
        w.putUint32(rnd.getInt(0, 5)); // Tree style.
    }
    for (auto part : rnd.partitionRange(4, world.getWidth())) {
        w.putUint32(part); // Cave style change locations.
    }
    for (int i = 0; i < 4; ++i) {
        w.putUint32(rnd.getInt(0, 7)); // Cave style.
    }
    w.putUint32(rnd.getInt(0, 3)); // Ice style.
    w.putUint32(rnd.getInt(0, 5)); // Jungle style.
    w.putUint32(rnd.getInt(0, 2)); // Underworld style.
    w.putUint32(world.spawn.x);    // Spawn X.
    w.putUint32(world.spawn.y);    // Spawn Y.
    w.putFloat64(world.getUndergroundLevel());
    w.putFloat64(world.getCavernLevel());
    w.putFloat64(13500);          // Time of day.
    w.putBool(true);              // Is day.
    w.putUint32(0);               // Moon phase.
    w.putBool(false);             // Blood moon.
    w.putBool(false);             // Eclipse.
    w.putUint32(world.dungeon.x); // Dungeon X.
    w.putUint32(world.dungeon.y); // Dungeon Y.
    w.putBool(world.isCrimson);   // Is crimson.
    for (int i = 0; i < 20; ++i) {
        w.putBool(false); // Bosses and npc saves.
    }
    w.putUint8(0); // Shadow orbs smashed.
    w.putUint32(
        conf.hardmode ? conf.doubleTrouble ? 6 : 3 : 0); // Altars smashed.
    w.putBool(conf.hardmode);                            // Hard mode.
    w.putBool(false);                                    // After party of doom.
    w.putUint32(0);                                      // Invasion delay.
    w.putUint32(0);                                      // Invasion size.
    w.putUint32(0);                                      // Invasion type.
    w.putFloat64(0);                                     // Invasion X.
    w.putFloat64(0);                                     // Slime rain time.
    w.putUint8(0);                                       // Sundial cooldown.
    w.putBool(false);                                    // Raining.
    w.putUint32(0);                                      // Rain time left.
    w.putFloat32(0);                                     // Max rain.
    w.putUint32(world.cobaltVariant);                    // Cobalt ore variant.
    w.putUint32(world.mythrilVariant);                   // Mythril ore variant.
    w.putUint32(world.adamantiteVariant);         // Adamantite ore variant.
    w.putUint8(rnd.select({FOREST_BACKGROUNDS})); // Forest style.
    w.putUint8(rnd.getInt(0, 4));                 // Corruption style.
    w.putUint8(rnd.getInt(0, 1));                 // Underground jungle style.
    w.putUint8(rnd.select({SNOW_BACKGROUNDS}));   // Snow style.
    w.putUint8(rnd.getInt(0, 4));                 // Hallow style.
    w.putUint8(rnd.getInt(0, 5));                 // Crimson style.
    w.putUint8(rnd.getInt(0, 4));                 // Desert style.
    w.putUint8(rnd.getInt(0, 5));                 // Ocean style.
    w.putUint32(0);                               // Cloud background.
    w.putUint16(rnd.getInt(50, 150));             // Number of clouds.
    w.putFloat32(rnd.getDouble(-0.2, 0.2));       // Wind speed.
    w.putUint32(0);                        // Players finished angler quest.
    w.putBool(false);                      // Saved angler.
    w.putUint32(rnd.getInt(0, 38));        // Angler quest.
    w.putBool(false);                      // Saved stylist.
    w.putBool(special == Seed::dontDigUp); // Saved tax collector.
    w.putBool(false);                      // Saved golfer.
    w.putUint32(0);                        // Invasion start size.
    w.putUint32(0);                        // Cultist delay.
    w.putUint16(688);                      // Mob types.
    for (int i = 0; i < 688; ++i) {
        w.putUint32(0); // Mob kill tally.
    }
    for (int i = 0; i < 19; ++i) {
        w.putBool(false); // Bosses.
    }
    w.putBool(false);                            // Manual party.
    w.putBool(special == Seed::celebrationmk10); // Genuine party.
    w.putUint32(0);                              // Party cooldown.
    w.putUint32(0);                              // Partying NPCs.
    w.putBool(false);                            // Sandstorm active.
    w.putUint32(0);                              // Sandstorm remaining time.
    w.putFloat32(0);                             // Sandstorm severity.
    w.putFloat32(0);                             // Sandstorm intended severity.
    w.putBool(false);                            // Saved tavernkeep.
    w.putBool(false);             // Old one's army tier 1 complete.
    w.putBool(false);             // Old one's army tier 2 complete.
    w.putBool(false);             // Old one's army tier 3 complete.
    w.putUint8(rnd.getInt(0, 3)); // Mushroom style.
    w.putUint8(rnd.getInt(0, 2)); // Underworld style (again?).
    for (int i = 0; i < 3; ++i) {
        w.putUint8(rnd.select({FOREST_BACKGROUNDS})); // Forest style.
    }
    w.putBool(false); // Used combat book.
    w.putUint32(0);   // Lantern night cooldown.
    w.putBool(false); // Genuine lantern night.
    w.putBool(false); // Manual lantern night.
    w.putBool(false); // Lantern night next is genuine.
    w.putUint32(13);  // Tree top variation count.
    for (int i = 0; i < 4; ++i) {
        w.putUint32(rnd.getInt(0, 5)); // Forest tree tops.
    }
    w.putUint32(rnd.getInt(0, 4));               // Corruption tree tops.
    w.putUint32(rnd.getInt(0, 5));               // Jungle tree tops.
    w.putUint32(rnd.select({SNOW_BACKGROUNDS})); // Snow tree tops.
    w.putUint32(rnd.getInt(0, 4));               // Hallow tree tops.
    w.putUint32(rnd.getInt(0, 5));               // Crimson tree tops.
    w.putUint32(rnd.getInt(0, 4));               // Desert tree tops.
    w.putUint32(rnd.getInt(0, 5));               // Ocean tree tops.
    w.putUint32(rnd.getInt(0, 3));               // Mushroom tree tops.
    w.putUint32(rnd.getInt(0, 5));               // Underworld tree tops.
    w.putBool(false);                            // Force halloween.
    w.putBool(false);                            // Force christmas.
    w.putUint32(world.copperVariant);
    w.putUint32(world.ironVariant);
    w.putUint32(world.silverVariant);
    w.putUint32(world.goldVariant);
    std::vector<bool> unlocks(25);
    if (special == Seed::forTheWorthy) {
        unlocks[8] = true; // Demolitionist.
    } else if (special == Seed::notTheBees) {
        unlocks[7] = true; // Merchant.
    } else if (special == Seed::celebrationmk10) {
        unlocks[2] = true;  // Town Bunny.
        unlocks[9] = true;  // Party Girl.
        unlocks[14] = true; // Princess.
    } else if (special == Seed::drunkWorld) {
        unlocks[9] = true; // Party Girl.
    }
    for (bool unlock : unlocks) {
        w.putBool(unlock); // Bosses and npc saves.
    }
    w.putUint8(0); // Moondial cooldown.
    sectionPointers.push_back(w.tellp());

    std::vector<std::pair<int, int>> sensors;

    for (int x = 0; x < world.getWidth(); ++x) {
        for (int y = 0; y < world.getHeight(); ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::sensor) {
                sensors.emplace_back(x, y);
            }

            int rle = 0;
            while (y + rle + 1 < world.getHeight() &&
                   tile == world.getTile(x, y + rle + 1)) {
                ++rle;
            }
            y += rle;

            std::array<uint8_t, 4> flags{0, 0, 0, 0};
            if (rle > 255) {
                flags[0] |= 128;
            } else if (rle > 0) {
                flags[0] |= 64;
            }
            if (tile.blockID != TileID::empty) {
                flags[0] |= 2;
                if (tile.blockID > 255) {
                    flags[0] |= 32;
                }
            }
            if (tile.wallID > 0) {
                flags[0] |= 4;
                if (tile.wallID > 255) {
                    flags[2] |= 64;
                }
            }
            switch (tile.liquid) {
            case Liquid::none:
                break;
            case Liquid::water:
                flags[0] |= 8;
                break;
            case Liquid::lava:
                flags[0] |= 16;
                break;
            case Liquid::honey:
                flags[0] |= 24;
                break;
            case Liquid::shimmer:
                flags[0] |= 8;
                flags[2] |= 128;
                break;
            }
            flags[1] |= static_cast<int>(tile.slope) << 4;
            if (tile.wireRed) {
                flags[1] |= 2;
            }
            if (tile.wireBlue) {
                flags[1] |= 4;
            }
            if (tile.wireGreen) {
                flags[1] |= 8;
            }
            if (tile.wireYellow) {
                flags[2] |= 32;
            }
            if (tile.actuator) {
                flags[2] |= 2;
            }
            if (tile.actuated) {
                flags[2] |= 4;
            }
            if (tile.blockPaint > 0) {
                flags[2] |= 8;
            }
            if (tile.wallPaint > 0) {
                flags[2] |= 16;
            }
            if (tile.echoCoatBlock) {
                flags[3] |= 2;
            }
            if (tile.echoCoatWall) {
                flags[3] |= 4;
            }
            if (tile.illuminantBlock) {
                flags[3] |= 8;
            }
            if (tile.illuminantWall) {
                flags[3] |= 16;
            }
            for (int i = 2; i >= 0; --i) {
                if (flags[i + 1] > 0) {
                    flags[i] |= 1;
                }
            }
            for (int i = 0; i < 4; ++i) {
                if (flags[i] == 0 && i > 0) {
                    break;
                }
                w.putUint8(flags[i]);
            }
            if (tile.blockID != TileID::empty) {
                if (tile.blockID > 255) {
                    w.putUint16(tile.blockID);
                } else {
                    w.putUint8(tile.blockID);
                }
                if (world.getFramedTiles()[tile.blockID]) {
                    w.putUint16(tile.frameX);
                    w.putUint16(tile.frameY);
                }
                if (tile.blockPaint > 0) {
                    w.putUint8(tile.blockPaint);
                }
            }
            if (tile.wallID > 0) {
                w.putUint8(0xff & tile.wallID);
                if (tile.wallPaint > 0) {
                    w.putUint8(tile.wallPaint);
                }
            }
            if (tile.liquid != Liquid::none) {
                w.putUint8(0xff); // Liquid amount.
            }
            if (tile.wallID > 255) {
                w.putUint8(tile.wallID >> 8);
            }
            if (rle > 255) {
                w.putUint16(rle);
            } else if (rle > 0) {
                w.putUint8(rle);
            }
        }
    }
    sectionPointers.push_back(w.tellp());

    w.putUint16(world.getChests().size()); // Number of chests.
    w.putUint16(40);                       // Slots per chest.
    for (auto &chest : world.getChests()) {
        w.putUint32(chest.x); // Chest position X.
        w.putUint32(chest.y); // Chest position Y.
        w.putString("");      // Chest name.
        for (auto &item : chest.items) {
            w.putUint16(item.stack); // Item stack count.
            if (item.stack > 0) {
                w.putUint32(item.id);    // Item ID.
                w.putUint8(item.prefix); // Item prefix.
            }
        }
    }
    sectionPointers.push_back(w.tellp());

    w.putUint16(0); // Number of signs.
    sectionPointers.push_back(w.tellp());

    if (conf.celebration) {
        w.putUint32(townNPCs.size()); // Number of shimmered NPCs.
        std::sort(townNPCs.begin(), townNPCs.end());
        for (auto npc : townNPCs) {
            w.putUint32(npc);
        }
    } else {
        w.putUint32(0); // Number of shimmered NPCs.
    }
    if (special == Seed::forTheWorthy) {
        writeNPC(
            NPC::demolitionist,
            rnd.select({"Bazdin",  "Beldin", "Boften",  "Darur",    "Dias",
                        "Dolbere", "Dolgen", "Dolgrim", "Duerthen", "Durim",
                        "Fikod",   "Garval", "Gimli",   "Gimut",    "Jarut",
                        "Morthal", "Norkas", "Norsun",  "Oten",     "Ovbere",
                        "Tordak",  "Urist"}),
            w,
            rnd,
            world);
    } else if (special == Seed::dontDigUp) {
        writeNPC(
            NPC::taxCollector,
            rnd.select(
                {"Agnew",
                 "Blanton",
                 "Carroll",
                 "Chester",
                 "Cleveland",
                 "Dwyer",
                 "Fillmore",
                 "Grover",
                 "Harrison",
                 "Herbert",
                 "Lyndon",
                 "McKinly",
                 "Millard",
                 "Ronald",
                 "Rutherford",
                 "Theodore",
                 "Tweed",
                 "Warren"}),
            w,
            rnd,
            world);
    } else if (special == Seed::notTheBees) {
        writeNPC(
            NPC::merchant,
            rnd.select({"Alfred",   "Barney", "Calvin",    "Edmund",   "Edwin",
                        "Eugene",   "Frank",  "Frederick", "Gilbert",  "Gus",
                        "Harold",   "Howard", "Humphrey",  "Isaac",    "Joseph",
                        "Kristian", "Louis",  "Milton",    "Mortimer", "Ralph",
                        "Seymour",  "Walter", "Wilbur"}),
            w,
            rnd,
            world);
    } else if (special == Seed::celebrationmk10) {
        writeNPC(NPC::guide, "Andrew", w, rnd, world, 1);
        writeNPC(NPC::steampunker, "Whitney", w, rnd, world, 1);
        writeNPC(NPC::princess, "Yorai", w, rnd, world, 1);
        writeNPC(NPC::partyGirl, "Amanda", w, rnd, world, 1);
        writeNPC(
            NPC::townBunny,
            rnd.select(
                {"Babs",
                 "Breadbuns",
                 "Fluffy",
                 "Greg",
                 "Loaf",
                 "Maximus",
                 "Muffin",
                 "Pom"}),
            w,
            rnd,
            world,
            1);
    } else if (special == Seed::drunkWorld) {
        writeNPC(
            NPC::partyGirl,
            rnd.select(
                {"Amanda",
                 "Bailey",
                 "Bambi",
                 "Bunny",
                 "Candy",
                 "Cherry",
                 "Dazzle",
                 "Destiny",
                 "Fantasia",
                 "Fantasy",
                 "Glitter",
                 "Isis",
                 "Lexus",
                 "Paris",
                 "Sparkle",
                 "Star",
                 "Sugar",
                 "Trixy"}),
            w,
            rnd,
            world);
    } else {
        writeNPC(
            NPC::guide,
            rnd.select(
                {"Andrew",  "Asher",   "Bradley", "Brandon", "Brett",  "Brian",
                 "Cody",    "Cole",    "Colin",   "Connor",  "Daniel", "Dylan",
                 "Garrett", "Harley",  "Jack",    "Jacob",   "Jake",   "Jan",
                 "Jeff",    "Jeffrey", "Joe",     "Kevin",   "Kyle",   "Levi",
                 "Logan",   "Luke",    "Marty",   "Maxwell", "Ryan",   "Scott",
                 "Seth",    "Steve",   "Tanner",  "Trent",   "Wyatt",  "Zach"}),
            w,
            rnd,
            world);
    }
    w.putBool(false); // End town NPC records.
    w.putBool(false); // End pillar records.
    sectionPointers.push_back(w.tellp());

    w.putUint32(sensors.size()); // Number of tile entities.
    for (size_t i = 0; i < sensors.size(); ++i) {
        auto [x, y] = sensors[i];
        Tile &tile = world.getTile(x, y);
        w.putUint8(2);                    // Type: sensor.
        w.putUint32(i);                   // Tile entity ID.
        w.putUint16(x);                   // Tile entity position X.
        w.putUint16(y);                   // Tile entity position Y.
        w.putUint8(1 + tile.frameY / 18); // Sensor type.
        w.putBool(false);                 // Sensor active.
    }
    sectionPointers.push_back(w.tellp());

    w.putUint32(0); // Number of weighted pressure plates.
    sectionPointers.push_back(w.tellp());

    w.putUint32(0); // Number of houses.
    sectionPointers.push_back(w.tellp());

    w.putUint32(0); // Bestiary kills.
    w.putUint32(0); // Bestiary seen.
    w.putUint32(0); // Bestiary chatted.
    sectionPointers.push_back(w.tellp());

    w.putBool(true); // New creative power record.
    w.putUint16(0);
    w.putBool(false); // Freeze time.
    w.putBool(true);  // New creative power record.
    w.putUint16(8);
    w.putFloat32(0); // Time rate.
    w.putBool(true); // New creative power record.
    w.putUint16(9);
    w.putBool(false); // Freeze rain status.
    w.putBool(true);  // New creative power record.
    w.putUint16(10);
    w.putBool(false); // Freeze wind status.
    w.putBool(true);  // New creative power record.
    w.putUint16(12);
    w.putFloat32(0); // Difficulty.
    w.putBool(true); // New creative power record.
    w.putUint16(13);
    w.putBool(false); // Freeze infection spread.
    w.putBool(false); // End creative powers records.
    sectionPointers.push_back(w.tellp());

    w.putBool(true); // Begin footer.
    w.putString(conf.name);
    w.putUint32(worldID);

    // Finalize.
    w.seekp(sectionTablePos);
    for (auto ptr : sectionPointers) {
        w.putUint32(ptr);
    }
}

int main()
{
    auto mainStart = std::chrono::high_resolution_clock::now();

    Random rnd;
    Config conf = readConfig(rnd);
    rnd.setSeed(conf.seed);
    World world{conf};

    world.isCrimson = conf.evil == EvilBiome::random
                          ? rnd.getBool()
                          : conf.evil == EvilBiome::crimson;
    world.copperVariant = rnd.select({TileID::copperOre, TileID::tinOre});
    world.ironVariant = rnd.select({TileID::ironOre, TileID::leadOre});
    world.silverVariant = rnd.select({TileID::silverOre, TileID::tungstenOre});
    world.goldVariant = rnd.select({TileID::goldOre, TileID::platinumOre});
    if (conf.hardmode) {
        world.cobaltVariant =
            rnd.select({TileID::cobaltOre, TileID::palladiumOre});
        world.mythrilVariant =
            rnd.select({TileID::mythrilOre, TileID::orichalcumOre});
        world.adamantiteVariant =
            rnd.select({TileID::adamantiteOre, TileID::titaniumOre});
    } else {
        world.cobaltVariant = TileID::empty;
        world.mythrilVariant = TileID::empty;
        world.adamantiteVariant = TileID::empty;
    }
    if (conf.celebration) {
        if (conf.spawn == SpawnPoint::normal) {
            conf.spawn = SpawnPoint::ocean;
        }
        conf.pots *= 1.6;
        conf.chests *= 1.1;
        conf.gems *= 1.15;
        conf.trees *= 1.1;
        conf.livingTrees *= 1.5;
        conf.minecartTracks *= 1.1;
        conf.minecartLength *= 1.35;
        PrefixSet::initCelebration();
    }
    if (conf.hiveQueen) {
        if (conf.biomes == BiomeLayout::columns) {
            conf.jungleSize *= 2;
        } else if (conf.biomes == BiomeLayout::layers) {
            conf.jungleSize *= 1.35;
        }
    } else if (conf.biomes == BiomeLayout::layers) {
        conf.graniteFreq *= 2;
        conf.graniteSize *= 0.7071;
        conf.marbleFreq *= 2;
        conf.marbleSize *= 0.7071;
    }
    if (conf.forTheWorthy) {
        conf.spiderNestFreq *= 2.5;
        conf.graniteFreq *= 1.7;
        conf.marbleFreq *= 1.85;
        conf.glowingMushroomFreq *= 1.5;
        conf.glowingMushroomSize *= 1.26;
        conf.templeSize *= 1.4;
        conf.glowingMossSize *= 1.225;
        conf.evilSize *= 1.58;
    }
    if (conf.dontDigUp) {
        if (conf.spawn == SpawnPoint::normal) {
            conf.spawn = SpawnPoint::underworld;
        }
        conf.gems *= 0.65;
        conf.evilSize *= 1.5;
    }
    if (conf.spawn == SpawnPoint::normal) {
        conf.spawn = SpawnPoint::surface;
    }

    doWorldGen(rnd, world);
    saveWorldFile(conf, rnd, world);

    auto mainEnd = std::chrono::high_resolution_clock::now();
    std::cout << "\nTime: "
              << 0.001 * std::chrono::duration_cast<std::chrono::milliseconds>(
                             mainEnd - mainStart)
                             .count()
              << "s\n\n";

    if (conf.map) {
        std::cout << "Rendering map preview\n";
        savePreviewImage(conf.getFilename(), world);
    }
    return 0;
}

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/map`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/map/DiegeticColor.cpp`
```
#include "map/DiegeticColor.h"

#include "Config.h"
#include "World.h"
#include "ids/WallID.h"
#include "vendor/frozen/map.h"
#include <algorithm>
#include <map>

inline constexpr auto tileToRepTile = frozen::make_map<int, int>({
    {TileID::aetherium, TileID::offlineAmethystGemspark},
    {TileID::amberGemspark, TileID::emeraldStone},
    {TileID::amberTree, TileID::emeraldStone},
    {TileID::amethystGemspark, TileID::emeraldStone},
    {TileID::amethystStone, TileID::amethystStone},
    {TileID::amethystTree, TileID::emeraldStone},
    {TileID::argonMossStone, TileID::stone},
    {TileID::ash, TileID::ash},
    {TileID::ashGrass, TileID::ash},
    {TileID::ashPlant, TileID::ash},
    {TileID::ashTree, TileID::wood},
    {TileID::ashVines, TileID::ash},
    {TileID::ashWood, TileID::wood},
    {TileID::asphalt, TileID::asphalt},
    {TileID::blueBrick, TileID::blueBrick},
    {TileID::blueMossStone, TileID::stone},
    {TileID::borealBeam, TileID::wood},
    {TileID::borealWood, TileID::borealWood},
    {TileID::boulder, TileID::stone},
    {TileID::bouncyBoulder, TileID::stone},
    {TileID::brownMossStone, TileID::stone},
    {TileID::clay, TileID::clay},
    {TileID::cloud, TileID::cloud},
    {TileID::cobweb, TileID::spiderNest},
    {TileID::copperOre, TileID::copperOre},
    {TileID::coralstone, TileID::coralstone},
    {TileID::corruptGrass, TileID::ebonstoneBrick},
    {TileID::corruptIce, TileID::ebonstoneBrick},
    {TileID::corruptJungleGrass, TileID::ebonstoneBrick},
    {TileID::corruptPlant, TileID::ebonstoneBrick},
    {TileID::corruptVines, TileID::ebonstoneBrick},
    {TileID::crackedBlueBrick, TileID::blueBrick},
    {TileID::crackedGreenBrick, TileID::greenBrick},
    {TileID::crackedPinkBrick, TileID::pinkBrick},
    {TileID::crimsand, TileID::crimstoneBrick},
    {TileID::crimsandstone, TileID::crimstoneBrick},
    {TileID::crimsonGrass, TileID::crimstoneBrick},
    {TileID::crimsonIce, TileID::crimstoneBrick},
    {TileID::crimsonJungleGrass, TileID::crimstoneBrick},
    {TileID::crimsonPlant, TileID::crimstoneBrick},
    {TileID::crimsonVines, TileID::crimstoneBrick},
    {TileID::crimstone, TileID::crimstoneBrick},
    {TileID::crimstoneBrick, TileID::crimstoneBrick},
    {TileID::crimtane, TileID::crimstoneBrick},
    {TileID::crispyHoney, TileID::honey},
    {TileID::crystalBlock, TileID::pearlstoneBrick},
    {TileID::demonite, TileID::ebonstoneBrick},
    {TileID::desertFossil, TileID::desertFossil},
    {TileID::diamondGemspark, TileID::emeraldStone},
    {TileID::diamondStone, TileID::diamondStone},
    {TileID::diamondTree, TileID::emeraldStone},
    {TileID::dirt, TileID::dirt},
    {TileID::dirtiestBlock, TileID::dirt},
    {TileID::ebonsand, TileID::ebonstoneBrick},
    {TileID::ebonsandstone, TileID::ebonstoneBrick},
    {TileID::ebonstone, TileID::ebonstoneBrick},
    {TileID::ebonstoneBrick, TileID::ebonstoneBrick},
    {TileID::emeraldGemspark, TileID::emeraldStone},
    {TileID::emeraldStone, TileID::stone},
    {TileID::emeraldTree, TileID::emeraldStone},
    {TileID::fallenLog, TileID::wood},
    {TileID::flesh, TileID::crimstoneBrick},
    {TileID::flowerVines, TileID::leaf},
    {TileID::glowingMushroom, TileID::slime},
    {TileID::goldOre, TileID::goldOre},
    {TileID::granite, TileID::granite},
    {TileID::grass, TileID::dirt},
    {TileID::grassPlant, TileID::leaf},
    {TileID::grayBrick, TileID::grayBrick},
    {TileID::greenBrick, TileID::greenBrick},
    {TileID::greenMossStone, TileID::stone},
    {TileID::hallowedGrass, TileID::pearlstoneBrick},
    {TileID::hallowedIce, TileID::pearlstoneBrick},
    {TileID::hardenedCrimsand, TileID::crimstoneBrick},
    {TileID::hardenedEbonsand, TileID::ebonstoneBrick},
    {TileID::hardenedPearlsand, TileID::pearlstoneBrick},
    {TileID::hardenedSand, TileID::hardenedSand},
    {TileID::heliumMossStone, TileID::offlineAmethystGemspark},
    {TileID::hellstone, TileID::hellstone},
    {TileID::hellstoneBrick, TileID::hellstoneBrick},
    {TileID::hive, TileID::honey},
    {TileID::honey, TileID::honey},
    {TileID::ice, TileID::ice},
    {TileID::iceBrick, TileID::iceBrick},
    {TileID::ironOre, TileID::ironOre},
    {TileID::jungleGrass, TileID::mud},
    {TileID::junglePlant, TileID::mahoganyLeaf},
    {TileID::jungleVines, TileID::mahoganyLeaf},
    {TileID::kryptonMossStone, TileID::stone},
    {TileID::largeJunglePlant, TileID::mahoganyLeaf},
    {TileID::lavaMossStone, TileID::stone},
    {TileID::leadOre, TileID::leadOre},
    {TileID::leaf, TileID::leaf},
    {TileID::lesion, TileID::ebonstoneBrick},
    {TileID::lihzahrdBrick, TileID::lihzahrdBrick},
    {TileID::livingMahogany, TileID::livingMahogany},
    {TileID::livingWood, TileID::wood},
    {TileID::mahoganyLeaf, TileID::mahoganyLeaf},
    {TileID::marble, TileID::marble},
    {TileID::meteorite, TileID::meteorite},
    {TileID::mud, TileID::mud},
    {TileID::mudstoneBrick, TileID::mudstoneBrick},
    {TileID::mushroomGrass, TileID::slime},
    {TileID::mushroomPlant, TileID::slime},
    {TileID::mushroomVines, TileID::slime},
    {TileID::neonMossStone, TileID::stone},
    {TileID::obsidian, TileID::obsidian},
    {TileID::obsidianBrick, TileID::obsidianBrick},
    {TileID::palmTree, TileID::wood},
    {TileID::palmWood, TileID::wood},
    {TileID::pearlsand, TileID::pearlstoneBrick},
    {TileID::pearlsandstone, TileID::pearlstoneBrick},
    {TileID::pearlstone, TileID::pearlstoneBrick},
    {TileID::pinkBrick, TileID::pinkBrick},
    {TileID::platinumOre, TileID::platinumOre},
    {TileID::purpleMossStone, TileID::stone},
    {TileID::rainCloud, TileID::cloud},
    {TileID::redBrick, TileID::redBrick},
    {TileID::redMossStone, TileID::stone},
    {TileID::richMahogany, TileID::wood},
    {TileID::richMahoganyBeam, TileID::wood},
    {TileID::rope, TileID::borealWood},
    {TileID::rubyGemspark, TileID::emeraldStone},
    {TileID::rubyStone, TileID::rubyStone},
    {TileID::rubyTree, TileID::emeraldStone},
    {TileID::sakuraTree, TileID::wood},
    {TileID::sand, TileID::hardenedSand},
    {TileID::sandstone, TileID::sandstone},
    {TileID::sandstoneBrick, TileID::sandstoneBrick},
    {TileID::sandstoneColumn, TileID::sandstoneBrick},
    {TileID::sandstoneSlab, TileID::sandstoneBrick},
    {TileID::sapphireGemspark, TileID::emeraldStone},
    {TileID::sapphireStone, TileID::sapphireStone},
    {TileID::sapphireTree, TileID::emeraldStone},
    {TileID::shellPile, TileID::hardenedSand},
    {TileID::silt, TileID::mud},
    {TileID::silverOre, TileID::silverOre},
    {TileID::slime, TileID::slime},
    {TileID::slush, TileID::snow},
    {TileID::smoothGranite, TileID::granite},
    {TileID::smoothMarble, TileID::marble},
    {TileID::snow, TileID::snow},
    {TileID::snowBrick, TileID::snowBrick},
    {TileID::snowCloud, TileID::cloud},
    {TileID::stone, TileID::stone},
    {TileID::stoneSlab, TileID::stone},
    {TileID::sunplate, TileID::sunplate},
    {TileID::tallGrassPlant, TileID::leaf},
    {TileID::tallJunglePlant, TileID::mahoganyLeaf},
    {TileID::thinIce, TileID::ice},
    {TileID::tinBrick, TileID::tinBrick},
    {TileID::tinOre, TileID::tinOre},
    {TileID::topazGemspark, TileID::emeraldStone},
    {TileID::topazStone, TileID::topazStone},
    {TileID::topazTree, TileID::emeraldStone},
    {TileID::torch, TileID::torch},
    {TileID::tree, TileID::wood},
    {TileID::tungstenOre, TileID::tungstenOre},
    {TileID::vineRope, TileID::mahoganyLeaf},
    {TileID::vines, TileID::leaf},
    {TileID::wood, TileID::wood},
    {TileID::woodenBeam, TileID::wood},
    {TileID::xenonMossStone, TileID::stone},
    {TileID::yellowWillowTree, TileID::wood},
});

inline constexpr auto wallToRepTile = frozen::make_map<int, int>({
    {WallID::Safe::ashWood, TileID::wood},
    {WallID::Safe::borealWood, TileID::wood},
    {WallID::Safe::cloud, TileID::cloud},
    {WallID::Safe::crimstoneBrick, TileID::crimstoneBrick},
    {WallID::Safe::crimtaneBrick, TileID::crimstoneBrick},
    {WallID::Safe::demoniteBrick, TileID::ebonstoneBrick},
    {WallID::Safe::ebonstoneBrick, TileID::ebonstoneBrick},
    {WallID::Safe::ember, TileID::ash},
    {WallID::Safe::goldBrick, TileID::goldOre},
    {WallID::Safe::grayBrick, TileID::grayBrick},
    {WallID::Safe::hardenedSand, TileID::hardenedSand},
    {WallID::Safe::ice, TileID::ice},
    {WallID::Safe::iceBrick, TileID::iceBrick},
    {WallID::Safe::livingLeaf, TileID::leaf},
    {WallID::Safe::livingWood, TileID::wood},
    {WallID::Safe::mudstoneBrick, TileID::mudstoneBrick},
    {WallID::Safe::obsidianBrick, TileID::obsidianBrick},
    {WallID::Safe::palmWood, TileID::wood},
    {WallID::Safe::palmWoodFence, TileID::wood},
    {WallID::Safe::planked, TileID::wood},
    {WallID::Safe::redBrick, TileID::redBrick},
    {WallID::Safe::richMahogany, TileID::borealWood},
    {WallID::Safe::sail, TileID::borealWood},
    {WallID::Safe::sandstone, TileID::sandstone},
    {WallID::Safe::sandstoneBrick, TileID::sandstoneBrick},
    {WallID::Safe::smoothSandstone, TileID::sandstone},
    {WallID::Safe::snow, TileID::snow},
    {WallID::Safe::snowBrick, TileID::snowBrick},
    {WallID::Safe::stone, TileID::stone},
    {WallID::Safe::stoneSlab, TileID::stone},
    {WallID::Safe::tinBrick, TileID::tinBrick},
    {WallID::Safe::wood, TileID::wood},
    {WallID::Safe::wornStone, TileID::stone},
    {WallID::Unsafe::amethystStone, TileID::amethystStone},
    {WallID::Unsafe::blueBrick, TileID::blueBrick},
    {WallID::Unsafe::blueMossy, TileID::stone},
    {WallID::Unsafe::blueSlab, TileID::blueBrick},
    {WallID::Unsafe::blueTiled, TileID::blueBrick},
    {WallID::Unsafe::brownMossy, TileID::stone},
    {WallID::Unsafe::caveDirt, TileID::dirt},
    {WallID::Unsafe::cinder, TileID::offlineRubyGemspark},
    {WallID::Unsafe::corruptGrass, TileID::ebonstoneBrick},
    {WallID::Unsafe::corruptGrowth, TileID::ebonstoneBrick},
    {WallID::Unsafe::corruptMass, TileID::ebonstoneBrick},
    {WallID::Unsafe::corruptPustule, TileID::ebonstoneBrick},
    {WallID::Unsafe::corruptTendril, TileID::ebonstoneBrick},
    {WallID::Unsafe::crackedDirt, TileID::dirt},
    {WallID::Unsafe::craggyStone, TileID::stone},
    {WallID::Unsafe::crimsandstone, TileID::crimstoneBrick},
    {WallID::Unsafe::crimsonBlister, TileID::crimstoneBrick},
    {WallID::Unsafe::crimsonCrust, TileID::crimstoneBrick},
    {WallID::Unsafe::crimsonGrass, TileID::crimstoneBrick},
    {WallID::Unsafe::crimsonScab, TileID::crimstoneBrick},
    {WallID::Unsafe::crimsonTeeth, TileID::crimstoneBrick},
    {WallID::Unsafe::crimstone, TileID::crimstoneBrick},
    {WallID::Unsafe::crumblingDirt, TileID::dirt},
    {WallID::Unsafe::diamondStone, TileID::diamondStone},
    {WallID::Unsafe::dirt, TileID::dirt},
    {WallID::Unsafe::ebonsandstone, TileID::ebonstoneBrick},
    {WallID::Unsafe::ebonstone, TileID::ebonstoneBrick},
    {WallID::Unsafe::ember, TileID::offlineRubyGemspark},
    {WallID::Unsafe::emeraldStone, TileID::emeraldStone},
    {WallID::Unsafe::flower, TileID::leaf},
    {WallID::Unsafe::fracturedStone, TileID::stone},
    {WallID::Unsafe::granite, TileID::granite},
    {WallID::Unsafe::grass, TileID::leaf},
    {WallID::Unsafe::greenBrick, TileID::greenBrick},
    {WallID::Unsafe::greenMossy, TileID::stone},
    {WallID::Unsafe::greenSlab, TileID::greenBrick},
    {WallID::Unsafe::greenTiled, TileID::greenBrick},
    {WallID::Unsafe::hallowedCavern, TileID::pearlstoneBrick},
    {WallID::Unsafe::hallowedCrystalline, TileID::pearlstoneBrick},
    {WallID::Unsafe::hallowedGrass, TileID::pearlstoneBrick},
    {WallID::Unsafe::hallowedPrism, TileID::pearlstoneBrick},
    {WallID::Unsafe::hallowedShard, TileID::pearlstoneBrick},
    {WallID::Unsafe::hardenedCrimsand, TileID::crimstoneBrick},
    {WallID::Unsafe::hardenedEbonsand, TileID::ebonstoneBrick},
    {WallID::Unsafe::hardenedPearlsand, TileID::pearlstoneBrick},
    {WallID::Unsafe::hardenedSand, TileID::hardenedSand},
    {WallID::Unsafe::hellstoneBrick, TileID::hellstoneBrick},
    {WallID::Unsafe::hive, TileID::honey},
    {WallID::Unsafe::ice, TileID::ice},
    {WallID::Unsafe::ivyStone, TileID::mud},
    {WallID::Unsafe::jungle, TileID::mud},
    {WallID::Unsafe::jungleVine, TileID::mud},
    {WallID::Unsafe::layeredDirt, TileID::dirt},
    {WallID::Unsafe::leafyJungle, TileID::mud},
    {WallID::Unsafe::lichenStone, TileID::mud},
    {WallID::Unsafe::lihzahrdBrick, TileID::lihzahrdBrick},
    {WallID::Unsafe::livingWood, TileID::wood},
    {WallID::Unsafe::magma, TileID::offlineRubyGemspark},
    {WallID::Unsafe::marble, TileID::marble},
    {WallID::Unsafe::mottledStone, TileID::stone},
    {WallID::Unsafe::mud, TileID::mud},
    {WallID::Unsafe::mushroom, TileID::slime},
    {WallID::Unsafe::obsidianBrick, TileID::obsidianBrick},
    {WallID::Unsafe::oldStone, TileID::stone},
    {WallID::Unsafe::pearlsandstone, TileID::pearlstoneBrick},
    {WallID::Unsafe::pinkBrick, TileID::pinkBrick},
    {WallID::Unsafe::pinkSlab, TileID::pinkBrick},
    {WallID::Unsafe::pinkTiled, TileID::pinkBrick},
    {WallID::Unsafe::purpleMossy, TileID::stone},
    {WallID::Unsafe::redMossy, TileID::stone},
    {WallID::Unsafe::rockyDirt, TileID::dirt},
    {WallID::Unsafe::roughDirt, TileID::dirt},
    {WallID::Unsafe::rubyStone, TileID::rubyStone},
    {WallID::Unsafe::sandstone, TileID::sandstone},
    {WallID::Unsafe::sapphireStone, TileID::sapphireStone},
    {WallID::Unsafe::smoulderingStone, TileID::offlineRubyGemspark},
    {WallID::Unsafe::snow, TileID::snow},
    {WallID::Unsafe::stalactiteStone, TileID::stone},
    {WallID::Unsafe::topazStone, TileID::topazStone},
    {WallID::Unsafe::wavyDirt, TileID::dirt},
    {WallID::Unsafe::wornStone, TileID::stone},
});

int getRepColorTile(int x, int y, World &world)
{
    Tile &tile = world.getTile(x, y);
    if (!tile.echoCoatBlock) {
        auto itr = tileToRepTile.find(tile.blockID);
        if (itr != tileToRepTile.end()) {
            return itr->second;
        }
    }
    switch (tile.liquid) {
    case Liquid::none:
        break;
    case Liquid::water:
        return TileID::waterfall;
    case Liquid::lava:
        return TileID::offlineRubyGemspark;
    case Liquid::honey:
        return TileID::honey;
    case Liquid::shimmer:
        return TileID::offlineAmethystGemspark;
    }
    if (!tile.echoCoatWall) {
        auto itr = wallToRepTile.find(tile.wallID);
        if (itr != wallToRepTile.end()) {
            return itr->second;
        }
    }
    return y < world.getUndergroundLevel()  ? TileID::offlineSapphireGemspark
           : y < world.getCavernLevel()     ? TileID::redStucco
           : y < world.getUnderworldLevel() ? TileID::grayStucco
                                            : TileID::offlineRubyGemspark;
}

int getSectorColor(int i, int j, int scale, World &world)
{
    int minX = i * scale;
    int maxX = std::min(minX + scale, world.getWidth());
    int minY = j * scale;
    int maxY = std::min(minY + scale, world.getHeight());
    std::map<int, int> colorFreqs;
    for (int x = minX; x < maxX; ++x) {
        for (int y = minY; y < maxY; ++y) {
            colorFreqs[getRepColorTile(x, y, world)] += 1;
        }
    }
    int total = (maxX - minX) * (maxY - minY);
    for (auto [prioTile, threshold] :
         {std::pair{TileID::offlineAmethystGemspark, 0.07},
          {TileID::meteorite, 0.017},
          {TileID::cloud, 0.08},
          {TileID::torch, 0.0085},
          {TileID::spiderNest, 0.04},
          {TileID::livingMahogany, 0.08},
          {TileID::borealWood, 0.07},
          {TileID::sandstoneBrick, 0.08},
          {TileID::emeraldStone, 0.032},
          {TileID::honey, world.conf.hiveQueen ? 1.0 : 0.08},
          {TileID::slime, 0.08},
          {TileID::blueBrick, 0.08},
          {TileID::greenBrick, 0.08},
          {TileID::pinkBrick, 0.08},
          {TileID::lihzahrdBrick, 0.08},
          {TileID::leaf, 0.2}}) {
        if (colorFreqs[prioTile] > threshold * total) {
            return prioTile;
        }
    }
    return std::max_element(
               colorFreqs.begin(),
               colorFreqs.end(),
               [](auto a, auto b) { return a.second < b.second; })
        ->first;
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/map/DiegeticColor.h`
```
#ifndef DIEGETICCOLOR_H
#define DIEGETICCOLOR_H

class World;

int getSectorColor(int i, int j, int scale, World &world);

#endif // DIEGETICCOLOR_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/map/ImgWriter.cpp`
```
#include "ImgWriter.h"

#include "World.h"
#include "map/TileColor.h"
#include "vendor/fpng.h"

void savePreviewImage(std::string basename, World &world)
{
    std::vector<uint8_t> img;
    img.reserve(3 * world.getWidth() * world.getHeight());
    for (int y = 0; y < world.getHeight(); ++y) {
        for (int x = 0; x < world.getWidth(); ++x) {
            const uint8_t *tileColor = getTileColor(x, y, world);
            img.insert(img.end(), tileColor, tileColor + 3);
        }
    }
    fpng::fpng_init();
    basename += "-map.png";
    fpng::fpng_encode_image_to_file(
        basename.c_str(),
        img.data(),
        world.getWidth(),
        world.getHeight(),
        3);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/map/ImgWriter.h`
```
#ifndef IMGWRITER_H
#define IMGWRITER_H

#include <string>

class World;

void savePreviewImage(std::string basename, World &world);

#endif // IMGWRITER_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/map/TileColor.cpp`
```
#include "TileColor.h"

#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include <cstring>

namespace
{
// clang-format off
uint8_t tileColors[] = {
    151, 107, 75, 128, 128, 128, 28, 216, 94, 26, 196, 84, 253, 221, 3, 151,
    107, 75, 140, 101, 80, 150, 67, 22, 185, 164, 23, 185, 194, 195, 119, 105,
    79, 119, 105, 79, 174, 24, 69, 133, 213, 247, 191, 142, 111, 191, 142, 111,
    140, 130, 116, 144, 148, 144, 191, 142, 111, 191, 142, 111, 163, 116, 81,
    174, 129, 92, 98, 95, 167, 141, 137, 223, 122, 116, 218, 109, 90, 128, 119,
    101, 125, 54, 154, 54, 151, 79, 80, 175, 105, 128, 151, 107, 75, 141, 120,
    168, 151, 135, 183, 253, 221, 3, 235, 166, 135, 226, 145, 30, 230, 89, 92,
    104, 86, 84, 128, 128, 128, 181, 62, 59, 146, 81, 68, 66, 84, 109, 251,
    235, 127, 84, 100, 63, 107, 68, 99, 185, 164, 23, 185, 194, 195, 150, 67,
    22, 128, 128, 128, 89, 201, 255, 170, 48, 114, 192, 202, 203, 23, 177, 76,
    186, 168, 84, 200, 246, 254, 191, 142, 111, 43, 40, 84, 68, 68, 76, 142,
    66, 66, 92, 68, 73, 143, 215, 29, 135, 196, 26, 121, 176, 24, 110, 140,
    182, 196, 96, 114, 56, 150, 97, 160, 118, 58, 140, 58, 166, 125, 191, 197,
    190, 150, 92, 93, 127, 255, 182, 175, 130, 182, 175, 130, 27, 197, 109, 96,
    197, 27, 26, 26, 26, 142, 66, 66, 238, 85, 70, 121, 110, 97, 191, 142, 111,
    73, 120, 17, 245, 133, 191, 246, 197, 26, 246, 197, 26, 246, 197, 26, 192,
    192, 192, 191, 142, 111, 191, 142, 111, 191, 142, 111, 191, 142, 111, 144,
    148, 144, 13, 88, 130, 213, 229, 237, 253, 221, 3, 191, 142, 111, 255, 162,
    31, 144, 148, 144, 144, 148, 144, 253, 221, 3, 144, 148, 144, 253, 221, 3,
    191, 142, 111, 229, 212, 73, 141, 98, 77, 191, 142, 111, 144, 148, 144,
    191, 142, 111, 11, 80, 143, 91, 169, 169, 78, 193, 227, 48, 186, 135, 128,
    26, 52, 103, 98, 122, 48, 208, 234, 191, 142, 111, 33, 171, 207, 238, 225,
    218, 181, 172, 190, 238, 225, 218, 107, 92, 108, 92, 68, 73, 11, 80, 143,
    91, 169, 169, 106, 107, 118, 73, 51, 36, 141, 175, 255, 159, 209, 229, 128,
    204, 230, 191, 142, 111, 255, 117, 224, 128, 128, 128, 52, 52, 52, 144,
    148, 144, 231, 53, 56, 166, 187, 153, 253, 114, 114, 213, 203, 204, 144,
    148, 144, 128, 128, 128, 191, 142, 111, 98, 95, 167, 192, 59, 59, 144, 148,
    144, 144, 148, 144, 144, 148, 144, 192, 30, 30, 43, 192, 30, 211, 236, 241,
    211, 236, 241, 220, 50, 50, 128, 26, 52, 190, 171, 94, 128, 133, 184, 239,
    141, 126, 190, 171, 94, 131, 162, 161, 170, 171, 157, 104, 100, 126, 145,
    81, 85, 148, 133, 98, 255, 76, 76, 144, 195, 232, 184, 219, 240, 174, 145,
    214, 218, 182, 204, 115, 173, 229, 129, 125, 93, 62, 82, 114, 132, 157,
    127, 152, 171, 198, 27, 109, 69, 33, 135, 85, 191, 142, 111, 253, 221, 3,
    253, 221, 3, 129, 125, 93, 132, 157, 127, 152, 171, 198, 208, 94, 201, 49,
    134, 114, 126, 134, 49, 134, 59, 49, 43, 86, 140, 121, 49, 134, 29, 106,
    88, 99, 99, 99, 99, 99, 99, 99, 99, 99, 73, 120, 17, 223, 255, 255, 182,
    175, 130, 151, 107, 75, 26, 196, 84, 56, 121, 255, 157, 157, 107, 134, 22,
    34, 147, 144, 178, 97, 200, 225, 62, 61, 52, 208, 80, 80, 216, 152, 144,
    203, 61, 64, 213, 178, 28, 128, 44, 45, 125, 55, 65, 186, 50, 52, 124, 175,
    201, 144, 148, 144, 88, 105, 118, 144, 148, 144, 192, 59, 59, 191, 233,
    115, 144, 148, 144, 137, 120, 67, 103, 103, 103, 254, 121, 2, 191, 142,
    111, 144, 148, 144, 144, 148, 144, 144, 148, 144, 144, 148, 144, 239, 90,
    50, 231, 96, 228, 57, 85, 101, 107, 132, 139, 227, 125, 22, 141, 56, 0, 74,
    197, 155, 144, 148, 144, 255, 156, 12, 131, 79, 13, 224, 194, 101, 145, 81,
    85, 107, 182, 29, 53, 44, 41, 214, 184, 46, 149, 232, 87, 255, 241, 51,
    225, 128, 206, 224, 194, 101, 120, 85, 60, 77, 74, 72, 99, 50, 30, 198,
    196, 170, 200, 245, 253, 99, 50, 30, 99, 50, 30, 140, 150, 150, 219, 71,
    38, 235, 38, 231, 86, 85, 92, 235, 150, 23, 153, 131, 44, 57, 48, 97, 248,
    158, 92, 107, 49, 154, 154, 148, 49, 49, 49, 154, 49, 154, 68, 154, 49, 77,
    85, 89, 118, 154, 83, 49, 221, 79, 255, 250, 255, 79, 79, 102, 255, 79,
    255, 89, 255, 79, 79, 240, 240, 247, 255, 145, 79, 191, 142, 111, 187, 255,
    107, 107, 250, 255, 121, 119, 101, 128, 128, 128, 190, 171, 94, 122, 217,
    232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217,
    232, 122, 217, 232, 122, 217, 232, 128, 128, 128, 150, 67, 22, 122, 217,
    232, 122, 217, 232, 79, 128, 17, 122, 217, 232, 122, 217, 232, 122, 217,
    232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217,
    232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 144, 148,
    144, 144, 148, 144, 144, 148, 144, 144, 148, 144, 144, 148, 144, 144, 148,
    144, 144, 148, 144, 144, 148, 144, 144, 148, 144, 122, 217, 232, 122, 217,
    232, 117, 61, 25, 204, 93, 73, 87, 150, 154, 181, 164, 125, 235, 114, 80,
    157, 176, 226, 118, 227, 129, 227, 118, 215, 96, 68, 48, 203, 185, 151, 96,
    77, 64, 198, 170, 104, 182, 141, 86, 228, 213, 173, 129, 125, 93, 9, 61,
    191, 253, 32, 3, 200, 246, 254, 15, 15, 15, 226, 118, 76, 161, 172, 173,
    204, 181, 72, 190, 190, 178, 191, 142, 111, 217, 174, 137, 253, 62, 3, 144,
    148, 144, 85, 255, 160, 122, 217, 232, 96, 248, 2, 105, 74, 202, 29, 240,
    255, 254, 202, 80, 131, 252, 245, 255, 156, 12, 149, 212, 89, 236, 74, 79,
    44, 26, 233, 144, 148, 144, 55, 97, 155, 31, 31, 31, 238, 97, 94, 28, 216,
    94, 141, 107, 89, 141, 107, 89, 233, 203, 24, 168, 178, 204, 122, 217, 232,
    122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232,
    122, 217, 232, 146, 136, 205, 223, 232, 233, 168, 178, 204, 50, 46, 104,
    50, 46, 104, 127, 116, 194, 249, 101, 189, 252, 128, 201, 9, 61, 191, 253,
    32, 3, 255, 156, 12, 160, 120, 92, 191, 142, 111, 160, 120, 100, 251, 209,
    240, 191, 142, 111, 254, 121, 2, 28, 216, 94, 221, 136, 144, 131, 206, 12,
    87, 21, 144, 127, 92, 69, 127, 92, 69, 127, 92, 69, 127, 92, 69, 253, 32,
    3, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 191, 142,
    111, 198, 124, 78, 212, 192, 100, 100, 82, 126, 77, 76, 66, 96, 68, 117,
    68, 60, 51, 174, 168, 186, 205, 152, 186, 212, 148, 88, 140, 140, 140, 120,
    120, 120, 255, 227, 132, 85, 83, 82, 85, 83, 82, 75, 139, 166, 227, 46, 46,
    75, 139, 166, 122, 217, 232, 122, 217, 232, 249, 75, 7, 0, 160, 170, 160,
    87, 234, 22, 173, 254, 88, 95, 114, 99, 255, 107, 65, 75, 90, 65, 75, 90,
    245, 197, 1, 146, 155, 187, 146, 155, 187, 168, 38, 47, 183, 53, 62, 255,
    255, 255, 220, 220, 220, 39, 168, 96, 39, 94, 168, 242, 221, 100, 224, 100,
    242, 197, 193, 216, 54, 183, 111, 54, 109, 183, 255, 236, 115, 239, 115,
    255, 212, 208, 231, 238, 51, 53, 174, 129, 92, 3, 144, 201, 144, 148, 144,
    191, 176, 124, 240, 240, 240, 255, 66, 152, 179, 132, 255, 0, 206, 180, 91,
    186, 240, 92, 240, 91, 240, 91, 147, 255, 150, 181, 179, 132, 255, 174, 16,
    176, 48, 225, 110, 179, 132, 255, 150, 164, 206, 211, 198, 111, 190, 223,
    232, 141, 163, 181, 212, 192, 100, 231, 178, 28, 155, 214, 240, 233, 183,
    128, 51, 84, 195, 205, 153, 73, 129, 56, 121, 129, 56, 121, 191, 142, 111,
    191, 142, 111, 191, 142, 111, 190, 160, 140, 85, 114, 123, 116, 94, 97,
    191, 142, 111, 160, 160, 160, 28, 216, 94, 108, 34, 35, 178, 114, 68, 120,
    50, 50, 66, 84, 109, 84, 100, 63, 107, 68, 99, 73, 120, 17, 198, 134, 88,
    191, 142, 111, 191, 142, 111, 127, 92, 69, 255, 29, 136, 211, 211, 211, 60,
    20, 160, 78, 193, 227, 250, 249, 252, 224, 219, 236, 253, 227, 215, 165,
    159, 153, 191, 142, 111, 202, 174, 165, 160, 187, 142, 254, 158, 35, 34,
    221, 151, 249, 170, 236, 35, 200, 254, 92, 75, 118, 122, 217, 232, 61, 61,
    61, 5, 5, 5, 5, 5, 5, 50, 50, 60, 191, 142, 111, 187, 68, 74, 49, 134, 114,
    126, 134, 49, 134, 59, 49, 43, 86, 140, 121, 49, 134, 254, 121, 2, 26, 196,
    84, 28, 216, 109, 224, 219, 236, 122, 217, 232, 122, 217, 232, 122, 217,
    232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 182, 175,
    130, 99, 150, 8, 107, 182, 0, 144, 148, 144, 122, 217, 232, 122, 217, 232,
    114, 254, 2, 114, 254, 2, 0, 197, 208, 0, 197, 208, 122, 217, 232, 208, 0,
    126, 208, 0, 126, 50, 107, 197, 122, 217, 232, 122, 217, 232, 122, 217,
    232, 255, 126, 145, 60, 60, 60, 120, 110, 100, 120, 110, 100, 54, 83, 20,
    122, 217, 232, 122, 217, 232, 186, 168, 84, 122, 217, 232, 122, 217, 232,
    122, 217, 232, 122, 217, 232, 60, 60, 60, 122, 217, 232, 122, 217, 232,
    150, 67, 22, 148, 158, 184, 165, 168, 26, 165, 168, 26, 87, 127, 220, 99,
    99, 99, 233, 180, 90, 144, 148, 144, 248, 203, 233, 203, 248, 218, 160,
    242, 255, 165, 168, 26, 255, 186, 212, 191, 142, 111, 76, 57, 44, 125, 61,
    65, 30, 26, 84, 178, 104, 58, 172, 155, 110, 99, 99, 99, 122, 217, 232,
    255, 150, 150, 122, 217, 232, 127, 127, 127, 127, 127, 127, 127, 127, 127,
    127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
    114, 81, 56, 254, 121, 2, 119, 105, 79, 119, 105, 79, 151, 107, 75, 151,
    107, 75, 28, 216, 94, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122,
    217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122,
    217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122, 217, 232, 122,
    217, 232, 122, 217, 232, 250, 100, 50, 250, 100, 50, 151, 107, 75, 151,
    107, 75, 233, 207, 94, 128, 128, 128, 122, 217, 232, 122, 217, 232, 250,
    250, 250, 235, 235, 249, 220, 210, 245, 210, 91, 77, 220, 12, 237, 220, 12,
    237, 255, 76, 76, 255, 76, 76, 122, 217, 232, 117, 145, 73, 122, 234, 225,
    122, 217, 232, 210, 140, 100, 145, 120, 120, 145, 120, 120, 122, 116, 218,
    200, 120, 75, 200, 120, 75, 110, 105, 255, 122, 217, 232, 235, 125, 150,
    149, 212, 89, 122, 217, 232, 122, 217, 232, 122, 217, 232, 108, 133, 140,
    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 107, 182, 29, 107, 182, 29,
    151, 79, 80, 200, 44, 28, 225, 128, 206, 21, 124, 212, 35, 205, 215, 200,
    105, 230, 247, 228, 254, 255, 150, 150, 141, 137, 223, 208, 80, 80, 24,
    203, 233, 128, 128, 128, 174, 24, 69, 115, 60, 40, 247, 228, 254, 151, 107,
    75, 83, 46, 57, 91, 87, 167, 23, 33, 81, 53, 133, 103, 11, 67, 80, 40, 49,
    60, 21, 13, 77, 195, 201, 215, 66, 84, 109, 84, 100, 63, 107, 68, 99, 185,
    164, 23, 185, 194, 195, 150, 67, 22, 100, 90, 190, 142, 66, 66, 11, 80,
    143, 91, 169, 169, 254, 121, 2, 208, 0, 126, 114, 254, 2, 0, 197, 208, 220,
    12, 237, 255, 76, 76
};

uint8_t wallColors[] = {
    0, 0, 0, 52, 52, 52, 88, 61, 46, 61, 58, 78, 73, 51, 36, 52, 52, 52, 91,
    30, 30, 27, 31, 42, 31, 39, 26, 41, 28, 36, 74, 62, 12, 46, 56, 59, 75, 32,
    11, 67, 37, 37, 15, 15, 15, 52, 43, 45, 88, 61, 46, 27, 31, 42, 31, 39, 26,
    41, 28, 36, 15, 15, 15, 54, 89, 98, 113, 99, 99, 38, 38, 43, 53, 39, 41,
    11, 35, 62, 21, 63, 70, 88, 61, 46, 81, 84, 101, 88, 23, 23, 28, 88, 23,
    78, 87, 99, 86, 17, 40, 49, 47, 83, 69, 67, 41, 51, 51, 70, 87, 59, 55, 69,
    67, 41, 49, 57, 49, 78, 79, 73, 85, 102, 103, 52, 50, 62, 71, 42, 44, 73,
    66, 50, 52, 52, 52, 60, 59, 51, 48, 57, 47, 71, 77, 85, 52, 52, 52, 52, 52,
    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 40, 56, 50, 49, 48, 36,
    43, 33, 32, 31, 40, 49, 48, 35, 52, 88, 61, 46, 1, 52, 20, 55, 39, 26, 39,
    33, 26, 30, 80, 48, 53, 80, 30, 30, 80, 48, 30, 80, 48, 53, 80, 30, 30, 80,
    48, 43, 42, 68, 30, 70, 80, 78, 105, 135, 52, 84, 12, 190, 204, 223, 64,
    62, 80, 65, 65, 35, 20, 46, 104, 61, 13, 16, 63, 39, 26, 51, 47, 96, 64,
    62, 80, 101, 51, 51, 77, 64, 34, 62, 38, 41, 48, 78, 93, 54, 63, 69, 138,
    73, 38, 50, 15, 8, 115, 68, 124, 129, 114, 74, 62, 86, 123, 90, 121, 94,
    135, 62, 61, 100, 96, 103, 32, 40, 45, 44, 41, 50, 72, 50, 77, 78, 50, 69,
    36, 45, 44, 38, 49, 50, 32, 40, 45, 44, 41, 50, 72, 50, 77, 78, 50, 69, 36,
    45, 44, 38, 49, 50, 97, 72, 51, 53, 53, 53, 138, 73, 38, 94, 25, 17, 125,
    36, 122, 51, 35, 27, 50, 15, 8, 135, 58, 0, 65, 52, 15, 39, 42, 51, 89, 26,
    27, 126, 123, 115, 8, 50, 19, 95, 21, 24, 17, 31, 65, 192, 173, 143, 114,
    114, 131, 136, 119, 7, 8, 72, 3, 117, 132, 82, 100, 102, 114, 30, 118, 226,
    93, 6, 102, 64, 40, 169, 39, 34, 180, 87, 94, 125, 6, 6, 6, 69, 72, 186,
    130, 62, 16, 22, 123, 163, 40, 86, 151, 183, 75, 15, 83, 80, 100, 115, 65,
    68, 119, 108, 81, 59, 67, 71, 222, 216, 202, 90, 112, 105, 62, 28, 87, 120,
    120, 120, 120, 59, 19, 59, 59, 59, 229, 218, 161, 73, 59, 50, 81, 69, 62,
    102, 75, 34, 103, 76, 36, 255, 145, 79, 221, 79, 255, 240, 240, 247, 79,
    255, 89, 154, 83, 49, 107, 49, 154, 85, 89, 118, 49, 154, 68, 154, 49, 77,
    49, 49, 154, 154, 148, 49, 255, 79, 79, 79, 102, 255, 250, 255, 79, 70, 68,
    51, 84, 97, 84, 5, 5, 5, 59, 39, 22, 59, 39, 22, 163, 96, 0, 94, 163, 46,
    117, 32, 59, 20, 11, 203, 74, 69, 88, 60, 30, 30, 111, 117, 135, 111, 117,
    135, 25, 23, 54, 25, 23, 54, 74, 71, 129, 111, 117, 135, 25, 23, 54, 52,
    52, 52, 38, 9, 66, 149, 80, 51, 82, 63, 80, 65, 61, 77, 64, 65, 92, 76, 53,
    84, 144, 67, 52, 149, 48, 48, 111, 32, 36, 147, 48, 55, 97, 67, 51, 112,
    80, 62, 88, 61, 46, 127, 94, 76, 143, 50, 123, 136, 120, 131, 219, 92, 143,
    113, 64, 150, 74, 67, 60, 60, 78, 59, 0, 54, 21, 74, 97, 72, 40, 37, 35,
    77, 63, 66, 111, 6, 6, 88, 67, 59, 88, 87, 80, 71, 71, 67, 76, 52, 60, 89,
    48, 59, 158, 100, 64, 62, 45, 75, 57, 14, 12, 96, 72, 133, 67, 55, 80, 64,
    37, 29, 70, 51, 91, 51, 18, 4, 57, 55, 52, 68, 68, 68, 148, 138, 74, 95,
    137, 191, 160, 2, 75, 100, 55, 164, 0, 117, 101, 110, 90, 78, 47, 69, 75,
    91, 67, 70, 60, 36, 39, 140, 75, 48, 127, 49, 44, 200, 44, 18, 24, 93, 66,
    160, 87, 234, 6, 106, 255, 146, 95, 53, 5, 5, 5, 5, 5, 5, 63, 39, 26, 102,
    102, 102, 61, 58, 78, 52, 43, 45, 81, 84, 101, 85, 102, 103, 52, 52, 52,
    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 40, 56, 50, 49,
    48, 36, 43, 33, 32, 31, 40, 49, 48, 35, 52, 88, 61, 46, 55, 39, 26, 39, 33,
    26, 43, 42, 68, 30, 70, 80, 78, 105, 135, 51, 47, 96, 101, 51, 51, 62, 38,
    41, 59, 39, 22, 59, 39, 22, 111, 117, 135, 25, 23, 54, 52, 52, 52, 149, 80,
    51, 82, 63, 80, 65, 61, 77, 64, 65, 92, 76, 53, 84, 144, 67, 52, 149, 48,
    48, 111, 32, 36, 147, 48, 55, 97, 67, 51, 112, 80, 62, 88, 61, 46, 127, 94,
    76, 143, 50, 123, 136, 120, 131, 219, 92, 143, 113, 64, 150, 74, 67, 60,
    60, 78, 59, 0, 54, 21, 74, 97, 72, 40, 37, 35, 77, 63, 66, 111, 6, 6, 88,
    67, 59, 88, 87, 80, 71, 71, 67, 76, 52, 60, 89, 48, 59, 158, 100, 64, 62,
    45, 75, 57, 14, 12, 96, 72, 133, 67, 55, 80, 64, 37, 29, 70, 51, 91, 51,
    18, 4, 78, 110, 51, 78, 110, 51, 52, 52, 52, 181, 230, 29, 125, 100, 100,
    125, 100, 100, 6, 6, 34, 105, 51, 108, 75, 30, 15, 91, 108, 130, 91, 108,
    130, 55, 25, 33, 60, 55, 145, 10, 5, 50, 30, 105, 75, 5, 45, 55, 20, 25,
    35, 15, 10, 50, 153, 164, 187, 27, 31, 42, 31, 39, 26, 41, 28, 36, 74, 62,
    12, 46, 56, 59, 75, 32, 11, 15, 15, 15, 67, 37, 37, 11, 35, 62, 21, 63, 70,
    100, 40, 1, 92, 30, 72, 42, 81, 1, 1, 81, 109, 56, 22, 97, 52, 52, 52
};

uint8_t paintColors[] = {
    0, 0, 0, 255, 0, 0, 255, 127, 0, 255, 255, 0, 127, 255, 0, 0, 255, 0, 0,
    255, 127, 0, 255, 255, 0, 127, 255, 0, 0, 255, 127, 0, 255, 255, 0, 255,
    255, 0, 127, 255, 0, 0, 255, 127, 0, 255, 255, 0, 127, 255, 0, 0, 255, 0,
    0, 255, 127, 0, 255, 255, 0, 127, 255, 0, 0, 255, 127, 0, 255, 255, 0, 255,
    255, 0, 127, 75, 75, 75, 255, 255, 255, 175, 175, 175, 255, 178, 125, 25,
    25, 25, 255, 255, 255, 255, 255, 255
};
// clang-format on

uint8_t waterColor[] = {0, 12, 255};
uint8_t lavaColor[] = {255, 30, 0};
uint8_t honeyColor[] = {255, 172, 0};
uint8_t shimmerColor[] = {155, 112, 233};

uint8_t surfaceColor[] = {155, 209, 255};
uint8_t undergroundColor[] = {84, 57, 42};
uint8_t cavernColor[] = {72, 64, 57};
uint8_t underworldColor[] = {51, 0, 0};

uint8_t colorBuffer[] = {0, 0, 0};
} // namespace

const uint8_t *getRawTileColor(int x, int y, World &world)
{
    Tile &tile = world.getTile(x, y);
    if (tile.blockID != TileID::empty && !tile.echoCoatBlock) {
        return tileColors + 3 * tile.blockID;
    }
    switch (tile.liquid) {
    case Liquid::water:
        return waterColor;
    case Liquid::lava:
        return lavaColor;
    case Liquid::honey:
        return honeyColor;
    case Liquid::shimmer:
        return shimmerColor;
    default:
        break;
    }
    if (tile.wallID != WallID::empty && !tile.echoCoatWall) {
        return wallColors + 3 * tile.wallID;
    }
    if (y < world.getUndergroundLevel()) {
        return surfaceColor;
    } else if (y < world.getCavernLevel()) {
        return undergroundColor;
    } else if (y < world.getUnderworldLevel()) {
        return cavernColor;
    } else {
        return underworldColor;
    }
}

void blendColor(uint8_t r, uint8_t g, uint8_t b)
{
    colorBuffer[0] = 0.7 * colorBuffer[0] + 0.3 * r;
    colorBuffer[1] = 0.7 * colorBuffer[1] + 0.3 * g;
    colorBuffer[2] = 0.7 * colorBuffer[1] + 0.3 * b;
}

void applyPaint(int paint)
{
    if (paint == Paint::none) {
        return;
    }
    const uint8_t *color = paintColors + 3 * paint;
    blendColor(color[0], color[1], color[2]);
}

const uint8_t *getTileColor(int x, int y, World &world)
{
    std::memcpy(colorBuffer, getRawTileColor(x, y, world), 3);
    Tile &tile = world.getTile(x, y);
    if (tile.blockID != TileID::empty && !tile.echoCoatBlock) {
        applyPaint(tile.blockPaint);
    } else if (
        tile.liquid == Liquid::none && tile.wallID != WallID::empty &&
        !tile.echoCoatWall) {
        applyPaint(tile.wallPaint);
    }
    if (tile.actuated && !tile.echoCoatBlock) {
        blendColor(0, 0, 0);
    }
    if (tile.wireRed) {
        blendColor(255, 0, 0);
    }
    if (tile.wireBlue) {
        blendColor(0, 0, 255);
    }
    if (tile.wireGreen) {
        blendColor(0, 255, 0);
    }
    if (tile.wireYellow) {
        blendColor(255, 255, 0);
    }
    return colorBuffer;
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/map/TileColor.h`
```
#ifndef TILECOLOR_H
#define TILECOLOR_H

#include <cstdint>

class World;

const uint8_t *getTileColor(int x, int y, World &world);

#endif // TILECOLOR_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/structures`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/BuriedBoat.cpp`
```
#include "structures/BuriedBoat.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/data/Boats.h"
#include "vendor/frozen/set.h"
#include <iostream>

Point selectBoatLocation(int width, int height, Random &rnd, World &world)
{
    int minX = world.conf.biomes == BiomeLayout::columns
                   ? world.snowCenter -
                         world.conf.snowSize * 0.06 * world.getWidth() - width
                   : 350;
    int maxX =
        world.conf.biomes == BiomeLayout::columns
            ? world.snowCenter + world.conf.snowSize * 0.06 * world.getWidth()
            : world.getWidth() - width - 350;
    int minY = world.conf.dontDigUp ? world.getUndergroundLevel() + height
                                    : world.getCavernLevel();
    int maxY =
        world.conf.dontDigUp
            ? world.getCavernLevel()
            : (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3 -
                  height;
    constexpr auto avoidBlocks = frozen::make_set<int>({
        TileID::aetherium,
        TileID::blueBrick,
        TileID::corruptIce,
        TileID::crimsonIce,
        TileID::dirt,
        TileID::granite,
        TileID::greenBrick,
        TileID::hive,
        TileID::lihzahrdBrick,
        TileID::marble,
        TileID::mushroomGrass,
        TileID::pinkBrick,
        TileID::stone,
    });
    int biomeScan = std::max(width, height) / 2;
    for (int tries = 0; tries < 8000; ++tries) {
        int x = rnd.getInt(minX, maxX);
        int y = rnd.getInt(minY, maxY);
        int maxEmpty = 0.7 * width * height;
        if ((world.conf.biomes == BiomeLayout::columns || isInBiome(
                                                              x + biomeScan,
                                                              y + biomeScan,
                                                              biomeScan,
                                                              Biome::snow,
                                                              world)) &&
            world.regionPasses(
                x,
                y,
                width,
                height,
                [&avoidBlocks, &maxEmpty](Tile &tile) {
                    if (tile.blockID == TileID::empty) {
                        --maxEmpty;
                    }
                    return !avoidBlocks.contains(tile.blockID) && maxEmpty > 0;
                })) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void genBuriedBoat(Random &rnd, World &world)
{
    std::cout << "Misplacing explorers\n";
    rnd.shuffleNoise();
    TileBuffer boat = Data::getBoat(Data::Boat::frozen, world.getFramedTiles());
    auto [x, y] =
        selectBoatLocation(boat.getWidth(), boat.getHeight(), rnd, world);
    if (x == -1) {
        return;
    }
    constexpr auto clearableTiles = frozen::make_set<int>(
        {TileID::borealWood,
         TileID::richMahogany,
         TileID::richMahoganyBeam,
         TileID::rope});
    for (int i = 0; i < boat.getWidth(); ++i) {
        for (int j = 0; j < boat.getHeight(); ++j) {
            Tile &boatTile = boat.getTile(i, j);
            if (boatTile.blockID == TileID::empty &&
                boatTile.wallID == WallID::empty) {
                continue;
            }
            Tile &tile = world.getTile(x + i, y + j);
            if (std::abs(rnd.getFineNoise(x + i, y + j)) < 0.11) {
                if (tile.blockID != TileID::empty &&
                    clearableTiles.contains(boatTile.blockID)) {
                    continue;
                }
                if (boatTile.blockID == TileID::empty) {
                    boatTile.blockID = tile.blockID;
                } else if (tile.wallID != WallID::empty) {
                    boatTile.wallID = tile.wallID;
                    boatTile.wallPaint = tile.wallPaint;
                }
            }
            if (boatTile.blockID == TileID::chest &&
                boatTile.frameX % 36 == 0 && boatTile.frameY == 0) {
                fillFrozenChest(
                    world.registerStorage(x + i, y + j),
                    Depth::cavern,
                    rnd,
                    world);
            }
            if (boatTile.wallID == WallID::empty) {
                boatTile.wallID = tile.wallID;
            }
            tile = boatTile;
            tile.guarded = true;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/BuriedBoat.h`
```
#ifndef BURIEDBOAT_H
#define BURIEDBOAT_H

class World;
class Random;

void genBuriedBoat(Random &rnd, World &world);

#endif // BURIEDBOAT_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/CavernSpawn.cpp`
```
#include "structures/CavernSpawn.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/WallID.h"
#include "vendor/frozen/set.h"
#include <iostream>

Point selectCavernSpawn(Random &rnd, World &world)
{
    int minX = 0.12 * world.getWidth();
    int maxX = world.getWidth() - minX;
    int minY = world.getCavernLevel();
    int maxY = (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    constexpr auto clearableTiles = frozen::make_set<int>(
        {TileID::empty,        TileID::dirt,          TileID::stone,
         TileID::clay,         TileID::mud,           TileID::sand,
         TileID::granite,      TileID::smoothGranite, TileID::marble,
         TileID::smoothMarble, TileID::ironOre,       TileID::leadOre,
         TileID::silverOre,    TileID::tungstenOre,   TileID::goldOre,
         TileID::platinumOre,  TileID::cobaltOre,     TileID::palladiumOre,
         TileID::mythrilOre,   TileID::orichalcumOre, TileID::adamantiteOre,
         TileID::titaniumOre});
    auto isAcceptableTile = [&clearableTiles](Tile &tile) {
        return !tile.guarded && (clearableTiles.contains(tile.blockID) ||
                                 tile.flag == Flag::border);
    };
    for (int tries = 0; tries < 20000; ++tries) {
        int x = rnd.getInt(minX, maxX);
        int y = rnd.getInt(minY, maxY);
        int numFilled = 0;
        int numEmpty = 0;
        if (world.regionPasses(
                x - 20,
                y - 14,
                40,
                15,
                [&numFilled, &isAcceptableTile](Tile &tile) {
                    if (tile.blockID != TileID::empty) {
                        ++numFilled;
                    }
                    return numFilled < 100 && isAcceptableTile(tile);
                }) &&
            world.regionPasses(
                x - 16,
                y + 1,
                32,
                4,
                [&numEmpty, &isAcceptableTile](Tile &tile) {
                    if (tile.blockID == TileID::empty) {
                        ++numEmpty;
                    }
                    return numEmpty < 30 && isAcceptableTile(tile);
                })) {
            return {x, y};
        }
    }
    return {-1, -1};
}

int getNearestWall(Point pos, World &world)
{
    int i = 0;
    int j = 0;
    for (int iter = 0; iter < 225; ++iter) {
        int wallId = world.getTile(pos + Point{i, j}).wallID;
        if (wallId != WallID::empty) {
            return wallId;
        }
        if (std::abs(i) > std::abs(j) || (i == j && i < 0)) {
            j += i < 0 ? 1 : -1;
        } else {
            i += j < 0 ? -1 : 1;
        }
    }
    return WallID::Unsafe::dirt;
}

void genCavernSpawn(Random &rnd, World &world)
{
    std::cout << "Beginning expedition\n";
    Point pos = selectCavernSpawn(rnd, world);
    if (pos.x == -1) {
        return;
    }
    world.spawn = pos;
    for (int i = -15; i < 15; ++i) {
        int maxJ = 1 - std::abs(i) / 5;
        for (int j = -15; j < maxJ; ++j) {
            if (std::hypot(i, j) < 15) {
                world.getTile(pos + Point{i, j}).blockID = TileID::empty;
            }
        }
    }
    if (!world.conf.home) {
        for (Point delta :
             {Point{-11, -4},
              {-8, -8},
              {-5, -10},
              {0, -12},
              {5, -10},
              {8, -8},
              {11, -4}}) {
            Tile &tile = world.getTile(pos + delta);
            tile.blockID = TileID::torch;
            tile.wallID = getNearestWall(pos + delta, world);
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/CavernSpawn.h`
```
#ifndef CAVERNSPAWN_H
#define CAVERNSPAWN_H

class World;
class Random;

void genCavernSpawn(Random &rnd, World &world);

#endif // CAVERNSPAWN_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/DesertTomb.cpp`
```
#include "structures/DesertTomb.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include "structures/data/Buildings.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

Point selectTombLocation(TileBuffer &tomb, Random &rnd, World &world)
{
    constexpr auto clearableTiles = frozen::make_set<int>({
        TileID::empty,       TileID::sand,          TileID::hardenedSand,
        TileID::sandstone,   TileID::desertFossil,  TileID::copperOre,
        TileID::tinOre,      TileID::ironOre,       TileID::leadOre,
        TileID::silverOre,   TileID::tungstenOre,   TileID::goldOre,
        TileID::platinumOre, TileID::cobaltOre,     TileID::palladiumOre,
        TileID::mythrilOre,  TileID::orichalcumOre, TileID::adamantiteOre,
        TileID::titaniumOre,
    });
    int minX = world.conf.biomes == BiomeLayout::columns
                   ? world.desertCenter -
                         world.conf.desertSize * 0.06 * world.getWidth()
                   : 350;
    int maxX = world.conf.biomes == BiomeLayout::columns
                   ? world.desertCenter +
                         world.conf.desertSize * 0.06 * world.getWidth() -
                         tomb.getWidth()
                   : world.getWidth() - 350;
    int minY = world.conf.dontDigUp
                   ? world.getUndergroundLevel() + tomb.getHeight()
                   : world.getCavernLevel();
    int maxY =
        world.conf.dontDigUp
            ? world.getCavernLevel()
            : (world.getCavernLevel() + 4 * world.getUnderworldLevel()) / 5 -
                  tomb.getHeight();
    int maxFoundationEmpty = 0.4 * tomb.getWidth();
    int biomeScan = std::max(tomb.getWidth(), tomb.getHeight()) / 2;
    for (int tries = 0; tries < 8000; ++tries) {
        int x = rnd.getInt(minX, maxX);
        int y = rnd.getInt(minY, maxY);
        int numEmpty = 0;
        int numFilled = 0;
        int maxEntryFilled = tries / 250;
        if ((world.conf.biomes == BiomeLayout::columns || isInBiome(
                                                              x + biomeScan,
                                                              y + biomeScan,
                                                              biomeScan,
                                                              Biome::desert,
                                                              world)) &&
            world.regionPasses(
                x - 3,
                y + tomb.getHeight() - 9,
                4,
                4,
                [maxEntryFilled, &numFilled](Tile &tile) {
                    if (tile.blockID != TileID::empty) {
                        ++numFilled;
                    }
                    return numFilled < maxEntryFilled;
                }) &&
            world.regionPasses(
                x + tomb.getWidth() - 1,
                y + tomb.getHeight() - 9,
                4,
                4,
                [maxEntryFilled, &numFilled](Tile &tile) {
                    if (tile.blockID != TileID::empty) {
                        ++numFilled;
                    }
                    return numFilled < maxEntryFilled;
                }) &&
            world.regionPasses(
                x - 10,
                y - 10,
                tomb.getWidth() + 20,
                tomb.getHeight() + 20,
                [&clearableTiles](Tile &tile) {
                    return !tile.guarded && tile.liquid != Liquid::shimmer &&
                           clearableTiles.contains(tile.blockID);
                }) &&
            world.regionPasses(
                x,
                y + tomb.getHeight() - 2,
                tomb.getWidth(),
                4,
                [maxFoundationEmpty, &numEmpty](Tile &tile) {
                    if (tile.blockID == TileID::empty) {
                        ++numEmpty;
                    }
                    return numEmpty < maxFoundationEmpty;
                })) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void degradeTombWalls(std::vector<Point> &locations, Random &rnd, World &world)
{
    int shuffleX = rnd.getInt(0, world.getWidth());
    int shuffleY = rnd.getInt(0, world.getHeight());
    for (auto [x, y] : locations) {
        if (std::min(
                std::abs(rnd.getFineNoise(2 * x, 2 * y)),
                std::abs(
                    rnd.getFineNoise(shuffleX + 2 * x, shuffleY + 2 * y))) <
            0.09) {
            Tile &tile = world.getTile(x, y);
            tile.wallID = WallID::Unsafe::sandstone;
            tile.wallPaint = Paint::none;
        }
    }
}

void addTombTreasure(std::vector<Point> &locations, Random &rnd, World &world)
{
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    for (auto [x, y] : locations) {
        if (static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) % 9 == 0) {
            if (world.regionPasses(
                    x,
                    y,
                    2,
                    1,
                    [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
                world.regionPasses(x, y + 1, 2, 1, [](Tile &tile) {
                    return tile.blockID == TileID::sandstoneBrick ||
                           tile.blockID == TileID::sandstoneSlab;
                })) {
                world.placeFramedTile(x, y, TileID::smallPile, Variant::gold);
            }
        } else if (
            world.regionPasses(
                x,
                y,
                2,
                2,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
            world.regionPasses(x, y + 2, 2, 1, [](Tile &tile) {
                return tile.blockID == TileID::sandstoneBrick ||
                       tile.blockID == TileID::sandstoneSlab;
            })) {
            world.placeFramedTile(x, y, TileID::pot, Variant::pyramid);
        }
    }
}

void genDesertTomb(Random &rnd, World &world)
{
    std::cout << "Embalming\n";
    TileBuffer tomb = Data::getBuilding(
        rnd.select(
            {Data::Building::desertTomb1,
             Data::Building::desertTomb2,
             Data::Building::desertTomb3,
             Data::Building::desertTomb4}),
        world.getFramedTiles());
    auto [x, y] = selectTombLocation(tomb, rnd, world);
    if (x == -1) {
        return;
    }
    std::vector<Point> locations;
    for (int i = 0; i < tomb.getWidth(); ++i) {
        for (int j = 0; j < tomb.getHeight(); ++j) {
            Tile &tombTile = tomb.getTile(i, j);
            if (tombTile.blockID == TileID::empty &&
                tombTile.wallID == WallID::empty) {
                continue;
            }
            Tile &tile = world.getTile(x + i, y + j);
            if (tombTile.blockID == TileID::sandstoneSlab &&
                fnv1a32pt(x + i, y + j) % 11 == 0) {
                tombTile.blockID = TileID::sandstoneBrick;
            }
            if (tombTile.wallID == WallID::empty) {
                tombTile.wallID = tile.wallID;
            } else if (tombTile.wallPaint != Paint::none) {
                locations.emplace_back(x + i, y + j);
            }
            tile = tombTile;
            tile.guarded = true;
            if (tile.blockID == TileID::chestGroup2 && tile.frameX % 36 == 0 &&
                tile.frameY == 0) {
                fillDesertChest(
                    world.registerStorage(x + i, y + j),
                    Depth::cavern,
                    rnd,
                    world);
            }
        }
    }
    world.placePainting(
        x + 23,
        y + 16,
        rnd.select({Painting::lifeAboveTheSand, Painting::oasis}));
    std::erase_if(locations, [&world](Point &pt) {
        return !world.regionPasses(pt.x - 1, pt.y - 1, 3, 3, [](Tile &tile) {
            return tile.wallPaint != Paint::none ||
                   tile.wallID == WallID::empty;
        });
    });
    degradeTombWalls(locations, rnd, world);
    addTombTreasure(locations, rnd, world);
    world.queuedDeco.emplace_back(
        [x, y, tW = tomb.getWidth(), tH = tomb.getHeight()](
            Random &,
            World &world) {
            for (int i = 4; i < tW - 4; ++i) {
                for (int j = 4; j < tH - 4; ++j) {
                    world.getTile(x + i, y + j).liquid = Liquid::none;
                }
            }
        });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/DesertTomb.h`
```
#ifndef DESERTTOMB_H
#define DESERTTOMB_H

class World;
class Random;

void genDesertTomb(Random &rnd, World &world);

#endif // DESERTTOMB_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Dungeon.cpp`
```
#include "structures/Dungeon.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/ItemID.h"
#include "ids/Paint.h"
#include "ids/Prefix.h"
#include "ids/WallID.h"
#include "map/DiegeticColor.h"
#include "structures/LootRules.h"
#include "structures/Platforms.h"
#include "structures/StructureUtil.h"
#include "structures/data/DungeonRooms.h"
#include "structures/data/Furniture.h"
#include "vendor/frozen/map.h"
#include <algorithm>
#include <iostream>
#include <set>

struct DungeonTheme {
    int brick;
    int crackedBrick;
    int brickWall;
    int slabWall;
    int tiledWall;
    int paint;
    int altPaint;
    Data::Variant furniture;

    void apply(int themeBrick, Random &rnd)
    {
        brick = themeBrick;
        if (themeBrick == TileID::blueBrick) {
            crackedBrick = TileID::crackedBlueBrick;
            brickWall = WallID::Unsafe::blueBrick;
            slabWall = WallID::Unsafe::blueSlab;
            tiledWall = WallID::Unsafe::blueTiled;
            paint = rnd.select(
                {Paint::deepCyan,
                 Paint::deepSkyBlue,
                 Paint::deepBlue,
                 Paint::deepPurple});
            furniture = Data::Variant::blueDungeon;
        } else if (themeBrick == TileID::greenBrick) {
            crackedBrick = TileID::crackedGreenBrick;
            brickWall = WallID::Unsafe::greenBrick;
            slabWall = WallID::Unsafe::greenSlab;
            tiledWall = WallID::Unsafe::greenTiled;
            paint = rnd.select(
                {Paint::deepYellow,
                 Paint::deepLime,
                 Paint::deepGreen,
                 Paint::deepTeal});
            furniture = Data::Variant::greenDungeon;
        } else {
            crackedBrick = TileID::crackedPinkBrick;
            brickWall = WallID::Unsafe::pinkBrick;
            slabWall = WallID::Unsafe::pinkSlab;
            tiledWall = WallID::Unsafe::pinkTiled;
            paint = rnd.select(
                {Paint::deepOrange,
                 Paint::deepRed,
                 Paint::deepPink,
                 Paint::deepViolet});
            furniture = Data::Variant::pinkDungeon;
        }
        altPaint = paint;
    }
};

class Dungeon
{
private:
    Random &rnd;
    World &world;
    int roomSize;
    int hallSize;
    int wallThickness;
    DungeonTheme theme;
    std::vector<Point> requestedDoors;

    Point selectSize(int dungeonCenter)
    {
        double dungeonSize = world.conf.dungeonSize;
        double initialW = rnd.getDouble(0.029, 0.034) * world.getWidth();
        double initialH = rnd.getDouble(0.35, 0.4) * world.getHeight();
        double targetSize = dungeonSize * initialW * initialH;
        int dungeonHeight = std::max(
            std::min(
                (dungeonSize < 1 ? std::lerp(
                                       std::sqrt(dungeonSize),
                                       dungeonSize,
                                       dungeonSize)
                                 : dungeonSize) *
                    initialH,
                0.4 * world.getHeight()),
            2.5 * roomSize);
        int maxWidth =
            std::min(dungeonCenter, world.getWidth() - dungeonCenter) - 100;
        return {
            std::min<int>(targetSize / dungeonHeight, maxWidth),
            dungeonHeight};
    }

    void sortInitialZones(
        int dungeonCenter,
        int dungeonWidth,
        std::vector<Point> &zones)
    {
        int thresholdY = zones.front().y + roomSize;
        auto endItr = zones.begin();
        while (endItr != zones.end() && endItr->y <= thresholdY) {
            ++endItr;
        }
        std::sort(zones.begin(), endItr);
        int thresholdX = dungeonCenter - dungeonWidth / 5;
        endItr = zones.begin();
        while (endItr != zones.end() && endItr->x < thresholdX &&
               endItr->y <= thresholdY) {
            ++endItr;
        }
        if (endItr != zones.begin()) {
            std::reverse(zones.begin(), endItr);
        }
    }

    void drawRect(
        Point topLeft,
        Point bottomRight,
        double skewX,
        double skewY,
        bool filled)
    {
        auto [width, height] = bottomRight - topLeft;
        for (int i = 0; i < width; ++i) {
            for (int j = 0; j < height; ++j) {
                Tile &tile = world.getTile(
                    topLeft.x + i + skewX * j,
                    topLeft.y + j + skewY * i);
                tile.blockPaint = Paint::none;
                if (i < wallThickness || j < wallThickness ||
                    width - i <= wallThickness || height - j <= wallThickness) {
                    if (tile.wallID != theme.brickWall) {
                        tile.blockID = theme.brick;
                    }
                } else {
                    if (filled && (tile.wallID != theme.brickWall ||
                                   tile.blockID == theme.brick ||
                                   tile.blockID == theme.crackedBrick)) {
                        tile.blockID = theme.crackedBrick;
                    } else {
                        tile.blockID = TileID::empty;
                    }
                }
                tile.wallID = theme.brickWall;
                if (tile.liquid == Liquid::water ||
                    tile.liquid == Liquid::lava) {
                    tile.liquid = Liquid::none;
                }
            }
        }
    }

    void findConnectedZones(
        int x,
        int y,
        std::set<Point> &connectedZones,
        const std::set<Point> &allZones)
    {
        if (connectedZones.contains({x, y})) {
            return;
        }
        connectedZones.insert({x, y});
        for (auto [i, j] :
             {Point{-roomSize, 0},
              {roomSize, 0},
              {0, -roomSize},
              {0, roomSize}}) {
            if (allZones.contains({x + i, y + j})) {
                findConnectedZones(x + i, y + j, connectedZones, allZones);
            }
        }
    }

    Point getClosestPoint(int x, int y, const std::set<Point> &points)
    {
        Point closest = *points.begin();
        double minDist = hypot(closest, {x, y});
        for (Point pt : points) {
            double curDist = hypot(pt, {x, y});
            if (curDist < minDist) {
                minDist = curDist;
                closest = pt;
            }
        }
        return closest;
    }

    void makeHallway(Point from, Point to)
    {
        int deltaX = std::abs(to.x - from.x);
        int deltaY = std::abs(to.y - from.y);
        bool filled = std::min(from.y, to.y) > world.getCavernLevel() &&
                      rnd.getInt(0, 4) == 0;
        if (deltaY == 0 && !filled) {
            requestedDoors.emplace_back(
                std::min(from.x, to.x) + 1 + roomSize / 2,
                from.y - hallSize / 2);
            requestedDoors.emplace_back(
                std::max(from.x, to.x) - 2 - roomSize / 2,
                from.y - hallSize / 2);
        }
        if (deltaY > deltaX) {
            if (from.y > to.y) {
                std::swap(from, to);
            }
            drawRect(
                {from.x - hallSize, from.y - hallSize},
                {from.x + hallSize, to.y + hallSize},
                (to.x - from.x) / (2.0 * hallSize + deltaY),
                0,
                filled);
        } else {
            if (from.x > to.x) {
                std::swap(from, to);
            }
            drawRect(
                {from.x - hallSize, from.y - hallSize},
                {to.x + hallSize, from.y + hallSize},
                0,
                (to.y - from.y) / (2.0 * hallSize + deltaX),
                filled);
        }
    }

    void makeMapRoom(std::vector<Point> &zones)
    {
        int minX = world.getWidth();
        int maxX = 0;
        int maxY = 0;
        for (auto [x, y] : zones) {
            minX = std::min(minX, x);
            maxX = std::max(maxX, x);
            maxY = std::max(maxY, y);
        }
        int padded = roomSize + 2 * wallThickness;
        minX += padded / 2;
        maxX -= padded / 2;
        maxY += padded / 2;
        int x =
            minX + roomSize * static_cast<int>(0.2 * (maxX - minX) / roomSize);
        int y = maxY + roomSize;
        drawRect({x, y}, {x + padded, y + padded}, 0, 0, false);
        zones.emplace_back(x + padded / 2, y + padded / 2);
        int scale = 80;
        int mapWidth = world.getWidth() / scale;
        int mapHeight = world.getHeight() / scale;
        x += 2 * roomSize;
        drawRect(
            {x, y},
            {x + mapWidth + 2 * wallThickness,
             y + mapHeight + 2 * wallThickness},
            0,
            0,
            false);
        makeHallway(
            {x - 2 * roomSize + padded / 2, y + padded / 2},
            {x + padded / 2, y + padded / 2});
        x += wallThickness;
        y += wallThickness;
        for (int i = 0; i < mapWidth; ++i) {
            for (int j = 0; j < mapHeight; ++j) {
                world.getTile(x + i, y + j).blockID = theme.brick;
            }
        }
        world.queuedDeco.emplace_back(
            [x, y, mapWidth, mapHeight, scale](Random &rnd, World &world) {
                parallelFor(
                    std::views::iota(0, mapWidth),
                    [x, y, mapHeight, scale, &world](int i) {
                        for (int j = 0; j < mapHeight; ++j) {
                            Tile &tile = world.getTile(x + i, y + j);
                            tile.blockID = getSectorColor(i, j, scale, world);
                            tile.blockPaint = Paint::none;
                            if (tile.blockID == TileID::torch) {
                                tile.frameX = 66;
                                tile.frameY = 286;
                            } else {
                                tile.actuated = true;
                            }
                        }
                    });
                if (world.conf.forTheWorthy) {
                    std::vector<Tile> mapTiles;
                    for (int j = 0; j < mapHeight; ++j) {
                        for (int i = 0; i < mapWidth; ++i) {
                            mapTiles.emplace_back(world.getTile(x + i, y + j));
                        }
                    }
                    int chunk = rnd.getInt(mapWidth * 3, mapWidth * 5);
                    for (size_t start = 0; start < mapTiles.size();
                         start += chunk) {
                        std::shuffle(
                            mapTiles.begin() + start,
                            mapTiles.begin() +
                                std::min(start + chunk, mapTiles.size()),
                            rnd.getPRNG());
                    }
                    for (int i = 0; i < mapWidth; ++i) {
                        for (int j = 0; j < mapHeight; ++j) {
                            if (rnd.getDouble(0, 1) < 0.15) {
                                world.getTile(x + i, y + j) =
                                    mapTiles[mapHeight + j * mapWidth];
                            }
                        }
                    }
                }
            });
    }

    bool isValidPlacementLocation(
        int x,
        int y,
        int width,
        int height,
        bool needsFloor)
    {
        if (needsFloor) {
            for (int i = 0; i < width; ++i) {
                if (world.getTile(x + i, y + 1).blockID != theme.brick) {
                    return false;
                }
            }
        }
        return world
            .regionPasses(x, y + 1 - height, width, height, [this](Tile &tile) {
                return tile.blockID == TileID::empty &&
                       tile.wallID == theme.brickWall &&
                       tile.liquid == Liquid::none;
            });
    }

    Point selectBiomeChestLocation(const std::vector<Point> &zones)
    {
        for (int tries = 0; tries < 1000; ++tries) {
            auto [x, y] = rnd.select(zones);
            x += rnd.getInt(-6, 2);
            y = scanWhileEmpty({x, y}, {0, 1}, world).y;
            if (isValidPlacementLocation(x, y, 6, 5, true)) {
                return {x, y};
            }
        }
        return {-1, -1};
    }

    void addBiomeChests(const std::vector<Point> &zones)
    {
        for (auto [chestType, lampType, platformBlock, dye, item] :
             {std::tuple{
                  Variant::jungle,
                  Variant::dynasty,
                  TileID::mudstoneBrick,
                  ItemID::chlorophyteDye,
                  Item{ItemID::piranhaGun, rnd.select(PrefixSet::ranged), 1}},
              {Variant::corruption,
               Variant::lesion,
               TileID::ebonstoneBrick,
               ItemID::reflectiveObsidianDye,
               {ItemID::scourgeOfTheCorruptor,
                rnd.select(PrefixSet::common),
                1}},
              {Variant::crimson,
               Variant::flesh,
               TileID::crimstoneBrick,
               ItemID::bloodbathDye,
               {ItemID::vampireKnives, rnd.select(PrefixSet::common), 1}},
              {Variant::hallowed,
               Variant::crystal,
               TileID::pearlstoneBrick,
               ItemID::rainbowDye,
               {ItemID::rainbowGun, rnd.select(PrefixSet::magic), 1}},
              {Variant::ice,
               Variant::frozen,
               TileID::iceBrick,
               ItemID::hadesDye,
               {ItemID::staffOfTheFrostHydra, rnd.select(PrefixSet::magic), 1}},
              {Variant::desert,
               Variant::sandstone,
               TileID::sandstoneBrick,
               ItemID::shiftingSandsDye,
               {ItemID::desertTigerStaff, rnd.select(PrefixSet::magic), 1}}}) {
            auto [x, y] = selectBiomeChestLocation(zones);
            if (x == -1) {
                continue;
            }
            for (int i = 0; i < 6; ++i) {
                world.getTile(x + i, y).blockID = platformBlock;
            }
            for (int i = 1; i < 5; ++i) {
                world.getTile(x + i, y - 1).blockID = platformBlock;
            }
            Chest &chest = world.placeChest(x + 2, y - 3, chestType);
            fillDungeonBiomeChest(chest, rnd, world, dye, std::move(item));
            world.placeFramedTile(x, y - 3, TileID::lamp, lampType);
            world.placeFramedTile(x + 5, y - 3, TileID::lamp, lampType);
        }
    }

    Point selectPlatformLocation(const std::vector<Point> &zones)
    {
        for (int tries = 0; tries < 100; ++tries) {
            auto [x, y] = rnd.select(zones);
            if (isValidPlacementLocation(x, y, 1, roomSize, false)) {
                y -= rnd.getInt(4, roomSize - 4);
                return {x, y};
            }
        }
        return {-1, -1};
    }

    void addPlatforms(const std::vector<Point> &zones)
    {
        std::set<int> usedRows;
        int maxPlatforms =
            (world.conf.dungeonSize > 1 ? 0.8 * world.conf.dungeonSize + 0.2
                                        : 1) *
            world.getHeight() / 40;
        for (int i = 0; i < maxPlatforms; ++i) {
            auto [centerX, centerY] = selectPlatformLocation(zones);
            if (centerX == -1 || usedRows.contains(centerY / 7)) {
                continue;
            }
            usedRows.insert(centerY / 7);
            int fromX = centerX - 4;
            int toX = centerX + 4;
            while (isValidPlacementLocation(
                fromX - 2,
                centerY + 5,
                2,
                10,
                false)) {
                fromX -= 2;
            }
            while (isValidPlacementLocation(toX, centerY + 5, 2, 10, false)) {
                toX += 2;
            }
            if (toX - fromX < roomSize) {
                continue;
            }
            auto partitions = rnd.partitionRange(rnd.getInt(2, 4), toX - fromX);
            auto partItr = partitions.begin();
            int drawTile = rnd.select(
                {theme.brick,
                 rnd.getInt(0, 9) == 0 ? theme.crackedBrick : TileID::empty});
            for (int x = fromX; x < toX; ++x) {
                if (partItr != partitions.end() && x - fromX == *partItr) {
                    ++partItr;
                    if (drawTile == theme.brick) {
                        drawTile = rnd.getInt(0, 9) == 0 ? theme.crackedBrick
                                                         : TileID::empty;
                    } else {
                        drawTile = theme.brick;
                    }
                }
                for (int y = centerY; y < centerY + 3; ++y) {
                    world.getTile(x, y).blockID = drawTile;
                }
            }
        }
    }

    void addDoors()
    {
        for (auto [x, y] : requestedDoors) {
            int floor = 0;
            for (int j = 0; j < hallSize + 1; ++j) {
                Tile &tile = world.getTile(x, y + j);
                if (tile.blockID != TileID::empty) {
                    if (tile.blockID == theme.brick) {
                        floor = j;
                    }
                    break;
                }
            }
            for (int j = 0; j < floor; ++j) {
                if (j < floor - 3) {
                    for (int i = -1; i < 2; ++i) {
                        Tile &tile = world.getTile(x + i, y + j);
                        tile.blockID = theme.brick;
                        if (j == floor - 4) {
                            if (i == -1) {
                                tile.slope = Slope::bottomLeft;
                            } else if (i == 1) {
                                tile.slope = Slope::bottomRight;
                            }
                        }
                    }
                } else if (j == floor - 3) {
                    world.placeFramedTile(
                        x,
                        y + j,
                        TileID::door,
                        Variant::dungeon);
                }
            }
        }
    }

    void addShelves(int dungeonCenter, int dungeonWidth)
    {
        rnd.shuffleNoise();
        for (int x = dungeonCenter - dungeonWidth;
             x < dungeonCenter + dungeonWidth + 2 * roomSize;
             ++x) {
            for (int y = world.getUndergroundLevel();
                 y < world.getUnderworldLevel();
                 ++y) {
                if (world.getTile(x, y).blockID != theme.brick ||
                    rnd.getCoarseNoise(x, y) < 0.15 ||
                    rnd.getDouble(0, 1) < 0.8) {
                    continue;
                }
                int shelfStyle;
                switch ((y / 40) % 4) {
                case 0:
                    shelfStyle = Platform::metalShelf;
                    break;
                case 1:
                    shelfStyle = Platform::brassShelf;
                    break;
                case 2:
                    shelfStyle = Platform::woodShelf;
                    break;
                default:
                    shelfStyle = Platform::dungeonShelf;
                    break;
                }
                if (isValidPlacementLocation(x + 1, y + 3, 5, 7, false)) {
                    for (int i = 0; i < 3; ++i) {
                        placePlatform(x + 1 + i, y, shelfStyle, world);
                        placeShelfItem(x + 1 + i, y - 1);
                    }
                } else if (isValidPlacementLocation(
                               x - 5,
                               y + 3,
                               5,
                               7,
                               false)) {
                    for (int i = 0; i < 3; ++i) {
                        placePlatform(x - 3 + i, y, shelfStyle, world);
                        placeShelfItem(x - 3 + i, y - 1);
                    }
                }
            }
        }
    }

    void placeShelfItem(int x, int y)
    {
        switch (rnd.getInt(0, 15)) {
        case 0:
        case 1:
            return;
        case 2:
            world.placeFramedTile(x, y, TileID::bottle, Variant::health);
            return;
        case 3:
            world.placeFramedTile(x, y, TileID::bottle, Variant::mana);
            return;
        case 4:
            world.getTile(x, y).blockID = TileID::waterCandle;
            return;
        }
        Tile &tile = world.getTile(x, y);
        tile.blockID = TileID::book;
        if (rnd.getInt(0, 40) == 0) {
            tile.frameX = 90; // Water Bolt.
        } else {
            tile.frameX = 18 * rnd.getInt(0, 4);
        }
    }

    void addSpikes(const std::vector<Point> &zones)
    {
        std::set<int> attachTiles{theme.brick, theme.crackedBrick};
        for (int numPatches = 0.7 * zones.size(); numPatches > 0;
             --numPatches) {
            Point delta = rnd.select({Point{1, 0}, {-1, 0}, {0, 1}, {0, -1}});
            Point wall = scanWhileEmpty(rnd.select(zones), delta, world);
            Point incr = delta.x == 0 ? Point{1, 0} : Point{0, 1};
            int patchSize = rnd.getInt(0.15 * roomSize, 0.6 * roomSize);
            Point patchIncr{patchSize * incr.x, patchSize * incr.y};
            Point minPos = wall - patchIncr;
            Point maxPos = wall + patchIncr;
            // Scan back for patch start.
            for (; wall > minPos &&
                   attachTiles.contains(world.getTile(wall + delta).blockID);
                 wall -= incr) {
                if (world.getTile(wall).blockID != TileID::empty) {
                    break;
                }
            }
            // Apply spike patch.
            for (wall += incr;
                 wall < maxPos &&
                 attachTiles.contains(world.getTile(wall + delta).blockID);
                 wall += incr) {
                Tile &tile = world.getTile(wall);
                if (tile.blockID != TileID::empty) {
                    break;
                }
                tile.blockID = TileID::spike;
                if ((wall.x + wall.y) % 2 == 0) {
                    Tile &spikeTile = world.getTile(wall - delta);
                    if (spikeTile.blockID == TileID::empty) {
                        spikeTile.blockID = TileID::spike;
                    }
                }
            }
        }
    }

    void addFloatingSpikes(int dungeonCenter, int dungeonWidth)
    {
        int numSpikes =
            dungeonWidth * world.getHeight() / rnd.getInt(10080, 15120);
        std::vector<Point> usedLocations;
        for (int iter = 0; iter < numSpikes; ++iter) {
            auto [x, y] = selectPaintingLocation(
                dungeonCenter,
                dungeonWidth,
                7,
                7,
                40,
                usedLocations);
            if (x == -1) {
                continue;
            }
            usedLocations.emplace_back(x, y);
            x += 3;
            y -= 5;
            bool asCross = rnd.getBool();
            for (int i = 0; i < 5; ++i) {
                for (int j = 0; j < 5; ++j) {
                    if (asCross ? i == 2 || j == 2
                                : std::abs(i - 2) == std::abs(j - 2)) {
                        world.getTile(x + i, y + j).blockID = TileID::spike;
                    }
                }
            }
        }
    }

    void addDartTraps(const std::vector<Point> &locations)
    {
        int numTraps = (world.conf.traps > 1 ? 1 + world.conf.traps / 25
                                             : world.conf.traps) *
                       locations.size() / rnd.getDouble(124.68, 187.03);
        while (numTraps > 0) {
            auto [x, y] = rnd.select(locations);
            if (!isValidPlacementLocation(x, y, 1, 4, true)) {
                continue;
            }
            std::vector<Point> traps;
            for (int j = 0; j < 4; ++j) {
                for (int dir : {-1, 1}) {
                    Point trap = scanWhileEmpty({x, y - j}, {dir, 0}, world);
                    double dist = hypot(trap, {x, y});
                    if (dist > 3 && dist < 40 &&
                        (world.getTile(trap.x, trap.y + 1).blockID ==
                             theme.brick ||
                         world.getTile(trap.x + dir, trap.y).blockID ==
                             theme.brick)) {
                        traps.push_back(trap);
                    }
                }
            }
            if (traps.empty()) {
                continue;
            }
            std::shuffle(traps.begin(), traps.end(), rnd.getPRNG());
            traps.resize(rnd.getInt(1, std::min<int>(traps.size(), 3)));
            for (auto trap : traps) {
                placeWire(trap, {x, y}, Wire::red, world);
                world.placeFramedTile(
                    trap.x,
                    trap.y,
                    TileID::trap,
                    trap.x > x ? Variant::dartLeft : Variant::dartRight);
            }
            Tile &tile = world.getTile(x, y);
            tile.blockID = TileID::pressurePlate;
            tile.frameY = 36;
            --numTraps;
        }
    }

    void addBoulderTraps(int dungeonCenter, int dungeonWidth)
    {
        int numBoulders =
            (world.conf.forTheWorthy ? std::max(15.0, world.conf.traps)
                                     : world.conf.traps) *
            dungeonWidth * world.getHeight() / 2222640;
        if (numBoulders <= 0 ||
            (world.conf.traps < 2 && !world.conf.forTheWorthy)) {
            return;
        }
        std::vector<Point> locations;
        for (int x = dungeonCenter - dungeonWidth;
             x < dungeonCenter + dungeonWidth + 2 * roomSize;
             ++x) {
            for (int y = world.getUndergroundLevel();
                 y < world.getUnderworldLevel();
                 ++y) {
                if (world.regionPasses(x - 2, y, 6, 4, [this](Tile &tile) {
                        return tile.blockID == theme.crackedBrick;
                    })) {
                    locations.emplace_back(x, y);
                }
            }
        }
        std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
        for (auto [x, y] : locations) {
            if (!world.regionPasses(x - 3, y - 4, 8, 10, [this](Tile &tile) {
                    return tile.blockID == theme.crackedBrick ||
                           tile.blockID == theme.brick;
                })) {
                continue;
            }
            world.placeFramedTile(x, y, TileID::bouncyBoulder);
            --numBoulders;
            if (numBoulders <= 0) {
                break;
            }
        }
    }

    void addFunctionalFurniture(int dungeonCenter, int dungeonWidth)
    {
        std::vector<Point> locations;
        for (int x = dungeonCenter - dungeonWidth;
             x < dungeonCenter + dungeonWidth + 2 * roomSize;
             ++x) {
            for (int y = world.getUndergroundLevel();
                 y < world.getUnderworldLevel();
                 ++y) {
                if (isValidPlacementLocation(x, y, 3, 3, true)) {
                    locations.emplace_back(x, y);
                }
            }
        }
        if (locations.empty()) {
            return;
        }
        addDartTraps(locations);
        for (auto [furnitureTile, lanternStyle] :
             {std::pair{TileID::alchemyTable, Variant::alchemy},
              {TileID::bewitchingTable, Variant::oilRagSconce},
              {TileID::boneWelder, Variant::bone}}) {
            int numPlacements = std::round(
                rnd.getDouble(0.5, 3.2) + locations.size() / 2737.56);
            for (int tries = 500 * numPlacements;
                 numPlacements > 0 && tries > 0;
                 --tries) {
                auto [x, y] = rnd.select(locations);
                if (isValidPlacementLocation(x, y, 3, 3, true)) {
                    world.placeFramedTile(x, y - 2, furnitureTile);
                    addLanternsFor(x, y, lanternStyle);
                    --numPlacements;
                }
            }
        }
        int numChests = world.conf.chests * locations.size() / 256.65;
        while (numChests > 0) {
            auto [x, y] = rnd.select(locations);
            if (isValidPlacementLocation(x, y, 2, 3, true)) {
                Chest &chest = world.placeChest(x, y - 1, Variant::goldLocked);
                fillDungeonChest(chest, rnd, world);
                --numChests;
            }
        }
    }

    void addLanternsFor(int x, int y, Variant lanternStyle)
    {
        int ceiling = scanWhileNotSolid({x, y}, {0, -1}, world).y;
        if (y - ceiling > 16 ||
            !world.regionPasses(
                x - 1,
                ceiling,
                5,
                2,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            !world.regionPasses(x - 1, ceiling - 1, 5, 1, [this](Tile &tile) {
                return tile.blockID == theme.brick;
            })) {
            return;
        }
        if (world.regionPasses(x - 1, ceiling + 2, 5, 5, [](Tile &tile) {
                return tile.blockID == TileID::empty;
            })) {
            TileBuffer hangingLantern =
                Data::getChainLantern(lanternStyle, world.getFramedTiles());
            world.placeBuffer(x - 1, ceiling, hangingLantern, Blend::blockOnly);
            world.placeBuffer(x + 3, ceiling, hangingLantern, Blend::blockOnly);
        } else {
            world
                .placeFramedTile(x - 1, ceiling, TileID::lantern, lanternStyle);
            world
                .placeFramedTile(x + 3, ceiling, TileID::lantern, lanternStyle);
        }
    }

    Point selectPaintingLocation(
        int dungeonCenter,
        int dungeonWidth,
        int width,
        int height,
        int radius,
        const std::vector<Point> &usedLocations)
    {
        for (int tries = 0; tries < 500; ++tries) {
            int x = rnd.getInt(
                dungeonCenter - dungeonWidth,
                dungeonCenter + dungeonWidth + 2 * roomSize);
            int y = rnd.getInt(
                world.getUndergroundLevel(),
                world.getUnderworldLevel());
            if (isValidPlacementLocation(x, y, width + 4, height + 4, false) &&
                !isLocationUsed(x, y, radius, usedLocations)) {
                return {x, y};
            }
        }
        return {-1, -1};
    }

    void addPaintings(int dungeonCenter, int dungeonWidth)
    {
        int numPaintings =
            dungeonWidth * world.getHeight() / rnd.getInt(20160, 30240);
        std::array dungeonPaintings{
            Painting::bloodMoonRising,
            Painting::boneWarp,
            Painting::gloryOfTheFire,
            Painting::skellingtonJSkellingsworth,
            Painting::theCursedMan,
            Painting::theGuardiansGaze,
            Painting::theHangedMan,
            Painting::dryadisque,
            Painting::facingTheCerebralMastermind,
            Painting::goblinsPlayingPoker,
            Painting::greatWave,
            Painting::impact,
            Painting::poweredByBirds,
            Painting::somethingEvilIsWatchingYou,
            Painting::sparky,
            Painting::starryNight,
            Painting::theCreationOfTheGuide,
            Painting::theDestroyer,
            Painting::theEyeSeesTheEnd,
            Painting::thePersistencyOfEyes,
            Painting::theScreamer,
            Painting::theTwinsHaveAwoken,
            Painting::trioSuperHeroes,
            Painting::unicornCrossingTheHallows,
        };
        std::shuffle(
            dungeonPaintings.begin(),
            dungeonPaintings.end(),
            rnd.getPRNG());
        std::vector<Point> usedLocations;
        for (int i = 0; i < numPaintings; ++i) {
            Painting curPainting = rnd.pool(dungeonPaintings);
            auto [width, height] = world.getPaintingDims(curPainting);
            auto [x, y] = selectPaintingLocation(
                dungeonCenter,
                dungeonWidth,
                width,
                height,
                40,
                usedLocations);
            if (x != -1) {
                usedLocations.emplace_back(x, y);
                world.placePainting(x + 2, y - height - 1, curPainting);
            }
        }
        numPaintings *= 2;
        for (int i = 0; i < numPaintings; ++i) {
            Painting curPainting =
                rnd.getInt(0, 3) != 0
                    ? rnd.select(
                          {Painting::hangingSkeleton, Painting::wallSkeleton})
                    : rnd.select(
                          {Painting::catacomb1,
                           Painting::catacomb2,
                           Painting::catacomb3,
                           Painting::catacomb4,
                           Painting::catacomb5,
                           Painting::catacomb6,
                           Painting::catacomb7,
                           Painting::catacomb8,
                           Painting::catacomb9});
            auto [width, height] = world.getPaintingDims(curPainting);
            auto [x, y] = selectPaintingLocation(
                dungeonCenter,
                dungeonWidth,
                width,
                height,
                25,
                usedLocations);
            if (x != -1) {
                usedLocations.emplace_back(x, y);
                world.placePainting(x + 2, y - height - 1, curPainting);
            }
        }
    }

    bool canPlaceFurniture(int x, int y, TileBuffer &data)
    {
        for (int i = 0; i < data.getWidth(); ++i) {
            for (int j = 0; j < data.getHeight(); ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.wallID != theme.brickWall) {
                    return false;
                }
                switch (data.getTile(i, j).blockID) {
                case TileID::empty:
                    if (isSolidBlock(tile.blockID)) {
                        return false;
                    }
                    break;
                case TileID::cloud:
                    if (tile.blockID != theme.brick &&
                        tile.blockID != theme.crackedBrick) {
                        return false;
                    }
                    break;
                default:
                    if (tile.blockID != TileID::empty) {
                        return false;
                    }
                    break;
                }
            }
        }
        return true;
    }

    Point selectFurnitureLocation(
        int dungeonCenter,
        int dungeonWidth,
        TileBuffer &data,
        const std::vector<Point> &usedLocations)
    {
        bool anchorTop =
            data.getWidth() > 1 && data.getTile(1, 0).blockID == TileID::cloud;
        bool anchorBot =
            data.getWidth() > 1 &&
            data.getTile(1, data.getHeight() - 1).blockID == TileID::cloud;
        int anchorLeftAt = -1;
        int anchorRightAt = -1;
        for (int j = 1; j < data.getHeight() - 1; ++j) {
            if (data.getTile(0, j).blockID == TileID::cloud) {
                anchorLeftAt = j;
            } else if (
                data.getTile(data.getWidth() - 1, j).blockID == TileID::cloud) {
                anchorRightAt = j;
            }
        }
        for (int tries = 0; tries < 10000; ++tries) {
            int x = rnd.getInt(
                dungeonCenter - dungeonWidth,
                dungeonCenter + dungeonWidth + 2 * roomSize);
            int y = rnd.getInt(
                world.getUndergroundLevel(),
                world.getUnderworldLevel());
            if (world.getTile(x, y).wallID != theme.brickWall) {
                continue;
            }
            if (anchorTop && world.getTile(x + 1, y).blockID == TileID::empty) {
                y = scanWhileNotSolid({x + 1, y}, {0, -1}, world).y - 1;
            } else if (
                anchorBot &&
                world.getTile(x + 1, y + data.getHeight() - 1).blockID ==
                    TileID::empty) {
                y = scanWhileNotSolid(
                        {x + 1, y + data.getHeight() - 1},
                        {0, 1},
                        world)
                        .y -
                    data.getHeight() + 2;
            }
            if (anchorLeftAt != -1 &&
                world.getTile(x, y + anchorLeftAt).blockID == TileID::empty) {
                x = scanWhileNotSolid({x, y + anchorLeftAt}, {-1, 0}, world).x -
                    1;
            } else if (
                anchorRightAt != -1 &&
                world.getTile(x + data.getWidth() - 1, y + anchorRightAt)
                        .blockID == TileID::empty) {
                x = scanWhileNotSolid(
                        {x + data.getWidth() - 1, y + anchorRightAt},
                        {1, 0},
                        world)
                        .x -
                    data.getWidth() + 2;
            }
            if (canPlaceFurniture(x, y, data) &&
                !isLocationUsed(x, y, 12, usedLocations)) {
                return {x, y};
            }
        }
        return {-1, -1};
    }

    void addFurniture(int dungeonCenter, int dungeonWidth)
    {
        double numPlacements =
            dungeonWidth * world.getHeight() / rnd.getInt(4536, 6048);
        std::vector<Point> usedLocations;
        while (numPlacements > 0) {
            TileBuffer data = getFurniture(
                rnd.select(Data::furnitureLayouts),
                theme.furniture,
                world.getFramedTiles());
            auto [x, y] = selectFurnitureLocation(
                dungeonCenter,
                dungeonWidth,
                data,
                usedLocations);
            if (x == -1) {
                numPlacements -= 0.1;
                continue;
            }
            usedLocations.emplace_back(x, y);
            for (auto [chestX, chestY] :
                 world.placeBuffer(x, y, data, Blend::blockOnly)) {
                fillDresser(world.registerStorage(chestX, chestY), rnd);
            }
            --numPlacements;
        }
    }

    void selectEntry(int dungeonCenter)
    {
        int scanDist = 0.1 * world.getWidth();
        world.dungeon = {dungeonCenter, world.getSurfaceLevel(dungeonCenter)};
        int offset = world.dungeon.x < world.getWidth() / 2 ? 23 : -23;
        for (int swapI = 0; swapI < scanDist; ++swapI) {
            int i = swapI / 2;
            if (swapI % 2 == 0) {
                i = -i;
            }
            int surfaceLevel = std::midpoint(
                world.getSurfaceLevel(dungeonCenter + i - 8),
                world.getSurfaceLevel(dungeonCenter + i + 8));
            if (world.regionPasses(
                    dungeonCenter + i + offset - 45,
                    surfaceLevel - 30,
                    90,
                    30,
                    [](Tile &tile) {
                        return tile.blockID != TileID::livingWood &&
                               tile.blockID != TileID::leaf &&
                               tile.blockID != TileID::aetherium &&
                               tile.wallID != WallID::Unsafe::livingWood;
                    })) {
                world.dungeon.x = dungeonCenter + i;
                break;
            }
        }
        std::vector<int> surface;
        for (int i = -30; i < 30; ++i) {
            surface.push_back(
                world.getSurfaceLevel(world.dungeon.x + i + offset));
        }
        std::sort(surface.begin(), surface.end());
        world.dungeon.y = surface[0.15 * surface.size()];
    }

    void makeEntryHallway(Point entry, Point room)
    {
        if (2 * std::abs(entry.x - room.x) < std::abs(entry.y - room.y)) {
            makeHallway(entry, room);
            return;
        }
        Point mid{(2 * entry.x + room.x) / 3, (entry.y + 2 * room.y) / 3};
        Point offset{
            roomSize / 2 + wallThickness,
            roomSize / 2 + wallThickness};
        drawRect(mid - offset, mid + offset, 0, 0, false);
        makeHallway(entry, mid);
        makeHallway(mid, room);
    }

    void makeEntry()
    {
        bool isOnLeft = world.dungeon.x < world.getWidth() / 2;
        TileBuffer entry = Data::getDungeonRoom(
            isOnLeft ? Data::Room::entranceRight : Data::Room::entranceLeft,
            theme.furniture,
            world.getFramedTiles());
        auto [x, y] = world.dungeon;
        int minX = world.getWidth();
        int maxX = 0;
        for (int i = -20; i < 20; ++i) {
            if (world.getTile(x + i, y).blockID == theme.brick) {
                minX = std::min(minX, x + i);
                maxX = std::max(maxX, x + i);
            }
        }
        x = std::midpoint(minX, maxX);
        bool foundAnchor = false;
        for (int i = 0; i < entry.getWidth() && !foundAnchor; ++i) {
            for (int j = 0; j < entry.getHeight(); ++j) {
                Tile &tile = entry.getTile(i, j);
                if (tile.blockID == TileID::cloud &&
                    tile.blockPaint == Paint::purple) {
                    x -= i;
                    y -= j;
                    foundAnchor = true;
                    break;
                }
            }
        }
        for (int i = 0; i < entry.getWidth(); ++i) {
            bool foundSolidTile = false;
            for (int j = 0; j < entry.getHeight(); ++j) {
                Tile &entryTile = entry.getTile(i, j);
                Tile &tile = world.getTile(x + i, y + j);
                if (entryTile.blockID == TileID::cloud) {
                    if (entryTile.blockPaint == Paint::red) {
                        world.dungeon = {x + i, y + j};
                    }
                    if (entryTile.blockPaint == Paint::none) {
                        entryTile.blockID = tile.blockID;
                    } else {
                        entryTile.blockID = TileID::empty;
                        entryTile.blockPaint = Paint::none;
                    }
                }
                if (tile.wallID == theme.brickWall &&
                    tile.blockID == TileID::empty &&
                    entryTile.blockID == theme.brick) {
                    continue;
                }
                double noise = rnd.getFineNoise(x + 2 * i, y + j);
                double threshold = 1.9 * j / entry.getHeight() - 0.56;
                if (noise > threshold + 0.15) {
                    if (entryTile.blockID != TileID::empty &&
                        !world.getFramedTiles()[entryTile.blockID]) {
                        entryTile.blockID = TileID::empty;
                    }
                    entryTile.wallID = WallID::empty;
                } else if (noise > threshold) {
                    if (entryTile.blockID != TileID::empty &&
                        !world.getFramedTiles()[entryTile.blockID]) {
                        entryTile.blockID = TileID::leaf;
                    }
                    if (entryTile.wallID != WallID::empty) {
                        entryTile.wallID = WallID::Safe::livingLeaf;
                    }
                }
                if (entryTile.blockID == TileID::empty &&
                    entryTile.wallID == WallID::empty) {
                    double halfI = 0.5 * entry.getWidth();
                    double halfJ = 0.5 * entry.getHeight();
                    if (j < halfJ &&
                        std::hypot((i - halfI) / halfI, (j - halfJ) / halfJ) >
                            1.1) {
                        continue;
                    }
                }
                int existingTileId = tile.blockID;
                tile = entryTile;
                if (tile.wallID != WallID::empty &&
                    std::abs(rnd.getFineNoise(x + 2 * i, y + 2 * j)) <
                        0.1 - 0.1 * j / entry.getHeight()) {
                    if (shouldPaint()) {
                        tile.wallID = WallID::Safe::mudstoneBrick;
                        tile.wallPaint = selectWallPaintAt(x + i, y + j);
                    } else {
                        tile.wallID = WallID::Unsafe::craggyStone;
                    }
                }
                if (!foundSolidTile && tile.blockID != TileID::empty) {
                    foundSolidTile = true;
                    if (tile.blockID == theme.brick) {
                        tile.slope = rnd.select(
                            {Slope::none,
                             Slope::none,
                             Slope::half,
                             Slope::topRight,
                             Slope::topLeft});
                    }
                }
                if (tile.blockID == TileID::empty &&
                    (existingTileId == TileID::livingWood ||
                     existingTileId == TileID::leaf)) {
                    tile.blockID = existingTileId;
                }
            }
            int maxJ =
                world.conf.shattered ? entry.getHeight() + roomSize + 1 : 100;
            for (int j = entry.getHeight(); j < maxJ; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.wallID == theme.brickWall) {
                    if (j < 50) {
                        continue;
                    } else {
                        break;
                    }
                }
                if (tile.blockID != TileID::empty) {
                    constexpr auto grassMap = frozen::make_map<int, int>(
                        {{TileID::grass, TileID::dirt},
                         {TileID::hallowedGrass, TileID::dirt},
                         {TileID::jungleGrass, TileID::mud}});
                    if (grassMap.contains(tile.blockID)) {
                        tile.blockID = grassMap.at(tile.blockID);
                        Tile &nextTile = world.getTile(x + i, y + j + 1);
                        if (grassMap.contains(nextTile.blockID)) {
                            nextTile.blockID = grassMap.at(nextTile.blockID);
                        }
                    }
                    break;
                }
                tile.blockID = theme.brick;
                tile.wallID = theme.brickWall;
            }
        }
        for (int i = 1; i < entry.getWidth() - 1; ++i) {
            for (int j = 0; j < entry.getHeight(); ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if ((tile.blockID == TileID::dirt ||
                     tile.blockID == TileID::mud) &&
                    world.isExposed(x + i, y + j)) {
                    tile.blockID = tile.blockID == TileID::dirt
                                       ? TileID::grass
                                       : TileID::jungleGrass;
                }
            }
        }
        int delta = isOnLeft ? 1 : -1;
        x += isOnLeft ? entry.getWidth() : -1;
        y += entry.getHeight() - 1;
        int maxJ = world.conf.shattered ? roomSize + 2 : 100;
        for (int i = 0; std::abs(i) < 50; i += delta) {
            int minJ = 2 * std::abs(i);
            if (world.getTile(x + i, y + minJ).blockID != TileID::empty) {
                break;
            }
            for (int j = minJ; j < maxJ; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID != TileID::empty) {
                    if (tile.blockID == TileID::grass) {
                        tile.blockID = TileID::dirt;
                    }
                    break;
                }
                tile.blockID = theme.brick;
                tile.wallID = theme.brickWall;
            }
        }
    }

    void applyWallVariety(const std::vector<Point> &zones)
    {
        size_t zonePortion = zones.size() / 3;
        int roomSpan = roomSize / 2 + wallThickness;
        for (size_t idx = 0; idx < zonePortion; ++idx) {
            auto [x, y] = zones[idx];
            for (int i = -roomSpan; i < roomSpan; ++i) {
                for (int j = -roomSpan; j < roomSpan; ++j) {
                    Tile &tile = world.getTile(x + i, y + j);
                    if (tile.wallID == theme.brickWall) {
                        tile.wallID = theme.slabWall;
                    }
                }
            }
        }
        for (size_t idx = zonePortion; idx < 2 * zonePortion; ++idx) {
            auto [x, y] = zones[idx];
            for (int i = -roomSpan; i < roomSpan; ++i) {
                for (int j = -roomSpan; j < roomSpan; ++j) {
                    Tile &tile = world.getTile(x + i, y + j);
                    if (tile.wallID == theme.brickWall) {
                        tile.wallID = theme.tiledWall;
                    }
                }
            }
        }
    }

    bool shouldPaint()
    {
        return !world.conf.unpainted &&
               (world.conf.doubleTrouble || world.conf.hiveQueen ||
                world.conf.celebration || world.conf.forTheWorthy ||
                world.conf.dontDigUp);
    }

    void applyPaint(int dungeonCenter, int dungeonWidth)
    {
        int maxX = std::max(
            world.dungeon.x + 80,
            dungeonCenter + dungeonWidth + roomSize);
        int yDivide =
            wallThickness +
            (world.conf.dontDigUp
                 ? (4 * world.getUndergroundLevel() + world.getCavernLevel()) /
                       5
                 : (world.getUndergroundLevel() + 4 * world.getCavernLevel()) /
                       5);
        for (int x =
                 std::min(world.dungeon.x - 80, dungeonCenter - dungeonWidth);
             x < maxX;
             ++x) {
            for (int y = world.dungeon.y - 40; y < yDivide; ++y) {
                applyPaintAt(x, y);
            }
        }
        maxX = dungeonCenter + dungeonWidth + 2 * roomSize;
        for (int x = dungeonCenter - dungeonWidth; x < maxX; ++x) {
            for (int y = yDivide; y < world.getHeight(); ++y) {
                applyPaintAt(x, y);
            }
        }
    }

    void applyPaintAt(int x, int y)
    {
        Tile &tile = world.getTile(x, y);
        if (tile.blockID == theme.brick || tile.blockID == theme.crackedBrick) {
            tile.blockPaint = theme.paint;
        }
        if (tile.wallID == theme.brickWall || tile.wallID == theme.slabWall ||
            tile.wallID == theme.tiledWall) {
            tile.wallPaint = selectWallPaintAt(x, y);
            if (tile.blockID == TileID::pressurePlate ||
                tile.blockID == TileID::trap) {
                tile.blockPaint = theme.paint;
            }
        }
    }

    int selectWallPaintAt(int x, int y)
    {
        if (world.conf.hiveQueen) {
            Point centroid = getHexCentroid(x, y, 8);
            if (static_cast<int>(
                    99999 * (1 + rnd.getFineNoise(centroid.x, centroid.y))) %
                    11 <
                4) {
                return theme.altPaint;
            }
        }
        return world.conf.dontDigUp ? theme.altPaint : theme.paint;
    }

public:
    Dungeon(Random &r, World &w)
        : rnd(r), world(w), roomSize(16), hallSize(9), wallThickness(5)
    {
        theme.apply(
            rnd.select(
                {TileID::blueBrick, TileID::greenBrick, TileID::pinkBrick}),
            rnd);
        if (world.conf.hiveQueen) {
            theme.paint = rnd.select(
                {Paint::yellow,
                 Paint::orange,
                 Paint::deepYellow,
                 Paint::deepOrange});
            theme.altPaint = theme.paint;
            while (theme.paint == theme.altPaint) {
                theme.altPaint = rnd.select(
                    {Paint::yellow,
                     Paint::orange,
                     Paint::deepYellow,
                     Paint::deepOrange});
            }
        } else if (!world.conf.forTheWorthy) {
            if (world.conf.dontDigUp) {
                theme.paint =
                    world.isCrimson ? Paint::deepRed : Paint::deepPurple;
                theme.altPaint = Paint::black;
            } else if (world.conf.celebration) {
                theme.paint = rnd.select({Paint::deepPink, Paint::deepViolet});
                theme.altPaint = theme.paint;
            }
        }
    }

    void gen(int dungeonCenter)
    {
        if (world.conf.dontDigUp && world.conf.doubleTrouble &&
            (dungeonCenter < world.getWidth() / 2) !=
                (world.surfaceEvilCenter < world.getWidth() / 2)) {
            theme.paint = theme.paint == Paint::deepPurple ? Paint::deepRed
                                                           : Paint::deepPurple;
        }
        selectEntry(dungeonCenter);
        auto [dungeonWidth, dungeonHeight] = selectSize(dungeonCenter);
        int yMin =
            world.conf.dontDigUp
                ? (4 * world.getUndergroundLevel() + world.getCavernLevel()) / 5
                : (world.getUndergroundLevel() + 4 * world.getCavernLevel()) /
                      5;
        int shuffleX = rnd.getInt(0, world.getWidth());
        int shuffleY = rnd.getInt(0, world.getHeight());
        std::vector<Point> zones;
        for (int y = yMin; y < yMin + dungeonHeight; y += roomSize) {
            for (int x = dungeonCenter - dungeonWidth;
                 x < dungeonCenter + dungeonWidth;
                 x += roomSize) {
                double threshold = std::max(
                    0.09,
                    rnd.getCoarseNoise(x + shuffleX, y + shuffleY));
                if (rnd.getCoarseNoise(1.5 * x, 3 * y) > threshold) {
                    int padded = roomSize + 2 * wallThickness;
                    drawRect({x, y}, {x + padded, y + padded}, 0, 0, false);
                    zones.emplace_back(x + padded / 2, y + padded / 2);
                }
            }
        }
        makeMapRoom(zones);
        std::set<Point> connectedZones;
        std::set<Point> allZones{zones.begin(), zones.end()};
        sortInitialZones(dungeonCenter, dungeonWidth, zones);
        for (auto [x, y] : zones) {
            if (connectedZones.empty()) {
                findConnectedZones(x, y, connectedZones, allZones);
                makeEntryHallway(
                    {world.dungeon.x, world.dungeon.y + hallSize - 3},
                    {x, y});
                continue;
            } else if (connectedZones.contains({x, y})) {
                continue;
            }
            Point closest = getClosestPoint(x, y, connectedZones);
            findConnectedZones(x, y, connectedZones, allZones);
            makeHallway({x, y}, closest);
        }
        for (int x = dungeonCenter - dungeonWidth;
             x < dungeonCenter + dungeonWidth + roomSize;
             x += 4) {
            bool prevWasDungeon = false;
            bool checkedForGround = false;
            for (int y = yMin; y < world.getUnderworldLevel(); ++y) {
                Tile &tile = world.getTile(x, y);
                if (prevWasDungeon && tile.blockID == TileID::empty &&
                    tile.wallID != theme.brickWall) {
                    if (checkedForGround) {
                        tile.blockID = theme.brick;
                        tile.actuated = true;
                    } else if (
                        scanWhileEmpty({x, y}, {0, 1}, world).y - y < 35) {
                        tile.blockID = theme.brick;
                        tile.actuated = true;
                        checkedForGround = true;
                    } else {
                        prevWasDungeon = false;
                    }
                } else if (tile.blockID == theme.brick) {
                    prevWasDungeon = true;
                    checkedForGround = false;
                } else {
                    prevWasDungeon = false;
                }
            }
        }
        addBiomeChests(zones);
        addPlatforms(zones);
        addDoors();
        addShelves(dungeonCenter, dungeonWidth);
        addFunctionalFurniture(dungeonCenter, dungeonWidth);
        addSpikes(zones);
        addBoulderTraps(dungeonCenter, dungeonWidth);
        makeEntry();
        addPaintings(dungeonCenter, dungeonWidth);
        addFurniture(dungeonCenter, dungeonWidth);
        if (world.conf.forTheWorthy) {
            addFloatingSpikes(dungeonCenter, dungeonWidth);
        }
        std::sort(
            zones.begin(),
            zones.end(),
            [this, shuffleX, shuffleY](Point a, Point b) {
                return rnd.getCoarseNoise(a.x + shuffleX, a.y + shuffleY) <
                       rnd.getCoarseNoise(b.x + shuffleX, b.y + shuffleY);
            });
        applyWallVariety(zones);
        if (shouldPaint()) {
            applyPaint(dungeonCenter, dungeonWidth);
        }
    }
};

int computeDungeonCenter(World &world)
{
    std::vector avoidPoints{
        0,
        world.spawn.x,
        world.getWidth(),
        world.surfaceEvilCenter,
        static_cast<int>(world.desertCenter),
        static_cast<int>(world.jungleCenter),
        static_cast<int>(world.snowCenter)};
    std::sort(avoidPoints.begin(), avoidPoints.end());
    int maxSpan = 0;
    int dungeonCenter = world.getWidth() / 4;
    for (size_t i = 0; i + 1 < avoidPoints.size(); ++i) {
        int span = avoidPoints[i + 1] - avoidPoints[i];
        if (span > maxSpan) {
            maxSpan = span;
            dungeonCenter = avoidPoints[i] + span / 2;
        }
    }
    return dungeonCenter;
}

void genDungeon(Random &rnd, World &world)
{
    if (world.conf.dungeonSize < 0.01) {
        return;
    }
    std::cout << "Employing the undead\n";
    rnd.shuffleNoise();
    Dungeon structure(rnd, world);
    structure.gen(computeDungeonCenter(world));
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Dungeon.h`
```
#ifndef DUNGEON_H
#define DUNGEON_H

class World;
class Random;

int computeDungeonCenter(World &world);
void genDungeon(Random &rnd, World &world);

#endif // DUNGEON_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/GlobalEcho.cpp`
```
#include "structures/GlobalEcho.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/WallID.h"
#include <algorithm>
#include <iostream>

void genGlobalEcho(Random &rnd, World &world)
{
    std::cout << "Decaying memories\n";
    rnd.shuffleNoise();
    double fadedMemories = std::clamp(world.conf.fadedMemories, 0.0, 1.0);
    double threshold =
        0.200700427 *
            std::log((fadedMemories + 0.048) / (1.048 - fadedMemories)) -
        0.000403907;
    if (fadedMemories < 0.05) {
        threshold = std::lerp(-1.12, threshold, 20 * fadedMemories);
    } else if (fadedMemories > 0.95) {
        threshold = std::lerp(threshold, 1.12, 20 * fadedMemories - 19);
    }
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [threshold, &rnd, &world](int x) {
            for (int y = 0; y < world.getHeight(); ++y) {
                if (rnd.getCoarseNoise(x, y) > threshold) {
                    continue;
                }
                Tile &tile = world.getTile(x, y);
                if (tile.blockID != TileID::empty) {
                    tile.echoCoatBlock = true;
                    for (int i = -1; i < 2; ++i) {
                        for (int j = -1; j < 2; ++j) {
                            Tile &wallTile = world.getTile(x + i, y + j);
                            if (wallTile.wallID != WallID::empty) {
                                wallTile.echoCoatWall = true;
                            }
                        }
                    }
                } else if (tile.wallID != WallID::empty) {
                    tile.echoCoatWall = true;
                }
            }
        });
    for (int i = -25; i < 25; ++i) {
        for (int j = -25; j < 25; ++j) {
            double dist = std::hypot(i, j);
            if (dist < 25) {
                Tile &tile = world.getTile(world.spawn + Point{i, j});
                tile.echoCoatBlock = false;
                if (dist < 24) {
                    tile.echoCoatWall = false;
                }
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/GlobalEcho.h`
```
#ifndef GLOBALECHO_H
#define GLOBALECHO_H

class World;
class Random;

void genGlobalEcho(Random &rnd, World &world);

#endif // GLOBALECHO_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Lake.cpp`
```
#include "structures/Lake.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/WallID.h"
#include "vendor/frozen/set.h"
#include <iostream>
#include <set>

bool isLiquidPathable(World &world, int x, int y)
{
    Tile &tile = world.getTile(x, y);
    return (tile.blockID == TileID::empty || tile.actuated) &&
           tile.liquid == Liquid::none;
}

template <typename Func>
std::tuple<int, int, int>
followRainFrom(World &world, int x, int y, Func isPathable)
{
    while (true) {
        if (isPathable(world, x, y + 1)) {
            ++y;
            if (y >= world.getHeight()) {
                return {x, x, y};
            }
            continue;
        }
        int flowLeft = x;
        for (; flowLeft > 0; --flowLeft) {
            if (isPathable(world, flowLeft, y + 1) ||
                !isPathable(world, flowLeft - 1, y)) {
                break;
            }
        }
        int flowRight = x;
        for (; flowRight < world.getWidth(); ++flowRight) {
            if (isPathable(world, flowRight, y + 1) ||
                !isPathable(world, flowRight + 1, y)) {
                break;
            }
        }
        if (x - flowLeft > flowRight - x &&
            isPathable(world, flowLeft, y + 1)) {
            x = flowLeft;
            continue;
        }
        if (isPathable(world, flowRight, y + 1)) {
            x = flowRight;
            continue;
        }
        if (isPathable(world, flowLeft, y + 1)) {
            x = flowLeft;
            continue;
        }
        return {flowLeft, flowRight + 1, y};
    }
}

void simulateRain(Random &rnd, World &world, int x)
{
    if (x % 4 != 0) {
        return;
    }
    int lavaLevel =
        (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    constexpr auto surfaceDryBlocks = frozen::make_set<int>(
        {TileID::ebonstone,
         TileID::ebonsand,
         TileID::lesion,
         TileID::corruptGrass,
         TileID::corruptJungleGrass,
         TileID::crimstone,
         TileID::crimsand,
         TileID::flesh,
         TileID::crimsonGrass,
         TileID::crimsonJungleGrass,
         TileID::pearlstone,
         TileID::pearlsand,
         TileID::aetherium,
         TileID::crystalBlock,
         TileID::livingWood,
         TileID::leaf,
         TileID::livingMahogany,
         TileID::mahoganyLeaf,
         TileID::ashGrass,
         TileID::sandstoneBrick,
         TileID::ebonstoneBrick,
         TileID::crimstoneBrick,
         TileID::pearlstoneBrick,
         TileID::blueBrick,
         TileID::greenBrick,
         TileID::pinkBrick});
    std::set<int> dryWalls{
        WallID::Safe::sandstoneBrick,
        WallID::Unsafe::sandstone,
        WallID::Unsafe::hardenedSand,
        WallID::Unsafe::hardenedEbonsand,
        WallID::Unsafe::hardenedCrimsand,
        WallID::Unsafe::hardenedPearlsand,
        WallID::Unsafe::ebonsandstone,
        WallID::Unsafe::crimsandstone,
        WallID::Unsafe::pearlsandstone,
        WallID::Unsafe::spider};
    dryWalls.insert(WallVariants::dungeon.begin(), WallVariants::dungeon.end());
    double pendingWater =
        world.conf.biomes != BiomeLayout::columns ? 0
        : std::abs(x - world.jungleCenter) <
                world.conf.jungleSize * 0.08 * world.getWidth()
            ? 15
            : -4;
    for (int y = world.getSurfaceLevel(x) - 45; y < world.getUnderworldLevel();
         y += 3) {
        if (!isLiquidPathable(world, x, y) ||
            (y < lavaLevel && dryWalls.contains(world.getTile(x, y).wallID))) {
            pendingWater = 2.1;
            continue;
        }
        pendingWater +=
            world.getTile(x, y).wallID == WallID::Unsafe::hive ? 2.4
            : world.conf.biomes != BiomeLayout::columns && y < lavaLevel
                ? 1.2 + rnd.getHumidity(x, y)
                : 1.65;
        if (world.conf.celebration && hypot(world.aether, {x, y}) < 200) {
            pendingWater += 1.5;
        }
        if (pendingWater > 10) {
            pendingWater *= 0.94;
        }
        auto [minDropX, maxDropX, dropY] =
            followRainFrom(world, x, y, isLiquidPathable);
        if (maxDropX - minDropX < pendingWater) {
            pendingWater -= maxDropX - minDropX;
            Tile &probeTile =
                world.getTile((minDropX + maxDropX) / 2, dropY + 1);
            if (probeTile.liquid == Liquid::shimmer ||
                probeTile.blockID == TileID::bubble ||
                (y < world.getUndergroundLevel() &&
                 (surfaceDryBlocks.contains(probeTile.blockID) ||
                  probeTile.liquid == Liquid::lava)) ||
                dropY > world.getUnderworldLevel() + 50 ||
                (world.conf.shattered && dropY < lavaLevel &&
                 dryWalls.contains(probeTile.wallID))) {
                continue;
            }
            if (y < world.getUndergroundLevel() &&
                (surfaceDryBlocks.contains(
                     world.getTile(minDropX - 1, dropY).blockID) ||
                 surfaceDryBlocks.contains(
                     world.getTile(maxDropX, dropY).blockID))) {
                continue;
            }
            for (int dropX = minDropX; dropX < maxDropX; ++dropX) {
                Tile &tile = world.getTile(dropX, dropY);
                tile.liquid = tile.wallID == WallID::Unsafe::hive
                                  ? Liquid::honey
                              : dropY > lavaLevel ? Liquid::lava
                                                  : Liquid::water;
                if (probeTile.blockID == TileID::hive &&
                    tile.liquid != Liquid::honey) {
                    tile.blockID = tile.liquid == Liquid::lava
                                       ? TileID::crispyHoney
                                       : TileID::honey;
                    tile.liquid = Liquid::none;
                }
            }
        }
    }
}

void evaporateSmallPools(World &world, int x)
{
    for (int y = world.getSurfaceLevel(x) - 50; y < world.getUnderworldLevel();
         ++y) {
        Tile &tile = world.getTile(x, y);
        if (tile.liquid != Liquid::water &&
            (tile.liquid != Liquid::lava || y < world.getUndergroundLevel())) {
            continue;
        }
        int poolDepth = std::get<2>(
            followRainFrom(world, x, y, [](World &world, int x, int y) {
                Tile &tile = world.getTile(x, y);
                return tile.liquid == Liquid::water ||
                       tile.liquid == Liquid::lava;
            }));
        if (poolDepth - y < 4 &&
            world.getTile(x, y - 1).blockID == TileID::empty) {
            while (y <= poolDepth) {
                world.getTile(x, y).liquid = Liquid::none;
                ++y;
            }
        } else if (
            poolDepth == y && world.getTile(x - 1, y).liquid == Liquid::none &&
            world.getTile(x + 1, y).liquid == Liquid::none) {
            world.getTile(x, y).liquid = Liquid::none;
        } else {
            if ((tile.wallID == WallID::Unsafe::snow ||
                 tile.wallID == WallID::Unsafe::ice) &&
                tile.liquid == Liquid::water) {
                tile.liquid = Liquid::none;
                tile.blockID = TileID::thinIce;
            }
            y = poolDepth;
        }
    }
}

void fillLavaHotzones(Random &rnd, World &world, int x)
{
    int lavaLevel =
        (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    constexpr auto skipWalls = frozen::make_set<int>({
        WallID::empty,
        WallID::Unsafe::blueBrick,
        WallID::Unsafe::blueSlab,
        WallID::Unsafe::blueTiled,
        WallID::Unsafe::greenBrick,
        WallID::Unsafe::greenSlab,
        WallID::Unsafe::greenTiled,
        WallID::Unsafe::pinkBrick,
        WallID::Unsafe::pinkSlab,
        WallID::Unsafe::pinkTiled,
        WallID::Unsafe::lihzahrdBrick,
    });
    for (int y = world.getSurfaceLevel(x) + 10; y < lavaLevel; ++y) {
        if (world.getBiome(x, y).underworld < 0.99) {
            continue;
        }
        Tile &tile = world.getTile(x, y);
        if (tile.blockID == TileID::empty && !skipWalls.contains(tile.wallID) &&
            tile.liquid != Liquid::shimmer) {
            if (std::abs(rnd.getFineNoise(x, y)) < 0.06) {
                tile.blockID = TileID::obsidian;
            } else {
                tile.liquid = Liquid::lava;
            }
        }
    }
}

void convertLiquid(int startX, int startY, Liquid from, Liquid to, World &world)
{
    std::vector<std::pair<int, int>> locations{{startX, startY}};
    while (!locations.empty()) {
        auto [x, y] = locations.back();
        locations.pop_back();
        Tile &tile = world.getTile(x, y);
        if (tile.liquid == from) {
            tile.liquid = to;
            for (auto [i, j] : {std::pair{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {
                locations.emplace_back(x + i, y + j);
            }
        }
    }
}

void convertExtraLava(Random &rnd, World &world, int x)
{
    int lavaLevel =
        (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    if (x > 350 && x < world.getWidth() - 350) {
        for (int y = 0; y < lavaLevel; ++y) {
            if (world.getTile(x, y).liquid == Liquid::water &&
                rnd.getCoarseNoise(x, y) > 0.13) {
                convertLiquid(x, y, Liquid::water, Liquid::lava, world);
            }
        }
    }
    lavaLevel = std::midpoint(lavaLevel, world.getUnderworldLevel());
    int lavaHeight = world.getHeight() - lavaLevel;
    for (int y = lavaLevel; y < world.getHeight(); ++y) {
        Tile &tile = world.getTile(x, y);
        if (tile.blockID == TileID::ash &&
            static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) %
                    static_cast<int>(17.5 * lavaHeight / (y + 1 - lavaLevel)) ==
                0) {
            tile.blockID = TileID::empty;
            tile.liquid = Liquid::lava;
        }
    }
}

void spreadShimmer(World &world)
{
    int minX = std::max<int>(300, world.aether.x - 0.03 * world.getWidth());
    int maxX = std::min<int>(
        world.getWidth() - 300,
        world.aether.x + 0.03 * world.getWidth());
    int minY = std::max<int>(
        world.getUndergroundLevel(),
        world.aether.y - 0.3 * world.getHeight());
    for (int x = minX; x < maxX; ++x) {
        for (int y = minY; y < world.getUnderworldLevel(); ++y) {
            if (std::abs(y - world.aether.y) < 200 &&
                world.getTile(x, y).liquid == Liquid::lava) {
                convertLiquid(x, y, Liquid::lava, Liquid::shimmer, world);
            } else {
                convertLiquid(x, y, Liquid::water, Liquid::shimmer, world);
            }
        }
    }
    minX = world.oceanCaveCenter < 400 ? world.getWidth() - 200 : 50;
    maxX = minX + 150;
    for (int x = minX; x < maxX; ++x) {
        for (int y = world.getSurfaceLevel(x); y < world.getUndergroundLevel();
             ++y) {
            convertLiquid(x, y, Liquid::water, Liquid::shimmer, world);
        }
    }
}

void convertUndergroundLava(World &world, int x)
{
    if (x < 200 || x > world.getWidth() - 200) {
        return;
    }
    int minY = (5 * world.getUndergroundLevel() + world.getCavernLevel()) / 6;
    int maxY = (world.getUndergroundLevel() + 5 * world.getCavernLevel()) / 6;
    for (int y = minY; y < maxY; ++y) {
        if (world.getTile(x, y).liquid == Liquid::water) {
            convertLiquid(x, y, Liquid::water, Liquid::lava, world);
        }
    }
}

void genLake(Random &rnd, World &world)
{
    std::cout << "Raining\n";
    parallelFor(std::views::iota(0, world.getWidth()), [&rnd, &world](int x) {
        simulateRain(rnd, world, x);
    });
    parallelFor(std::views::iota(0, world.getWidth()), [&world](int x) {
        evaporateSmallPools(world, x);
    });
    if (world.conf.biomes != BiomeLayout::columns) {
        rnd.shuffleNoise();
        parallelFor(
            std::views::iota(0, world.getWidth()),
            [&rnd, &world](int x) { fillLavaHotzones(rnd, world, x); });
    }
    if (world.conf.hiveQueen) {
        rnd.shuffleNoise();
        parallelFor(
            std::views::iota(0, world.getWidth()),
            [&rnd, &world](int x) {
                if (world.oceanCaveCenter < world.getWidth() / 2
                        ? x > 350
                        : x < world.getWidth() - 350) {
                    for (int y = 0; y < world.getUnderworldLevel(); ++y) {
                        if (world.getTile(x, y).liquid == Liquid::water &&
                            rnd.getCoarseNoise(x, y) > 0.13) {
                            convertLiquid(
                                x,
                                y,
                                Liquid::water,
                                Liquid::honey,
                                world);
                        }
                    }
                }
            });
    }
    if (world.conf.forTheWorthy) {
        rnd.shuffleNoise();
        parallelFor(
            std::views::iota(0, world.getWidth()),
            [&rnd, &world](int x) { convertExtraLava(rnd, world, x); });
    }
    if (world.conf.celebration) {
        spreadShimmer(world);
    }
    if (world.conf.dontDigUp) {
        parallelFor(std::views::iota(0, world.getWidth()), [&world](int x) {
            convertUndergroundLava(world, x);
        });
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Lake.h`
```
#ifndef LAKE_H
#define LAKE_H

class Random;
class World;

void genLake(Random &rnd, World &world);

#endif // LAKE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/LootRules.cpp`
```
#include "structures/LootRules.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/ItemID.h"
#include "ids/Prefix.h"

bool fuzzyIsSurfaceChest(int x, int y, World &world)
{
    return y < world.getUndergroundLevel() ||
           (y < (2 * world.getUndergroundLevel() + world.getCavernLevel()) /
                    3 &&
            fnv1a32pt(x, y) % 2 == 0);
}

Depth getChestDepth(int x, int y, World &world)
{
    Depth depth = fuzzyIsSurfaceChest(x, y, world) ? Depth::surface
                  : y < world.getCavernLevel()     ? Depth::underground
                                                   : Depth::cavern;
    if (world.conf.dontDigUp) {
        if (depth == Depth::surface) {
            return Depth::cavern;
        } else if (depth == Depth::cavern) {
            return Depth::surface;
        }
    }
    return depth;
}

int doFillLoot(
    Chest &chest,
    Random &rnd,
    std::initializer_list<std::pair<double, Item>> loot)
{
    int itemIndex = 0;
    for (auto [probability, item] : loot) {
        if (probability > rnd.getDouble(0, 1)) {
            chest.items[itemIndex] = item;
            ++itemIndex;
            if (item.id == ItemID::flareGun) {
                chest.items[itemIndex] = {
                    ItemID::flare,
                    Prefix::none,
                    rnd.getInt(25, 50)};
                ++itemIndex;
            } else if (item.id == ItemID::livingWoodWand) {
                chest.items[itemIndex] = {ItemID::leafWand, Prefix::none, 1};
                ++itemIndex;
            } else if (item.id == ItemID::livingMahoganyWand) {
                chest.items[itemIndex] = {
                    ItemID::richMahoganyLeafWand,
                    Prefix::none,
                    1};
                ++itemIndex;
            } else if (item.id == ItemID::pharaohsMask) {
                chest.items[itemIndex] = {
                    ItemID::pharaohsRobe,
                    Prefix::none,
                    1};
                ++itemIndex;
            } else if (item.id == ItemID::mushroomHat) {
                chest.items[itemIndex] = {
                    ItemID::mushroomVest,
                    Prefix::none,
                    1};
                ++itemIndex;
                chest.items[itemIndex] = {
                    ItemID::mushroomPants,
                    Prefix::none,
                    1};
                ++itemIndex;
            } else if (item.id == ItemID::tuxedoShirt) {
                chest.items[itemIndex] = {ItemID::tuxedoPants, Prefix::none, 1};
                ++itemIndex;
            }
        }
    }
    return itemIndex;
}

void fillLoot(
    Chest &chest,
    Random &rnd,
    std::initializer_list<std::pair<double, Item>> loot)
{
    double expectedValue = 0;
    for (const auto &row : loot) {
        expectedValue += row.first;
    }
    if (expectedValue > 5) {
        expectedValue = 5 + 0.6 * (expectedValue - 5);
    }
    int minLoot = std::floor(0.9 * expectedValue - 0.5);
    while (doFillLoot(chest, rnd, loot) < minLoot) {
    }
}

std::pair<double, Item> getGlobalItemPrimary(Random &rnd, World &world)
{
    if (world.conf.traps > 14) {
        if (world.conf.doubleTrouble) {
            return {
                0.117,
                {rnd.select({ItemID::gasTrap, ItemID::moonLordLegs}),
                 Prefix::none,
                 1}};
        }
        return {0.05, {ItemID::gasTrap, Prefix::none, 1}};
    }
    return {
        world.conf.doubleTrouble ? 1.0 / 15 : 0,
        {ItemID::moonLordLegs, Prefix::none, 1}};
}

std::pair<double, Item> getGlobalItemPotion(World &world)
{
    return {
        world.conf.forTheWorthy    ? 0.1
        : world.conf.doubleTrouble ? 1.0 / 30
                                   : 0,
        {ItemID::redPotion, Prefix::none, 1}};
}

std::pair<double, Item> getCavernBonusItem(int y, Random &rnd, World &world)
{
    if (y < (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3) {
        return {0.05, {ItemID::extractinator, Prefix::none, 1}};
    } else {
        return {0.15, {ItemID::lavaCharm, rnd.select(PrefixSet::accessory), 1}};
    }
}

bool skipPrimaryLoot(Random &rnd, World &world)
{
    return world.conf.forTheWorthy && rnd.getDouble(0, 1) < 0.06;
}

Item getSurfacePrimaryLoot(Random &rnd, World &world)
{
    if (skipPrimaryLoot(rnd, world)) {
        return {ItemID::angelStatue, Prefix::none, 1};
    }
    return rnd.pool<Item>({
        {ItemID::spear, rnd.select(PrefixSet::universal), 1},
        {ItemID::blowpipe, rnd.select(PrefixSet::ranged), 1},
        {ItemID::woodenBoomerang, rnd.select(PrefixSet::universal), 1},
        {ItemID::aglet, rnd.select(PrefixSet::accessory), 1},
        {ItemID::climbingClaws, rnd.select(PrefixSet::accessory), 1},
        {ItemID::umbrella, rnd.select(PrefixSet::melee), 1},
        {ItemID::guideToPlantFiberCordage, rnd.select(PrefixSet::accessory), 1},
        {ItemID::wandOfSparking, rnd.select(PrefixSet::magiclownokb), 1},
        {ItemID::radar, rnd.select(PrefixSet::accessory), 1},
        {ItemID::stepStool, rnd.select(PrefixSet::accessory), 1},
    });
}

Item getUndergroundPrimaryLoot(Random &rnd, World &world)
{
    if (skipPrimaryLoot(rnd, world)) {
        return {ItemID::angelStatue, Prefix::none, 1};
    }
    return rnd.pool<Item>({
        {ItemID::bandOfRegeneration, rnd.select(PrefixSet::accessory), 1},
        {ItemID::magicMirror, Prefix::none, 1},
        {ItemID::cloudInABottle, rnd.select(PrefixSet::accessory), 1},
        {ItemID::hermesBoots, rnd.select(PrefixSet::accessory), 1},
        {ItemID::mace, rnd.select(PrefixSet::universal), 1},
        {ItemID::shoeSpikes, rnd.select(PrefixSet::accessory), 1},
    });
}

Item getCavernPrimaryLoot(Random &rnd, World &world)
{
    if (skipPrimaryLoot(rnd, world)) {
        return {ItemID::angelStatue, Prefix::none, 1};
    }
    return rnd.pool<Item>({
        {ItemID::bandOfRegeneration, rnd.select(PrefixSet::accessory), 1},
        {ItemID::magicMirror, Prefix::none, 1},
        {ItemID::cloudInABottle, rnd.select(PrefixSet::accessory), 1},
        {ItemID::hermesBoots, rnd.select(PrefixSet::accessory), 1},
        {ItemID::shoeSpikes, rnd.select(PrefixSet::accessory), 1},
        {ItemID::flareGun, Prefix::none, 1},
    });
}

Item getFrozenPrimaryLoot(Random &rnd, World &world)
{
    if (skipPrimaryLoot(rnd, world)) {
        return {ItemID::angelStatue, Prefix::none, 1};
    }
    return rnd.pool<Item>({
        {ItemID::iceBoomerang, rnd.select(PrefixSet::universal), 1},
        {ItemID::iceBlade, rnd.select(PrefixSet::melee), 1},
        {ItemID::iceSkates, rnd.select(PrefixSet::accessory), 1},
        {ItemID::snowballCannon, rnd.select(PrefixSet::ranged), 1},
        {ItemID::blizzardInABottle, rnd.select(PrefixSet::accessory), 1},
        {ItemID::flurryBoots, rnd.select(PrefixSet::accessory), 1},
    });
}

Item getHoneyPrimaryLoot(Random &rnd)
{
    return {
        rnd.pool(
            {ItemID::abeemination,
             ItemID::beeMinecart,
             ItemID::hiveWand,
             ItemID::honeyDispenser}),
        Prefix::none,
        1};
}

Item getIvyPrimaryLoot(Random &rnd, World &world)
{
    if (skipPrimaryLoot(rnd, world)) {
        return {ItemID::angelStatue, Prefix::none, 1};
    }
    return rnd.pool<Item>({
        {ItemID::feralClaws, rnd.select(PrefixSet::accessory), 1},
        {ItemID::ankletOfTheWind, rnd.select(PrefixSet::accessory), 1},
        {ItemID::staffOfRegrowth, rnd.select(PrefixSet::melee), 1},
        {ItemID::boomstick, rnd.select(PrefixSet::ranged), 1},
        rnd.select<Item>(
            {{ItemID::flowerBoots, rnd.select(PrefixSet::accessory), 1},
             {ItemID::fiberglassFishingPole, Prefix::none, 1}}),
    });
}

Item getMushroomPrimaryLoot(Random &rnd, World &world)
{
    if (skipPrimaryLoot(rnd, world)) {
        return {ItemID::angelStatue, Prefix::none, 1};
    }
    return rnd.pool<Item>({
        {ItemID::bandOfRegeneration, rnd.select(PrefixSet::accessory), 1},
        {ItemID::magicMirror, Prefix::none, 1},
        {ItemID::cloudInABottle, rnd.select(PrefixSet::accessory), 1},
        {ItemID::hermesBoots, rnd.select(PrefixSet::accessory), 1},
        {ItemID::shroomerang, rnd.select(PrefixSet::universal), 1},
    });
}

Item getWaterPrimaryLoot(Random &rnd, World &world)
{
    if (skipPrimaryLoot(rnd, world)) {
        return {ItemID::angelStatue, Prefix::none, 1};
    }
    return rnd.pool<Item>({
        {ItemID::breathingReed, rnd.select(PrefixSet::melee), 1},
        {ItemID::flipper, rnd.select(PrefixSet::accessory), 1},
        {ItemID::trident, rnd.select(PrefixSet::universal), 1},
        {ItemID::innerTube, rnd.select(PrefixSet::accessory), 1},
        {ItemID::waterWalkingBoots, rnd.select(PrefixSet::accessory), 1},
        {ItemID::beachBall, Prefix::none, 1},
    });
}

void fillSurfaceChest(Chest &chest, int torchID, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1, getSurfacePrimaryLoot(rnd, world)},
         getGlobalItemPrimary(rnd, world),
         {1.0 / 6, {ItemID::glowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6, {ItemID::throwingKnife, Prefix::none, rnd.getInt(150, 300)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::grenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select<int>({torchID, ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {0.5, {ItemID::wood, Prefix::none, rnd.getInt(50, 99)}}});
}

void fillSurfaceAshWoodChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1, getSurfacePrimaryLoot(rnd, world)},
         getGlobalItemPrimary(rnd, world),
         {1.0 / 6, {ItemID::glowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6, {ItemID::throwingKnife, Prefix::none, rnd.getInt(150, 300)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::grenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select({ItemID::torch, ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {0.5, {ItemID::ashWood, Prefix::none, rnd.getInt(50, 99)}}});
}

void fillSurfaceFrozenChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1, getFrozenPrimaryLoot(rnd, world)},
         getGlobalItemPrimary(rnd, world),
         {0.05, {ItemID::extractinator, Prefix::none, 1}},
         {0.02, {ItemID::fish, Prefix::none, 1}},
         {1.0 / 7, {ItemID::iceMachine, Prefix::none, 1}},
         {0.2, {ItemID::iceMirror, Prefix::none, 1}},
         {1.0 / 6, {ItemID::glowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6,
          {ItemID::frostDaggerfish, Prefix::none, rnd.getInt(150, 300)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::grenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion,
                ItemID::warmthPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select({ItemID::iceTorch, ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {0.5, {ItemID::borealWood, Prefix::none, rnd.getInt(50, 99)}}});
}

void fillLivingWoodChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1,
          skipPrimaryLoot(rnd, world)
              ? Item{ItemID::angelStatue, Prefix::none, 1}
              : rnd.pool<Item>({
                    {ItemID::livingWoodWand, Prefix::none, 1},
                    rnd.select<Item>({
                        {ItemID::bugNet, Prefix::none, 1},
                        {ItemID::greenString,
                         rnd.select(PrefixSet::accessory),
                         1},
                        {ItemID::brownAndSilverDye,
                         Prefix::none,
                         rnd.getInt(3, 6)},
                        {ItemID::greenAndBlackDye,
                         Prefix::none,
                         rnd.getInt(3, 6)},
                        {ItemID::wandOfSparking,
                         rnd.select(PrefixSet::magiclownokb),
                         1},
                    }),
                    {ItemID::livingWoodWand, Prefix::none, 1},
                    {ItemID::finchStaff, rnd.select(PrefixSet::magic), 1},
                })},
         getGlobalItemPrimary(rnd, world),
         {0.1,
          {rnd.select({ItemID::sunflowerMinecart, ItemID::ladybugMinecart}),
           Prefix::none,
           1}},
         {1.0 / 6, {ItemID::glowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6, {ItemID::throwingKnife, Prefix::none, rnd.getInt(150, 300)}},
         {0.4,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::grenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::vineRope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select({ItemID::torch, ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {0.5, {ItemID::wood, Prefix::none, rnd.getInt(50, 99)}}});
}

void fillSurfaceMushroomChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1, getSurfacePrimaryLoot(rnd, world)},
         {0.1,
          {rnd.select({ItemID::shroomMinecart, ItemID::mushroomHat}),
           Prefix::none,
           1}},
         getGlobalItemPrimary(rnd, world),
         {1.0 / 6, {ItemID::glowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6, {ItemID::throwingKnife, Prefix::none, rnd.getInt(150, 300)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::grenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select({ItemID::mushroomTorch, ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {0.5, {ItemID::glowingMushroom, Prefix::none, rnd.getInt(50, 99)}}});
}

void fillSurfacePalmWoodChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1,
          skipPrimaryLoot(rnd, world)
              ? Item{ItemID::angelStatue, Prefix::none, 1}
              : rnd.pool<Item>({
                    {ItemID::spear, rnd.select(PrefixSet::universal), 1},
                    {ItemID::blowpipe, rnd.select(PrefixSet::ranged), 1},
                    {ItemID::woodenBoomerang,
                     rnd.select(PrefixSet::universal),
                     1},
                    {ItemID::aglet, rnd.select(PrefixSet::accessory), 1},
                    {ItemID::climbingClaws,
                     rnd.select(PrefixSet::accessory),
                     1},
                    {ItemID::umbrella, rnd.select(PrefixSet::melee), 1},
                    {ItemID::wandOfSparking,
                     rnd.select(PrefixSet::magiclownokb),
                     1},
                    {ItemID::radar, rnd.select(PrefixSet::accessory), 1},
                    {ItemID::stepStool, rnd.select(PrefixSet::accessory), 1},
                })},
         getGlobalItemPrimary(rnd, world),
         {0.05, {ItemID::whitePearl, Prefix::none, 1}},
         {1.0 / 6, {ItemID::glowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6,
          {ItemID::boneThrowingKnife, Prefix::none, rnd.getInt(150, 300)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::grenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select({ItemID::desertTorch, ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {0.5, {ItemID::palmWood, Prefix::none, rnd.getInt(50, 99)}}});
}

void fillSurfacePearlwoodChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1, getSurfacePrimaryLoot(rnd, world)},
         getGlobalItemPrimary(rnd, world),
         {1.0 / 6, {ItemID::bouncyGlowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6, {ItemID::throwingKnife, Prefix::none, rnd.getInt(150, 300)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::happyGrenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::silkRope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::starAnise}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select({ItemID::hallowedTorch, ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {0.5, {ItemID::pearlwood, Prefix::none, rnd.getInt(50, 99)}}});
}

void fillSurfaceRichMahoganyChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1, getSurfacePrimaryLoot(rnd, world)},
         getGlobalItemPrimary(rnd, world),
         {1.0 / 6, {ItemID::glowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6, {ItemID::poisonedKnife, Prefix::none, rnd.getInt(150, 300)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::grenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::vineRope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion,
                ItemID::ammoReservationPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select({ItemID::jungleTorch, ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {0.5, {ItemID::richMahogany, Prefix::none, rnd.getInt(50, 99)}}});
}

void fillSurfaceWaterChest(Chest &chest, Random &rnd, World &world)
{
    bool nearEdge = chest.x < 350 || chest.x > world.getWidth() - 350;
    fillLoot(
        chest,
        rnd,
        {{1, getWaterPrimaryLoot(rnd, world)},
         getGlobalItemPrimary(rnd, world),
         {nearEdge ? 0.05 : 0, {ItemID::whitePearl, Prefix::none, 1}},
         {0.5, {ItemID::sandcastleBucket, Prefix::none, 1}},
         {0.5, {ItemID::sharkBait, Prefix::none, 1}},
         {1.0 / 6, {ItemID::glowstick, Prefix::none, rnd.getInt(40, 75)}},
         {1.0 / 6, {ItemID::throwingKnife, Prefix::none, rnd.getInt(150, 300)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {1.0 / 3, {ItemID::grenade, Prefix::none, rnd.getInt(3, 5)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::ironskinPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion,
                ItemID::miningPotion,
                ItemID::builderPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5,
          {rnd.select(
               {nearEdge ? ItemID::coralTorch : ItemID::glowstick,
                ItemID::bottle}),
           Prefix::none,
           rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}},
         {nearEdge ? 0.5 : 0,
          {ItemID::coral, Prefix::none, rnd.getInt(3, 5)}}});
}

void fillUndergroundChest(
    Chest &chest,
    int torchID,
    bool isTrapped,
    Random &rnd,
    World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getUndergroundPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {isTrapped ? 1.0 / 3 : 0,
             {ItemID::deadMansSweater, Prefix::none, 1}},
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::bomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {torchID, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillUndergroundFrozenChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getFrozenPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.02, {ItemID::fish, Prefix::none, 1}},
            {1.0 / 7, {ItemID::iceMachine, Prefix::none, 1}},
            {0.2, {ItemID::iceMirror, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::bomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion,
                   ItemID::warmthPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::iceTorch, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillUndergroundHoneyChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getHoneyPrimaryLoot(rnd)},
            getGlobalItemPrimary(rnd, world),
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::honeyBomb, Prefix::none, rnd.getInt(3, 5)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::vineRope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::bottledHoney, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion,
                   ItemID::ammoReservationPotion,
                   ItemID::summoningPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::jungleTorch, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillUndergroundIvyChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getIvyPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {1.0 / 6, {ItemID::livingMahoganyWand, Prefix::none, 1}},
            {0.1, {ItemID::beeMinecart, Prefix::none, 1}},
            {0.2, {ItemID::honeyDispenser, Prefix::none, 1}},
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::bomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::vineRope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::bottledHoney, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion,
                   ItemID::ammoReservationPotion,
                   ItemID::summoningPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::jungleTorch, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillUndergroundMushroomChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getMushroomPrimaryLoot(rnd, world)},
            {1,
             {rnd.pool({ItemID::shroomMinecart, ItemID::mushroomHat}),
              Prefix::none,
              1}},
            getGlobalItemPrimary(rnd, world),
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::bomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::mushroomTorch, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillUndergroundPearlwoodChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getUndergroundPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::bomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::silkRope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::jestersArrow, ItemID::starAnise}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::hallowedTorch, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillUndergroundSandstoneChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             skipPrimaryLoot(rnd, world)
                 ? Item{ItemID::angelStatue, Prefix::none, 1}
                 : rnd.pool<Item>({
                       {ItemID::magicConch, Prefix::none, 1},
                       {ItemID::snakeCharmersFlute, Prefix::none, 1},
                       {ItemID::ancientChisel,
                        rnd.select(PrefixSet::accessory),
                        1},
                       {ItemID::duneriderBoots,
                        rnd.select(PrefixSet::accessory),
                        1},
                   })},
            getGlobalItemPrimary(rnd, world),
            {0.05,
             {rnd.select({ItemID::whitePearl, ItemID::blackPearl}),
              Prefix::none,
              1}},
            {1.0 / 15, {ItemID::desertMinecart, Prefix::none, 1}},
            {1.0 / 7, {ItemID::encumberingStone, Prefix::none, 1}},
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::scarabBomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::desertTorch, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillUndergroundRichMahoganyChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getUndergroundPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::bomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::vineRope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::bottledHoney, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion,
                   ItemID::ammoReservationPotion,
                   ItemID::summoningPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::jungleTorch, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillUndergroundWaterChest(Chest &chest, Random &rnd, World &world)
{
    bool nearEdge = chest.x < 350 || chest.x > world.getWidth() - 350;
    fillLoot(
        chest,
        rnd,
        {
            {1, getWaterPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {nearEdge ? 0.6 : 0,
             {rnd.select({ItemID::whitePearl, ItemID::blackPearl}),
              Prefix::none,
              1}},
            {0.5, {ItemID::sandcastleBucket, Prefix::none, 1}},
            {0.5, {ItemID::sharkBait, Prefix::none, 1}},
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::bomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {nearEdge ? 0.5 : 0,
             {ItemID::coralTorch, Prefix::none, rnd.getInt(10, 20)}},
            {nearEdge ? 0.5 : 0,
             {ItemID::coral, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillCavernChest(
    Chest &chest,
    int torchID,
    bool isTrapped,
    Random &rnd,
    World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getCavernPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {isTrapped ? 1.0 / 3 : 0,
             {ItemID::deadMansSweater, Prefix::none, 1}},
            getCavernBonusItem(chest.y, rnd, world),
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::flamingArrow, ItemID::throwingKnife}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::healingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select<int>({torchID, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCavernFrozenChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getFrozenPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.02, {ItemID::fish, Prefix::none, 1}},
            {1.0 / 7, {ItemID::iceMachine, Prefix::none, 1}},
            {0.2, {ItemID::iceMirror, Prefix::none, 1}},
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::frostburnArrow, ItemID::frostDaggerfish}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::healingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion,
                   ItemID::warmthPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::iceTorch, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCavernHoneyChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getHoneyPrimaryLoot(rnd)},
            getGlobalItemPrimary(rnd, world),
            {1.0 / 3, {ItemID::honeyBomb, Prefix::none, rnd.getInt(3, 5)}},
            getCavernBonusItem(chest.y, rnd, world),
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::flamingArrow, ItemID::poisonedKnife}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::bottledHoney, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion,
                   ItemID::ammoReservationPotion,
                   ItemID::summoningPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::jungleTorch, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCavernIvyChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getIvyPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {1.0 / 6, {ItemID::livingMahoganyWand, Prefix::none, 1}},
            {0.1, {ItemID::beeMinecart, Prefix::none, 1}},
            {0.2, {ItemID::honeyDispenser, Prefix::none, 1}},
            getCavernBonusItem(chest.y, rnd, world),
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::flamingArrow, ItemID::poisonedKnife}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::bottledHoney, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion,
                   ItemID::ammoReservationPotion,
                   ItemID::summoningPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::jungleTorch, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCavernMushroomChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getMushroomPrimaryLoot(rnd, world)},
            {1,
             {rnd.pool({ItemID::shroomMinecart, ItemID::mushroomHat}),
              Prefix::none,
              1}},
            getGlobalItemPrimary(rnd, world),
            getCavernBonusItem(chest.y, rnd, world),
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::flamingArrow, ItemID::throwingKnife}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::healingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::mushroomTorch, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCavernPearlwoodChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getCavernPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            getCavernBonusItem(chest.y, rnd, world),
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::holyArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::crystalBullet, ItemID::crystalDart}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::healingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::hallowedTorch, ItemID::bouncyGlowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCavernSandstoneChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             skipPrimaryLoot(rnd, world)
                 ? Item{ItemID::angelStatue, Prefix::none, 1}
                 : rnd.pool<Item>({
                       {ItemID::stormSpear,
                        rnd.select(PrefixSet::universal),
                        1},
                       {ItemID::thunderZapper, rnd.select(PrefixSet::magic), 1},
                       {ItemID::bastStatue, Prefix::none, 1},
                   })},
            getGlobalItemPrimary(rnd, world),
            {0.05,
             {rnd.select({ItemID::blackPearl, ItemID::pinkPearl}),
              Prefix::none,
              1}},
            {1.0 / 15, {ItemID::desertMinecart, Prefix::none, 1}},
            {1.0 / 7, {ItemID::encumberingStone, Prefix::none, 1}},
            getCavernBonusItem(chest.y, rnd, world),
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::flamingArrow, ItemID::boneThrowingKnife}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::healingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::desertTorch, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCavernRichMahoganyChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, getCavernPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            getCavernBonusItem(chest.y, rnd, world),
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::flamingArrow, ItemID::poisonedKnife}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::bottledHoney, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion,
                   ItemID::ammoReservationPotion,
                   ItemID::summoningPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::jungleTorch, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCavernWaterChest(Chest &chest, Random &rnd, World &world)
{
    bool nearEdge = chest.x < 350 || chest.x > world.getWidth() - 350;
    fillLoot(
        chest,
        rnd,
        {
            {1, getWaterPrimaryLoot(rnd, world)},
            getGlobalItemPrimary(rnd, world),
            {nearEdge ? 0.7 : 0,
             {rnd.select({ItemID::whitePearl, ItemID::blackPearl}),
              Prefix::none,
              1}},
            {0.5, {ItemID::sandcastleBucket, Prefix::none, 1}},
            {0.5, {ItemID::sharkBait, Prefix::none, 1}},
            getCavernBonusItem(chest.y, rnd, world),
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::flamingArrow, ItemID::throwingKnife}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::healingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {nearEdge ? ItemID::coralTorch : ItemID::glowstick,
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillSkywareChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {{1,
          skipPrimaryLoot(rnd, world)
              ? Item{ItemID::angelStatue, Prefix::none, 1}
              : rnd.pool<Item>({
                    {ItemID::shinyRedBalloon,
                     rnd.select(PrefixSet::accessory),
                     1},
                    {ItemID::starfury, rnd.select(PrefixSet::melee), 1},
                    {ItemID::luckyHorseshoe,
                     rnd.select(PrefixSet::accessory),
                     1},
                    {ItemID::celestialMagnet,
                     rnd.select(PrefixSet::accessory),
                     1},
                })},
         getGlobalItemPrimary(rnd, world),
         {1.0 / 3, {ItemID::skyMill, Prefix::none, 1}},
         {world.conf.celebration ? 0.08 : 0.025,
          {ItemID::fledglingWings, rnd.select(PrefixSet::accessory), 1}},
         {1,
          {rnd.pool(
               {ItemID::highPitch,
                ItemID::blessingFromTheHeavens,
                ItemID::constellation,
                ItemID::seeTheWorldForWhatItIs,
                ItemID::loveIsInTheTrashSlot,
                ItemID::eyeOfTheSun}),
           Prefix::none,
           1}},
         {1, {ItemID::cloud, Prefix::none, rnd.getInt(50, 100)}},
         {0.5, {ItemID::fallenStar, Prefix::none, rnd.getInt(3, 5)}},
         {0.2,
          {rnd.select({ItemID::herbBag, ItemID::canOfWorms}),
           Prefix::none,
           rnd.getInt(1, 4)}},
         {0.5,
          {rnd.select(
               {world.copperVariant == TileID::copperOre ? ItemID::copperBar
                                                         : ItemID::tinBar,
                world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                     : ItemID::leadBar}),
           Prefix::none,
           rnd.getInt(3, 10)}},
         {0.5,
          {world.conf.celebration ? rnd.select(
                                        {ItemID::blueStreamer,
                                         ItemID::greenStreamer,
                                         ItemID::pinkStreamer})
                                  : ItemID::rope,
           Prefix::none,
           rnd.getInt(50, 100)}},
         {2.0 / 3,
          {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
           Prefix::none,
           rnd.getInt(25, 50)}},
         getGlobalItemPotion(world),
         {0.5, {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(3, 5)}},
         {2.0 / 3,
          {rnd.select(
               {ItemID::featherfallPotion,
                ItemID::shinePotion,
                ItemID::nightOwlPotion,
                ItemID::swiftnessPotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {0.5, {ItemID::fairyGlowstick, Prefix::none, rnd.getInt(10, 20)}},
         {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(10, 29)}}});
}

void fillShadowChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             skipPrimaryLoot(rnd, world)
                 ? Item{ItemID::angelStatue, Prefix::none, 1}
                 : rnd.pool<Item>({
                       {ItemID::sunfury, rnd.select(PrefixSet::universal), 1},
                       {ItemID::flowerOfFire, rnd.select(PrefixSet::magic), 1},
                       {ItemID::flamelash, rnd.select(PrefixSet::magic), 1},
                       {ItemID::darkLance, rnd.select(PrefixSet::universal), 1},
                       {ItemID::hellwingBow, rnd.select(PrefixSet::ranged), 1},
                   })},
            getGlobalItemPrimary(rnd, world),
            {0.1, {ItemID::demonicHellcart, Prefix::none, 1}},
            {0.1, {ItemID::ornateShadowKey, Prefix::none, 1}},
            {0.1, {ItemID::sliceOfHellCake, Prefix::none, 1}},
            {0.2, {ItemID::treasureMagnet, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.5,
             {rnd.select(
                  {ItemID::meteoriteBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5,
             {rnd.select(
                  {ItemID::hellfireArrow,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBullet
                       : ItemID::tungstenBullet}),
              Prefix::none,
              rnd.getInt(50, 74)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::restorationPotion, Prefix::none, rnd.getInt(15, 20)}},
            {0.75,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::manaRegenerationPotion,
                   ItemID::obsidianSkinPotion,
                   ItemID::magicPowerPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::heartreachPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::gravitationPotion,
                   ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::obsidianSkinPotion,
                   ItemID::battlePotion,
                   ItemID::teleportationPotion,
                   ItemID::infernoPotion,
                   ItemID::lifeforcePotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select({ItemID::recallPotion, ItemID::potionOfReturn}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::demonTorch, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(2, 4)}},
        });
}

void fillPyramidChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             {rnd.pool({ItemID::flyingCarpet, ItemID::sandstormInABottle}),
              rnd.select(PrefixSet::accessory),
              1}},
            getGlobalItemPrimary(rnd, world),
            {world.conf.celebration ? 1.0 : 0.1,
             {ItemID::pharaohsMask, Prefix::none, 1}},
            {1.0 / 15, {ItemID::desertMinecart, Prefix::none, 1}},
            {1.0 / 7, {ItemID::encumberingStone, Prefix::none, 1}},
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.05, {ItemID::flareGun, Prefix::none, 1}},
            {1.0 / 3, {ItemID::scarabBomb, Prefix::none, rnd.getInt(10, 19)}},
            {0.2, {ItemID::angelStatue, Prefix::none, 1}},
            {1.0 / 3, {ItemID::rope, Prefix::none, rnd.getInt(50, 100)}},
            {0.5,
             {rnd.select(
                  {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                        : ItemID::leadBar,
                   world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar}),
              Prefix::none,
              rnd.getInt(5, 14)}},
            {0.5,
             {rnd.select({ItemID::woodenArrow, ItemID::shuriken}),
              Prefix::none,
              rnd.getInt(25, 49)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::lesserHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::regenerationPotion,
                   ItemID::shinePotion,
                   ItemID::nightOwlPotion,
                   ItemID::swiftnessPotion,
                   ItemID::archeryPotion,
                   ItemID::gillsPotion,
                   ItemID::hunterPotion,
                   ItemID::miningPotion,
                   ItemID::dangersensePotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::desertTorch, Prefix::none, rnd.getInt(10, 20)}},
            {2.0 / 3, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(50, 89)}},
        });
}

void fillWebCoveredChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             {skipPrimaryLoot(rnd, world) ? ItemID::angelStatue
                                          : ItemID::webSlinger,
              Prefix::none,
              1}},
            getGlobalItemPrimary(rnd, world),
            {1, {ItemID::cobweb, Prefix::none, rnd.getInt(10, 29)}},
            {0.05, {ItemID::extractinator, Prefix::none, 1}},
            {0.2, {ItemID::suspiciousLookingEye, Prefix::none, 1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {world.silverVariant == TileID::silverOre
                       ? ItemID::silverBar
                       : ItemID::tungstenBar,
                   world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                                        : ItemID::platinumBar}),
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {rnd.select({ItemID::flamingArrow, ItemID::throwingKnife}),
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::healingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             {rnd.select({ItemID::torch, ItemID::glowstick}),
              Prefix::none,
              rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillCrystalChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             {world.goldVariant == TileID::goldOre ? ItemID::goldCrown
                                                   : ItemID::platinumCrown,
              Prefix::none,
              1}},
            {0.5,
             {rnd.select({ItemID::diamond, ItemID::amber, ItemID::ruby}),
              Prefix::none,
              rnd.getInt(3, 5)}},
            {0.5,
             {rnd.select({ItemID::emerald, ItemID::sapphire}),
              Prefix::none,
              rnd.getInt(3, 5)}},
            {0.5,
             {rnd.select({ItemID::topaz, ItemID::amethyst}),
              Prefix::none,
              rnd.getInt(3, 5)}},
            {0.3,
             {rnd.select(
                  {ItemID::diamondGemcorn,
                   ItemID::amberGemcorn,
                   ItemID::rubyGemcorn}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.3,
             {rnd.select({ItemID::emeraldGemcorn, ItemID::sapphireGemcorn}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.3,
             {rnd.select({ItemID::topazGemcorn, ItemID::amethystGemcorn}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::lesserLuckPotion,
                   ItemID::nightOwlPotion,
                   ItemID::shinePotion,
                   ItemID::spelunkerPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.4,
             {rnd.select(
                  {ItemID::whiteTorch, ItemID::orangeTorch, ItemID::redTorch}),
              Prefix::none,
              rnd.getInt(10, 20)}},
            {0.4,
             {rnd.select({ItemID::greenTorch, ItemID::blueTorch}),
              Prefix::none,
              rnd.getInt(10, 20)}},
            {0.4,
             {rnd.select({ItemID::yellowTorch, ItemID::purpleTorch}),
              Prefix::none,
              rnd.getInt(10, 20)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillDungeonChest(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             rnd.pool<Item>({
                 {ItemID::muramasa, rnd.select(PrefixSet::melee), 1},
                 {ItemID::cobaltShield, rnd.select(PrefixSet::accessory), 1},
                 {ItemID::aquaScepter, rnd.select(PrefixSet::magic), 1},
                 {ItemID::blueMoon, rnd.select(PrefixSet::universal), 1},
                 {ItemID::magicMissile, rnd.select(PrefixSet::magic), 1},
                 {ItemID::valor, rnd.select(PrefixSet::universal), 1},
                 {ItemID::handgun, rnd.select(PrefixSet::ranged), 1},
             })},
            getGlobalItemPrimary(rnd, world),
            {1.0 / 3, {ItemID::shadowKey, Prefix::none, 1}},
            {0.125, {ItemID::boneWelder, Prefix::none, 1}},
            {0.2,
             {rnd.select({ItemID::suspiciousLookingEye, ItemID::slimeCrown}),
              Prefix::none,
              1}},
            {1.0 / 3, {ItemID::dynamite, Prefix::none, 1}},
            {0.25, {ItemID::jestersArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {world.isCrimson ? ItemID::crimtaneBar : ItemID::demoniteBar,
              Prefix::none,
              rnd.getInt(3, 10)}},
            {0.5,
             {world.silverVariant == TileID::silverOre ? ItemID::silverBullet
                                                       : ItemID::tungstenBullet,
              Prefix::none,
              rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5, {ItemID::healingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::spelunkerPotion,
                   ItemID::featherfallPotion,
                   ItemID::nightOwlPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::archeryPotion,
                   ItemID::gravitationPotion,
                   ItemID::titanPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::thornsPotion,
                   ItemID::waterWalkingPotion,
                   ItemID::invisibilityPotion,
                   ItemID::hunterPotion,
                   ItemID::dangersensePotion,
                   ItemID::teleportationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::recallPotion, Prefix::none, rnd.getInt(1, 2)}},
            {0.5,
             rnd.select<Item>(
                 {{ItemID::boneTorch, Prefix::none, rnd.getInt(15, 29)},
                  {ItemID::spelunkerGlowstick,
                   Prefix::none,
                   rnd.getInt(1, 3)}})},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillDungeonBiomeChest(
    Chest &chest,
    Random &rnd,
    World &world,
    int dye,
    Item &&primaryItem)
{
    fillLoot(
        chest,
        rnd,
        {{1, primaryItem},
         getGlobalItemPrimary(rnd, world),
         {1, {dye, Prefix::none, rnd.getInt(3, 6)}},
         {0.5, {ItemID::remnantsOfDevotion, Prefix::none, 1}},
         {1,
          {rnd.select(
               {ItemID::blueBrick, ItemID::greenBrick, ItemID::pinkBrick}),
           Prefix::none,
           rnd.getInt(30, 60)}},
         {1, {ItemID::chlorophyteBar, Prefix::none, rnd.getInt(5, 10)}},
         {1, {ItemID::lifeFruit, Prefix::none, rnd.getInt(1, 2)}},
         getGlobalItemPotion(world),
         {1, {ItemID::greaterHealingPotion, Prefix::none, rnd.getInt(5, 10)}},
         {1,
          {rnd.select(
               {ItemID::wrathPotion,
                ItemID::lifeforcePotion,
                ItemID::ragePotion,
                ItemID::endurancePotion}),
           Prefix::none,
           rnd.getInt(1, 2)}},
         {1, {ItemID::goldCoin, Prefix::none, rnd.getInt(20, 30)}}});
}

void fillLihzahrdChest(Chest &chest, Random &rnd, World &world)
{
    bool brokenTablet = rnd.getBool();
    fillLoot(
        chest,
        rnd,
        {
            {1, {ItemID::lihzahrdPowerCell, Prefix::none, 1}},
            {brokenTablet ? 1.0 : 0.0,
             {ItemID::solarTabletFragment, Prefix::none, rnd.getInt(3, 7)}},
            {brokenTablet ? 0.0 : 1.0, {ItemID::solarTablet, Prefix::none, 1}},
            getGlobalItemPrimary(rnd, world),
            {0.2, {ItemID::lihzahrdFurnace, Prefix::none, 1}},
            {0.2, {ItemID::lihzahrdBrick, Prefix::none, rnd.getInt(30, 60)}},
            {0.2,
             {rnd.select(
                  {ItemID::mechanicalEye,
                   ItemID::mechanicalWorm,
                   ItemID::mechanicalSkull}),
              Prefix::none,
              1}},
            {1.0 / 3, {ItemID::miniNukeII, Prefix::none, rnd.getInt(3, 5)}},
            {0.25,
             {ItemID::chlorophyteArrow, Prefix::none, rnd.getInt(25, 50)}},
            {0.5,
             {rnd.select(
                  {ItemID::chlorophyteBar,
                   ItemID::shroomiteBar,
                   ItemID::spectreBar}),
              Prefix::none,
              rnd.getInt(2, 5)}},
            {0.5,
             {ItemID::chlorophyteBullet, Prefix::none, rnd.getInt(25, 50)}},
            getGlobalItemPotion(world),
            {0.5,
             {ItemID::greaterHealingPotion, Prefix::none, rnd.getInt(3, 5)}},
            {2.0 / 3,
             {rnd.select(
                  {ItemID::lesserLuckPotion,
                   ItemID::heartreachPotion,
                   ItemID::archeryPotion,
                   ItemID::titanPotion,
                   ItemID::magicPowerPotion,
                   ItemID::manaRegenerationPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {1.0 / 3,
             {rnd.select(
                  {ItemID::wrathPotion,
                   ItemID::ragePotion,
                   ItemID::lifeforcePotion,
                   ItemID::endurancePotion,
                   ItemID::luckPotion,
                   ItemID::summoningPotion}),
              Prefix::none,
              rnd.getInt(1, 2)}},
            {0.5, {ItemID::potionOfReturn, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::jungleTorch, Prefix::none, rnd.getInt(15, 29)}},
            {0.5, {ItemID::goldCoin, Prefix::none, rnd.getInt(5, 10)}},
        });
}

void fillStarterChestIron(Chest &chest, Random &rnd, World &world)
{
    bool isIron = world.ironVariant == TileID::ironOre;
    fillLoot(
        chest,
        rnd,
        {
            {1,
             {isIron ? ItemID::ironHelmet : ItemID::leadHelmet,
              Prefix::none,
              1}},
            {1,
             {isIron ? ItemID::ironChainmail : ItemID::leadChainmail,
              Prefix::none,
              1}},
            {1,
             {isIron ? ItemID::ironGreaves : ItemID::leadGreaves,
              Prefix::none,
              1}},
            {1,
             {isIron ? ItemID::ironBar : ItemID::leadBar,
              Prefix::none,
              rnd.getInt(80, 85)}},
            {1, {ItemID::cloudInABottle, rnd.select(PrefixSet::accessory), 1}},
            {1, {ItemID::silverCoin, Prefix::none, rnd.getInt(12, 24)}},
        });
}

void fillStarterChestPlatinum(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             {world.ironVariant == TileID::ironOre ? ItemID::ironAnvil
                                                   : ItemID::leadAnvil,
              Prefix::none,
              1}},
            {1, {ItemID::platinumHelmet, Prefix::none, 1}},
            {1, {ItemID::platinumChainmail, Prefix::none, 1}},
            {1, {ItemID::platinumGreaves, Prefix::none, 1}},
            {1, {ItemID::platinumBar, Prefix::none, rnd.getInt(95, 100)}},
            {1, {ItemID::grapplingHook, Prefix::none, 1}},
            {1, {ItemID::silverCoin, Prefix::none, rnd.getInt(70, 99)}},
        });
}

void fillStarterChestHellstone(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             {world.ironVariant == TileID::ironOre ? ItemID::ironAnvil
                                                   : ItemID::leadAnvil,
              Prefix::none,
              1}},
            {1, {ItemID::moltenHelmet, Prefix::none, 1}},
            {1, {ItemID::moltenBreastplate, Prefix::none, 1}},
            {1, {ItemID::moltenGreaves, Prefix::none, 1}},
            {1, {ItemID::hellstoneBar, Prefix::none, rnd.getInt(85, 90)}},
            {1, {ItemID::hellfireTreads, rnd.select(PrefixSet::accessory), 1}},
            {1, {ItemID::lifeCrystal, Prefix::none, rnd.getInt(2, 4)}},
            {1, {ItemID::goldCoin, Prefix::none, rnd.getInt(1, 2)}},
        });
}

void fillStarterChestMythril(Chest &chest, Random &rnd, World &world)
{
    int anvilVariant = world.ironVariant == TileID::ironOre ? ItemID::ironAnvil
                                                            : ItemID::leadAnvil;
    if (world.mythrilVariant == TileID::orichalcumOre) {
        fillLoot(
            chest,
            rnd,
            {
                {1, {anvilVariant, Prefix::none, 1}},
                {1, {ItemID::orichalcumHeadgear, Prefix::none, 1}},
                {1, {ItemID::orichalcumMask, Prefix::none, 1}},
                {1, {ItemID::orichalcumHelmet, Prefix::none, 1}},
                {1, {ItemID::orichalcumBreastplate, Prefix::none, 1}},
                {1, {ItemID::orichalcumLeggings, Prefix::none, 1}},
                {1, {ItemID::orichalcumBar, Prefix::none, rnd.getInt(90, 95)}},
                {1,
                 {ItemID::fledglingWings, rnd.select(PrefixSet::accessory), 1}},
                {1, {ItemID::lifeCrystal, Prefix::none, rnd.getInt(4, 6)}},
                {1, {ItemID::goldCoin, Prefix::none, rnd.getInt(3, 6)}},
            });
    } else {
        fillLoot(
            chest,
            rnd,
            {
                {1, {anvilVariant, Prefix::none, 1}},
                {1, {ItemID::mythrilHood, Prefix::none, 1}},
                {1, {ItemID::mythrilHelmet, Prefix::none, 1}},
                {1, {ItemID::mythrilHat, Prefix::none, 1}},
                {1, {ItemID::mythrilChainmail, Prefix::none, 1}},
                {1, {ItemID::mythrilGreaves, Prefix::none, 1}},
                {1, {ItemID::mythrilBar, Prefix::none, rnd.getInt(75, 80)}},
                {1,
                 {ItemID::fledglingWings, rnd.select(PrefixSet::accessory), 1}},
                {1, {ItemID::lifeCrystal, Prefix::none, rnd.getInt(4, 6)}},
                {1, {ItemID::goldCoin, Prefix::none, rnd.getInt(3, 6)}},
            });
    }
}

void fillStarterChestDebug(Chest &chest, Random &rnd, World &world)
{
    fillLoot(
        chest,
        rnd,
        {
            {1, {ItemID::zenith, Prefix::legendary, 1}},
            {1, {ItemID::zenith, Prefix::legendary, 1}},
            {1, {ItemID::picksaw, Prefix::legendary, 1}},
            {1, {ItemID::picksaw, Prefix::legendary, 1}},
            {1, {ItemID::valhallaKnightsHelm, Prefix::none, 1}},
            {1, {ItemID::valhallaKnightsBreastplate, Prefix::none, 1}},
            {1, {ItemID::valhallaKnightsGreaves, Prefix::none, 1}},
            {1, {ItemID::valhallaKnightsHelm, Prefix::none, 1}},
            {1, {ItemID::valhallaKnightsBreastplate, Prefix::none, 1}},
            {1, {ItemID::valhallaKnightsGreaves, Prefix::none, 1}},
            {1, {ItemID::witchsBroom, Prefix::none, 1}},
            {1, {ItemID::witchsBroom, Prefix::none, 1}},
            {1, {ItemID::theGrandDesign, Prefix::none, 1}},
            {1, {ItemID::theGrandDesign, Prefix::none, 1}},
            {1,
             {world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                                   : ItemID::leadBar,
              Prefix::none,
              9999}},
            {1, {ItemID::shinePotion, Prefix::none, 9999}},
            {1, {ItemID::wormholePotion, Prefix::none, 9999}},
        });
}

void fillStarterChest(int level, Chest &chest, Random &rnd, World &world)
{
    switch (level) {
    case ItemID::ironBar:
        fillStarterChestIron(chest, rnd, world);
        break;
    case ItemID::platinumBar:
        fillStarterChestPlatinum(chest, rnd, world);
        break;
    case ItemID::hellstoneBar:
        fillStarterChestHellstone(chest, rnd, world);
        break;
    case ItemID::mythrilBar:
        fillStarterChestMythril(chest, rnd, world);
        break;
    case ItemID::zenith:
        fillStarterChestDebug(chest, rnd, world);
        break;
    }
}

void fillBarrel(Chest &chest, Random &rnd)
{
    fillLoot(
        chest,
        rnd,
        {
            {0.3, {ItemID::atlanticCod, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::bass, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::flounder, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::neonTetra, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::redSnapper, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::rockLobster, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::salmon, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::shrimp, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::trout, Prefix::none, rnd.getInt(2, 5)}},
            {0.3, {ItemID::tuna, Prefix::none, rnd.getInt(2, 5)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::cobweb, Prefix::none, rnd.getInt(10, 29)}},
        });
}

void fillDresser(Chest &chest, Random &rnd)
{
    fillLoot(
        chest,
        rnd,
        {
            {1,
             {rnd.pool(
                  {ItemID::tuxedoShirt,
                   ItemID::summerHat,
                   ItemID::robe,
                   ItemID::crimsonCloak,
                   ItemID::redCape,
                   ItemID::winterCape}),
              Prefix::none,
              1}},
            {1, {ItemID::book, Prefix::none, rnd.getInt(3, 5)}},
            {0.5, {ItemID::silverCoin, Prefix::none, rnd.getInt(1, 2)}},
            {0.5, {ItemID::cobweb, Prefix::none, rnd.getInt(10, 29)}},
        });
}

void fillChest(
    Chest &chest,
    Depth depth,
    int torchID,
    bool isTrapped,
    Random &rnd,
    World &world)
{
    switch (depth) {
    case Depth::surface:
        fillSurfaceChest(chest, torchID, rnd, world);
        break;
    case Depth::underground:
        fillUndergroundChest(chest, torchID, isTrapped, rnd, world);
        break;
    case Depth::cavern:
        fillCavernChest(chest, torchID, isTrapped, rnd, world);
        break;
    }
}

void fillAshWoodChest(Chest &chest, Depth depth, Random &rnd, World &world)
{
    switch (depth) {
    case Depth::surface:
        fillSurfaceAshWoodChest(chest, rnd, world);
        break;
    case Depth::underground:
        fillUndergroundChest(chest, ItemID::torch, false, rnd, world);
        break;
    case Depth::cavern:
        fillCavernChest(chest, ItemID::torch, false, rnd, world);
        break;
    }
}

void fillDesertChest(Chest &chest, Depth depth, Random &rnd, World &world)
{
    switch (depth) {
    case Depth::surface:
        fillSurfacePalmWoodChest(chest, rnd, world);
        break;
    case Depth::underground:
        fillUndergroundSandstoneChest(chest, rnd, world);
        break;
    case Depth::cavern:
        fillCavernSandstoneChest(chest, rnd, world);
        break;
    }
}

void fillSurfaceHoneyChest(Chest &chest, Random &rnd, World &world)
{
    fillUndergroundHoneyChest(chest, rnd, world);
}

void fillSurfaceIvyChest(Chest &chest, Random &rnd, World &world)
{
    fillUndergroundIvyChest(chest, rnd, world);
}

#define REGISTER_FILL_CHEST(type)                                              \
    void fill##type##Chest(                                                    \
        Chest &chest,                                                          \
        Depth depth,                                                           \
        Random &rnd,                                                           \
        World &world)                                                          \
    {                                                                          \
        switch (depth) {                                                       \
        case Depth::surface:                                                   \
            fillSurface##type##Chest(chest, rnd, world);                       \
            break;                                                             \
        case Depth::underground:                                               \
            fillUnderground##type##Chest(chest, rnd, world);                   \
            break;                                                             \
        case Depth::cavern:                                                    \
            fillCavern##type##Chest(chest, rnd, world);                        \
            break;                                                             \
        }                                                                      \
    }

REGISTER_FILL_CHEST(Frozen)
REGISTER_FILL_CHEST(Honey)
REGISTER_FILL_CHEST(Ivy)
REGISTER_FILL_CHEST(Mushroom)
REGISTER_FILL_CHEST(Pearlwood)
REGISTER_FILL_CHEST(RichMahogany)
REGISTER_FILL_CHEST(Water)

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/LootRules.h`
```
#ifndef LOOTRULES_H
#define LOOTRULES_H

class Chest;
class Item;
class World;
class Random;

enum class Depth { surface, underground, cavern };

bool fuzzyIsSurfaceChest(int x, int y, World &world);
Depth getChestDepth(int x, int y, World &world);

void fillChest(
    Chest &chest,
    Depth depth,
    int torchID,
    bool isTrapped,
    Random &rnd,
    World &world);
void fillAshWoodChest(Chest &chest, Depth depth, Random &rnd, World &world);
void fillFrozenChest(Chest &chest, Depth depth, Random &rnd, World &world);
void fillHoneyChest(Chest &chest, Depth depth, Random &rnd, World &world);
void fillIvyChest(Chest &chest, Depth depth, Random &rnd, World &world);
void fillMushroomChest(Chest &chest, Depth depth, Random &rnd, World &world);
void fillDesertChest(Chest &chest, Depth depth, Random &rnd, World &world);
void fillPearlwoodChest(Chest &chest, Depth depth, Random &rnd, World &world);
void fillRichMahoganyChest(
    Chest &chest,
    Depth depth,
    Random &rnd,
    World &world);
void fillWaterChest(Chest &chest, Depth depth, Random &rnd, World &world);

void fillLivingWoodChest(Chest &chest, Random &rnd, World &world);
void fillSkywareChest(Chest &chest, Random &rnd, World &world);
void fillShadowChest(Chest &chest, Random &rnd, World &world);
void fillPyramidChest(Chest &chest, Random &rnd, World &world);
void fillWebCoveredChest(Chest &chest, Random &rnd, World &world);
void fillCrystalChest(Chest &chest, Random &rnd, World &world);
void fillDungeonChest(Chest &chest, Random &rnd, World &world);
void fillDungeonBiomeChest(
    Chest &chest,
    Random &rnd,
    World &world,
    int dye,
    Item &&primaryItem);
void fillLihzahrdChest(Chest &chest, Random &rnd, World &world);
void fillStarterChest(int level, Chest &chest, Random &rnd, World &world);
void fillBarrel(Chest &chest, Random &rnd);
void fillDresser(Chest &chest, Random &rnd);

#endif // LOOTRULES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/MinecartTracks.cpp`
```
#include "structures/MinecartTracks.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/Platforms.h"
#include "structures/StructureUtil.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>
#include <numbers>
#include <set>

namespace Track
{
enum {
    flat = 1,
    flatEndLeft = 2,
    flatEndRight = 3,
    ascToFlat = 4,
    flatToDesc = 5,
    flatToAsc = 6,
    descToFlat = 7,
    desc = 8,
    asc = 9,
    ascEndRight = 10,
    descEndLeft = 11,
    descEndRight = 12,
    ascEndLeft = 13,
};
}

enum class Mode { none, flat, asc, desc };

inline constexpr auto trackClearTiles = frozen::make_set<int>({
    TileID::empty,
    TileID::dirt,
    TileID::stone,
    TileID::grass,
    TileID::ironOre,
    TileID::copperOre,
    TileID::goldOre,
    TileID::silverOre,
    TileID::demonite,
    TileID::corruptGrass,
    TileID::clay,
    TileID::cobweb,
    TileID::sand,
    TileID::ash,
    TileID::hellstone,
    TileID::mud,
    TileID::jungleGrass,
    TileID::mushroomGrass,
    TileID::hallowedGrass,
    TileID::ebonsand,
    TileID::pearlsand,
    TileID::pearlstone,
    TileID::silt,
    TileID::snow,
    TileID::ice,
    TileID::thinIce,
    TileID::corruptIce,
    TileID::hallowedIce,
    TileID::tinOre,
    TileID::leadOre,
    TileID::tungstenOre,
    TileID::platinumOre,
    TileID::gem,
    TileID::corruptIce,
    TileID::slime,
    TileID::crimsonGrass,
    TileID::crimsonIce,
    TileID::crimtane,
    TileID::slush,
    TileID::crimsand,
    TileID::crispyHoney,
    TileID::smoothMarble,
    TileID::marble,
    TileID::granite,
    TileID::smoothGranite,
    TileID::pinkSlime,
    TileID::lavaMossStone,
    TileID::sandstone,
    TileID::hardenedSand,
    TileID::hardenedEbonsand,
    TileID::hardenedCrimsand,
    TileID::ebonsandstone,
    TileID::crimsandstone,
    TileID::hardenedPearlsand,
    TileID::pearlsandstone,
    TileID::desertFossil,
    TileID::kryptonMossStone,
    TileID::xenonMossStone,
    TileID::argonMossStone,
    TileID::neonMossStone,
    TileID::ashGrass,
    TileID::corruptJungleGrass,
    TileID::crimsonJungleGrass,
    TileID::cobaltOre,
    TileID::palladiumOre,
    TileID::mythrilOre,
    TileID::orichalcumOre,
    TileID::adamantiteOre,
    TileID::titaniumOre,
    TileID::chlorophyteOre,
});

bool canTrackClearTile(Tile &tile)
{
    return trackClearTiles.contains(tile.blockID) ||
           (tile.blockID == TileID::hive && tile.flag != Flag::none);
}

inline std::array gemsparkRainbow{
    WallID::Safe::rubyGemspark,
    WallID::Safe::amberGemspark,
    WallID::Safe::topazGemspark,
    WallID::Safe::emeraldGemspark,
    WallID::Safe::sapphireGemspark,
    WallID::Safe::amethystGemspark};

int getRainbowGemsparkWall(int x, int y)
{
    return gemsparkRainbow[(x + y) % gemsparkRainbow.size()];
}

std::pair<size_t, int>
computeTrackBounds(double lengthScale, Random &rnd, World &world)
{
    int hardMaxLen = world.getWidth() / 4.2;
    int maxLen = std::min(
        std::max<int>(
            lengthScale * rnd.getDouble(world.getWidth() / 26, hardMaxLen),
            20),
        hardMaxLen);
    size_t minLen =
        std::min<int>(lengthScale * (120 + world.getWidth() / 70), maxLen - 10);
    return {minLen, maxLen};
}

bool isValidTrackSegment(int x, int y, World &world)
{
    int minY = 0.8 * world.getUndergroundLevel();
    int maxY = 0.2 * world.getHeight() + 0.8 * world.getUnderworldLevel();
    return x > 50 && x < world.getWidth() - 50 && y > minY && y < maxY &&
           world.regionPasses(
               x,
               y - 10,
               1,
               12,
               [](Tile &tile) {
                   return !tile.guarded &&
                          (!tile.actuator || tile.blockID != TileID::sand) &&
                          canTrackClearTile(tile);
               }) &&
           world.regionPasses(x, y + 1, 1, 20, [](Tile &tile) {
               return tile.blockID != TileID::minecartTrack;
           });
}

std::vector<Point>
planStandardTrackAt(int x, int y, double lengthScale, Random &rnd, World &world)
{
    Point pos{x, y};
    Point delta{rnd.select({-1, 1}), 0};
    auto [minLen, maxLen] = computeTrackBounds(lengthScale, rnd, world);
    std::vector<Point> track;
    for (int i = 0; i < maxLen; ++i) {
        double noise = rnd.getCoarseNoise(pos.x, pos.y);
        delta.y = noise > 0.2 ? 1 : noise < -0.2 ? -1 : 0;
        pos += delta;
        if (!isValidTrackSegment(pos.x, pos.y, world)) {
            break;
        }
        track.push_back(pos);
    }
    if (track.size() < minLen) {
        return {};
    }
    track.resize(track.size() - rnd.getInt(4, 10));
    if (delta.x == -1) {
        std::reverse(track.begin(), track.end());
    }
    return track;
}

std::vector<Point>
planWavyTrackAt(int x, int y, double lengthScale, Random &rnd, World &world)
{
    Pointf pos{x, y};
    int delta = rnd.select({-1, 1});
    auto [minLen, maxLen] = computeTrackBounds(lengthScale, rnd, world);
    double noiseScale = rnd.getDouble(1.2, 3.8);
    double angle = std::numbers::pi *
                   rnd.getCoarseNoise(noiseScale * x, noiseScale * y) / 4;
    int prevY = y;
    int curY = y;
    std::vector<Point> track;
    for (int i = 0; i < maxLen; ++i) {
        double noise =
            rnd.getCoarseNoise(noiseScale * pos.x, noiseScale * pos.y);
        double turn = std::max(std::abs(noise) / 10, 0.015);
        angle = std::clamp(
            0.975 * angle + (noise > 0 ? turn : -turn),
            -std::numbers::pi / 4,
            std::numbers::pi / 4);
        pos.x += delta;
        pos.y += std::tan(angle);
        if (!isValidTrackSegment(pos.x, pos.y, world)) {
            break;
        }
        int nextY = std::clamp<int>(
            std::round(pos.y),
            prevY < curY ? curY : curY - 1,
            prevY > curY ? curY : curY + 1);
        prevY = curY;
        curY = nextY;
        track.emplace_back(std::round(pos.x), curY);
    }
    if (track.size() < minLen) {
        return {};
    }
    track.resize(track.size() - rnd.getInt(4, 10));
    if (delta == -1) {
        std::reverse(track.begin(), track.end());
    }
    return track;
}

std::vector<Point>
planTrackAt(int x, int y, double lengthScale, Random &rnd, World &world)
{
    return world.conf.celebration ||
                   (!world.conf.hiveQueen &&
                    hypot(world.aether, {x, y}) <
                        world.conf.aetherSize *
                            (80 +
                             world.getWidth() * world.getHeight() / 115200))
               ? planWavyTrackAt(x, y, lengthScale, rnd, world)
               : planStandardTrackAt(x, y, lengthScale, rnd, world);
}

std::vector<Point> planTrack(double lengthScale, Random &rnd, World &world)
{
    return planTrackAt(
        rnd.getInt(50, world.getWidth() - 50),
        rnd.getInt(world.getUndergroundLevel(), world.getUnderworldLevel()),
        lengthScale,
        rnd,
        world);
}

std::vector<Point> planSurfaceTrack(Random &rnd, World &world)
{
    if (world.conf.sunken) {
        return {};
    }
    std::vector<Point> locations;
    int minY = 0.8 * world.getUndergroundLevel();
    for (int x = 0.25 * world.getWidth(); x < 0.75 * world.getWidth(); ++x) {
        if (x == world.getWidth() / 2 - 150) {
            x = world.getWidth() / 2 + 150;
        }
        int y = world.getSurfaceLevel(x);
        if (y > minY && world.getTile(x, y - 1).liquid == Liquid::none) {
            locations.emplace_back(x, y);
        }
    }
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    for (auto [x, y] : locations) {
        auto track = planTrackAt(x, y, 1.0, rnd, world);
        if (!track.empty()) {
            return track;
        }
    }
    return {};
}

std::pair<int, int> findGrassInColumn(int x, int y, bool isDirt, World &world)
{
    constexpr auto dirtGrasses = frozen::make_set<int>(
        {TileID::grass,
         TileID::hallowedGrass,
         TileID::corruptGrass,
         TileID::crimsonGrass});
    constexpr auto mudGrasses = frozen::make_set<int>(
        {TileID::jungleGrass,
         TileID::mushroomGrass,
         TileID::corruptJungleGrass,
         TileID::crimsonJungleGrass});
    for (int swapJ = 0; swapJ < 100; ++swapJ) {
        int j = swapJ / 2;
        int minI = -j / 4;
        if (swapJ % 2 == 0) {
            j = -j;
        }
        for (int i = minI; i < 1 - minI; ++i) {
            Tile &tile = world.getTile(x + i, y + j);
            if (isDirt ? dirtGrasses.contains(tile.blockID)
                       : mudGrasses.contains(tile.blockID)) {
                return {tile.blockID, tile.blockPaint};
            }
        }
    }
    return {isDirt ? TileID::dirt : TileID::mud, Paint::none};
}

void applyTrackGrass(int x, int y, World &world)
{
    for (int j = -10; j < 2; ++j) {
        Tile &tile = world.getTile(x, y + j);
        bool isDirt =
            tile.blockID == TileID::dirt &&
            (y + j < world.getUndergroundLevel() || world.conf.dontDigUp);
        if ((!isDirt && tile.blockID != TileID::mud) ||
            !world.isExposed(x, y + j)) {
            continue;
        }
        std::tie(tile.blockID, tile.blockPaint) =
            findGrassInColumn(x, y + j, isDirt, world);
    }
}

void applyTrackSupport(int x, int y, World &world)
{
    constexpr auto allowed = frozen::make_set<int>(
        {TileID::platform, TileID::marbleColumn, TileID::woodenBeam});
    if (!allowed.contains(world.getTile(x - 1, y).blockID) ||
        !allowed.contains(world.getTile(x + 1, y).blockID)) {
        return;
    }
    Tile &tile = world.getTile(x, y);
    tile.wallID = world.conf.celebration ? getRainbowGemsparkWall(x, y)
                                         : WallID::Safe::palmWood;
    if (x % 7 != 0 || world.getTile(x, y + 1).blockID != TileID::empty) {
        return;
    }
    int supFloor = scanWhileEmpty({x, y + 1}, {0, 1}, world).y;
    ++supFloor;
    if (supFloor - y < 4 || supFloor - y > 24 ||
        !canTrackClearTile(world.getTile(x, supFloor))) {
        return;
    }
    tile.blockPaint = Paint::none;
    for (int beamY = y; beamY < supFloor; ++beamY) {
        if (world.conf.celebration) {
            Tile &beamTile = world.getTile(x, beamY);
            beamTile.blockID = TileID::marbleColumn;
            beamTile.blockPaint = getDeepRainbowPaint(x, beamY);
        } else {
            world.getTile(x, beamY).blockID = TileID::woodenBeam;
        }
    }
}

void clearTrackHex(Point centroid, World &world)
{
    iterateZone(
        centroid,
        world,
        [centroid](Point pt) { return getHexCentroid(pt, 10) == centroid; },
        [&world](Point pt) {
            Tile &prevTile = world.getTile(pt.x, pt.y - 1);
            if (!canTrackClearTile(prevTile) &&
                prevTile.blockID != TileID::minecartTrack &&
                prevTile.blockID != TileID::platform) {
                return;
            }
            Tile &tile = world.getTile(pt);
            if (!tile.guarded && canTrackClearTile(tile)) {
                tile.blockID = TileID::empty;
                tile.actuator = false;
            }
        });
    for (int i = -10; i < 10; ++i) {
        applyTrackGrass(centroid.x + i, centroid.y, world);
        applyTrackGrass(centroid.x + i, centroid.y + 10, world);
    }
}

void genTracks(Random &rnd, World &world)
{
    std::cout << "Installing tracks\n";
    rnd.shuffleNoise();
    int numTracks = world.conf.minecartTracks * world.getWidth() *
                    world.getHeight() / rnd.getInt(640000, 960000);
    int maxTries = 5000 * numTracks;
    for (int tries = 0; numTracks > 0 && tries < maxTries; ++tries) {
        auto track = tries == 0
                         ? planSurfaceTrack(rnd, world)
                         : planTrack(
                               world.conf.minecartLength > 1.0
                                   ? std::lerp(
                                         world.conf.minecartLength,
                                         1.0,
                                         static_cast<double>(tries) / maxTries)
                                   : world.conf.minecartLength,
                               rnd,
                               world);
        if (track.empty()) {
            continue;
        }
        Mode prevMode = Mode::none;
        int noiseRow = track.front().y;
        std::set<Point> clearedHexes;
        for (size_t idx = 0; idx < track.size(); ++idx) {
            auto [x, y] = track[idx];
            int height = 7 + 2.9 * rnd.getFineNoise(2 * x, noiseRow);
            bool isEndpoint = idx == 0 || idx + 1 == track.size();
            if (isEndpoint) {
                height *= 0.3;
            } else if (idx == 1 || idx == track.size() - 2) {
                height *= 0.8;
            }
            if (world.conf.hiveQueen) {
                Point centroid = getHexCentroid(x, y - height, 10);
                if (!clearedHexes.contains(centroid) && centroid.y + 4 < y) {
                    clearTrackHex(centroid, world);
                    clearedHexes.insert(centroid);
                }
            }
            for (int j = -height; j < 0; ++j) {
                Tile &tile = world.getTile(x, y + j);
                tile.blockID = TileID::empty;
                tile.actuator = false;
            }
            Tile &tile = world.getTile(x, y);
            if (isEndpoint) {
                tile.blockID = TileID::empty;
                applyTrackGrass(x, y, world);
                continue;
            }
            tile.blockID = TileID::minecartTrack;
            tile.blockPaint = world.conf.celebration
                                  ? getDeepRainbowPaint(x, tries)
                                  : Paint::none;
            Mode mode = idx + 2 == track.size() ? Mode::none
                        : y > track[idx + 1].y  ? Mode::asc
                        : y < track[idx + 1].y  ? Mode::desc
                                                : Mode::flat;
            switch (prevMode) {
            case Mode::none:
                tile.frameX = mode == Mode::asc    ? Track::ascEndLeft
                              : mode == Mode::desc ? Track::descEndLeft
                                                   : Track::flatEndLeft;
                break;
            case Mode::flat:
                tile.frameX = mode == Mode::none   ? Track::flatEndRight
                              : mode == Mode::flat ? Track::flat
                              : mode == Mode::asc  ? Track::flatToAsc
                                                   : Track::flatToDesc;
                break;
            case Mode::asc:
                tile.frameX = mode == Mode::none   ? Track::ascEndRight
                              : mode == Mode::flat ? Track::ascToFlat
                                                   : Track::asc;
                break;
            case Mode::desc:
                tile.frameX = mode == Mode::none   ? Track::descEndRight
                              : mode == Mode::flat ? Track::descToFlat
                                                   : Track::desc;
                break;
            }
            tile.frameY = -1;
            prevMode = mode;
            applyTrackGrass(x, y, world);
            Tile &supportTile = world.getTile(x, y + 1);
            if (tile.frameX == Track::flat &&
                supportTile.blockID == TileID::empty) {
                if (world.conf.celebration) {
                    placePlatform(x, y + 1, Platform::balloon, world);
                } else {
                    placePlatform(x, y + 1, Platform::stone, world);
                    supportTile.blockPaint = Paint::brown;
                }
                supportTile.guarded = true;
                applyTrackSupport(x - 1, y + 1, world);
            }
        }
        --numTracks;
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/MinecartTracks.h`
```
#ifndef MINECARTTRACKS_H
#define MINECARTTRACKS_H

class World;
class Random;

void genTracks(Random &rnd, World &world);

#endif // MINECARTTRACKS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/MushroomCabin.cpp`
```
#include "structures/MushroomCabin.h"

#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/Statues.h"
#include "structures/StructureUtil.h"
#include "structures/data/Furniture.h"
#include "structures/data/Mushrooms.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

Point selectCabinLocation(
    Point center,
    int cabinWidth,
    Random &rnd,
    World &world)
{
    int scanX = 0.02 * world.getWidth();
    int scanY = scanX / 2;
    constexpr auto allowedTiles = frozen::make_set<int>(
        {TileID::empty,
         TileID::mud,
         TileID::mushroomGrass,
         TileID::silt,
         TileID::slime});
    for (int tries = 0; tries < 1000; ++tries) {
        int x = rnd.getInt(center.x - scanX - cabinWidth, center.x + scanX);
        int y = rnd.getInt(center.y - scanY, center.y + scanY);
        if (world.regionPasses(x, y, cabinWidth, 18, [](Tile &tile) {
                return tile.blockID == TileID::empty &&
                       (tile.wallID == WallID::empty ||
                        tile.wallID == WallID::Unsafe::mushroom);
            })) {
            std::vector<int> surface;
            for (int i = 0; i < cabinWidth; ++i) {
                surface.push_back(scanWhileEmpty({x + i, y}, {0, 1}, world).y);
            }
            std::sort(surface.begin(), surface.end());
            y = surface[0.75 * surface.size()];
            if (world.regionPasses(
                    x - 5,
                    y - 18,
                    cabinWidth + 10,
                    20,
                    [&allowedTiles](Tile &tile) {
                        return !tile.guarded &&
                               allowedTiles.contains(tile.blockID);
                    })) {
                return {x, y};
            }
        }
    }
    return {-1, -1};
}

int placeMushroomStruct(
    int x,
    int y,
    int mushroomId,
    int paint,
    Random &rnd,
    World &world)
{
    TileBuffer data = Data::getMushroom(mushroomId, world.getFramedTiles());
    bool mirror = rnd.getBool();
    for (int i = 0; i < data.getWidth(); ++i) {
        int dataI = mirror ? data.getWidth() - 1 - i : i;
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &dataTile = data.getTile(dataI, j);
            if (dataTile.blockID == TileID::empty) {
                continue;
            }
            Tile &tile = world.getTile(x + i, y + j + 1 - data.getHeight());
            tile.blockID =
                std::abs(rnd.getFineNoise(x + 3 * i, y + 3 * j)) > 0.3
                    ? TileID::slime
                    : TileID::mud;
            tile.blockPaint =
                tile.blockID == TileID::slime ? paint : Paint::none;
            tile.wallID = WallID::Unsafe::mushroom;
            tile.liquid = Liquid::none;
        }
    }
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &tile = world.getTile(x + i, y + j + 1 - data.getHeight());
            if (!world.isExposed(x + i, y + j + 1 - data.getHeight())) {
                tile.guarded = true;
            } else if (tile.blockID == TileID::mud) {
                tile.blockID = TileID::mushroomGrass;
                tile.blockPaint = paint;
            }
        }
    }
    return data.getWidth() / 2;
}

bool canPlaceCabinFurniture(int x, int y, TileBuffer &data, World &world)
{
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            switch (data.getTile(i, j).blockID) {
            case TileID::empty:
                if (isSolidBlock(tile.blockID)) {
                    return false;
                }
                break;
            case TileID::cloud:
                if (!isSolidBlock(tile.blockID) || tile.actuated) {
                    return false;
                }
                break;
            default:
                if (tile.blockID != TileID::empty) {
                    return false;
                }
                break;
            }
        }
    }
    return true;
}

void placeMushroomFurniture(
    std::vector<Point> &&locations,
    Random &rnd,
    World &world)
{
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    std::vector<int> furniture{
        Data::furnitureLayouts.begin(),
        Data::furnitureLayouts.end()};
    std::shuffle(furniture.begin(), furniture.end(), rnd.getPRNG());
    auto furnitureItr = furniture.begin();
    double numPlacements = locations.size() / 50.0;
    int tries = 0;
    TileBuffer data;
    while (numPlacements > 0) {
        for (auto [x, y] : locations) {
            if (tries > 30) {
                tries = 0;
                numPlacements -= 0.1;
            }
            if (tries == 0) {
                data = getFurniture(
                    *furnitureItr,
                    Data::Variant::mushroom,
                    world.getFramedTiles());
                ++furnitureItr;
                if (furnitureItr == furniture.end()) {
                    furnitureItr = furniture.begin();
                }
            }
            ++tries;
            if (!canPlaceCabinFurniture(x, y, data, world)) {
                continue;
            }
            for (auto [chestX, chestY] :
                 world.placeBuffer(x, y, data, Blend::blockOnly)) {
                fillDresser(world.registerStorage(chestX, chestY), rnd);
            }
            tries = 0;
            --numPlacements;
            if (numPlacements < 0) {
                break;
            }
        }
    }
}

void genMushroomCabin(Random &rnd, World &world)
{
    std::cout << "Shaping mushrooms\n";
    std::vector<int> structIds{Data::mushrooms.begin(), Data::mushrooms.end()};
    std::shuffle(structIds.begin(), structIds.end(), rnd.getPRNG());
    auto mushroomItr = structIds.begin();
    for (Point center : world.mushroomCenter) {
        int cabinWidth = rnd.getInt(20, 30);
        auto [x, y] = selectCabinLocation(center, cabinWidth, rnd, world);
        if (x == -1) {
            continue;
        }
        for (int i = 0; i < cabinWidth; ++i) {
            for (int j = -10; j < 1; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.wallID != WallID::empty ||
                    rnd.getFineNoise(x + i, y + j) > 0.5) {
                    tile.wallID = WallID::Unsafe::mud;
                }
            }
        }
        bool isHallow =
            !world.regionPasses(x, y, cabinWidth, 10, [](Tile &tile) {
                return tile.blockPaint != Paint::pink;
            });
        for (int i = -10; i < cabinWidth - 8; i += 2) {
            i += placeMushroomStruct(
                x + i,
                y,
                *mushroomItr,
                isHallow ? Paint::pink : Paint::none,
                rnd,
                world);
            ++mushroomItr;
            if (mushroomItr == structIds.end()) {
                mushroomItr = structIds.begin();
            }
        }
        std::vector<Point> locations;
        for (int i = 0; i < cabinWidth; ++i) {
            for (int j = -8; j < 1; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                locations.emplace_back(x + i, y + j);
                if (i == 0 || i == cabinWidth - 1 || j == -8 || j == 0) {
                    if (tile.blockID == TileID::empty ||
                        (j > -5 && tile.blockID == TileID::mud)) {
                        tile.blockID = TileID::glowingMushroom;
                    }
                } else {
                    tile.blockID = TileID::empty;
                }
                tile.liquid = Liquid::none;
            }
        }
        world.placeFramedTile(x, y - 3, TileID::door, Variant::mushroom);
        world.placeFramedTile(
            x + cabinWidth - 1,
            y - 3,
            TileID::door,
            Variant::mushroom);
        Chest &chest = world.placeChest(
            x + rnd.getDouble(0.25, 0.75) * cabinWidth,
            y - 2,
            Variant::mushroom);
        fillMushroomChest(
            chest,
            getChestDepth(chest.x, chest.y, world),
            rnd,
            world);
        int statueX = x + rnd.getDouble(0.1, 0.9) * cabinWidth;
        if (world.regionPasses(statueX, y - 3, 2, 3, [](Tile &tile) {
                return tile.blockID == TileID::empty;
            })) {
            placeStatue(
                statueX,
                y - 3,
                rnd.pool(StatueVariants::utility),
                world);
        }
        statueX = x + rnd.getDouble(0.1, 0.9) * cabinWidth;
        if (world.regionPasses(statueX, y - 3, 2, 3, [](Tile &tile) {
                return tile.blockID == TileID::empty;
            })) {
            placeStatue(
                statueX,
                y - 3,
                rnd.select(StatueVariants::enemy),
                world);
        }
        statueX = x + rnd.getDouble(0.1, 0.9) * cabinWidth;
        if (world.regionPasses(statueX, y - 3, 2, 3, [](Tile &tile) {
                return tile.blockID == TileID::empty;
            })) {
            placeStatue(statueX, y - 3, Statue::mushroom, world);
        }
        placeMushroomFurniture(std::move(locations), rnd, world);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/MushroomCabin.h`
```
#ifndef MUSHROOMCABIN_H
#define MUSHROOMCABIN_H

class World;
class Random;

void genMushroomCabin(Random &rnd, World &world);

#endif // MUSHROOMCABIN_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/OceanWreck.cpp`
```
#include "structures/OceanWreck.h"

#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include "structures/data/Wrecks.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

bool tryPlaceWreck(int x, int y, TileBuffer &wreck, World &world)
{
    int surfaceLeft = y;
    int rightX = x + wreck.getWidth() - 1;
    int surfaceRight =
        scanWhileEmpty({rightX, world.getSurfaceLevel(rightX)}, {0, 1}, world)
            .y +
        1;
    constexpr auto clearableTiles = frozen::make_set<int>(
        {TileID::empty, TileID::sand, TileID::coralstone, TileID::honey});
    for (y += 1 - wreck.getHeight(); y <= surfaceLeft; ++y) {
        int jLeft = surfaceLeft - y;
        int jRight = surfaceRight - y;
        if (jLeft < 0 || jRight < 0 || jLeft >= wreck.getHeight() ||
            jRight >= wreck.getHeight() ||
            wreck.getTile(0, jLeft).blockPaint != Paint::red ||
            wreck.getTile(wreck.getWidth() - 1, jRight).blockPaint !=
                Paint::red ||
            !world.regionPasses(
                x,
                y,
                wreck.getWidth(),
                wreck.getHeight(),
                [&clearableTiles](Tile &tile) {
                    return !tile.guarded &&
                           clearableTiles.contains(tile.blockID);
                })) {
            continue;
        }
        world.placeBuffer(x, y, wreck);
        return true;
    }
    return false;
}

void genOceanWreck(Random &rnd, World &world)
{
    std::cout << "Dropping debris\n";
    std::vector<int> wrecks(Data::wrecks.begin(), Data::wrecks.end());
    std::shuffle(wrecks.begin(), wrecks.end(), rnd.getPRNG());
    wrecks.resize(rnd.getInt(2, 4));
    std::vector<int> locations(150);
    std::iota(
        locations.begin(),
        locations.end(),
        world.oceanCaveCenter > world.getWidth() / 2 ? 50
                                                     : world.getWidth() - 200);
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    auto locItr = locations.begin();
    for (int wreckId : wrecks) {
        TileBuffer wreck = Data::getWreck(wreckId, world.getFramedTiles());
        for (; locItr != locations.end(); ++locItr) {
            int x = *locItr;
            if (tryPlaceWreck(
                    x,
                    scanWhileEmpty({x, world.getSurfaceLevel(x)}, {0, 1}, world)
                            .y +
                        1,
                    wreck,
                    world)) {
                ++locItr;
                break;
            }
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/OceanWreck.h`
```
#ifndef OCEANWRECK_H
#define OCEANWRECK_H

class World;
class Random;

void genOceanWreck(Random &rnd, World &world);

#endif // OCEANWRECK_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Plants.cpp`
```
#include "structures/Plants.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/Traps.h"
#include "structures/data/Trees.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

bool isRegionEmpty(int x, int y, int width, int height, World &world)
{
    return world.regionPasses(x, y, width, height, [](Tile &tile) {
        return tile.blockID == TileID::empty;
    });
}

bool isSunken(int x, int y, World &world)
{
    int delta = world.conf.shattered ? 120 : 130;
    return world.conf.sunken && y < world.getUndergroundLevel() &&
           y > std::max(
                   {world.getSurfaceLevel(world.getWidth() / 2 - delta),
                    world.getSurfaceLevel(world.getWidth() / 2),
                    world.getSurfaceLevel(world.getWidth() / 2 + delta)}) +
                   (world.conf.shattered ? 3 : 0) &&
           hypot(world.spawn, {x, y}) > 38 && hypot(world.dungeon, {x, y}) > 78;
}

void growBamboo(int x, int y, Random &rnd, World &world)
{
    if (rnd.getDouble(0, 1) > 0.21) {
        return;
    }
    for (int i = 0; i < 11; ++i) {
        Tile &tile = world.getTile(x, y - i - 1);
        if (tile.blockID != TileID::empty ||
            (tile.liquid == Liquid::water && i > 4)) {
            return;
        }
    }
    int bambooSize = rnd.getInt(3, 10);
    int paint = world.getTile(x, y).blockPaint;
    for (int i = 0; i < bambooSize; ++i) {
        Tile &tile = world.getTile(x, y - i - 1);
        tile.blockID = TileID::bambooStalk;
        tile.blockPaint = paint;
        if (i == 0) {
            tile.frameX = 18 * rnd.getInt(0, 4);
        } else if (i == bambooSize - 1) {
            tile.frameX = 18 * rnd.getInt(14, 19);
        } else {
            tile.frameX = 18 * rnd.getInt(5, 13);
        }
    }
}

void growCactus(int x, int y, Random &rnd, World &world)
{
    if (rnd.getDouble(0, 1) > 0.07 ||
        !isRegionEmpty(x - 1, y - 8, 3, 8, world)) {
        if (static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) % 13 == 0) {
            world.queuedDeco.emplace_back([x, y](Random &, World &world) {
                if (isRegionEmpty(x, y - 2, 3, 2, world) &&
                    world.regionPasses(x, y, 3, 1, [](Tile &tile) {
                        return tile.blockID == TileID::sand &&
                               tile.slope == Slope::none;
                    })) {
                    world.placeFramedTile(
                        x,
                        y - 2,
                        TileID::largePileGroup2,
                        Variant::dryBone);
                }
            });
        }
        return;
    }
    int cactusSize = rnd.getInt(3, 7);
    for (int i = 0; i < cactusSize; ++i) {
        world.getTile(x, y - i - 1).blockID = TileID::cactusPlant;
        if (i > 0) {
            if (rnd.getInt(0, 4) <
                (world.getTile(x - 1, y - i).blockID == TileID::cactusPlant
                     ? 3
                     : 1)) {
                world.getTile(x - 1, y - i - 1).blockID = TileID::cactusPlant;
            }
            if (rnd.getInt(0, 4) <
                (world.getTile(x + 1, y - i).blockID == TileID::cactusPlant
                     ? 3
                     : 1)) {
                world.getTile(x + 1, y - i - 1).blockID = TileID::cactusPlant;
            }
        }
    }
}

void growPalmTree(int x, int y, Random &rnd, World &world)
{
    if (rnd.getDouble(0, 1) > 0.3 * world.conf.trees) {
        return;
    }
    for (int i = 0; i < 3; ++i) {
        if (world.getTile(x + i, y).blockID != TileID::sand) {
            return;
        }
    }
    if (world.getTile(x - 1, y - 2).blockID == TileID::palmTree ||
        world.getTile(x - 2, y - 2).blockID == TileID::palmTree) {
        return;
    }
    int height = rnd.getInt(10, 20);
    if (!isRegionEmpty(x, y - 4 - height, 3, height + 4, world)) {
        return;
    }
    int paint =
        world.conf.celebration ? getRainbowPaint(x / 6, y / 6) : Paint::none;
    int bend = 0;
    int targetBend = 2 * rnd.getInt(-8, 8);
    for (int j = 0; j < height; ++j) {
        Tile &tile = world.getTile(x + 1, y - j - 1);
        tile.blockID = TileID::palmTree;
        tile.blockPaint = paint;
        tile.frameX = j == height - 1 ? 22 * rnd.getInt(4, 6)
                      : j == 0        ? 66
                                      : 22 * rnd.getInt(0, 2);
        tile.frameY = bend;
        if (j * 4 > height) {
            if (bend > targetBend) {
                bend -= 2;
            } else if (bend < targetBend) {
                bend += 2;
            }
        }
    }
}

void growSandPlant(int x, int y, Random &rnd, World &world)
{
    if (isSunken(x, y, world)) {
        return;
    }
    Tile &probeTile = world.getTile(x, y - 1);
    if (probeTile.wallID != WallID::empty || probeTile.liquid != Liquid::none) {
        return;
    }
    int sandCount = 0;
    for (int i = -10; i < 10; ++i) {
        for (int j = -8; j < 8; ++j) {
            switch (world.getTile(x + i, y + j).blockID) {
            case TileID::grass:
            case TileID::cactusPlant:
                return;
            case TileID::sand:
            case TileID::hardenedSand:
            case TileID::ebonsand:
            case TileID::hardenedEbonsand:
            case TileID::crimsand:
            case TileID::hardenedCrimsand:
                ++sandCount;
                break;
            }
        }
    }
    if (sandCount < 15) {
        return;
    }
    if (x < 380 || x > world.getWidth() - 380) {
        growPalmTree(x, y, rnd, world);
        return;
    }
    int waterCount = 0;
    for (int i = -50; i < 50; ++i) {
        for (int j = -25; j < 25; ++j) {
            if (world.getTile(x + i, y + j).liquid == Liquid::water) {
                ++waterCount;
                if (waterCount > 5) {
                    growPalmTree(x, y, rnd, world);
                    return;
                }
            }
        }
    }
    growCactus(x, y, rnd, world);
}

void growRollingCactus(int x, int y, World &world)
{
    Tile &probeTile = world.getTile(x, y - 1);
    if ((probeTile.wallID != WallID::Unsafe::sandstone &&
         probeTile.wallID != WallID::Unsafe::hardenedSand) ||
        probeTile.liquid != Liquid::none) {
        return;
    }
    world.queuedTraps.emplace_back([x, y](Random &, World &world) {
        if (isRegionEmpty(x - 1, y - 3, 4, 3, world)) {
            world.placeFramedTile(x, y - 2, TileID::rollingCactus);
        }
    });
}

void growTree(
    int x,
    int y,
    int groundTile,
    int treeTile,
    Random &rnd,
    World &world)
{
    if (isSunken(x, y, world)) {
        return;
    }
    for (int i = 0; i < 3; ++i) {
        if (world.getTile(x + i, y).blockID != groundTile) {
            return;
        }
    }
    constexpr auto treeTiles = frozen::make_set<int>(
        {TileID::tree,
         TileID::sakuraTree,
         TileID::yellowWillowTree,
         TileID::ashTree,
         TileID::amethystTree,
         TileID::topazTree,
         TileID::sapphireTree,
         TileID::emeraldTree,
         TileID::rubyTree,
         TileID::amberTree,
         TileID::diamondTree});
    if (treeTiles.contains(world.getTile(x - 1, y - 2).blockID) ||
        treeTiles.contains(world.getTile(x - 2, y - 2).blockID)) {
        return;
    }
    int height = rnd.getInt(7, 15);
    if (!isRegionEmpty(x, y - 4 - height, 3, height + 4, world)) {
        return;
    }
    if (y < world.getUndergroundLevel()) {
        for (int i = 0; i < 3; ++i) {
            world.getTile(x + i, y).wallID = WallID::empty;
        }
    }
    constexpr auto gemTrees = frozen::make_set<int>(
        {TileID::amethystTree,
         TileID::topazTree,
         TileID::sapphireTree,
         TileID::emeraldTree,
         TileID::rubyTree,
         TileID::amberTree,
         TileID::diamondTree});
    int paint = gemTrees.contains(treeTile) ? Paint::none
                : world.conf.celebration    ? getRainbowPaint(x / 6, y / 6)
                                         : world.getTile(x + 1, y).blockPaint;
    for (int j = 0; j < height; ++j) {
        TileBuffer tree =
            Data::getTree(rnd.select(Data::trees), world.getFramedTiles());
        int treeRow = j > height - 3 ? j - height + tree.getHeight()
                      : j < 2        ? j
                                     : rnd.getInt(2, tree.getHeight() - 3);
        for (int i = 0; i < tree.getWidth(); ++i) {
            Tile &tile = world.getTile(x + i, y + j - height);
            int curWall = tile.wallID;
            tile = tree.getTile(i, treeRow);
            if (tile.blockID != TileID::empty) {
                tile.blockID = treeTile;
                tile.blockPaint = paint;
            }
            tile.wallID = curWall;
        }
    }
}

bool inGemGrove(int x, int y, World &world)
{
    return hypot(world.gemGrove, {x, y}) < world.gemGroveSize;
}

void genPlants(const LocationBins &locations, Random &rnd, World &world)
{
    std::cout << "Growing trees\n";
    std::vector<Point> oreLocations;
    for (const auto &bin : locations) {
        for (auto [x, y] : bin.second) {
            int curTileID = world.getTile(x, y).blockID;
            switch (curTileID) {
            case TileID::ashGrass:
                if (world.getTile(x, y - 1).liquid == Liquid::none &&
                    rnd.getDouble(0, 1) < 0.18 * world.conf.trees) {
                    growTree(
                        x,
                        y,
                        TileID::ashGrass,
                        TileID::ashTree,
                        rnd,
                        world);
                }
                break;
            case TileID::corruptGrass:
            case TileID::corruptJungleGrass:
            case TileID::crimsonGrass:
            case TileID::crimsonJungleGrass:
            case TileID::grass:
            case TileID::hallowedGrass:
            case TileID::snow:
                if ((world.conf.dontDigUp ||
                     (y < world.getUndergroundLevel() &&
                      world.getTile(x, y - 1).wallID == WallID::empty)) &&
                    world.getTile(x, y - 1).liquid == Liquid::none &&
                    rnd.getDouble(0, 1) < 0.21 * world.conf.trees) {
                    growTree(
                        x,
                        y,
                        curTileID,
                        curTileID == TileID::grass &&
                                rnd.getDouble(0, 1) <
                                    (world.conf.celebration     ? 0.75
                                     : world.conf.doubleTrouble ? 0.23
                                                                : 0.1)
                            ? rnd.select(
                                  {TileID::sakuraTree,
                                   TileID::yellowWillowTree})
                            : TileID::tree,
                        rnd,
                        world);
                }
                break;
            case TileID::jungleGrass:
                if (y < world.getUndergroundLevel()) {
                    if (world.getTile(x, y - 1).liquid == Liquid::water) {
                        growBamboo(x, y, rnd, world);
                        if (world.getTile(x + 1, y).blockID ==
                            TileID::jungleGrass) {
                            growBamboo(x + 1, y, rnd, world);
                        }
                    } else if (
                        world.getTile(x, y - 1).liquid == Liquid::none &&
                        world.getTile(x, y - 1).wallID == WallID::empty &&
                        rnd.getDouble(0, 1) < 0.2 * world.conf.trees) {
                        growTree(
                            x,
                            y,
                            TileID::jungleGrass,
                            TileID::tree,
                            rnd,
                            world);
                    }
                } else if (
                    world.getTile(x, y - 1).liquid == Liquid::none &&
                    rnd.getDouble(0, 1) < 0.09 * world.conf.trees) {
                    growTree(
                        x,
                        y,
                        TileID::jungleGrass,
                        TileID::tree,
                        rnd,
                        world);
                }
                break;
            case TileID::mushroomGrass:
                if (world.getTile(x, y - 1).liquid == Liquid::none &&
                    rnd.getDouble(0, 1) < 0.35 * world.conf.trees) {
                    growTree(
                        x,
                        y,
                        TileID::mushroomGrass,
                        TileID::tree,
                        rnd,
                        world);
                }
                break;
            case TileID::sand:
                if (y < world.getUndergroundLevel()) {
                    growSandPlant(x, y, rnd, world);
                    break;
                }
                [[fallthrough]];
            case TileID::hardenedSand:
            case TileID::sandstone:
                if (static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) %
                        std::max<int>(
                            11 / std::max(world.conf.traps, 0.1),
                            2) ==
                    0) {
                    growRollingCactus(x, y, world);
                }
                break;
            case TileID::stone:
            case TileID::pearlstone:
                if ((y > world.getCavernLevel() || world.conf.dontDigUp) &&
                    world.getTile(x, y - 1).liquid == Liquid::none &&
                    (static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) %
                             std::max<int>(
                                 (world.conf.celebration ? 75 : 100) /
                                     std::max(world.conf.trees, 0.1),
                                 2) ==
                         0 ||
                     (inGemGrove(x, y, world) &&
                      rnd.getDouble(0, 1) <
                          0.85 * std::max(world.conf.trees, 0.95)))) {
                    growTree(
                        x,
                        y,
                        TileID::stone,
                        rnd.select(
                            {TileID::amethystTree,
                             TileID::topazTree,
                             TileID::sapphireTree,
                             TileID::emeraldTree,
                             TileID::rubyTree,
                             TileID::amberTree,
                             TileID::diamondTree}),
                        rnd,
                        world);
                }
                break;
            case TileID::copperOre:
            case TileID::tinOre:
            case TileID::ironOre:
            case TileID::leadOre:
            case TileID::silverOre:
            case TileID::tungstenOre:
            case TileID::goldOre:
            case TileID::platinumOre:
                oreLocations.emplace_back(x, y);
                break;
            }
        }
    }
    world.queuedTraps.emplace_back(
        [locs = std::move(oreLocations)](Random &rnd, World &world) mutable {
            addOreTraps(std::move(locs), rnd, world);
        });
}

void placeLivingTreeDecoAt(int x, Random &rnd, World &world)
{
    int y = world.getSurfaceLevel(x);
    switch (static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) % 5) {
    case 0:
        for (int j = -10; j < 10; ++j) {
            if (world.regionPasses(
                    x,
                    y + j,
                    2,
                    1,
                    [](Tile &tile) {
                        return tile.blockID == TileID::empty &&
                               tile.wallID == WallID::empty;
                    }) &&
                world.regionPasses(x, y + j + 1, 2, 1, [](Tile &tile) {
                    return tile.slope == Slope::none &&
                           (tile.blockID == TileID::grass ||
                            tile.blockID == TileID::livingWood);
                })) {
                world.placeFramedTile(
                    x,
                    y + j,
                    TileID::smallPile,
                    Variant::livingWood);
                return;
            }
        }
        break;
    case 1:
        for (int j = -10; j < 10; ++j) {
            if (world.regionPasses(
                    x,
                    y + j,
                    3,
                    2,
                    [](Tile &tile) {
                        return tile.blockID == TileID::empty &&
                               tile.wallID == WallID::empty;
                    }) &&
                world.regionPasses(x, y + j + 2, 3, 1, [](Tile &tile) {
                    return tile.slope == Slope::none &&
                           (tile.blockID == TileID::grass ||
                            tile.blockID == TileID::livingWood);
                })) {
                world.placeFramedTile(
                    x,
                    y + j,
                    TileID::largePileGroup2,
                    Variant::livingWood);
                return;
            }
        }
        break;
    case 2:
    case 3:
        for (int j = -120; j < -10; ++j) {
            if (world.regionPasses(
                    x,
                    y + j + 2,
                    3,
                    1,
                    [](Tile &tile) {
                        return tile.blockID == TileID::leaf &&
                               tile.slope == Slope::none;
                    }) &&
                world.regionPasses(x, y + j, 3, 2, [](Tile &tile) {
                    return tile.blockID == TileID::empty &&
                           tile.wallID == WallID::empty;
                })) {
                world.placeFramedTile(
                    x,
                    y + j,
                    TileID::largePileGroup2,
                    Variant::livingLeaf,
                    world.getTile(x, y + j + 2).blockPaint);
                return;
            }
        }
        break;
    }
}

void growLivingTreeDeco(Random &rnd, World &world)
{
    int doPlacementUntil = -1;
    for (int x = 300; x < world.getWidth() - 300; ++x) {
        if (world.getTile(x, world.getSurfaceLevel(x)).blockID ==
            TileID::livingWood) {
            doPlacementUntil = x + 20;
        }
        if (x - 20 < doPlacementUntil) {
            placeLivingTreeDecoAt(x - 20, rnd, world);
        }
    }
}

bool placeSmallPile(int x, int y, World &world)
{
    Tile &nextBase = world.getTile(x + 1, y);
    if (nextBase.blockID != world.getTile(x, y).blockID ||
        nextBase.slope != Slope::none ||
        world.getTile(x + 1, y - 1).blockID != TileID::empty) {
        return false;
    }
    if (!world.regionPasses(x - 1, y - 1, 4, 3, [](Tile &tile) {
            return tile.wallID != WallID::Unsafe::spider;
        })) {
        world.placeFramedTile(x, y - 1, TileID::smallPile, Variant::spider);
        return true;
    }
    switch (nextBase.blockID) {
    case TileID::ash:
    case TileID::ashGrass:
    case TileID::blueBrick:
    case TileID::greenBrick:
    case TileID::pinkBrick:
    case TileID::hellstone:
    case TileID::hellstoneBrick:
    case TileID::obsidianBrick:
        world.placeFramedTile(
            x,
            y - 1,
            TileID::smallPile,
            y < world.getUndergroundLevel() ? Variant::stone : Variant::bone);
        return true;
    case TileID::dirt:
        world.placeFramedTile(x, y - 1, TileID::smallPile, Variant::dirt);
        return true;
    case TileID::granite:
        world.placeFramedTile(x, y - 1, TileID::smallPile, Variant::granite);
        return true;
    case TileID::grass:
    case TileID::hallowedGrass:
        world.placeFramedTile(x, y - 1, TileID::smallPile, Variant::forest);
        return true;
    case TileID::ice:
    case TileID::snow:
        world.placeFramedTile(x, y - 1, TileID::smallPile, Variant::ice);
        return true;
    case TileID::marble:
        world.placeFramedTile(x, y - 1, TileID::smallPile, Variant::marble);
        return true;
    case TileID::sandstone:
        world.placeFramedTile(x, y - 1, TileID::smallPile, Variant::sandstone);
        return true;
    case TileID::stone:
        world.placeFramedTile(x, y - 1, TileID::smallPile, Variant::stone);
        return true;
    }
    return false;
}

bool placeLargePile(int x, int y, World &world)
{
    if (!isRegionEmpty(x, y - 2, 3, 2, world) ||
        !world.regionPasses(x + 1, y, 2, 1, [](Tile &tile) {
            return tile.slope == Slope::none && isSolidBlock(tile.blockID);
        })) {
        return false;
    }
    if (!world.regionPasses(x - 1, y - 1, 5, 4, [](Tile &tile) {
            return tile.wallID != WallID::Unsafe::spider;
        })) {
        world.placeFramedTile(
            x,
            y - 2,
            TileID::largePileGroup2,
            Variant::spider);
        return true;
    }
    switch (world.getTile(x + 1, y).blockID) {
    case TileID::ash:
    case TileID::ashGrass:
    case TileID::hellstone:
    case TileID::hellstoneBrick:
    case TileID::obsidianBrick:
        if (y > world.getUnderworldLevel() && fnv1a32pt(x, y) % 5 == 0) {
            world.placeFramedTile(x, y - 2, TileID::largePile, Variant::bone);
        } else {
            world.placeFramedTile(
                x,
                y - 2,
                TileID::largePileGroup2,
                Variant::ash);
        }
        return true;
    case TileID::blueBrick:
    case TileID::greenBrick:
    case TileID::pinkBrick:
        if (y > world.getUndergroundLevel() && fnv1a32pt(x, y) % 5 == 0) {
            world.placeFramedTile(x, y - 2, TileID::largePile, Variant::bone);
            return true;
        }
        return false;
    case TileID::granite:
        world.placeFramedTile(
            x,
            y - 2,
            TileID::largePileGroup2,
            Variant::granite);
        return true;
    case TileID::grass:
    case TileID::hallowedGrass:
        world.placeFramedTile(
            x,
            y - 2,
            TileID::largePileGroup2,
            Variant::forest);
        return true;
    case TileID::ice:
    case TileID::snow:
        world.placeFramedTile(x, y - 2, TileID::largePile, Variant::ice);
        return true;
    case TileID::jungleGrass:
        world.placeFramedTile(
            x,
            y - 2,
            TileID::largePileGroup2,
            Variant::jungle);
        return true;
    case TileID::lihzahrdBrick:
        if (world.getTile(x + 1, y - 1).wallID ==
            WallID::Unsafe::lihzahrdBrick) {
            world.placeFramedTile(
                x,
                y - 2,
                TileID::largePileGroup2,
                Variant::lihzahrd);
            return true;
        }
        return false;
    case TileID::marble:
        world.placeFramedTile(
            x,
            y - 2,
            TileID::largePileGroup2,
            Variant::marble);
        return true;
    case TileID::mushroomGrass:
        world.placeFramedTile(x, y - 2, TileID::largePile, Variant::mushroom);
        return true;
    case TileID::sandstone:
    case TileID::ebonsandstone:
    case TileID::crimsandstone:
    case TileID::pearlsandstone:
        world.placeFramedTile(
            x,
            y - 2,
            TileID::largePileGroup2,
            Variant::sandstone);
        return true;
    case TileID::stone:
        world.placeFramedTile(x, y - 2, TileID::largePile, Variant::stone);
        return true;
    }
    return false;
}

bool placeSunflower(int x, int y, World &world)
{
    Tile &nextBase = world.getTile(x + 1, y);
    if (nextBase.blockID != TileID::grass || nextBase.slope != Slope::none ||
        !world.regionPasses(x, y - 4, 2, 4, [&world](Tile &tile) {
            return tile.blockID == TileID::empty &&
                   (tile.wallID == WallID::empty || world.conf.dontDigUp);
        })) {
        return false;
    }
    world.placeFramedTile(x, y - 4, TileID::sunflower);
    return true;
}

bool placeGeyser(int x, int y, World &world)
{
    int lavaLevel =
        (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    if (y > lavaLevel && isRegionEmpty(x, y - 3, 2, 3, world) &&
        world.regionPasses(x, y, 2, 1, [&world](Tile &tile) {
            return tile.slope == Slope::none &&
                   (tile.blockID == TileID::ash ||
                    tile.blockID == TileID::jungleGrass ||
                    tile.blockID == TileID::stone ||
                    (tile.blockID == TileID::obsidianBrick &&
                     tile.wallID != WallID::Unsafe::obsidianBrick &&
                     world.conf.traps > 14));
        })) {
        world.placeFramedTile(x, y - 1, TileID::geyser);
        return true;
    }
    return false;
}

void growGrass(int x, int y, Random &rnd, World &world)
{
    Tile &baseTile = world.getTile(x, y);
    Tile &probeTile = world.getTile(x, y - 1);
    if (baseTile.slope != Slope::none || probeTile.blockID != TileID::empty) {
        return;
    }
    int randInt = 99999 * (1 + rnd.getFineNoise(x, y));
    if (probeTile.liquid == Liquid::water &&
        (baseTile.blockID == TileID::sand ||
         baseTile.blockID == TileID::coralstone) &&
        (x < 200 || x > world.getWidth() - 200) && randInt % 7 == 0) {
        probeTile.blockID = TileID::coral;
        probeTile.frameX = 26 * (fnv1a32pt(x, y) % 6);
        return;
    }
    if (probeTile.liquid != Liquid::none) {
        return;
    }
    if (randInt % 61 < 2) {
        probeTile.blockID = TileID::herb;
        switch (baseTile.blockID) {
        case TileID::ash:
        case TileID::ashGrass:
            probeTile.frameX = 90;
            return;
        case TileID::corruptGrass:
        case TileID::corruptJungleGrass:
        case TileID::crimsonGrass:
        case TileID::crimsonJungleGrass:
        case TileID::ebonstone:
        case TileID::crimstone:
            probeTile.frameX = 54;
            return;
        case TileID::dirt:
        case TileID::mud:
            probeTile.frameX = 36;
            return;
        case TileID::grass:
        case TileID::hallowedGrass:
            return;
        case TileID::jungleGrass:
            if (randInt % 61 == 0) {
                probeTile.frameX = 18;
                return;
            }
            break;
        case TileID::sand:
        case TileID::pearlsand:
            if (x > 350 && x < world.getWidth() - 350) {
                probeTile.frameX = 72;
                return;
            }
            break;
        case TileID::snow:
        case TileID::ice:
            if (randInt % 61 == 0) {
                probeTile.frameX = 108;
                return;
            }
            break;
        }
        probeTile.blockID = TileID::empty;
    }
    bool increasedPileRate = probeTile.wallID == WallID::Unsafe::granite ||
                             probeTile.wallID == WallID::Unsafe::marble;
    if (randInt % 41 < (increasedPileRate ? 5 : 1) &&
        placeSmallPile(x, y, world)) {
        return;
    }
    if (randInt % 37 < (increasedPileRate ? 6 : 1) &&
        placeLargePile(x, y, world)) {
        return;
    }
    if (randInt % std::max<int>(131 / std::max(world.conf.traps, 0.1), 7) ==
            0 &&
        placeGeyser(x, y, world)) {
        return;
    }
    if (baseTile.blockID == TileID::grass &&
        randInt % (world.conf.dontDigUp ? 11 : 3) == 0 &&
        rnd.getCoarseNoise(x, y) < -0.3 && placeSunflower(x, y, world)) {
        return;
    }
    switch (baseTile.blockID) {
    case TileID::ashGrass:
        world.placeFramedTile(x, y - 1, TileID::ashPlant);
        break;
    case TileID::corruptGrass:
        world.placeFramedTile(x, y - 1, TileID::corruptPlant);
        break;
    case TileID::crimsonGrass:
        world.placeFramedTile(x, y - 1, TileID::crimsonPlant);
        break;
    case TileID::grass:
        world.placeFramedTile(
            x,
            y - 1,
            rnd.getCoarseNoise(x, y) > 0 ? TileID::tallGrassPlant
                                         : TileID::grassPlant);
        break;
    case TileID::jungleGrass:
        if (isRegionEmpty(x, y - 2, 3, 2, world) &&
            world.regionPasses(
                x + 1,
                y,
                2,
                1,
                [](Tile &tile) {
                    return tile.blockID == TileID::jungleGrass &&
                           tile.slope == Slope::none;
                }) &&
            randInt % 3 != 0) {
            world.placeFramedTile(x, y - 2, TileID::largeJunglePlant);
            break;
        }
        world.placeFramedTile(
            x,
            y - 1,
            rnd.getCoarseNoise(x, y) > 0 ? TileID::tallJunglePlant
                                         : TileID::junglePlant);
        world.getTile(x, y - 1).blockPaint = world.getTile(x, y).blockPaint;
        break;
    case TileID::mushroomGrass:
        world.placeFramedTile(x, y - 1, TileID::mushroomPlant);
        world.getTile(x, y - 1).blockPaint = world.getTile(x, y).blockPaint;
        break;
    }
}

void genGrasses(const LocationBins &locations, Random &rnd, World &world)
{
    std::cout << "Growing plants\n";
    rnd.shuffleNoise();
    for (const auto &applyQueuedDeco : world.queuedDeco) {
        applyQueuedDeco(rnd, world);
    }
    growLivingTreeDeco(rnd, world);
    for (const auto &bin : locations) {
        for (auto [x, y] : bin.second) {
            growGrass(x, y, rnd, world);
            growGrass(x + 1, y, rnd, world);
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Plants.h`
```
#ifndef PLANTS_H
#define PLANTS_H

#include "structures/StructureUtil.h"

class World;
class Random;

void genPlants(const LocationBins &locations, Random &rnd, World &world);
void genGrasses(const LocationBins &locations, Random &rnd, World &world);

#endif // PLANTS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Platforms.cpp`
```
#include "structures/Platforms.h"

#include "World.h"
#include "structures/StructureUtil.h"

namespace Anchor
{
enum {
    flat = 0,
    endcapRight = 18,
    endcapLeft = 36,
    attachLeft = 54,
    attachRight = 72,
    single = 90,
    attachLeftEndcap = 108,
    attachRightEndcap = 126
};
}

void updatePlatformAnchor(int x, int y, World &world)
{
    Tile &cur = world.getTile(x, y);
    if (cur.blockID != TileID::platform) {
        return;
    }
    Tile &prev = world.getTile(x - 1, y);
    Tile &next = world.getTile(x + 1, y);
    if (prev.blockID == TileID::platform) {
        if (next.blockID == TileID::platform) {
            cur.frameX = Anchor::flat;
        } else if (isSolidBlock(next.blockID)) {
            cur.frameX = Anchor::attachRight;
        } else {
            cur.frameX = Anchor::endcapRight;
        }
    } else if (isSolidBlock(prev.blockID)) {
        if (next.blockID == TileID::platform) {
            cur.frameX = Anchor::attachLeft;
        } else if (isSolidBlock(next.blockID)) {
            cur.frameX = Anchor::single;
        } else {
            cur.frameX = Anchor::attachLeftEndcap;
        }
    } else {
        if (next.blockID == TileID::platform) {
            cur.frameX = Anchor::endcapLeft;
        } else if (isSolidBlock(next.blockID)) {
            cur.frameX = Anchor::attachRightEndcap;
        } else {
            cur.frameX = Anchor::single;
        }
    }
}

void placePlatform(int x, int y, int style, World &world)
{
    Tile &cur = world.getTile(x, y);
    cur.blockID = TileID::platform;
    cur.frameY = style;
    updatePlatformAnchor(x - 1, y, world);
    updatePlatformAnchor(x, y, world);
    updatePlatformAnchor(x + 1, y, world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Platforms.h`
```
#ifndef PLATFORMS_H
#define PLATFORMS_H

class World;

namespace Platform
{
enum {
    metalShelf = 162,
    brassShelf = 180,
    woodShelf = 198,
    dungeonShelf = 216,
    obsidian = 234,
    lihzahrd = 594,
    stone = 774,
    balloon = 828,
};
}

void placePlatform(int x, int y, int style, World &world);

#endif // PLATFORMS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Pyramid.cpp`
```
#include "structures/Pyramid.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/data/Rooms.h"
#include "vendor/frozen/map.h"
#include "vendor/frozen/set.h"
#include <iostream>
#include <map>
#include <set>

template <typename T> constexpr int getOrKey(const T &data, int key)
{
    auto itr = data.find(key);
    return itr == data.end() ? key : itr->second;
}

std::pair<int, int> makeHall(int x, int y, int steps, Point delta, World &world)
{
    constexpr auto accent1 = frozen::make_map<int, int>(
        {{WallID::Safe::sandstoneBrick, WallID::Safe::smoothSandstone},
         {WallID::Safe::ebonstoneBrick, WallID::Unsafe::ebonsandstone},
         {WallID::Safe::crimstoneBrick, WallID::Unsafe::crimsandstone},
         {WallID::Safe::pearlstoneBrick, WallID::Unsafe::pearlsandstone}});
    constexpr auto accent2 = frozen::make_map<int, int>(
        {{WallID::Safe::sandstoneBrick, WallID::Safe::goldBrick},
         {WallID::Safe::ebonstoneBrick, WallID::Safe::demoniteBrick},
         {WallID::Safe::crimstoneBrick, WallID::Safe::crimtaneBrick},
         {WallID::Safe::pearlstoneBrick, WallID::Safe::crystalBlock}});
    constexpr auto validBlocks = frozen::make_set<int>(
        {TileID::sandstoneBrick,
         TileID::ebonstoneBrick,
         TileID::crimstoneBrick,
         TileID::pearlstoneBrick});
    for (; steps > 0; --steps, x += delta.x, y += delta.y) {
        for (int j = 0; j < 7; ++j) {
            Tile &tile = world.getTile(x, y + j);
            if (validBlocks.contains(tile.blockID)) {
                tile.blockID = TileID::empty;
                if (j == 0) {
                    tile.wallID = getOrKey(accent1, tile.wallID);
                } else if (j == 1) {
                    tile.wallID = getOrKey(accent2, tile.wallID);
                }
            }
        }
    }
    return {x, y};
}

void placePyramidPainting(int x, int y, World &world)
{
    world.placePainting(x, y, Painting::ancientTablet);
    int numCorrupt = 0;
    int numCrimson = 0;
    auto [width, height] = world.getPaintingDims(Painting::ancientTablet);
    constexpr auto corruptWalls = frozen::make_set<int>(
        {WallID::Safe::ebonstoneBrick,
         WallID::Unsafe::ebonsandstone,
         WallID::Safe::demoniteBrick});
    constexpr auto crimsonWalls = frozen::make_set<int>(
        {WallID::Safe::crimstoneBrick,
         WallID::Unsafe::crimsandstone,
         WallID::Safe::crimtaneBrick});
    for (int i = 0; i < width; ++i) {
        for (int j = 0; j < height; ++j) {
            int wallId = world.getTile(x + i, y + j).wallID;
            if (corruptWalls.contains(wallId)) {
                ++numCorrupt;
            } else if (crimsonWalls.contains(wallId)) {
                ++numCrimson;
            }
        }
    }
    int paint = numCorrupt > width * height - 4   ? Paint::purple
                : numCrimson > width * height - 4 ? Paint::red
                                                  : Paint::none;
    if (paint != Paint::none) {
        for (int i = 0; i < width; ++i) {
            for (int j = 0; j < height; ++j) {
                world.getTile(x + i, y + j).blockPaint = paint;
            }
        }
    }
}

std::pair<int, int> fillTreasureRoom(int x, int y, Random &rnd, World &world)
{
    TileBuffer treasureRoom =
        Data::getRoom(rnd.select(Data::pyramidRooms), world.getFramedTiles());
    x -= treasureRoom.getWidth() - 1;
    int align = 0;
    for (int j = 0; j < treasureRoom.getHeight(); ++j) {
        if (treasureRoom.getTile(0, j).wallID ==
            WallID::Safe::smoothSandstone) {
            align = -j;
            break;
        }
    }
    for (int i = 0; i < treasureRoom.getWidth(); ++i) {
        for (int j = 0; j < treasureRoom.getHeight(); ++j) {
            Tile &roomTile = treasureRoom.getTile(i, j);
            if (roomTile.blockID == TileID::chest &&
                roomTile.frameX % 36 == 0 && roomTile.frameY == 0) {
                fillPyramidChest(
                    world.registerStorage(x + i, y + j + align),
                    rnd,
                    world);
            }
            Tile &tile = world.getTile(x + i, y + j + align);
            std::map<int, int> blockMap{{roomTile.blockID, roomTile.blockID}};
            std::map<int, int> wallMap{{roomTile.wallID, roomTile.wallID}};
            if (tile.blockID == TileID::ebonstoneBrick ||
                tile.blockID == TileID::lesion) {
                blockMap[TileID::sand] = TileID::ebonsand;
                blockMap[TileID::sandstoneBrick] = TileID::ebonstoneBrick;
                wallMap[WallID::Safe::smoothSandstone] =
                    WallID::Unsafe::ebonsandstone;
                wallMap[WallID::Safe::goldBrick] = WallID::Safe::demoniteBrick;
                wallMap[WallID::Safe::sandstoneBrick] =
                    WallID::Safe::ebonstoneBrick;
            } else if (
                tile.blockID == TileID::crimstoneBrick ||
                tile.blockID == TileID::flesh) {
                blockMap[TileID::sand] = TileID::crimsand;
                blockMap[TileID::sandstoneBrick] = TileID::crimstoneBrick;
                wallMap[WallID::Safe::smoothSandstone] =
                    WallID::Unsafe::crimsandstone;
                wallMap[WallID::Safe::goldBrick] = WallID::Safe::crimtaneBrick;
                wallMap[WallID::Safe::sandstoneBrick] =
                    WallID::Safe::crimstoneBrick;
            } else if (tile.blockID == TileID::pearlstoneBrick) {
                blockMap[TileID::sand] = TileID::pearlsand;
                blockMap[TileID::sandstoneBrick] = TileID::pearlstoneBrick;
                wallMap[WallID::Safe::smoothSandstone] =
                    WallID::Unsafe::pearlsandstone;
                wallMap[WallID::Safe::goldBrick] = WallID::Safe::crystalBlock;
                wallMap[WallID::Safe::sandstoneBrick] =
                    WallID::Safe::pearlstoneBrick;
            }
            roomTile.blockID = blockMap[roomTile.blockID];
            roomTile.wallID = wallMap[roomTile.wallID];
            tile = roomTile;
        }
    }
    for (int i = 0; i < treasureRoom.getWidth(); ++i) {
        if (world.regionPasses(
                x + i,
                y + 5,
                2,
                2,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
            rnd.getDouble(0, 1) < 0.9) {
            if (rnd.getDouble(0, 1) < 0.1) {
                world.placeFramedTile(
                    x + i,
                    y + 6,
                    TileID::smallPile,
                    Variant::gold);
            } else {
                world.placeFramedTile(
                    x + i,
                    y + 5,
                    TileID::pot,
                    Variant::pyramid);
            }
        }
    }
    for (int i : {1, 3, 10, 12, 23, 25, 32, 34}) {
        if (world.regionPasses(x + i, y, 1, 3, [](Tile &tile) {
                return tile.blockID == TileID::empty;
            })) {
            world.placeFramedTile(
                x + i,
                y,
                TileID::banner,
                rnd.select({Variant::ankh, Variant::omega, Variant::snake}));
        }
    }
    return {x - 1, y};
}

void applyGravity(int x, int y, int width, int height, World &world)
{
    constexpr auto unstableBlocks = frozen::make_set<int>(
        {TileID::sand, TileID::ebonsand, TileID::crimsand, TileID::pearlsand});
    for (int i = 0; i < width; ++i) {
        int lastGap = -1;
        std::set<int> fallenTiles;
        for (int j = height; j > -1; --j) {
            Tile &tile = world.getTile(x + i, y + j);
            if (tile.blockID == TileID::empty) {
                if (lastGap == -1) {
                    lastGap = j;
                }
            } else if (unstableBlocks.contains(tile.blockID)) {
                if (lastGap != -1) {
                    world.getTile(x + i, y + lastGap).blockID = tile.blockID;
                    tile.blockID = TileID::empty;
                    fallenTiles.insert(j);
                    --lastGap;
                }
            } else {
                lastGap = -1;
            }
        }
        int cloneWall = world.getTile(x + i, y).wallID;
        for (int j = 0; j < height; ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            if (tile.blockID != TileID::empty) {
                break;
            }
            if (fallenTiles.contains(j)) {
                tile.wallID = cloneWall;
            }
        }
    }
}

Point findLinkingCave(int x, int y, World &world)
{
    for (int j = 30; j < 200; ++j) {
        for (int iSwap = 0; iSwap < j; ++iSwap) {
            int i = iSwap / 2;
            if (iSwap % 2 == 0) {
                i = -i;
            }
            if (world.regionPasses(x + i - 2, y + j, 5, 4, [](Tile &tile) {
                    return tile.blockID == TileID::empty;
                })) {
                return {x + i, y + j};
            }
        }
    }
    return {-1, -1};
}

std::vector<int> getDesertSurfaceCols(int size, World &world)
{
    std::vector<int> vals;
    if (world.conf.biomes == BiomeLayout::columns) {
        double scanDist =
            world.conf.desertSize * 0.061 * world.getWidth() - size;
        for (int x = world.desertCenter - scanDist;
             x < world.desertCenter + scanDist;
             ++x) {
            vals.push_back(x);
        }
    } else {
        for (int x = 350; x < world.getWidth() - 350; ++x) {
            if (world.getBiome(x, world.getSurfaceLevel(x)).desert > 0.99) {
                vals.push_back(x);
            }
        }
    }
    return vals;
}

void applyPyramidPaint(std::vector<Point> &queuedPaint, World &world)
{
    for (Point pos : queuedPaint) {
        Tile &tile = world.getTile(pos);
        if (tile.blockID == TileID::sandstoneBrick ||
            tile.blockID == TileID::sandstoneColumn ||
            tile.blockID == TileID::pot) {
            tile.blockPaint = Paint::pink;
        }
        if (tile.wallID == WallID::Safe::sandstoneBrick) {
            tile.wallPaint = Paint::pink;
        } else if (tile.wallID == WallID::Safe::goldBrick) {
            tile.wallPaint = Paint::violet;
        }
    }
}

Point selectPyramidLocation(int size, Random &rnd, World &world)
{
    int x = world.surfaceEvilCenter;
    int numTries = 0;
    auto desertSurface = getDesertSurfaceCols(size, world);
    if (desertSurface.empty()) {
        return {-1, -1};
    }
    constexpr auto avoidTiles = frozen::make_set<int>(
        {TileID::blueBrick,
         TileID::greenBrick,
         TileID::pinkBrick,
         TileID::meteorite});
    while (std::abs(x - world.surfaceEvilCenter) < 1.5 * size ||
           std::abs(x - world.spawn.x) < 2 * size ||
           !world.regionPasses(
               x - size,
               world.getSurfaceLevel(x),
               2 * size,
               size,
               [&avoidTiles](Tile &tile) {
                   return !avoidTiles.contains(tile.blockID);
               })) {
        x = rnd.select(desertSurface);
        ++numTries;
        if (numTries > 1000) {
            return {-1, -1};
        }
    }
    int y = world.getSurfaceLevel(x);
    constexpr auto ignoreBlocks = frozen::make_set<int>(
        {TileID::empty, TileID::lesion, TileID::flesh, TileID::crystalBlock});
    while (ignoreBlocks.contains(world.getTile(x, y).blockID) &&
           y < 0.85 * world.getUndergroundLevel()) {
        ++y;
    }
    return {x - size, y - 5};
}

std::pair<int, int>
selectUndergroundPyramidLocation(int size, Random &rnd, World &world)
{
    int maxX = world.getWidth() - 350 - 2 * size;
    if (maxX < 400) {
        return {-1, -1};
    }
    constexpr auto clearableTiles = frozen::make_set<int>({
        TileID::empty,
        TileID::sand,
        TileID::hardenedSand,
        TileID::sandstone,
        TileID::ebonsand,
        TileID::hardenedEbonsand,
        TileID::ebonsandstone,
        TileID::demonite,
        TileID::lesion,
        TileID::crimsand,
        TileID::hardenedCrimsand,
        TileID::crimsandstone,
        TileID::crimtane,
        TileID::flesh,
        TileID::pearlsand,
        TileID::hardenedPearlsand,
        TileID::pearlsandstone,
        TileID::crystalBlock,
        TileID::desertFossil,
        TileID::copperOre,
        TileID::tinOre,
        TileID::ironOre,
        TileID::leadOre,
        TileID::silverOre,
        TileID::tungstenOre,
        TileID::goldOre,
        TileID::platinumOre,
        TileID::cobaltOre,
        TileID::palladiumOre,
        TileID::mythrilOre,
        TileID::orichalcumOre,
        TileID::adamantiteOre,
        TileID::titaniumOre,
    });
    for (int tries = 0; tries < 5000; ++tries) {
        int x = rnd.getInt(350, maxX);
        int y = rnd.getInt(
            world.getUndergroundLevel(),
            std::midpoint(world.getCavernLevel(), world.getUnderworldLevel()));
        int maxEmpty = 0.12 * size * size;
        if (world.regionPasses(
                x + size / 2,
                y,
                size,
                size / 2,
                [&clearableTiles](Tile &tile) {
                    return !tile.guarded && tile.liquid != Liquid::shimmer &&
                           clearableTiles.contains(tile.blockID);
                }) &&
            world.regionPasses(
                x,
                y + size / 2,
                2 * size,
                size / 2,
                [&maxEmpty, &clearableTiles](Tile &tile) {
                    if (tile.blockID == TileID::empty) {
                        --maxEmpty;
                    }
                    return maxEmpty > 0 && !tile.guarded &&
                           tile.liquid != Liquid::shimmer &&
                           (clearableTiles.contains(tile.blockID) ||
                            tile.flag == Flag::border);
                })) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void genPyramid(Random &rnd, World &world)
{
    std::cout << "Building monuments\n";
    int size = 80;
    auto [x, y] = selectPyramidLocation(size, rnd, world);
    if (x == -1) {
        std::tie(x, y) = selectUndergroundPyramidLocation(size, rnd, world);
        if (x == -1) {
            return;
        }
    }
    constexpr auto convertTiles = frozen::make_map<int, int>(
        {{TileID::ebonstone, TileID::ebonstoneBrick},
         {TileID::ebonsand, TileID::ebonstoneBrick},
         {TileID::ebonsandstone, TileID::ebonstoneBrick},
         {TileID::hardenedEbonsand, TileID::ebonstoneBrick},
         {TileID::crimstone, TileID::crimstoneBrick},
         {TileID::crimsand, TileID::crimstoneBrick},
         {TileID::crimsandstone, TileID::crimstoneBrick},
         {TileID::hardenedCrimsand, TileID::crimstoneBrick},
         {TileID::pearlstone, TileID::pearlstoneBrick},
         {TileID::pearlsand, TileID::pearlstoneBrick},
         {TileID::pearlsandstone, TileID::pearlstoneBrick},
         {TileID::hardenedPearlsand, TileID::pearlstoneBrick}});
    constexpr auto skipTiles = frozen::make_set<int>(
        {TileID::demonite,
         TileID::lesion,
         TileID::crimtane,
         TileID::flesh,
         TileID::crystalBlock});
    std::vector<Point> queuedPaint;
    for (int i = 0; i < 2 * size; ++i) {
        for (int j = std::abs(i - size); j < size; ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            if (skipTiles.contains(tile.blockID)) {
                continue;
            }
            auto itr = convertTiles.find(tile.blockID);
            if (itr == convertTiles.end()) {
                tile.blockID = TileID::sandstoneBrick;
                tile.wallID = WallID::Safe::sandstoneBrick;
                queuedPaint.emplace_back(x + i, y + j);
            } else {
                tile.blockID = itr->second;
                tile.wallID = itr->second == TileID::ebonstoneBrick
                                  ? WallID::Safe::ebonstoneBrick
                              : itr->second == TileID::pearlstoneBrick
                                  ? WallID::Safe::pearlstoneBrick
                                  : WallID::Safe::crimstoneBrick;
            }
        }
    }
    std::tie(x, y) = makeHall(x + size - 16, y + 10, 10, {1, 0}, world);
    applyGravity(x - 12, y - 20, 12, 30, world);
    world.queuedTreasures.emplace_back([x, y](Random &, World &world) {
        for (int i = -12; i < 12; ++i) {
            for (int j = -20; j < 10; ++j) {
                world.getTile(x + i, y + j).liquid = Liquid::none;
            }
        }
    });
    std::tie(x, y) = makeHall(x, y, 25, {1, 1}, world);
    std::tie(x, y) = makeHall(x, y, 12, {1, 0}, world);
    std::tie(x, y) = makeHall(x, y, 14, {-1, 1}, world);
    std::tie(x, y) = makeHall(x, y, 5, {-1, 0}, world);
    if (rnd.getBool()) {
        placePyramidPainting(x + 11, y - 13, world);
    }
    std::tie(x, y) = fillTreasureRoom(x, y, rnd, world);
    std::tie(x, y) = makeHall(x, y, 18, {-1, 0}, world);
    std::tie(x, y) = makeHall(x, y, 30, {1, 1}, world);
    x -= 3;
    ++y;
    Point cave = findLinkingCave(x, y, world);
    if (cave.x != -1 && cave.y > y + 2) {
        constexpr auto clearTiles = frozen::make_set<int>(
            {TileID::sand,
             TileID::hardenedSand,
             TileID::sandstone,
             TileID::ebonsand,
             TileID::hardenedEbonsand,
             TileID::ebonsandstone,
             TileID::crimsand,
             TileID::hardenedCrimsand,
             TileID::crimsandstone,
             TileID::pearlsand,
             TileID::hardenedPearlsand,
             TileID::pearlsandstone});
        double aspect = static_cast<double>(cave.x - x) / (cave.y - y);
        for (int j = 0; y + j < cave.y; ++j) {
            int minI = aspect * j - 3 + 4 * rnd.getFineNoise(0, j);
            int maxI = aspect * j + 3 + 4 * rnd.getFineNoise(x, j);
            for (int i = minI; i < maxI; ++i) {
                Tile &tile = world.getTile(x + i, y + j);
                if (clearTiles.contains(tile.blockID)) {
                    tile.blockID = TileID::empty;
                }
            }
        }
    }
    if (!world.conf.unpainted && world.conf.celebration) {
        applyPyramidPaint(queuedPaint, world);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Pyramid.h`
```
#ifndef PYRAMID_H
#define PYRAMID_H

class World;
class Random;

void genPyramid(Random &rnd, World &world);

#endif // PYRAMID_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Ruins.cpp`
```
#include "structures/Ruins.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/Platforms.h"
#include "structures/StructureUtil.h"
#include "structures/data/Furniture.h"
#include "structures/data/RoomWindows.h"
#include <algorithm>
#include <iostream>
#include <set>

inline std::array const roofCurve{1, 2, 3, 5, 8, 13, 21, 26, 29, 31, 32, 33};

bool canPlaceFurniture(int x, int y, TileBuffer &data, World &world)
{
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            if (tile.wallID != WallID::Unsafe::obsidianBrick && i != 0 &&
                j != 0 && i != data.getWidth() - 1 &&
                j != data.getHeight() - 1) {
                return false;
            }
            switch (data.getTile(i, j).blockID) {
            case TileID::empty:
                if (isSolidBlock(tile.blockID)) {
                    return false;
                }
                break;
            case TileID::cloud:
                if ((tile.blockID != TileID::obsidianBrick &&
                     tile.blockID != TileID::hellstoneBrick) ||
                    tile.actuated) {
                    return false;
                }
                break;
            default:
                if (tile.blockID != TileID::empty) {
                    return false;
                }
                break;
            }
        }
    }
    return true;
}

class Ruins
{
private:
    Random &rnd;
    World &world;
    std::set<Point> queuedPlatforms;
    std::vector<Point> queuedDoors;
    std::vector<Point> locations;
    std::vector<Point> structLocs;

    void buildRoof(int &minX, int &maxX, int &roofLevel)
    {
        int center = std::midpoint(minX, maxX);
        for (size_t j = 0; j < roofCurve.size(); ++j) {
            for (int i = -roofCurve[j]; i < roofCurve[j]; ++i) {
                Tile &tile = world.getTile(center + i, roofLevel + j);
                if (tile.blockID == TileID::lesion ||
                    tile.blockID == TileID::flesh ||
                    tile.blockID == TileID::crystalBlock) {
                    continue;
                }
                tile.blockID = TileID::obsidianBrick;
                if (i == -roofCurve[j]) {
                    tile.slope = j == 0 || j > 2 ? Slope::half : Slope::topLeft;
                } else if (i == roofCurve[j] - 1) {
                    tile.slope =
                        j == 0 || j > 2 ? Slope::half : Slope::topRight;
                }
                if (world.getTile(center + i, roofLevel + j - 1).blockID ==
                    TileID::empty) {
                    tile.wallID = WallID::empty;
                } else {
                    tile.wallID = WallID::Unsafe::obsidianBrick;
                }
                structLocs.emplace_back(center + i, roofLevel + j);
            }
            if (center - roofCurve[j] <= minX) {
                roofLevel += j + 1;
                minX = std::max(minX, center - roofCurve[j] + 1);
                maxX = std::min(maxX, center + roofCurve[j] - 1);
                return;
            }
        }
    }

    void partitionRooms(int minX, int maxX, int minY, int maxY)
    {
        if (maxY - minY > 11) {
            int center = std::midpoint(minY, maxY) + rnd.getInt(-1, 1);
            partitionRooms(minX, maxX, minY, center);
            partitionRooms(minX, maxX, center, maxY);
            return;
        }
        auto isRoomWall = [maxY, this](int x) {
            return static_cast<int>(99999 * (1 + rnd.getFineNoise(x, maxY))) %
                       23 ==
                   0;
        };
        for (int x = minX; x < maxX; ++x) {
            for (int y = minY; y < maxY; ++y) {
                Tile &tile = world.getTile(x, y);
                if (tile.blockID == TileID::lesion ||
                    tile.blockID == TileID::flesh ||
                    tile.blockID == TileID::crystalBlock) {
                    continue;
                }
                tile.blockID =
                    y == minY || x == minX || x == maxX - 1 ||
                            (x > minX + 1 && x < maxX - 2 && isRoomWall(x) &&
                             !isRoomWall(x - 1) && !isRoomWall(x - 2))
                        ? TileID::obsidianBrick
                        : TileID::empty;
                tile.wallID = WallID::Unsafe::obsidianBrick;
                tile.liquid = Liquid::none;
                locations.emplace_back(x, y);
                if (y == maxY - 3 && tile.blockID == TileID::obsidianBrick &&
                    static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) %
                            3 ==
                        0) {
                    queuedDoors.emplace_back(x, y);
                }
            }
        }
        int range = maxX - minX;
        for (auto partition : rnd.partitionRange(
                 std::max(rnd.getInt(range / 18, range / 10), 2),
                 range)) {
            for (int i = -2; i < 2; ++i) {
                queuedPlatforms.emplace(minX + partition + i, minY);
            }
        }
    }

    void buildRuin(int minX, int maxX, int cityBase)
    {
        if (minX == -1) {
            return;
        }
        if (maxX - minX > 66) {
            int center = std::midpoint(minX, maxX);
            buildRuin(minX, center - rnd.getInt(2, 5), cityBase);
            buildRuin(center + rnd.getInt(2, 5), maxX, cityBase);
            return;
        }
        cityBase += rnd.getInt(-2, 8);
        int roofLevel = std::max<int>(
            cityBase - 5 - rnd.getDouble(0.7, 1.3) * (maxX - minX),
            world.getUnderworldLevel() + 50);
        if (cityBase - roofLevel < 12) {
            return;
        }
        buildRoof(minX, maxX, roofLevel);
        partitionRooms(minX, maxX, roofLevel, cityBase);
        for (int x = minX; x < maxX; ++x) {
            Tile &tile = world.getTile(x, cityBase);
            if (tile.blockID == TileID::lesion ||
                tile.blockID == TileID::flesh ||
                tile.blockID == TileID::crystalBlock) {
                continue;
            }
            // Base.
            tile.blockID = TileID::obsidianBrick;
            structLocs.emplace_back(x, cityBase);
            for (int j = 1; j < 20; ++j) {
                double noise = rnd.getFineNoise(x, cityBase + j);
                if (noise > j / 10.0 - 1) {
                    Tile &baseTile = world.getTile(x, cityBase + j);
                    if (baseTile.blockID == TileID::empty) {
                        baseTile.blockID =
                            static_cast<int>(99999 * (1 + noise)) % 5 == 0
                                ? TileID::obsidianBrick
                                : TileID::ash;
                        baseTile.liquid = Liquid::none;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
    }

public:
    Ruins(Random &r, World &w) : rnd(r), world(w) {}

    std::vector<Point> gen()
    {
        int step = 8;
        int underworldHeight = world.getHeight() - world.getUnderworldLevel();
        int cityBase = world.getUnderworldLevel() + 0.47 * underworldHeight;
        int minX = makeCongruent(
            world.conf.dontDigUp ? 100 : 0.15 * world.getWidth(),
            step);
        int maxX = makeCongruent(
            world.conf.dontDigUp ? world.getWidth() - 100
                                 : 0.85 * world.getWidth(),
            step);
        int skipFrom = world.conf.dontDigUp
                           ? makeCongruent(0.39 * world.getWidth(), step)
                           : -1;
        int skipTo = world.conf.dontDigUp
                         ? makeCongruent(0.61 * world.getWidth(), step)
                         : -1;
        int ruinStartX = -1;
        for (int x = minX; x < maxX; ++x) {
            if (x == skipFrom) {
                x = skipTo;
                ruinStartX = -1;
            }
            if (x % step == 0 &&
                (rnd.getCoarseNoise(x, 0) < 0.15 ||
                 !world.regionPasses(
                     x,
                     world.getUnderworldLevel(),
                     step,
                     cityBase - world.getUnderworldLevel(),
                     [](Tile &tile) { return !tile.guarded; }))) {
                buildRuin(ruinStartX, x, cityBase);
                ruinStartX = -1;
                x += step - 1;
            } else if (rnd.getFineNoise(makeCongruent(x, step), 0) < -0.2) {
                buildRuin(ruinStartX, x, cityBase);
                ruinStartX = -1;
            } else if (ruinStartX == -1) {
                ruinStartX = x;
            }
        }
        return locations;
    }

    void applyDamage()
    {
        locations.insert(locations.end(), structLocs.begin(), structLocs.end());
        std::vector<Point> noiseShuffles;
        for (int iter = 0; iter < 4; ++iter) {
            noiseShuffles.emplace_back(
                rnd.getInt(0, world.getWidth()),
                rnd.getInt(0, world.getHeight()));
        }
        auto getCompsiteNoise = [noiseShuffles, this](int x, int y) {
            double noise = 0;
            for (auto [shuffleX, shuffleY] : noiseShuffles) {
                noise = std::max(
                    std::abs(rnd.getFineNoise(x + shuffleX, y + shuffleY)),
                    noise);
            }
            return noise;
        };
        for (auto [x, y] : locations) {
            double noise = getCompsiteNoise(x, y);
            if (noise > 0.65) {
                world.getTile(x, y) = {};
            } else if (noise > 0.55) {
                Tile &tile = world.getTile(x, y);
                if (tile.blockID == TileID::obsidianBrick) {
                    tile.blockID = TileID::hellstoneBrick;
                }
                if (tile.wallID == WallID::Unsafe::obsidianBrick) {
                    tile.wallID = WallID::Unsafe::hellstoneBrick;
                }
            }
        }
        for (auto [x, y] : queuedDoors) {
            if (isSolidBlock(world.getTile(x, y - 1).blockID) &&
                isSolidBlock(world.getTile(x, y + 3).blockID)) {
                world.placeFramedTile(x, y, TileID::door, Variant::obsidian);
            }
        }
        std::erase_if(queuedPlatforms, [this](const auto &pt) {
            return world.getTile(pt.x, pt.y - 1).blockID != TileID::empty ||
                   world.getTile(pt).blockID == TileID::empty ||
                   world.getTile(pt.x, pt.y + 1).blockID != TileID::empty;
        });
        for (auto [x, y] : queuedPlatforms) {
            if (queuedPlatforms.contains({x - 1, y}) ||
                queuedPlatforms.contains({x + 1, y})) {
                placePlatform(x, y, Platform::obsidian, world);
            }
        }
    }
};

void igniteRuins(World &world)
{
    parallelFor(std::views::iota(0, world.getWidth()), [&world](int x) {
        for (int y = world.getUnderworldLevel(); y < world.getHeight(); ++y) {
            Tile &tile = world.getTile(x, y);
            switch (tile.blockID) {
            case TileID::hellstoneBrick:
                tile.blockID = TileID::obsidianBrick;
                break;
            case TileID::obsidianBrick:
                tile.blockID = TileID::hellstoneBrick;
                break;
            }
            switch (tile.wallID) {
            case WallID::Unsafe::hellstoneBrick:
                tile.wallID = WallID::Unsafe::obsidianBrick;
                break;
            case WallID::Unsafe::obsidianBrick:
                tile.wallID = WallID::Unsafe::hellstoneBrick;
                break;
            }
        }
    });
}

void genRuins(Random &rnd, World &world)
{
    std::cout << "Abandoning cities\n";
    Ruins structure(rnd, world);
    std::vector<Point> locations = structure.gen();
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    // Windows.
    int numPlacements = locations.size() / 500;
    auto locItr = locations.begin();
    Data::Window windowStyle = Data::Window::tall;
    TileBuffer data = Data::getWindow(
        windowStyle,
        TileID::obsidianBrick,
        WallID::Safe::redStainedGlass,
        world.getFramedTiles());
    std::vector<Point> usedLocations;
    for (; locItr != locations.end(); ++locItr) {
        auto [x, y] = *locItr;
        y = scanWhileEmpty({x, y}, {0, -1}, world).y;
        if (windowStyle == Data::Window::square) {
            ++y;
        }
        if (!world.regionPasses(
                x - 1,
                windowStyle == Data::Window::tall ? y : y - 1,
                data.getWidth() + 2,
                data.getHeight() + (windowStyle == Data::Window::tall ? 1 : 2),
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            isLocationUsed(x, y, 10, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        for (int i = 0; i < data.getWidth(); ++i) {
            for (int j = 0; j < data.getHeight(); ++j) {
                Tile &dataTile = data.getTile(i, j);
                Tile &tile = world.getTile(x + i, y + j);
                if (dataTile.blockID != TileID::empty) {
                    tile.blockID = dataTile.blockID;
                    tile.slope = dataTile.slope;
                    tile.actuated = dataTile.actuated;
                    tile.guarded = true;
                }
                if (dataTile.wallID != WallID::empty) {
                    tile.wallID = dataTile.wallID;
                }
            }
        }
        --numPlacements;
        if (numPlacements < 0) {
            break;
        }
        windowStyle = rnd.select({Data::Window::square, Data::Window::tall});
        data = Data::getWindow(
            windowStyle,
            TileID::obsidianBrick,
            rnd.select(
                {WallID::Safe::redStainedGlass,
                 WallID::Safe::multicoloredStainedGlass,
                 WallID::Safe::leadFence}),
            world.getFramedTiles());
    }
    structure.applyDamage();
    // Furniture.
    int tries = 0;
    numPlacements = locations.size() / 450;
    for (; locItr != locations.end(); ++locItr) {
        auto [x, y] = *locItr;
        if (tries > 30) {
            tries = 0;
        }
        if (tries == 0) {
            data = getFurniture(
                rnd.select(Data::furnitureLayouts),
                Data::Variant::obsidian,
                world.getFramedTiles());
        }
        ++tries;
        if (!canPlaceFurniture(x, y, data, world)) {
            continue;
        }
        for (auto [chestX, chestY] :
             world.placeBuffer(x, y, data, Blend::blockOnly)) {
            fillDresser(world.registerStorage(chestX, chestY), rnd);
        }
        tries = 0;
        --numPlacements;
        if (numPlacements < 0) {
            break;
        }
    }
    std::array underworldPaintings{
        Painting::darkness,
        Painting::darkSoulReaper,
        Painting::trappedGhost,
        Painting::demonsEye,
        Painting::livingGore,
        Painting::flowingMagma,
        Painting::handEarth,
        Painting::impFace,
        Painting::ominousPresence,
        Painting::shiningMoon,
        Painting::skelehead,
        Painting::lakeOfFire};
    std::shuffle(
        underworldPaintings.begin(),
        underworldPaintings.end(),
        rnd.getPRNG());
    auto paintingItr = underworldPaintings.begin();
    // Paintings.
    numPlacements = locations.size() / 650;
    usedLocations.clear();
    for (; locItr != locations.end(); ++locItr) {
        auto [x, y] = *locItr;
        auto [width, height] = world.getPaintingDims(*paintingItr);
        y = scanWhileNotSolid({x, y}, {0, -1}, world).y + 1;
        if (!world.regionPasses(
                x,
                y,
                width,
                height,
                [](Tile &tile) {
                    return tile.blockID == TileID::empty &&
                           (tile.wallID == WallID::Unsafe::obsidianBrick ||
                            tile.wallID == WallID::Unsafe::hellstoneBrick);
                }) ||
            world.getTile(x, y - 2).actuated ||
            isLocationUsed(x, y, 30, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        world.placePainting(x, y, *paintingItr);
        --numPlacements;
        if (numPlacements < 0) {
            break;
        }
        ++paintingItr;
        if (paintingItr == underworldPaintings.end()) {
            paintingItr = underworldPaintings.begin();
        }
    }
    // Chests.
    numPlacements = world.conf.chests * locations.size() / 640;
    usedLocations.clear();
    for (; locItr != locations.end() && numPlacements > 0; ++locItr) {
        auto [x, y] = *locItr;
        y = scanWhileNotSolid({x, y}, {0, 1}, world).y - 1;
        if (!world.regionPasses(
                x,
                y,
                2,
                2,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            !world.regionPasses(
                x,
                y + 2,
                2,
                1,
                [](Tile &tile) {
                    return isSolidBlock(tile.blockID) && !tile.actuated;
                }) ||
            isLocationUsed(x, y, 25, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        Chest &chest = world.placeChest(x, y, Variant::shadow);
        fillShadowChest(chest, rnd, world);
        --numPlacements;
    }
    // Hellforges.
    numPlacements = locations.size() / 600;
    usedLocations.clear();
    for (auto rItr = locations.rbegin();
         rItr != locations.rend() && numPlacements > 0;
         ++rItr) {
        auto [x, y] = *rItr;
        y = scanWhileNotSolid({x, y}, {0, 1}, world).y - 1;
        if (!world.regionPasses(
                x,
                y,
                3,
                2,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            !world.regionPasses(
                x,
                y + 2,
                3,
                1,
                [](Tile &tile) {
                    return isSolidBlock(tile.blockID) && !tile.actuated;
                }) ||
            isLocationUsed(x, y, 25, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        world.placeFramedTile(x, y, TileID::hellforge);
        --numPlacements;
    }
    // Pots.
    numPlacements = locations.size() / 600;
    usedLocations.clear();
    for (; locItr != locations.end() && numPlacements > 0; ++locItr) {
        auto [x, y] = *locItr;
        y = scanWhileNotSolid({x, y}, {0, 1}, world).y - 1;
        if (!world.regionPasses(
                x,
                y,
                2,
                2,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            !world.regionPasses(
                x,
                y + 2,
                2,
                1,
                [](Tile &tile) {
                    return isSolidBlock(tile.blockID) && !tile.actuated;
                }) ||
            isLocationUsed(x, y, 5, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        world.placeFramedTile(x, y, TileID::pot, Variant::underworld);
        --numPlacements;
    }
    if (world.conf.forTheWorthy) {
        igniteRuins(world);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Ruins.h`
```
#ifndef RUINS_H
#define RUINS_H

class World;
class Random;

void genRuins(Random &rnd, World &world);

#endif // RUINS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/SpiderHall.cpp`
```
#include "structures/SpiderHall.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include "structures/data/Buildings.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

void convertRainbowBricks(int x, int y, Tile &tile)
{
    if (tile.blockID == TileID::stoneSlab) {
        tile.blockID = TileID::rainbowBrick;
    } else if (
        tile.blockID == TileID::stone || tile.blockID == TileID::grayBrick) {
        tile.blockPaint = getDeepRainbowPaint(x, y);
    }
    constexpr auto paintWalls = frozen::make_set<int>(
        {WallID::Unsafe::craggyStone,
         WallID::Safe::grayBrick,
         WallID::Unsafe::spider});
    if (tile.wallID == WallID::Safe::stoneSlab) {
        tile.wallID = WallID::Safe::rainbowBrick;
    } else if (paintWalls.contains(tile.wallID)) {
        tile.wallPaint = getDeepRainbowPaint(x, y);
    }
}

bool canPlaceSpiderDecoAt(int x, int y, int width, int height, World &world)
{
    return world.regionPasses(x, y, width, height, [](Tile &tile) {
        return tile.blockID == TileID::empty;
    }) && world.regionPasses(x, y + height, width, 1, [](Tile &tile) {
        return tile.slope == Slope::none && !tile.actuated &&
               isSolidBlock(tile.blockID);
    }) && world.getTile(x, y).wallID == WallID::Unsafe::spider;
}

void placeSpiderDeco(
    int x,
    int y,
    int width,
    int height,
    Random &rnd,
    World &world)
{
    std::vector<Point> locations;
    for (int i = 0; i < width; ++i) {
        bool prevIsSolid = false;
        for (int j = 0; j < height; ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            bool curIsSolid = tile.guarded && tile.slope == Slope::none &&
                              (tile.blockID == TileID::stoneSlab ||
                               tile.blockID == TileID::stone);
            if (prevIsSolid && !curIsSolid) {
                locations.emplace_back(x + i, y + j);
            }
            prevIsSolid = curIsSolid;
            switch (
                static_cast<int>(99999 * (1 + rnd.getFineNoise(x + i, y + j))) %
                11) {
            case 0:
                if (canPlaceSpiderDecoAt(x + i, y + j, 2, 2, world)) {
                    world.placeFramedTile(
                        x + i,
                        y + j,
                        TileID::pot,
                        Variant::spider);
                }
                break;
            case 1:
                if (canPlaceSpiderDecoAt(x + i, y + j, 2, 1, world)) {
                    world.placeFramedTile(
                        x + i,
                        y + j,
                        TileID::smallPile,
                        Variant::spider);
                }
                break;
            case 2:
                if (canPlaceSpiderDecoAt(x + i, y + j, 3, 2, world)) {
                    world.placeFramedTile(
                        x + i,
                        y + j,
                        TileID::largePileGroup2,
                        Variant::spider);
                }
                break;
            }
        }
    }
    std::array paintings{
        Painting::gloriousNight,
        Painting::happyLittleTree,
        Painting::land,
        Painting::strangeGrowth,
        Painting::auroraBorealis,
        Painting::heartlands,
        Painting::vikingVoyage,
        Painting::wildflowers,
        Painting::discover,
        Painting::morningHunt,
        Painting::oldMiner,
        Painting::sunflowers,
        Painting::theMerchant};
    std::shuffle(paintings.begin(), paintings.end(), rnd.getPRNG());
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    auto paintingItr = paintings.begin();
    int numPaintings = rnd.getInt(4, 5);
    std::vector<Point> usedLocations;
    for (auto [pX, pY] : locations) {
        auto [pWidth, pHeight] = world.getPaintingDims(*paintingItr);
        if (!world.regionPasses(
                pX - 2,
                pY,
                pWidth + 2,
                pHeight + 2,
                [](Tile &tile) {
                    return tile.blockID == TileID::empty &&
                           tile.wallID != WallID::Safe::grayBrick;
                }) ||
            isLocationUsed(pX, pY, 10, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(pX, pY);
        world.placePainting(pX - 1, pY + 1, *paintingItr);
        --numPaintings;
        if (numPaintings <= 0) {
            break;
        }
        ++paintingItr;
    }
}

void placeCobwebs(
    int centerX,
    int centerY,
    int width,
    int height,
    Random &rnd,
    World &world)
{
    for (int i = -width; i < width; ++i) {
        for (int j = -height; j < height; ++j) {
            double threshold = std::max(
                0.1,
                2 * std::hypot(
                        static_cast<double>(i) / width,
                        static_cast<double>(j) / height) -
                    1);
            if (rnd.getFineNoise(centerX + 4 * i, centerY + 4 * j) <
                threshold) {
                continue;
            }
            Tile &tile = world.getTile(centerX + i, centerY + j);
            if (tile.blockID == TileID::empty && tile.wallID != WallID::empty) {
                tile.blockID = TileID::cobweb;
            }
        }
    }
}

Point selectSpiderHallLocation(
    int minX,
    int maxX,
    TileBuffer &hall,
    Random &rnd,
    World &world)
{
    constexpr auto clearableTiles = frozen::make_set<int>({
        TileID::empty,         TileID::dirt,        TileID::stone,
        TileID::clay,          TileID::sand,        TileID::mud,
        TileID::copperOre,     TileID::tinOre,      TileID::ironOre,
        TileID::leadOre,       TileID::silverOre,   TileID::tungstenOre,
        TileID::goldOre,       TileID::platinumOre, TileID::cobaltOre,
        TileID::palladiumOre,  TileID::mythrilOre,  TileID::orichalcumOre,
        TileID::adamantiteOre, TileID::titaniumOre,
    });
    int minY = (world.getUndergroundLevel() + 2 * world.getCavernLevel()) / 3;
    int maxY = (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3 -
               hall.getHeight() / 2;
    int maxFoundationEmpty = 0.4 * hall.getWidth();
    for (int tries = 0; tries < 8000; ++tries) {
        int x = rnd.getInt(minX, maxX);
        int y = rnd.getInt(minY, maxY);
        int numEmpty = 0;
        int numFilled = 0;
        int maxEntryFilled = tries / 250;
        if (world.regionPasses(
                x - 3,
                y + hall.getHeight() - 9,
                4,
                4,
                [maxEntryFilled, &numFilled](Tile &tile) {
                    if (tile.blockID != TileID::empty) {
                        ++numFilled;
                    }
                    return numFilled < maxEntryFilled;
                }) &&
            world.regionPasses(
                x + hall.getWidth() - 1,
                y + hall.getHeight() - 9,
                4,
                4,
                [maxEntryFilled, &numFilled](Tile &tile) {
                    if (tile.blockID != TileID::empty) {
                        ++numFilled;
                    }
                    return numFilled < maxEntryFilled;
                }) &&
            world.regionPasses(
                x - 20,
                y - 20,
                hall.getWidth() + 40,
                hall.getHeight() + 40,
                [&clearableTiles](Tile &tile) {
                    return !tile.guarded && tile.liquid != Liquid::shimmer &&
                           (clearableTiles.contains(tile.blockID) ||
                            (tile.flag == Flag::border &&
                             tile.blockID == TileID::hive));
                }) &&
            world.regionPasses(
                x,
                y + hall.getHeight() - 2,
                hall.getWidth(),
                4,
                [maxFoundationEmpty, &numEmpty](Tile &tile) {
                    if (tile.blockID == TileID::empty) {
                        ++numEmpty;
                    }
                    return numEmpty < maxFoundationEmpty;
                })) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void genSpiderHall(Random &rnd, World &world)
{
    std::cout << "Spinning webs\n";
    TileBuffer hall = Data::getBuilding(
        rnd.select({Data::Building::spiderHall1, Data::Building::spiderHall2}),
        world.getFramedTiles());
    std::vector<Point> bounds;
    if (world.getWidth() < 8000) {
        bounds.emplace_back(200, world.getWidth() - hall.getWidth() - 200);
    } else {
        bounds.emplace_back(200, 0.35 * world.getWidth() - hall.getWidth());
        bounds.emplace_back(
            0.65 * world.getWidth(),
            world.getWidth() - hall.getWidth() - 200);
    }
    for (auto [minX, maxX] : bounds) {
        auto [x, y] = selectSpiderHallLocation(minX, maxX, hall, rnd, world);
        if (x == -1) {
            continue;
        }
        for (int i = 0; i < hall.getWidth(); ++i) {
            for (int j = 0; j < hall.getHeight(); ++j) {
                Tile &hallTile = hall.getTile(i, j);
                if (hallTile.blockID == TileID::empty &&
                    hallTile.wallID == WallID::empty) {
                    continue;
                }
                Tile &tile = world.getTile(x + i, y + j);
                bool shouldConvertWall =
                    hallTile.wallID != WallID::Safe::grayBrick &&
                    hallTile.wallID != WallID::empty;
                if (static_cast<int>(
                        99999 * (1 + rnd.getFineNoise(x + i, y + j))) %
                        5 ==
                    0) {
                    if (hallTile.blockID == TileID::grayBrick ||
                        hallTile.blockID == TileID::stoneSlab) {
                        hallTile.blockID = TileID::stone;
                    }
                    if (hallTile.wallID == WallID::Safe::grayBrick ||
                        hallTile.wallID == WallID::Safe::stoneSlab) {
                        hallTile.wallID = WallID::Unsafe::craggyStone;
                    }
                }
                if (shouldConvertWall &&
                    std::abs(rnd.getFineNoise(x + 3 * i, y + 3 * j)) < 0.45) {
                    hallTile.wallID = WallID::Unsafe::spider;
                } else if (hallTile.wallID == WallID::empty) {
                    hallTile.wallID = tile.wallID;
                }
                if (world.conf.celebration) {
                    convertRainbowBricks(x + i, y + j, hallTile);
                }
                tile = hallTile;
                tile.guarded = true;
                if (tile.blockID == TileID::chest && tile.frameX % 36 == 0 &&
                    tile.frameY == 0) {
                    fillWebCoveredChest(
                        world.registerStorage(x + i, y + j),
                        rnd,
                        world);
                }
            }
        }
        placeSpiderDeco(x, y, hall.getWidth(), hall.getHeight(), rnd, world);
        placeCobwebs(
            x + hall.getWidth() / 2,
            y + hall.getHeight() / 2,
            hall.getWidth(),
            hall.getHeight(),
            rnd,
            world);
        hall = Data::getBuilding(
            rnd.select(
                {Data::Building::spiderHall1, Data::Building::spiderHall2}),
            world.getFramedTiles());
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/SpiderHall.h`
```
#ifndef SPIDERHALL_H
#define SPIDERHALL_H

class World;
class Random;

void genSpiderHall(Random &rnd, World &world);

#endif // SPIDERHALL_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/StarterHome.cpp`
```
#include "structures/StarterHome.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include "structures/data/Furniture.h"
#include "structures/data/Homes.h"
#include "vendor/frozen/map.h"
#include "vendor/frozen/set.h"
#include <iostream>
#include <map>

int themeToDirtVariant(Data::Variant theme)
{
    switch (theme) {
    case Data::Variant::ashWood:
        return TileID::ash;
    case Data::Variant::boreal:
        return TileID::snow;
    case Data::Variant::granite:
        return TileID::granite;
    case Data::Variant::honey:
    case Data::Variant::mahogany:
        return TileID::mud;
    case Data::Variant::marble:
        return TileID::marble;
    case Data::Variant::palm:
        return TileID::sand;
    default:
        return TileID::dirt;
    }
}

void placeHomeAt(
    int x,
    int y,
    Data::Variant theme,
    Data::Variant origTheme,
    TileBuffer &home,
    Random &rnd,
    World &world)
{
    std::map<int, int> themeTiles;
    std::map<int, int> themeWalls;
    switch (theme) {
    case Data::Variant::ashWood:
        themeTiles.insert(
            {{TileID::wood, TileID::ashWood}, {TileID::dirt, TileID::ash}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::ashWood},
             {WallID::Safe::planked,
              rnd.select({WallID::Safe::obsidianBrick, WallID::Safe::planked})},
             {WallID::Safe::stone,
              rnd.select({WallID::Safe::ember, WallID::Safe::wornStone})}});
        break;
    case Data::Variant::balloon:
        themeTiles.insert(
            {{TileID::wood,
              rnd.select(
                  {TileID::sillyPinkBalloon,
                   TileID::sillyPurpleBalloon,
                   TileID::sillyGreenBalloon})},
             {TileID::woodenBeam, TileID::marbleColumn},
             {TileID::grayBrick,
              rnd.select(
                  {TileID::argonMossBrick,
                   TileID::neonMossBrick,
                   TileID::kryptonMossBrick})},
             {TileID::dirt, themeToDirtVariant(origTheme)}});
        themeWalls.insert(
            {{WallID::Safe::wood,
              rnd.select(
                  {WallID::Safe::sillyPinkBalloon,
                   WallID::Safe::sillyPurpleBalloon,
                   WallID::Safe::sillyGreenBalloon})},
             {WallID::Safe::planked,
              rnd.select(
                  {WallID::Safe::darkCelestialBrick,
                   WallID::Safe::cryocoreBrick,
                   WallID::Safe::lunarRustBrick})},
             {WallID::Safe::stone,
              rnd.select(
                  {WallID::Safe::hallowedPrism,
                   WallID::Safe::hallowedCrystalline,
                   WallID::Safe::aetheriumBrick})}});
        break;
    case Data::Variant::boreal:
        themeTiles.insert(
            {{TileID::wood, TileID::borealWood},
             {TileID::woodenBeam, TileID::borealBeam},
             {TileID::grayBrick,
              rnd.select({TileID::snowBrick, TileID::iceBrick})},
             {TileID::dirt, TileID::snow}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::borealWood},
             {WallID::Safe::stone,
              rnd.select({WallID::Safe::snow, WallID::Safe::ice})}});
        break;
    case Data::Variant::forest:
        themeWalls.insert(
            {{WallID::Safe::stone,
              rnd.select({WallID::Safe::mudstoneBrick, WallID::Safe::stone})}});
        break;
    case Data::Variant::granite:
        themeTiles.insert(
            {{TileID::wood, TileID::smoothGranite},
             {TileID::woodenBeam, TileID::graniteColumn},
             {TileID::grayBrick,
              rnd.select({TileID::ironBrick, TileID::titanstone})},
             {TileID::dirt, TileID::granite}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::smoothGranite},
             {WallID::Safe::planked,
              rnd.select({WallID::Safe::shadewood, WallID::Safe::spookyWood})},
             {WallID::Safe::stone,
              rnd.select({WallID::Safe::granite, WallID::Safe::obsidian})}});
        break;
    case Data::Variant::honey:
        themeTiles.insert(
            {{TileID::wood, TileID::honey},
             {TileID::woodenBeam, TileID::richMahoganyBeam},
             {TileID::grayBrick,
              rnd.select({TileID::hive, TileID::richMahogany})},
             {TileID::dirt, TileID::mud}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::hay},
             {WallID::Safe::planked,
              rnd.select(
                  {WallID::Safe::honeyfall, WallID::Safe::iridescentBrick})},
             {WallID::Safe::stone,
              rnd.select(
                  {WallID::Safe::bamboo,
                   WallID::Safe::largeBamboo,
                   WallID::Safe::lichenStone,
                   WallID::Safe::leafyJungle})}});
        break;
    case Data::Variant::livingWood:
        themeTiles.insert(
            {{TileID::wood, TileID::livingWood}, {TileID::dirt, TileID::leaf}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::livingWood},
             {WallID::Safe::planked,
              rnd.select({WallID::Safe::livingLeaf, WallID::Safe::planked})},
             {WallID::Safe::stone,
              rnd.select({WallID::Safe::mudstoneBrick, WallID::Safe::stone})}});
        break;
    case Data::Variant::mahogany:
        themeTiles.insert(
            {{TileID::wood, TileID::richMahogany},
             {TileID::woodenBeam, TileID::richMahoganyBeam},
             {TileID::grayBrick,
              rnd.select({TileID::iridescentBrick, TileID::mudstoneBrick})},
             {TileID::dirt, TileID::mud}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::richMahogany},
             {WallID::Safe::planked,
              rnd.select(
                  {WallID::Safe::whiteDynasty, WallID::Safe::blueDynasty})},
             {WallID::Safe::stone,
              rnd.select(
                  {WallID::Safe::bamboo,
                   WallID::Safe::largeBamboo,
                   WallID::Safe::richMahoganyFence})}});
        break;
    case Data::Variant::marble:
        themeTiles.insert(
            {{TileID::wood, TileID::smoothMarble},
             {TileID::woodenBeam, TileID::marbleColumn},
             {TileID::grayBrick,
              rnd.select({TileID::grayBrick, TileID::pearlstoneBrick})},
             {TileID::dirt, TileID::marble}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::smoothMarble},
             {WallID::Safe::planked,
              rnd.select(
                  {WallID::Safe::fancyGrayWallpaper,
                   WallID::Safe::platinumBrick})},
             {WallID::Safe::stone,
              rnd.select(
                  {WallID::Safe::marble, WallID::Safe::stalactiteStone})}});
        break;
    case Data::Variant::palm:
        themeTiles.insert(
            {{TileID::wood, TileID::palmWood},
             {TileID::woodenBeam, TileID::sandstoneColumn},
             {TileID::grayBrick,
              rnd.select({TileID::sandstoneBrick, TileID::tinBrick})},
             {TileID::dirt, TileID::sand}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::palmWood},
             {WallID::Safe::planked,
              rnd.select({WallID::Safe::palmWoodFence, WallID::Safe::planked})},
             {WallID::Safe::stone,
              rnd.select(
                  {WallID::Safe::hardenedSand, WallID::Safe::sandstone})}});
        break;
    case Data::Variant::skyware:
        themeTiles.insert(
            {{TileID::wood, TileID::sunplate},
             {TileID::woodenBeam, TileID::sandstoneColumn},
             {TileID::grayBrick,
              rnd.select({TileID::ironBrick, TileID::tinBrick})},
             {TileID::dirt, themeToDirtVariant(origTheme)}});
        themeWalls.insert(
            {{WallID::Safe::wood, WallID::Safe::disc},
             {WallID::Safe::planked,
              rnd.select(
                  {WallID::Safe::whiteDynasty, WallID::Safe::blueDynasty})},
             {WallID::Safe::stone,
              rnd.select(
                  {WallID::Safe::lichenStone, WallID::Safe::mudstoneBrick})}});
        break;
    default:
        break;
    }
    if (!themeTiles.contains(TileID::grayBrick)) {
        themeTiles[TileID::grayBrick] =
            rnd.select({TileID::grayBrick, TileID::redBrick, TileID::tinBrick});
    }
    constexpr auto brickToWall = frozen::make_map<int, int>({
        {TileID::argonMossBrick, WallID::Safe::argonMossBrick},
        {TileID::grayBrick, WallID::Safe::grayBrick},
        {TileID::hive, WallID::Safe::hive},
        {TileID::iceBrick, WallID::Safe::iceBrick},
        {TileID::iridescentBrick, WallID::Safe::iridescentBrick},
        {TileID::ironBrick, WallID::Safe::ironBrick},
        {TileID::kryptonMossBrick, WallID::Safe::kryptonMossBrick},
        {TileID::mudstoneBrick, WallID::Safe::mudstoneBrick},
        {TileID::neonMossBrick, WallID::Safe::neonMossBrick},
        {TileID::pearlstoneBrick, WallID::Safe::pearlstoneBrick},
        {TileID::redBrick, WallID::Safe::redBrick},
        {TileID::richMahogany, WallID::Safe::richMahogany},
        {TileID::sandstoneBrick, WallID::Safe::sandstoneBrick},
        {TileID::snowBrick, WallID::Safe::snowBrick},
        {TileID::tinBrick, WallID::Safe::tinBrick},
        {TileID::titanstone, WallID::Safe::titanstone},
    });
    themeWalls[WallID::Safe::grayBrick] =
        brickToWall.at(themeTiles[TileID::grayBrick]);
    constexpr auto unguardedBlocks = frozen::make_set<int>(
        {TileID::ash,
         TileID::dirt,
         TileID::granite,
         TileID::leaf,
         TileID::mud,
         TileID::marble,
         TileID::sand,
         TileID::snow});
    int rainbowOffset = rnd.getInt(0, 999);
    for (int i = 0; i < home.getWidth(); ++i) {
        int numSolid = 0;
        for (int j = 0; j < home.getHeight(); ++j) {
            Tile &homeTile = home.getTile(i, j);
            if (numSolid > 1) {
                homeTile.blockID = TileID::cloud;
            }
            Tile &tile = world.getTile(x + i, y + j);
            if (tile.blockID != TileID::empty &&
                (tile.blockID != TileID::thinIce ||
                 world.getTile(x + i, y + j + 1).blockID != TileID::empty) &&
                j > home.getHeight() / 2) {
                ++numSolid;
                continue;
            }
            if (homeTile.blockID == TileID::cloud ||
                (homeTile.blockID == TileID::empty &&
                 homeTile.wallID == WallID::empty)) {
                continue;
            }
            if (homeTile.blockID == TileID::chest &&
                homeTile.frameX % 36 == 0 && homeTile.frameY == 0) {
                fillStarterChest(
                    world.conf.equipment,
                    world.registerStorage(x + i, y + j),
                    rnd,
                    world);
            }
            convertFurniture(homeTile, theme);
            auto tileItr = themeTiles.find(homeTile.blockID);
            if (tileItr != themeTiles.end()) {
                homeTile.blockID = tileItr->second;
                if (theme == Data::Variant::balloon &&
                    homeTile.blockID == TileID::marbleColumn) {
                    homeTile.blockPaint =
                        getDeepRainbowPaint(x + i + rainbowOffset, y + j);
                }
            }
            auto wallItr = themeWalls.find(homeTile.wallID);
            if (wallItr != themeWalls.end()) {
                homeTile.wallID = wallItr->second;
            }
            if (tile.blockID == TileID::thinIce &&
                homeTile.blockID == TileID::empty) {
                homeTile.blockID = TileID::thinIce;
            }
            homeTile.liquid = tile.liquid;
            tile = homeTile;
            tile.guarded = !unguardedBlocks.contains(tile.blockID);
        }
    }
    constexpr auto blockToGrass = frozen::make_map<int, int>(
        {{TileID::ash, TileID::ashGrass},
         {TileID::dirt, TileID::grass},
         {TileID::mud, TileID::jungleGrass}});
    constexpr auto grassToBlock = frozen::make_map<int, int>(
        {{TileID::ashGrass, TileID::ash},
         {TileID::grass, TileID::dirt},
         {TileID::hallowedGrass, TileID::dirt},
         {TileID::jungleGrass, TileID::mud}});
    for (int i = 0; i < home.getWidth(); ++i) {
        for (int j = 0; j < home.getHeight(); ++j) {
            Tile &homeTile = home.getTile(i, j);
            if (homeTile.blockID == TileID::cloud ||
                (homeTile.blockID == TileID::empty &&
                 homeTile.wallID == WallID::empty)) {
                continue;
            }
            Tile &tile = world.getTile(x + i, y + j);
            auto toGrassItr = blockToGrass.find(tile.blockID);
            if (toGrassItr != blockToGrass.end() &&
                (y < world.getUndergroundLevel() ||
                 toGrassItr->second != TileID::grass) &&
                world.isExposed(x + i, y + j)) {
                tile.blockID = toGrassItr->second;
            } else {
                auto toBlockItr = grassToBlock.find(tile.blockID);
                if (toBlockItr != grassToBlock.end() &&
                    !world.isExposed(x + i, y + j)) {
                    tile.blockID = toBlockItr->second;
                }
            }
        }
    }
}

int realSurfaceAt(int x, World &world, int prevY)
{
    int minY = world.getSurfaceLevel(x) - 2;
    if (!world.regionPasses(x, minY - 5, 1, 4, [](Tile &tile) {
            return tile.blockID == TileID::empty;
        })) {
        minY -= 73;
    }
    if (prevY != -1) {
        minY = std::min(minY, prevY);
    }
    while (world.getTile(x, minY).blockID != TileID::empty) {
        --minY;
    }
    return scanWhileEmpty({x, minY}, {0, 1}, world).y + 1;
}

int scanForSurfaceAt(int x, World &world, int prevY)
{
    int minY = prevY;
    while (!world.regionPasses(x, minY - 3, 1, 4, [](Tile &tile) {
        return tile.blockID == TileID::empty;
    })) {
        --minY;
        if (minY < 50) {
            return prevY;
        }
    }
    return scanWhileEmpty({x, minY}, {0, 1}, world).y + 1;
}

void clearSpawnHive(bool isNearSurface, World &world)
{
    int x = world.spawn.x;
    int y = isNearSurface ? world.getSurfaceLevel(x) : world.spawn.y;
    int radius = 30;
    for (int i = -radius; i < radius; ++i) {
        for (int j = -radius; j < (isNearSurface ? radius : 3); ++j) {
            if (isNearSurface && y + j >= world.getSurfaceLevel(x + i)) {
                break;
            }
            Tile &tile = world.getTile(x + i, y + j);
            if (tile.flag == Flag::border &&
                (tile.blockID == TileID::hive ||
                 tile.blockID == TileID::crispyHoney) &&
                std::hypot(i, j) < radius) {
                tile.blockID = TileID::empty;
            }
        }
    }
}

void genStarterHome(Random &rnd, World &world)
{
    std::cout << "Purchasing property\n";
    bool isNearSurface =
        std::abs(world.getSurfaceLevel(world.spawn.x) - world.spawn.y) < 30;
    if (world.conf.hiveQueen) {
        clearSpawnHive(isNearSurface, world);
    }
    std::map<int, int> tileCounts;
    int x = world.spawn.x;
    int y = isNearSurface ? realSurfaceAt(x, world, world.spawn.y)
                          : scanForSurfaceAt(x, world, world.spawn.y);
    for (int j = 0; j < 6; ++j) {
        tileCounts[world.getTile(x, y + j).blockID] += 1;
    }
    Data::Variant theme = Data::Variant::forest;
    if (tileCounts[TileID::ash] + tileCounts[TileID::hellstone] > 2) {
        theme = Data::Variant::ashWood;
    } else if (tileCounts[TileID::snow] > 2) {
        theme = Data::Variant::boreal;
    } else if (
        tileCounts[TileID::granite] + tileCounts[TileID::smoothGranite] > 2) {
        theme = Data::Variant::granite;
    } else if (
        (tileCounts[TileID::jungleGrass] > 0 && tileCounts[TileID::mud] > 1) ||
        tileCounts[TileID::livingMahogany] > 2) {
        theme = Data::Variant::mahogany;
    } else if (
        tileCounts[TileID::marble] + tileCounts[TileID::smoothMarble] > 2) {
        theme = Data::Variant::marble;
    } else if (tileCounts[TileID::sand] + tileCounts[TileID::pearlsand] > 2) {
        theme = Data::Variant::palm;
    } else if (
        tileCounts[TileID::leaf] > 2 ||
        !world.regionPasses(x - 100, y, 200, 1, [](Tile &tile) {
            return tile.blockID != TileID::livingWood;
        })) {
        theme = Data::Variant::livingWood;
    }
    if ((theme == Data::Variant::forest || theme == Data::Variant::mahogany) &&
        !world.regionPasses(x - 20, y - 2, 40, 8, [](Tile &tile) {
            return tile.wallID != WallID::Unsafe::hive &&
                   tile.liquid != Liquid::honey;
        })) {
        theme = Data::Variant::honey;
    }
    Data::Variant origTheme = theme;
    if (world.conf.celebration && !world.conf.forTheWorthy &&
        !world.conf.hiveQueen) {
        theme = Data::Variant::balloon;
    } else if (y < 0.45 * world.getUndergroundLevel()) {
        theme = Data::Variant::skyware;
    }
    TileBuffer home =
        Data::getHome(rnd.select(Data::homes), world.getFramedTiles());
    x -= home.getWidth() / 2;
    for (int iter = 0; iter < 2; ++iter) {
        for (int i = 7; i < home.getWidth() - 7; ++i) {
            y = std::min(
                isNearSurface ? realSurfaceAt(x + i, world, y)
                              : scanForSurfaceAt(x + i, world, y),
                y);
        }
    }
    world.spawn.y = y - 1;
    for (int j = 0; j < home.getHeight(); ++j) {
        --y;
        if (home.getTile(0, j).blockPaint == Paint::red) {
            break;
        }
    }
    placeHomeAt(x, y, theme, origTheme, home, rnd, world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/StarterHome.h`
```
#ifndef STARTERHOME_H
#define STARTERHOME_H

class World;
class Random;

void genStarterHome(Random &rnd, World &world);

#endif // STARTERHOME_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Statues.cpp`
```
#include "structures/Statues.h"

#include "World.h"

void placeStatue(int x, int y, int style, World &world)
{
    int offsetX = style / 1000;
    int offsetY = style % 1000 + 162 * (fnv1a32pt(x, y) % 2);
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 3; ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            tile.blockID = TileID::statue;
            tile.frameX = 18 * i + offsetX;
            tile.frameY = 18 * j + offsetY;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Statues.h`
```
#ifndef STATUES_H
#define STATUES_H

#include <array>

class World;

namespace Statue
{
enum {
    armedZombie = 684'054,
    bat = 252'000,
    bloodZombie = 720'054,
    boneSkeleton = 432'054,
    chest = 972'000,
    corrupt = 1080'000,
    crab = 648'000,
    drippler = 360'054,
    eyeball = 1260'000,
    goblin = 180'000,
    graniteGolem = 648'054,
    harpy = 540'054,
    hoplite = 612'054,
    hornet = 576'000,
    imp = 468'000,
    jellyfish = 828'000,
    medusa = 504'054,
    pigron = 576'054,
    piranha = 1512'000,
    shark = 1800'000,
    skeleton = 360'000,
    slime = 144'000,
    undeadViking = 468'054,
    unicorn = 324'054,
    wallCreeper = 288'054,
    wraith = 396'054,
    king = 1440'000,
    queen = 1476'000,
    bomb = 612'000,
    heart = 1332'000,
    star = 72'000,
    mushroom = 1224'000,
    anvil = 1152'000,
    axe = 1044'000,
    boomerang = 900'000,
    boot = 936'000,
    bow = 864'000,
    cross = 792'000,
    gargoyle = 504'000,
    gloom = 540'000,
    hammer = 684'000,
    pickaxe = 1188'000,
    pillar = 1296'000,
    pot = 1368'000,
    potion = 720'000,
    reaper = 396'000,
    shield = 216'000,
    spear = 756'000,
    sunflower = 1404'000,
    sword = 108'000,
    tree = 1116'000,
    woman = 432'000,
};

}

namespace StatueVariants
{

inline std::array const deco = {
    Statue::anvil,     Statue::axe,     Statue::boomerang, Statue::boot,
    Statue::bow,       Statue::cross,   Statue::gargoyle,  Statue::gloom,
    Statue::hammer,    Statue::pickaxe, Statue::pillar,    Statue::pot,
    Statue::potion,    Statue::reaper,  Statue::shield,    Statue::spear,
    Statue::sunflower, Statue::sword,   Statue::tree,      Statue::woman};

inline std::array const enemy = {
    Statue::armedZombie,  Statue::bat,          Statue::bloodZombie,
    Statue::boneSkeleton, Statue::chest,        Statue::corrupt,
    Statue::crab,         Statue::drippler,     Statue::eyeball,
    Statue::goblin,       Statue::graniteGolem, Statue::harpy,
    Statue::hoplite,      Statue::hornet,       Statue::imp,
    Statue::jellyfish,    Statue::medusa,       Statue::pigron,
    Statue::piranha,      Statue::shark,        Statue::skeleton,
    Statue::slime,        Statue::undeadViking, Statue::unicorn,
    Statue::wallCreeper,  Statue::wraith};

inline std::array const utility =
    {Statue::king, Statue::queen, Statue::bomb, Statue::heart, Statue::star};

} // namespace StatueVariants

void placeStatue(int x, int y, int style, World &world);

#endif // STATUES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/StructureUtil.cpp`
```
#include "structures/StructureUtil.h"

#include "World.h"
#include "ids/Paint.h"
#include "vendor/frozen/set.h"
#include <cmath>

int makeCongruent(int val, int mod)
{
    return mod * (val / mod);
}

int binLocation(int x, int y, int maxY)
{
    int factor = 128;
    x /= factor;
    y /= factor;
    maxY /= factor;
    return x * maxY + y;
}

bool isLocationUsed(
    int x,
    int y,
    int radius,
    const std::vector<Point> &usedLocations,
    int maxCount)
{
    int count = 0;
    for (auto [usedX, usedY] : usedLocations) {
        if (std::hypot(x - usedX, y - usedY) < radius) {
            ++count;
            if (count >= maxCount) {
                return true;
            }
        }
    }
    return false;
}

inline constexpr auto nonSolidTiles = frozen::make_set<int>({
    TileID::empty,
    TileID::alchemyTable,
    TileID::altar,
    TileID::amberTree,
    TileID::amethystTree,
    TileID::ashPlant,
    TileID::ashTree,
    TileID::ashVines,
    TileID::banner,
    TileID::bastStatue,
    TileID::bathtub,
    TileID::bed,
    TileID::bench,
    TileID::bewitchingTable,
    TileID::boneWelder,
    TileID::book,
    TileID::bookcase,
    TileID::borealBeam,
    TileID::bottle,
    TileID::boulder,
    TileID::bouncyBoulder,
    TileID::bubble,
    TileID::cactusPlant,
    TileID::campfire,
    TileID::candelabra,
    TileID::candle,
    TileID::catacomb,
    TileID::chain,
    TileID::chair,
    TileID::chandelier,
    TileID::chest,
    TileID::chestGroup2,
    TileID::chimney,
    TileID::clock,
    TileID::cobweb,
    TileID::coral,
    TileID::corruptPlant,
    TileID::corruptVines,
    TileID::crimsonPlant,
    TileID::crimsonVines,
    TileID::detonator,
    TileID::diamondTree,
    TileID::door,
    TileID::dresser,
    TileID::emeraldTree,
    TileID::explosives,
    TileID::fallenLog,
    TileID::fireplace,
    TileID::flowerVines,
    TileID::gem,
    TileID::geyser,
    TileID::goldCoin,
    TileID::graniteColumn,
    TileID::grassPlant,
    TileID::hellforge,
    TileID::herb,
    TileID::honeyDrip,
    TileID::junglePlant,
    TileID::jungleVines,
    TileID::lamp,
    TileID::lantern,
    TileID::largeJunglePlant,
    TileID::largePile,
    TileID::largePileGroup2,
    TileID::larva,
    TileID::lavaDrip,
    TileID::lifeCrystal,
    TileID::lifeCrystalBoulder,
    TileID::lihzahrdAltar,
    TileID::loom,
    TileID::manaCrystal,
    TileID::marbleColumn,
    TileID::minecartTrack,
    TileID::mossPlant,
    TileID::mushroomPlant,
    TileID::mushroomVines,
    TileID::orbHeart,
    TileID::painting2x3,
    TileID::painting3x2,
    TileID::painting3x3,
    TileID::painting6x4,
    TileID::palmTree,
    TileID::piano,
    TileID::platform,
    TileID::pot,
    TileID::pressurePlate,
    TileID::richMahoganyBeam,
    TileID::rollingCactus,
    TileID::rope,
    TileID::rubyTree,
    TileID::sakuraTree,
    TileID::sandDrip,
    TileID::sandstoneColumn,
    TileID::sapphireTree,
    TileID::sensor,
    TileID::sharpeningStation,
    TileID::silverCoin,
    TileID::sink,
    TileID::smallPile,
    TileID::stalactite,
    TileID::statue,
    TileID::sunflower,
    TileID::table,
    TileID::tableGroup2,
    TileID::tallGrassPlant,
    TileID::tallJunglePlant,
    TileID::TNTBarrel,
    TileID::toilet,
    TileID::tombstone,
    TileID::topazTree,
    TileID::torch,
    TileID::tree,
    TileID::vineRope,
    TileID::vines,
    TileID::waterCandle,
    TileID::waterDrip,
    TileID::weatherVane,
    TileID::woodenBeam,
    TileID::workBench,
    TileID::yellowWillowTree,
});

bool isSolidBlock(int tileId)
{
    return !nonSolidTiles.contains(tileId);
}

bool isInBounds(Point pt, World &world)
{
    return pt.x > 5 && pt.x < world.getWidth() - 5 && pt.y > 5 &&
           pt.y < world.getHeight() - 5;
}

Point scanWhileEmpty(Point from, Point delta, World &world)
{
    while (world.getTile(from + delta).blockID == TileID::empty &&
           isInBounds(from, world)) {
        from += delta;
    }
    return from;
}

Point scanWhileNotSolid(Point from, Point delta, World &world)
{
    while (!isSolidBlock(world.getTile(from + delta).blockID) &&
           isInBounds(from, world)) {
        from += delta;
    }
    return from;
}

inline std::array paintRainbow{
    Paint::red,     Paint::orange, Paint::yellow,  Paint::lime,   Paint::green,
    Paint::teal,    Paint::cyan,   Paint::skyBlue, Paint::blue,   Paint::purple,
    Paint::violet,  Paint::pink,   Paint::violet,  Paint::purple, Paint::blue,
    Paint::skyBlue, Paint::cyan,   Paint::teal,    Paint::green,  Paint::lime,
    Paint::yellow,  Paint::orange, Paint::red};

int getRainbowPaint(int x, int y)
{
    return paintRainbow[(x + y) % paintRainbow.size()];
}

inline std::array paintDeepRainbow{
    Paint::deepRed,    Paint::deepOrange, Paint::deepYellow, Paint::deepLime,
    Paint::deepGreen,  Paint::deepTeal,   Paint::deepCyan,   Paint::deepSkyBlue,
    Paint::deepBlue,   Paint::deepPurple, Paint::deepViolet, Paint::deepPink,
    Paint::deepViolet, Paint::deepPurple, Paint::deepBlue,   Paint::deepSkyBlue,
    Paint::deepCyan,   Paint::deepTeal,   Paint::deepGreen,  Paint::deepLime,
    Paint::deepYellow, Paint::deepOrange, Paint::deepRed};

int getDeepRainbowPaint(int x, int y)
{
    return paintDeepRainbow[(x + y) % paintDeepRainbow.size()];
}

void placeWire(Point from, Point to, Wire wire, World &world)
{
    auto enableWireAt = [wire, &world](Point pt) {
        Tile &tile = world.getTile(pt);
        switch (wire) {
        case Wire::red:
            tile.wireRed = true;
            break;
        case Wire::blue:
            tile.wireBlue = true;
            break;
        case Wire::green:
            tile.wireGreen = true;
            break;
        case Wire::yellow:
            tile.wireYellow = true;
            break;
        }
    };
    enableWireAt(from);
    while (from != to) {
        if (from.x < to.x) {
            ++from.x;
        } else if (from.x > to.x) {
            --from.x;
        }
        enableWireAt(from);
        if (from.y < to.y) {
            ++from.y;
        } else if (from.y > to.y) {
            --from.y;
        }
        enableWireAt(from);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/StructureUtil.h`
```
#ifndef STRUCTUREUTIL_H
#define STRUCTUREUTIL_H

#include "Point.h"
#include <map>
#include <vector>

class World;

typedef std::map<int, std::vector<Point>> LocationBins;

enum class Wire { red = 0, blue, green, yellow };

int makeCongruent(int val, int mod);

int binLocation(int x, int y, int maxY);

bool isLocationUsed(
    int x,
    int y,
    int radius,
    const std::vector<Point> &usedLocations,
    int maxCount = 1);

bool isSolidBlock(int tileId);

Point scanWhileEmpty(Point from, Point delta, World &world);

Point scanWhileNotSolid(Point from, Point delta, World &world);

int getRainbowPaint(int x, int y);

int getDeepRainbowPaint(int x, int y);

void placeWire(Point from, Point to, Wire wire, World &world);

#endif // STRUCTUREUTIL_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/SurfaceIgloo.cpp`
```
#include "structures/SurfaceIgloo.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/StructureUtil.h"
#include "structures/data/Igloos.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

bool canPlaceIglooAt(int x, int y, TileBuffer &igloo, World &world)
{
    int surfaceLeft =
        scanWhileEmpty({x, world.getSurfaceLevel(x)}, {0, 1}, world).y - y;
    int surfaceRight = scanWhileEmpty(
                           {x + igloo.getWidth() - 1,
                            world.getSurfaceLevel(x + igloo.getWidth() - 1)},
                           {0, 1},
                           world)
                           .y -
                       y;
    if (surfaceLeft < 0 || surfaceRight < 0 ||
        surfaceLeft >= igloo.getHeight() || surfaceRight >= igloo.getHeight() ||
        igloo.getTile(0, surfaceLeft).blockPaint != Paint::red ||
        igloo.getTile(igloo.getWidth() - 1, surfaceRight).blockPaint !=
            Paint::red) {
        return false;
    }
    constexpr auto clearableTiles = frozen::make_set<int>(
        {TileID::empty,
         TileID::snow,
         TileID::ice,
         TileID::copperOre,
         TileID::tinOre,
         TileID::cobaltOre,
         TileID::palladiumOre});
    return world.regionPasses(
        x,
        y,
        igloo.getWidth(),
        igloo.getHeight(),
        [&clearableTiles](Tile &tile) {
            return clearableTiles.contains(tile.blockID);
        });
}

bool placeIgloo(Point pt, TileBuffer &igloo, Random &rnd, World &world)
{
    int minOpenHeight = igloo.getHeight();
    int maxOpenHeight = -1;
    for (int j = 0; j < igloo.getHeight(); ++j) {
        if (igloo.getTile(0, j).blockPaint == Paint::red) {
            minOpenHeight = std::min(j, minOpenHeight);
            maxOpenHeight = std::max(j, maxOpenHeight);
        }
    }
    int x = pt.x;
    int y =
        pt.y + std::midpoint(minOpenHeight, maxOpenHeight) - igloo.getHeight();
    for (int offsetSwap = 0; offsetSwap < 2 * igloo.getHeight(); ++offsetSwap) {
        int offset = offsetSwap / 2;
        if (offsetSwap % 2 == 1) {
            offset = -offset;
        }
        if (canPlaceIglooAt(x, y + offset, igloo, world)) {
            y += offset;
            std::vector<std::tuple<int, int, int>> wallMerges;
            for (int i = 0; i < igloo.getWidth(); ++i) {
                int maxClearY = std::lerp(
                                    world.getSurfaceLevel(x),
                                    world.getSurfaceLevel(x + igloo.getWidth()),
                                    static_cast<double>(i) / igloo.getWidth()) -
                                1;
                for (int cY = world.getSurfaceLevel(x + i) - 1; cY < maxClearY;
                     ++cY) {
                    world.getTile(x + i, cY) = {};
                }
                for (int j = 0; j < igloo.getHeight(); ++j) {
                    Tile &iglooTile = igloo.getTile(i, j);
                    if (iglooTile.blockID == TileID::cloud) {
                        continue;
                    }
                    Tile &tile = world.getTile(x + i, y + j);
                    if (iglooTile.wallID == WallID::empty &&
                        isSolidBlock(iglooTile.blockID) &&
                        tile.wallID != WallID::empty) {
                        wallMerges.emplace_back(x + i, y + j, tile.wallID);
                    }
                    tile = iglooTile;
                    tile.guarded = true;
                    if (tile.blockID == TileID::chest &&
                        tile.frameX % 36 == 0 && tile.frameY == 0) {
                        if (tile.frameX == 180) {
                            fillBarrel(
                                world.registerStorage(x + i, y + j),
                                rnd);
                        } else {
                            fillFrozenChest(
                                world.registerStorage(x + i, y + j),
                                getChestDepth(x + i, y + j, world),
                                rnd,
                                world);
                        }
                    }
                }
            }
            for (auto [wX, wY, wallID] : wallMerges) {
                if (!world.isExposed(wX, wY)) {
                    world.getTile(wX, wY).wallID = wallID;
                }
            }
            return true;
        }
    }
    return false;
}

void genIgloo(Random &rnd, World &world)
{
    std::cout << "Piling snow\n";
    std::vector<int> locations;
    if (world.conf.biomes == BiomeLayout::columns) {
        int scanDist = world.conf.snowSize * 0.05 * world.getWidth();
        for (int x = world.snowCenter - scanDist;
             x < world.snowCenter + scanDist;
             ++x) {
            if (std::abs(x - world.spawn.x) > 100) {
                locations.push_back(x);
            }
        }
    } else {
        for (int x = 350; x < world.getWidth() - 350; ++x) {
            if (std::abs(x - world.spawn.x) > 100 &&
                world.getBiome(x, world.getSurfaceLevel(x)).snow > 0.99) {
                locations.push_back(x);
            }
        }
    }
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    TileBuffer igloo =
        Data::getIgloo(rnd.select(Data::igloos), world.getFramedTiles());
    for (int x : locations) {
        if (placeIgloo(
                scanWhileEmpty({x, world.getSurfaceLevel(x)}, {0, 1}, world),
                igloo,
                rnd,
                world)) {
            break;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/SurfaceIgloo.h`
```
#ifndef SURFACEIGLOO_H
#define SURFACEIGLOO_H

class World;
class Random;

void genIgloo(Random &rnd, World &world);

#endif // SURFACEIGLOO_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Temple.cpp`
```
#include "structures/Temple.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/Platforms.h"
#include "structures/StructureUtil.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>
#include <set>

template <typename Func> void iterateTemple(Point center, World &world, Func f)
{
    int scanX =
        std::max<int>(world.conf.templeSize * 0.029 * world.getWidth(), 128);
    int scanY = 0.45 * scanX;
    int startScanY = scanY;
    int stepCtrl = -1;
    for (int i = -scanX; i < scanX; ++i) {
        if (stepCtrl < 0) {
            if (stepCtrl < -3) {
                stepCtrl = i > -30 && i < -15 ? -i * 2 - 1 : 15;
            }
            if (i < 0) {
                startScanY -= 4;
            } else {
                startScanY += 4;
            }
        }
        --stepCtrl;
        int endScanY = scanY - (((i + scanX) / 3) % 2);
        for (int j = startScanY; j < endScanY; ++j) {
            if (!f(center.x + i, center.y + j)) {
                return;
            }
        }
    }
}

bool testTempleSelection(Point center, World &world)
{
    std::set<int> avoidBlocks{
        TileID::aetherium,
        TileID::ash,
        TileID::blueBrick,
        TileID::granite,
        TileID::greenBrick,
        TileID::hive,
        TileID::livingMahogany,
        TileID::livingWood,
        TileID::marble,
        TileID::mushroomGrass,
        TileID::pinkBrick,
    };
    if (!world.conf.dontDigUp) {
        avoidBlocks.insert(
            {TileID::corruptJungleGrass, TileID::crimsonJungleGrass});
    }
    bool isValid = true;
    iterateTemple(
        center,
        world,
        [&avoidBlocks, &isValid, &world](int x, int y) {
            if (avoidBlocks.contains(world.getTile(x, y).blockID)) {
                isValid = false;
                return false;
            }
            return true;
        });
    return isValid;
}

Point selectTempleCenter(
    std::function<bool(Point, World &)> isValid,
    Random &rnd,
    World &world)
{
    int minX = world.conf.biomes == BiomeLayout::columns
                   ? std::max<int>(
                         world.jungleCenter -
                             world.conf.jungleSize * 0.079 * world.getWidth(),
                         350)
                   : 350;
    int maxX = world.conf.biomes == BiomeLayout::columns
                   ? std::min<int>(
                         world.jungleCenter +
                             world.conf.jungleSize * 0.079 * world.getWidth(),
                         world.getWidth() - 350)
                   : world.getWidth() - 350;
    if (maxX < minX) {
        minX = std::midpoint(minX, maxX);
        maxX = minX + 1;
    }
    int minY = world.conf.dontDigUp
                   ? world.getSurfaceLevel(world.jungleCenter) +
                         std::max(
                             world.conf.templeSize * 0.009 * world.getWidth(),
                             40.0) -
                         20
                   : std::midpoint(
                         world.getUndergroundLevel(),
                         world.getCavernLevel());
    int maxY = world.conf.dontDigUp ? minY + 30 : world.getUnderworldLevel();
    for (int numTries = 0; numTries < 1000; ++numTries) {
        int x = rnd.getInt(minX, maxX);
        int y = rnd.getInt(minY, maxY);
        if ((world.conf.biomes == BiomeLayout::columns ||
             isInBiome(x, y, 200 - 0.19 * numTries, Biome::jungle, world)) &&
            isValid({x, y}, world)) {
            return {x, y};
        }
    }
    return {world.jungleCenter, std::midpoint(minY, maxY)};
}

void clearTempleSurface(Point center, int grassTile, Random &rnd, World &world)
{
    clearTempleSurface(
        center,
        std::max<double>(world.conf.templeSize * 0.019 * world.getWidth(), 82),
        grassTile,
        rnd,
        world);
}

void clearTempleSurface(
    Point center,
    int scanDist,
    int grassTile,
    Random &rnd,
    World &world)
{
    rnd.shuffleNoise();
    constexpr auto clearableTiles = frozen::make_set<int>(
        {TileID::dirt,          TileID::mud,         TileID::jungleGrass,
         TileID::ebonstone,     TileID::demonite,    TileID::corruptJungleGrass,
         TileID::crimstone,     TileID::crimtane,    TileID::crimsonJungleGrass,
         TileID::stone,         TileID::clay,        TileID::silt,
         TileID::copperOre,     TileID::tinOre,      TileID::ironOre,
         TileID::leadOre,       TileID::silverOre,   TileID::tungstenOre,
         TileID::goldOre,       TileID::platinumOre, TileID::cobaltOre,
         TileID::palladiumOre,  TileID::mythrilOre,  TileID::orichalcumOre,
         TileID::adamantiteOre, TileID::titaniumOre, TileID::chlorophyteOre});
    for (int x = center.x - scanDist; x < center.x + scanDist; ++x) {
        for (int y = center.y - scanDist; y < center.y + scanDist; ++y) {
            double threshold = 3 * hypot(center, {x, y}) / scanDist - 2;
            Tile &tile = world.getTile(x, y);
            if (rnd.getFineNoise(x, y) > threshold) {
                if (tile.blockID == TileID::lihzahrdBrick) {
                    break;
                } else if (clearableTiles.contains(tile.blockID)) {
                    tile.blockID = TileID::empty;
                    Tile &leftTile = world.getTile(x - 1, y);
                    if (leftTile.blockID == TileID::mud) {
                        leftTile.blockID = grassTile;
                    }
                }
            } else if (tile.blockID == TileID::mud && world.isExposed(x, y)) {
                tile.blockID = grassTile;
            }
        }
    }
}

void applyRoomConnection(Point from, Point to, int roomSize, World &world)
{
    if (from.x == to.x) {
        int minY = std::min(from.y, to.y);
        int maxY = std::max(from.y, to.y);
        for (int x = from.x; x < from.x + roomSize; ++x) {
            for (int y = minY + roomSize; y < maxY; ++y) {
                world.getTile(x, y).blockID = TileID::empty;
            }
        }
    } else {
        int minX = std::min(from.x, to.x);
        int maxX = std::max(from.x, to.x);
        for (int x = minX + roomSize; x < maxX; ++x) {
            for (int y = from.y; y < from.y + roomSize; ++y) {
                world.getTile(x, y).blockID = TileID::empty;
            }
        }
    }
}

void addTempleEntry(int centerX, int minY, World &world)
{
    int doorOffset = 29;
    int x = centerX;
    while (world.getTile(x - 1, minY + doorOffset).wallID ==
           WallID::Unsafe::lihzahrdBrick) {
        --x;
    }
    world
        .placeFramedTile(x, minY + doorOffset, TileID::door, Variant::lihzahrd);
    world.placeFramedTile(
        x - 2,
        minY + doorOffset,
        TileID::lamp,
        Variant::lihzahrd);
    world.placeFramedTile(
        x + 2,
        minY + doorOffset + 1,
        TileID::pot,
        Variant::lihzahrd);
    int clearedGap = 0;
    for (++x; x < centerX; ++x) {
        for (int i = 0; i < 3; ++i) {
            Tile &tile = world.getTile(x, minY + doorOffset + i);
            if (tile.blockID == TileID::lihzahrdBrick) {
                tile.blockID = TileID::empty;
            }
        }
        if (world.getTile(x, minY + doorOffset - 1).blockID == TileID::empty ||
            world.getTile(x, minY + doorOffset + 3).blockID == TileID::empty) {
            ++clearedGap;
            if (clearedGap > 1) {
                break;
            }
        }
    }
    x = centerX;
    while (world.getTile(x + 1, minY + doorOffset).wallID ==
           WallID::Unsafe::lihzahrdBrick) {
        ++x;
    }
    world
        .placeFramedTile(x, minY + doorOffset, TileID::door, Variant::lihzahrd);
    world.placeFramedTile(
        x + 2,
        minY + doorOffset,
        TileID::lamp,
        Variant::lihzahrd);
    world.placeFramedTile(
        x - 3,
        minY + doorOffset + 1,
        TileID::pot,
        Variant::lihzahrd);
    clearedGap = 0;
    for (--x; x > centerX; --x) {
        for (int i = 0; i < 3; ++i) {
            Tile &tile = world.getTile(x, minY + doorOffset + i);
            if (tile.blockID == TileID::lihzahrdBrick) {
                tile.blockID = TileID::empty;
            }
        }
        if (world.getTile(x, minY + doorOffset - 1).blockID == TileID::empty ||
            world.getTile(x, minY + doorOffset + 3).blockID == TileID::empty) {
            ++clearedGap;
            if (clearedGap > 1) {
                break;
            }
        }
    }
}

void addDeadEndPlatforms(
    int roomSize,
    const std::set<Point> &rooms,
    World &world)
{
    for (auto [x, y] : rooms) {
        bool isVertDeadEnd = true;
        for (auto [i, j] :
             {std::pair{-1, 0}, {0, -1}, {roomSize - 1, -1}, {roomSize, 0}}) {
            if (world.getTile(x + i, y + j).blockID != TileID::lihzahrdBrick) {
                isVertDeadEnd = false;
                break;
            }
        }
        if (!isVertDeadEnd) {
            continue;
        }
        for (int i = 0; i < roomSize; ++i) {
            placePlatform(x + i, y + roomSize - 1, Platform::lihzahrd, world);
        }
    }
}

bool canPlaceTempleTreasureAt(int x, int y, World &world)
{
    constexpr auto baseTiles =
        frozen::make_set<int>({TileID::lihzahrdBrick, TileID::platform});
    return baseTiles.contains(world.getTile(x, y).blockID) &&
           baseTiles.contains(world.getTile(x + 1, y).blockID) &&
           world.regionPasses(x, y - 4, 2, 4, [](Tile &tile) {
               return tile.blockID == TileID::empty &&
                      tile.wallID == WallID::Unsafe::lihzahrdBrick;
           });
}

std::vector<Point>
addTempleTreasures(Point center, int numRooms, Random &rnd, World &world)
{
    std::vector<Point> locations;
    iterateTemple(center, world, [&](int x, int y) {
        if (canPlaceTempleTreasureAt(x, y, world)) {
            locations.emplace_back(x, y);
            if (world.getTile(x, y).blockID == TileID::platform) {
                for (int i = 0; i < 14; ++i) {
                    locations.emplace_back(x, y);
                }
            }
        }
        return true;
    });
    addTempleTreasures(locations, numRooms, rnd, world);
    return locations;
}

void addTempleTreasures(
    std::vector<Point> &locations,
    int numRooms,
    Random &rnd,
    World &world)
{
    int numChests = world.conf.chests * numRooms / 17.5;
    std::vector<Point> usedLocations;
    while (numChests > 0) {
        auto [x, y] = rnd.select(locations);
        if (!canPlaceTempleTreasureAt(x, y, world) ||
            isLocationUsed(x, y, 12, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        Chest &chest = world.placeChest(x, y - 2, Variant::lihzahrd);
        fillLihzahrdChest(chest, rnd, world);
        --numChests;
    }
    int numPots = numRooms / 14;
    while (numPots > 0) {
        auto [x, y] = rnd.select(locations);
        if (!canPlaceTempleTreasureAt(x, y, world)) {
            continue;
        }
        world.placeFramedTile(x, y - 2, TileID::pot, Variant::lihzahrd);
        --numPots;
    }
    int numStatues = numRooms / 12;
    while (numStatues > 0) {
        auto [x, y] = rnd.select(locations);
        if (!canPlaceTempleTreasureAt(x - 1, y, world) ||
            !canPlaceTempleTreasureAt(x + 1, y, world)) {
            continue;
        }
        world.placeFramedTile(x, y - 3, TileID::statue, Variant::lihzahrd);
        --numStatues;
    }
}

void addWallTrap(
    Point pos,
    Variant trapLeft,
    Variant trapRight,
    Random &rnd,
    World &world)
{
    if (!canPlaceTempleTreasureAt(pos.x, pos.y, world)) {
        return;
    }
    auto [x, y] = pos;
    --y;
    std::vector<Point> traps;
    for (int j = 0; j < 4; ++j) {
        for (int dir : {-1, 1}) {
            Point trap = scanWhileNotSolid({x, y - j}, {dir, 0}, world);
            double dist = hypot(trap, {x, y});
            if (dist > 1.5 && dist < 20 &&
                world.getTile(trap.x + dir, trap.y).blockID ==
                    TileID::lihzahrdBrick) {
                traps.push_back({trap.x + dir, trap.y});
            }
        }
    }
    if (traps.empty()) {
        return;
    }
    std::shuffle(traps.begin(), traps.end(), rnd.getPRNG());
    traps.resize(rnd.getInt(1, std::min<int>(traps.size(), 3)));
    for (auto trap : traps) {
        placeWire(trap, {x, y}, static_cast<Wire>((x + y) % 4), world);
        world.placeFramedTile(
            trap.x,
            trap.y,
            TileID::trap,
            trap.x > x ? trapLeft : trapRight);
    }
    world.placeFramedTile(x, y, TileID::pressurePlate, Variant::lihzahrd);
}

void addCeilingTrap(Point pos, Variant trapType, World &world)
{
    if (!canPlaceTempleTreasureAt(pos.x, pos.y, world)) {
        return;
    }
    auto [x, y] = pos;
    --y;
    int trapCeiling = scanWhileEmpty({x, y}, {0, -1}, world).y - 1;
    if (world.getTile(x, trapCeiling).blockID != TileID::lihzahrdBrick ||
        (trapType == Variant::spear && y - trapCeiling > 18)) {
        return;
    }
    for (int i = -3; i < 4; ++i) {
        if (world.getTile(x + i, trapCeiling).blockID ==
                TileID::lihzahrdBrick &&
            world.getTile(x + i, trapCeiling + 1).blockID == TileID::empty) {
            placeWire(
                {x + i, trapCeiling},
                {x, y},
                static_cast<Wire>((x + y) % 4),
                world);
            world.placeFramedTile(x + i, trapCeiling, TileID::trap, trapType);
        }
    }
    world.placeFramedTile(x, y, TileID::pressurePlate, Variant::lihzahrd);
}

void addTempleTraps(
    std::vector<Point> &locations,
    int freqCtrl,
    Random &rnd,
    World &world)
{
    for (auto [x, y] : locations) {
        switch (static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) %
                freqCtrl) {
        case 0:
            if (canPlaceTempleTreasureAt(x, y, world)) {
                world.placeFramedTile(x, y - 2, TileID::TNTBarrel);
            }
            break;
        case 1:
        case 2:
            addWallTrap(
                {x, y},
                Variant::flameLeft,
                Variant::flameRight,
                rnd,
                world);
            break;
        case 3:
        case 4:
            addWallTrap(
                {x, y},
                Variant::superDartLeft,
                Variant::superDartRight,
                rnd,
                world);
            break;
        case 5:
        case 6:
            addCeilingTrap({x, y}, Variant::spear, world);
            break;
        case 7:
        case 8:
            addCeilingTrap({x, y}, Variant::spikyBall, world);
            break;
        }
    }
}

void addTempleSpikesAt(Point pos, Random &rnd, World &world)
{
    if (static_cast<int>(99999 * (1 + rnd.getFineNoise(pos.x, pos.y))) % 150 !=
        0) {
        return;
    }
    Point delta = rnd.select({Point{1, 0}, {-1, 0}, {0, 1}, {0, -1}});
    Point wall = scanWhileNotSolid(pos, delta, world);
    Point incr = delta.x == 0 ? Point{1, 0} : Point{0, 1};
    for (int t = 0; t < 4; ++t) {
        wall -= incr;
    }
    for (int t = 0; t < 9; ++t, wall += incr) {
        if (world.getTile(wall).blockID != TileID::empty ||
            world.getTile(wall + delta).blockID != TileID::lihzahrdBrick) {
            continue;
        }
        world.getTile(wall).blockID = TileID::woodenSpike;
        if ((wall.x + wall.y) % 2 == 0) {
            world.getTile(wall + delta).blockID = TileID::woodenSpike;
        } else {
            Tile &tile = world.getTile(wall - delta);
            if (tile.blockID == TileID::empty) {
                tile.blockID = TileID::woodenSpike;
            }
        }
    }
}

void addSpikes(Point center, Random &rnd, World &world)
{
    iterateTemple(center, world, [&](int x, int y) {
        if (world.regionPasses(x - 1, y - 1, 3, 3, [](Tile &tile) {
                return tile.blockID == TileID::empty;
            })) {
            addTempleSpikesAt({x, y}, rnd, world);
        }
        return true;
    });
}

void paintTemple(Point center, int blockPaint, int wallPaint, World &world)
{
    iterateTemple(center, world, [blockPaint, wallPaint, &world](int x, int y) {
        Tile &tile = world.getTile(x, y);
        if (tile.blockID == TileID::lihzahrdBrick ||
            tile.blockID == TileID::platform ||
            tile.blockID == TileID::pressurePlate ||
            tile.blockID == TileID::trap) {
            tile.blockPaint = blockPaint;
        }
        if (tile.wallID == WallID::Unsafe::lihzahrdBrick) {
            tile.wallPaint = wallPaint;
        }
        return true;
    });
}

void genTemple(Random &rnd, World &world)
{
    if (world.conf.templeSize < 0.01) {
        return;
    }
    std::cout << "Training acolytes\n";
    Point center = selectTempleCenter(testTempleSelection, rnd, world);
    if (center.x < 100) {
        return;
    }
    int numCorrupt = 0;
    int numCrimson = 0;
    iterateTemple(
        center,
        world,
        [&numCorrupt, &numCrimson, &world](int x, int y) {
            Tile &tile = world.getTile(x, y);
            if (tile.blockID == TileID::corruptJungleGrass) {
                ++numCorrupt;
            } else if (tile.blockID == TileID::crimsonJungleGrass) {
                ++numCrimson;
            }
            tile.blockID = TileID::lihzahrdBrick;
            tile.blockPaint = Paint::none;
            tile.wallID = WallID::Unsafe::lihzahrdBrick;
            return true;
        });
    clearTempleSurface(
        center,
        numCrimson > numCorrupt ? TileID::crimsonJungleGrass
        : numCorrupt == 0       ? TileID::jungleGrass
                                : TileID::corruptJungleGrass,
        rnd,
        world);
    int wallThickness = 4;
    int roomSize = 7;
    int roomStep = roomSize + wallThickness;
    std::set<Point> rooms;
    int modTargetX = center.x % roomStep;
    int modTargetY = center.y % roomStep;
    int centerRoomX = 0;
    int maxRoomY = 0;
    int minY = center.y;
    iterateTemple(center, world, [&](int x, int y) {
        minY = std::min(y, minY);
        if (x % roomStep == modTargetX && y % roomStep == modTargetY &&
            world.regionPasses(
                x - wallThickness,
                y - wallThickness,
                roomStep + wallThickness,
                roomStep + wallThickness,
                [](Tile &tile) {
                    return tile.wallID == WallID::Unsafe::lihzahrdBrick;
                })) {
            if (std::abs(x - center.x) < std::abs(centerRoomX - center.x)) {
                centerRoomX = x;
            }
            maxRoomY = std::max(y, maxRoomY);
            rooms.emplace(x, y);
        }
        return true;
    });
    for (int i = -2; i < 3; ++i) {
        for (int j = -2; j < 1; ++j) {
            rooms.erase({centerRoomX + i * roomStep, maxRoomY + j * roomStep});
        }
    }
    rooms.emplace(
        rnd.select({centerRoomX - 2 * roomStep, centerRoomX + 2 * roomStep}),
        maxRoomY);
    Point agent = *rooms.begin();
    std::set<Point> connectedRooms{agent};
    std::set<Point> connections;
    std::vector<Point> junctions;
    while (connectedRooms.size() < rooms.size()) {
        std::vector<Point> choices;
        for (Point step :
             {Point{-roomStep, 0},
              {roomStep, 0},
              {0, -roomStep},
              {0, roomStep}}) {
            Point candidate = agent + step;
            if (rooms.contains(candidate) &&
                (!connectedRooms.contains(candidate) ||
                 connections.contains(agent + candidate))) {
                choices.push_back(candidate);
            }
        }
        if (choices.size() == 1 && connectedRooms.contains(choices[0])) {
            agent = junctions.back();
            junctions.pop_back();
        } else {
            for (Point choice : choices) {
                if (!connectedRooms.contains(choice)) {
                    junctions.push_back(agent);
                    break;
                }
            }
            Point next = rnd.select(choices);
            if (!connectedRooms.contains(next)) {
                connections.insert(agent + next);
                connectedRooms.insert(next);
                applyRoomConnection(agent, next, roomSize, world);
            }
            agent = next;
        }
    }
    for (auto [x, y] : rooms) {
        for (int i = 0; i < roomSize; ++i) {
            for (int j = 0; j < roomSize; ++j) {
                world.getTile(x + i, y + j).blockID = TileID::empty;
            }
        }
    }
    for (int x = centerRoomX - 2 * roomStep;
         x < centerRoomX + 2 * roomStep + roomSize;
         ++x) {
        for (int y = maxRoomY - 2 * roomStep; y < maxRoomY + roomSize; ++y) {
            world.getTile(x, y).blockID = TileID::empty;
        }
    }
    addTempleEntry(center.x, minY, world);
    addDeadEndPlatforms(roomSize, rooms, world);
    world.placeFramedTile(
        centerRoomX + roomSize / 2 - 1,
        maxRoomY + roomSize - 2,
        TileID::lihzahrdAltar);
    std::vector<Point> flatLocations =
        addTempleTreasures(center, rooms.size(), rnd, world);
    std::erase_if(flatLocations, [&world](Point &pt) {
        return world.getTile(pt).blockID == TileID::platform;
    });
    std::shuffle(flatLocations.begin(), flatLocations.end(), rnd.getPRNG());
    addTempleTraps(flatLocations, 75, rnd, world);
    addSpikes(center, rnd, world);
    if (!world.conf.unpainted) {
        if (world.conf.forTheWorthy) {
            paintTemple(center, Paint::deepGreen, Paint::deepGreen, world);
        } else if (world.conf.dontDigUp) {
            paintTemple(
                center,
                numCrimson > numCorrupt ? Paint::deepRed : Paint::deepPurple,
                Paint::black,
                world);
        } else if (world.conf.celebration) {
            paintTemple(center, Paint::purple, Paint::cyan, world);
        } else if (world.conf.doubleTrouble) {
            paintTemple(center, Paint::deepLime, Paint::deepLime, world);
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Temple.h`
```
#ifndef TEMPLE_H
#define TEMPLE_H

#include "Point.h"
#include <functional>
#include <vector>

class World;
class Random;

void genTemple(Random &rnd, World &world);
Point selectTempleCenter(
    std::function<bool(Point, World &)> isValid,
    Random &rnd,
    World &world);
void clearTempleSurface(
    Point center,
    int scanDist,
    int grassTile,
    Random &rnd,
    World &world);
bool canPlaceTempleTreasureAt(int x, int y, World &world);
void addTempleTreasures(
    std::vector<Point> &locations,
    int numRooms,
    Random &rnd,
    World &world);
void addTempleTraps(
    std::vector<Point> &locations,
    int freqCtrl,
    Random &rnd,
    World &world);
void addTempleSpikesAt(Point pos, Random &rnd, World &world);

#endif // TEMPLE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/TorchArena.cpp`
```
#include "structures/TorchArena.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include "structures/data/Torches.h"
#include "vendor/frozen/set.h"
#include <iostream>

Point selectArenaLocation(
    int arenaWidth,
    int arenaHeight,
    Random &rnd,
    World &world)
{
    constexpr auto clearableTiles = frozen::make_set<int>({
        TileID::empty,
        TileID::dirt,
        TileID::stone,
        TileID::mud,
        TileID::sand,
        TileID::clay,
        TileID::ironOre,
        TileID::leadOre,
        TileID::silverOre,
        TileID::tungstenOre,
        TileID::goldOre,
        TileID::platinumOre,
        TileID::cobaltOre,
        TileID::palladiumOre,
        TileID::mythrilOre,
        TileID::orichalcumOre,
        TileID::adamantiteOre,
        TileID::titaniumOre,
    });
    int minX = 100;
    int maxX = world.getWidth() - 100 - arenaWidth;
    int minY =
        std::midpoint(world.getCavernLevel(), world.getUnderworldLevel()) -
        arenaHeight;
    int maxY = world.getUnderworldLevel() - arenaHeight;
    int maxFoundationEmpty = 0.4 * arenaWidth;
    int padding = world.conf.hiveQueen ? 6 : 20;
    for (int tries = 0; tries < 8000; ++tries) {
        int x = rnd.getInt(minX, maxX);
        int y = rnd.getInt(minY, maxY);
        if (world.conf.hiveQueen) {
            while (world.getBiome(x, y).active == Biome::jungle) {
                x = rnd.getInt(minX, maxX);
                y = rnd.getInt(minY, maxY);
            }
        }
        if (hypot(world.gemGrove, {x, y}) < 150) {
            continue;
        }
        int numEmpty = 0;
        int numFilled = 0;
        int maxEntryFilled = tries / 250;
        if (world.conf.hiveQueen) {
            maxEntryFilled += 5;
        }
        if (world.regionPasses(
                x - 3,
                y + arenaHeight - 9,
                4,
                4,
                [maxEntryFilled, &numFilled](Tile &tile) {
                    if (tile.blockID != TileID::empty) {
                        ++numFilled;
                    }
                    return numFilled < maxEntryFilled;
                }) &&
            world.regionPasses(
                x + arenaWidth - 1,
                y + arenaHeight - 9,
                4,
                4,
                [maxEntryFilled, &numFilled](Tile &tile) {
                    if (tile.blockID != TileID::empty) {
                        ++numFilled;
                    }
                    return numFilled < maxEntryFilled;
                }) &&
            world.regionPasses(
                x - padding / 2,
                y - padding / 2,
                arenaWidth + padding,
                arenaHeight + padding,
                [&clearableTiles](Tile &tile) {
                    return !tile.guarded && tile.liquid != Liquid::shimmer &&
                           clearableTiles.contains(tile.blockID);
                }) &&
            world.regionPasses(
                x,
                y + arenaHeight - 2,
                arenaWidth,
                4,
                [maxFoundationEmpty, &numEmpty](Tile &tile) {
                    if (tile.blockID == TileID::empty) {
                        ++numEmpty;
                    }
                    return numEmpty < maxFoundationEmpty;
                })) {
            return {x, y};
        }
    }
    return {-1, -1};
}

void placeTorchStructure(int x, int y, TileBuffer &data, World &world)
{
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &dataTile = data.getTile(i, j);
            if (dataTile.wallID == WallID::Safe::cloud) {
                if (world.getTile(x + i, y + j).wallID == WallID::empty) {
                    dataTile.wallID = WallID::Unsafe::ember;
                    dataTile.echoCoatWall = true;
                } else {
                    dataTile.wallID = WallID::empty;
                }
            }
        }
    }
    world.placeBuffer(x, y, data);
    world.queuedDeco.emplace_back(
        [x, y, dW = data.getWidth(), dH = data.getHeight()](
            Random &,
            World &world) {
            for (int i = 0; i < dW; ++i) {
                for (int j = 0; j < dH; ++j) {
                    world.getTile(x + i, y + j).liquid = Liquid::none;
                }
            }
        });
}

void addArenaBubble(int x, int y, World &world)
{
    if (!world.conf.sunken || !world.conf.shattered || x < 420 ||
        x > world.getWidth() - 420) {
        return;
    }
    double maxS = 45.5;
    double minS = maxS - 3;
    for (int i = -maxS; i < maxS; ++i) {
        for (int j = -maxS; j < maxS; ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            if (tile.blockID != TileID::empty) {
                continue;
            }
            double dist = std::hypot(i, j);
            if (dist < maxS && dist > minS) {
                tile.blockID = TileID::bubble;
            }
        }
    }
}

void genTorchArena(Random &rnd, World &world)
{
    std::cout << "Fueling TORCH\n";
    int arenaWidth = rnd.getInt(90, 110);
    int arenaHeight = rnd.getInt(45, 52);
    auto [x, y] = selectArenaLocation(arenaWidth, arenaHeight, rnd, world);
    if (x == -1) {
        return;
    }
    arenaWidth /= 2;
    x += arenaWidth;
    arenaWidth += 3;
    arenaHeight -= 5;
    y += arenaHeight;
    int favorBase = -3;
    for (int i = -arenaWidth; i < arenaWidth; ++i) {
        int arenaBase = 3.5 * (10 + arenaWidth - std::abs(i)) *
                        rnd.getFineNoise(x + i, 0) / arenaWidth;
        if (i > -4 && i < 4) {
            favorBase = std::max(favorBase, arenaBase);
        }
        for (int j = -arenaHeight; j < arenaBase; ++j) {
            double threshold = 3.5 * std::hypot(
                                         static_cast<double>(i) / arenaWidth,
                                         static_cast<double>(j) / arenaHeight) -
                               2.5;
            if (rnd.getFineNoise(x + i, y + j) > threshold) {
                world.getTile(x + i, y + j).blockID = TileID::empty;
            }
        }
    }
    TileBuffer torchFavor =
        Data::getTorch(Data::Torch::favor, world.getFramedTiles());
    placeTorchStructure(
        x - torchFavor.getWidth() / 2,
        y + favorBase + 1 - torchFavor.getHeight(),
        torchFavor,
        world);
    addArenaBubble(x, y + favorBase - torchFavor.getHeight(), world);
    int offset =
        rnd.select({-1, 1}) * (torchFavor.getWidth() / 2 + arenaWidth / 4);
    TileBuffer torch = Data::getTorch(
        rnd.getBool() ? Data::Torch::up
        : offset > 0  ? Data::Torch::left
                      : Data::Torch::right,
        world.getFramedTiles());
    offset -= torch.getWidth() / 2;
    int torchBase = -3;
    for (int i = 2; i < torch.getWidth() - 2; ++i) {
        int curBase =
            scanWhileEmpty({x + offset + i, y - 3}, {0, 1}, world).y - y;
        if (curBase < 5) {
            torchBase = std::max(torchBase, curBase);
        }
    }
    placeTorchStructure(
        x + offset,
        y + torchBase + 2 - torch.getHeight(),
        torch,
        world);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/TorchArena.h`
```
#ifndef TORCHARENA_H
#define TORCHARENA_H

class World;
class Random;

void genTorchArena(Random &rnd, World &world);

#endif // TORCHARENA_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Traps.cpp`
```
#include "structures/Traps.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

inline constexpr auto trappableTiles = frozen::make_set<int>({
    TileID::empty,
    TileID::dirt,
    TileID::stone,
    TileID::grass,
    TileID::corruptGrass,
    TileID::ebonstone,
    TileID::clay,
    TileID::mud,
    TileID::jungleGrass,
    TileID::mushroomGrass,
    TileID::hallowedGrass,
    TileID::pearlstone,
    TileID::snow,
    TileID::ice,
    TileID::corruptIce,
    TileID::hallowedIce,
    TileID::slime,
    TileID::crimsonGrass,
    TileID::crimsonIce,
    TileID::crimstone,
    TileID::crispyHoney,
    TileID::smoothMarble,
    TileID::marble,
    TileID::granite,
    TileID::smoothGranite,
    TileID::pinkSlime,
    TileID::lavaMossStone,
    TileID::sandstone,
    TileID::hardenedSand,
    TileID::hardenedEbonsand,
    TileID::hardenedCrimsand,
    TileID::ebonsandstone,
    TileID::crimsandstone,
    TileID::hardenedPearlsand,
    TileID::pearlsandstone,
    TileID::kryptonMossStone,
    TileID::xenonMossStone,
    TileID::argonMossStone,
    TileID::neonMossStone,
    TileID::corruptJungleGrass,
    TileID::crimsonJungleGrass,
});

bool isTrappable(Tile &tile)
{
    return !tile.guarded &&
           (trappableTiles.contains(tile.blockID) ||
            (tile.blockID == TileID::hive && tile.flag != Flag::none));
}

bool makeSaferTraps(World &world)
{
    return world.conf.celebration && !world.conf.forTheWorthy;
}

void placePressurePlate(int x, int y, bool isSingleUse, World &world)
{
    Tile &tile = world.getTile(x, y);
    tile.blockID = TileID::pressurePlate;
    if (makeSaferTraps(world)) {
        tile.frameY = isSingleUse ? 126 : 54;
        tile.blockPaint = Paint::red;
        return;
    }
    if (isSingleUse) {
        tile.frameY = 126;
        switch (world.getTile(x, y + 1).blockID) {
        case TileID::dirt:
        case TileID::mud:
            tile.blockPaint = Paint::brown;
            break;
        case TileID::stone:
        case TileID::ebonstone:
        case TileID::crimstone:
        case TileID::granite:
        case TileID::silt:
        case TileID::pearlstone:
        case TileID::pearlsand:
        case TileID::hardenedPearlsand:
        case TileID::pearlsandstone:
            tile.blockPaint = Paint::gray;
            break;
        case TileID::jungleGrass:
            tile.blockPaint = Paint::lime;
            break;
        case TileID::snow:
        case TileID::marble:
            tile.blockPaint = Paint::white;
            break;
        case TileID::ice:
        case TileID::corruptIce:
        case TileID::crimsonIce:
        case TileID::slime:
            tile.blockPaint = Paint::skyBlue;
            break;
        }
    } else {
        tile.frameY = 36;
        switch (world.getTile(x, y + 1).blockID) {
        case TileID::dirt:
        case TileID::mud:
            tile.frameY = 54;
            break;
        case TileID::jungleGrass:
            tile.blockPaint = Paint::lime;
            break;
        case TileID::snow:
        case TileID::marble:
            tile.blockPaint = Paint::white;
            break;
        case TileID::ice:
        case TileID::corruptIce:
        case TileID::crimsonIce:
        case TileID::slime:
            tile.blockPaint = Paint::skyBlue;
            break;
        }
    }
}

void placeSandTraps(Random &rnd, World &world)
{
    double scanDist = world.conf.desertSize * 0.065 * world.getWidth();
    int minX = world.conf.biomes == BiomeLayout::columns
                   ? world.desertCenter - scanDist
                   : 350;
    int maxX = world.conf.biomes == BiomeLayout::columns
                   ? world.desertCenter + scanDist
                   : world.getWidth() - 350;
    LocationBins locations;
    for (int x = minX; x < maxX; ++x) {
        int fallingCount = 0;
        for (int y = world.conf.traps > 14 ? std::midpoint(
                                                 world.getSurfaceLevel(x),
                                                 world.getUndergroundLevel())
                                           : world.getUndergroundLevel();
             y < world.getUnderworldLevel();
             ++y) {
            Tile &tile = world.getTile(x, y);
            switch (tile.blockID) {
            case TileID::sand:
            case TileID::ebonsand:
            case TileID::crimsand:
            case TileID::pearlsand:
            case TileID::silt:
                ++fallingCount;
                break;
            case TileID::empty:
                if (fallingCount > 3) {
                    locations[binLocation(x, y, world.getUnderworldLevel())]
                        .emplace_back(x, y);
                }
                [[fallthrough]];
            default:
                fallingCount = 0;
            }
        }
    }
    int minBin = binLocation(
        minX,
        world.getUndergroundLevel(),
        world.getUnderworldLevel());
    int maxBin = binLocation(
        maxX,
        world.getUnderworldLevel(),
        world.getUnderworldLevel());
    int numSandTraps = world.conf.traps * world.getWidth() * world.getHeight() /
                       rnd.getInt(240000, 360000);
    constexpr auto validFloors = frozen::make_set<int>(
        {TileID::sand,
         TileID::hardenedSand,
         TileID::sandstone,
         TileID::ebonsand,
         TileID::hardenedEbonsand,
         TileID::ebonsandstone,
         TileID::crimsand,
         TileID::hardenedCrimsand,
         TileID::crimsandstone,
         TileID::pearlsand,
         TileID::hardenedPearlsand,
         TileID::pearlsandstone,
         TileID::silt});
    constexpr auto looseBlocks = frozen::make_set<int>(
        {TileID::sand,
         TileID::ebonsand,
         TileID::crimsand,
         TileID::pearlsand,
         TileID::silt});
    std::vector<Point> usedLocations;
    for (int tries = 50 * numSandTraps; numSandTraps > 0 && tries > 0;
         --tries) {
        int binId = rnd.getInt(minBin, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        int trapFloor = scanWhileEmpty({x, y}, {0, 1}, world).y;
        if (trapFloor - y < 4 || trapFloor - y > 30 ||
            !validFloors.contains(world.getTile(x, trapFloor + 1).blockID) ||
            isLocationUsed(x, trapFloor, 3, usedLocations)) {
            continue;
        }
        placePressurePlate(x, trapFloor, true, world);
        usedLocations.emplace_back(x, trapFloor);
        placeWire({x, trapFloor}, {x, y - 1}, Wire::red, world);
        Point prevActuator{-1, -1};
        for (int i = -5; i < 5; ++i) {
            int trapCeiling =
                scanWhileEmpty({x + i, (y + trapFloor) / 2}, {0, -1}, world).y -
                1;
            if (trapCeiling + 45 < trapFloor) {
                continue;
            }
            Tile &tile = world.getTile(x + i, trapCeiling);
            if (looseBlocks.contains(tile.blockID) ||
                (validFloors.contains(tile.blockID) &&
                 looseBlocks.contains(
                     world.getTile(x + i, trapCeiling - 1).blockID))) {
                tile.actuator = true;
                if (prevActuator.x != -1) {
                    placeWire(
                        prevActuator,
                        {x + i, trapCeiling},
                        Wire::red,
                        world);
                }
                prevActuator = {x + i, trapCeiling};
            }
        }
        --numSandTraps;
    }
}

bool isValidBoulderPlacement(int x, int y, bool allowMud, World &world)
{
    constexpr auto validTiles = frozen::make_set<int>(
        {TileID::crimstone,
         TileID::crispyHoney,
         TileID::ebonstone,
         TileID::granite,
         TileID::pearlstone,
         TileID::sandstone,
         TileID::slime,
         TileID::stone});
    return world.regionPasses(x, y, 6, 6, [allowMud, &validTiles](Tile &tile) {
        return !tile.guarded &&
               (validTiles.contains(tile.blockID) ||
                (allowMud && (tile.blockID == TileID::mud ||
                              tile.blockID == TileID::mushroomGrass)) ||
                (tile.flag == Flag::hive && tile.blockID == TileID::hive));
    }) && world.regionPasses(x + 2, y + 6, 2, 1, [](Tile &tile) {
        return tile.blockID != TileID::empty;
    });
}

Point selectBoulderLocation(Random &rnd, World &world)
{
    bool allowMud = rnd.getDouble(0, 1) < 0.0053 * world.conf.traps - 0.0265;
    for (int tries = 0; tries < 50; ++tries) {
        int x = rnd.getInt(100, world.getWidth() - 100);
        int y = rnd.getInt(
            0.85 * world.getUndergroundLevel(),
            world.getUnderworldLevel() - 100);
        if (isValidBoulderPlacement(x, y, allowMud, world)) {
            while (isValidBoulderPlacement(x, y + 1, allowMud, world)) {
                ++y;
            }
            return {x + 2, y + 2};
        }
    }
    return {-1, -1};
}

void placeBoulderTraps(Random &rnd, World &world)
{
    int numBoulders = world.conf.traps * (world.conf.hiveQueen ? 0.65 : 1) *
                      world.getWidth() * world.getHeight() /
                      rnd.getInt(57600, 64000);
    std::vector<Point> usedLocations;
    for (int tries = 5 * numBoulders; numBoulders > 0 && tries > 0; --tries) {
        auto [x, y] = selectBoulderLocation(rnd, world);
        if (x == -1) {
            continue;
        }
        int trapFloor = y + 4;
        while (!world.regionPasses(x, trapFloor, 2, 3, [](Tile &tile) {
            return tile.blockID == TileID::empty;
        })) {
            ++trapFloor;
        }
        int trapX = rnd.select({x, x + 1});
        trapFloor = scanWhileEmpty({trapX, trapFloor}, {0, 1}, world).y;
        if (trapFloor > world.getUnderworldLevel() || trapFloor - y > 25 ||
            !world.regionPasses(
                x,
                y,
                2,
                trapFloor - y + 2,
                [](Tile &tile) {
                    return isTrappable(tile) && tile.liquid == Liquid::none;
                }) ||
            isLocationUsed(x, y, 20, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        int probeTileId = world.getTile(x, y).blockID;
        int probeWallId = world.getTile(x, y).wallID;
        world.placeFramedTile(
            x,
            y,
            probeTileId == TileID::sandstone ? TileID::rollingCactus
            : probeTileId == TileID::slime ||
                    probeTileId == TileID::pinkSlime ||
                    probeWallId == WallID::Unsafe::mushroom
                ? TileID::bouncyBoulder
            : makeSaferTraps(world) &&
                    rnd.getDouble(0, 1) < 0.1 / std::max(world.conf.traps, 1.0)
                ? TileID::lifeCrystalBoulder
                : TileID::boulder);
        for (int i = -2; i < 4; ++i) {
            for (int j = -2; j < 4; ++j) {
                world.getTile(x + i, y + j).guarded = true;
            }
        }
        for (int i = 0; i < 2; ++i) {
            for (int j = 2; j < trapFloor - y; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID != TileID::empty) {
                    tile.actuator = true;
                    tile.wireRed = true;
                } else if (x + i == trapX) {
                    tile.wireRed = true;
                }
            }
        }
        placePressurePlate(trapX, trapFloor, true, world);
        world.getTile(trapX, trapFloor).wireRed = true;
        --numBoulders;
    }
}

void placeLavaTraps(Random &rnd, World &world)
{
    int lavaLevel =
        world.conf.forTheWorthy
            ? world.getUndergroundLevel()
            : (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    std::vector<Point> locations;
    for (int x = 100; x < world.getWidth() - 100; ++x) {
        int lavaCount = 0;
        for (int y = lavaLevel; y < world.getUnderworldLevel() - 10; ++y) {
            Tile &tile = world.getTile(x, y);
            if (tile.liquid == Liquid::lava) {
                ++lavaCount;
            } else {
                if (lavaCount > 5) {
                    locations.emplace_back(x, y);
                }
                lavaCount = 0;
            }
        }
    }
    if (locations.empty()) {
        return;
    }
    std::vector<Point> usedLocations;
    double numLavaTraps = world.conf.traps * world.getWidth() *
                          world.getHeight() / rnd.getInt(164000, 230400);
    for (; numLavaTraps > 0; numLavaTraps -= 0.1) {
        auto [x, y] = rnd.select(locations);
        if (isLocationUsed(x, y, 15, usedLocations)) {
            continue;
        }
        int gapJ = 0;
        while (gapJ < 50 &&
               !world.regionPasses(x - 1, y + gapJ, 3, 3, [](Tile &tile) {
                   return tile.blockID == TileID::empty &&
                          tile.liquid == Liquid::none;
               })) {
            ++gapJ;
        }
        if (gapJ == 50) {
            continue;
        }
        int trapFloor = scanWhileEmpty({x, y + gapJ}, {0, 1}, world).y;
        if (trapFloor > world.getUnderworldLevel() ||
            !world.regionPasses(x, y, 1, trapFloor - y, isTrappable)) {
            continue;
        }
        trapFloor = std::min(y + gapJ + 30, trapFloor);
        std::vector<Point> plateLocs;
        for (int plateX = x - 4; plateX < x + 4; ++plateX) {
            for (int plateY = y + gapJ - 2; plateY < trapFloor + 4; ++plateY) {
                Tile &baseTile = world.getTile(plateX, plateY + 1);
                if (baseTile.blockID != TileID::empty &&
                    isTrappable(baseTile) &&
                    world
                        .regionPasses(plateX, plateY - 2, 1, 3, [](Tile &tile) {
                            return tile.blockID == TileID::empty &&
                                   tile.liquid == Liquid::none;
                        })) {
                    plateLocs.emplace_back(plateX, plateY);
                }
            }
        }
        if (plateLocs.empty()) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        for (int j = 0; j < gapJ; ++j) {
            Tile &tile = world.getTile(x, y + j);
            tile.wireRed = true;
            if (tile.blockID != TileID::empty) {
                tile.actuator = true;
                if (j < 2) {
                    tile.guarded = true;
                }
            }
        }
        auto [plateX, plateY] = rnd.select(plateLocs);
        placePressurePlate(plateX, plateY, true, world);
        placeWire({x, y + gapJ}, {plateX, plateY}, Wire::red, world);
        numLavaTraps -= 0.9;
    }
}

bool targetWithDartTraps(int x, int y, int maxTraps, Random &rnd, World &world)
{
    std::vector<Point> traps;
    for (auto delta : {Point{-1, 0}, {1, 0}}) {
        for (int j = -4; j < 2; ++j) {
            Point pos = scanWhileNotSolid({x, y + j}, delta, world);
            int dist = std::abs(pos.x - x);
            if (dist < 5 || dist > 30) {
                continue;
            }
            if (!isTrappable(world.getTile(pos)) ||
                !isSolidBlock(world.getTile(pos + Point{0, 1}).blockID)) {
                pos += delta;
                if (!isTrappable(world.getTile(pos)) ||
                    !isSolidBlock(world.getTile(pos + Point{0, 1}).blockID)) {
                    continue;
                }
            }
            traps.push_back(pos);
        }
    }
    if (traps.empty()) {
        return false;
    }
    if (makeSaferTraps(world)) {
        maxTraps = std::max(maxTraps / 2, 1);
    }
    std::shuffle(traps.begin(), traps.end(), rnd.getPRNG());
    traps.resize(rnd.getInt(1, std::min<int>(traps.size(), maxTraps)));
    for (auto trap : traps) {
        placeWire(trap, {x, y}, Wire::red, world);
        world.placeFramedTile(
            trap.x,
            trap.y,
            TileID::trap,
            trap.x > x ? Variant::dartLeft : Variant::dartRight);
    }
    return true;
}

void placeDartTraps(Random &rnd, World &world)
{
    int numDartTraps = world.conf.traps * world.getWidth() * world.getHeight() /
                       rnd.getInt(209000, 256000);
    int scanDist = 0.12 * world.getWidth();
    for (int tries = 20 * numDartTraps; numDartTraps > 0 && tries > 0;
         --tries) {
        int bias = rnd.select({world.jungleCenter, world.snowCenter});
        int x = rnd.getInt(bias - scanDist, bias + scanDist);
        int y = rnd.getInt(
            world.conf.traps > 14 ? world.getSurfaceLevel(x) - 2
                                  : std::midpoint(
                                        world.getSurfaceLevel(x),
                                        world.getUndergroundLevel()),
            world.getUnderworldLevel());
        y = scanWhileEmpty({x, y}, {0, 1}, world).y;
        if (y > world.getUnderworldLevel() ||
            !world.regionPasses(x - 1, y - 2, 3, 4, isTrappable) ||
            !world.regionPasses(
                x - 1,
                y - 2,
                3,
                3,
                [](Tile &tile) {
                    return tile.blockID == TileID::empty &&
                           tile.liquid == Liquid::none;
                }) ||
            !targetWithDartTraps(x, y, 1 + (x + y) % 2, rnd, world)) {
            continue;
        }
        placePressurePlate(x, y, false, world);
        --numDartTraps;
    }
}

void genTraps(Random &rnd, World &world)
{
    std::cout << "Arming traps\n";
    placeSandTraps(rnd, world);
    placeBoulderTraps(rnd, world);
    placeLavaTraps(rnd, world);
    placeDartTraps(rnd, world);
    for (const auto &applyQueuedTrap : world.queuedTraps) {
        applyQueuedTrap(rnd, world);
    }
}

bool addChestBoulderTraps(int x, int y, Random &rnd, World &world)
{
    std::vector<Point> traps;
    for (int i = rnd.getInt(-10, -7); i < 10; i += 4) {
        Point pos = scanWhileNotSolid({x + i, y}, {0, -1}, world);
        int dist = y - pos.y;
        if (dist < 5 || dist > 30) {
            continue;
        }
        pos.y -= 5;
        if (world.regionPasses(
                pos.x - 2,
                pos.y - 2,
                6,
                6,
                [](Tile &tile) {
                    return tile.blockID != TileID::empty && isTrappable(tile);
                }) &&
            world.regionPasses(pos.x, pos.y, 2, pos.y - y - 3, isTrappable)) {
            traps.push_back(pos);
        }
    }
    if (traps.empty()) {
        return false;
    }
    if (makeSaferTraps(world) && traps.size() > 2) {
        std::shuffle(traps.begin(), traps.end(), rnd.getPRNG());
        traps.resize(traps.size() / 2);
    }
    for (auto trap : traps) {
        placeWire({trap.x, trap.y + 2}, {x, y}, Wire::red, world);
        for (int i = 0; i < 2; ++i) {
            for (int wireY = trap.y + 2; wireY < y; ++wireY) {
                Tile &tile = world.getTile(trap.x + i, wireY);
                if (isSolidBlock(tile.blockID)) {
                    tile.actuator = true;
                    placeWire(
                        {trap.x, trap.y + 2},
                        {trap.x + i, wireY},
                        Wire::red,
                        world);
                }
            }
        }
        world.placeFramedTile(
            trap.x,
            trap.y,
            world.getTile(trap).blockID == TileID::sandstone
                ? TileID::rollingCactus
                : TileID::boulder);
    }
    return true;
}

bool addChestDartTraps(int x, int y, Random &rnd, World &world)
{
    return targetWithDartTraps(x, y, 4, rnd, world);
}

bool addChestExplosiveTraps(int x, int y, Random &rnd, World &world)
{
    double numExplosives = rnd.getDouble(0, 3);
    if (makeSaferTraps(world)) {
        numExplosives *= 0.7;
    }
    bool didTrap = false;
    while (numExplosives > 0) {
        int i = rnd.getInt(-9, 9);
        int j = rnd.getInt(-7, 4);
        if (!world.regionPasses(x + i - 1, y + j - 1, 3, 3, [](Tile &tile) {
                return tile.blockID != TileID::empty && isTrappable(tile);
            })) {
            numExplosives -= 0.1;
            continue;
        }
        world.getTile(x + i, y + j).blockID = TileID::explosives;
        placeWire({x + i, y + j}, {x, y}, Wire::red, world);
        didTrap = true;
        --numExplosives;
    }
    return didTrap;
}

bool addChestLavaTrap(int x, int y, Random &rnd, World &world)
{
    if (y < std::midpoint(world.getCavernLevel(), world.getUnderworldLevel())) {
        return false;
    }
    Point pos = scanWhileNotSolid({x, y}, {0, -1}, world);
    int dist = y - pos.y;
    if (dist < 5 || dist > 30) {
        return false;
    }
    pos.y -= 5;
    constexpr auto oreTiles = frozen::make_set<int>(
        {TileID::ironOre,
         TileID::copperOre,
         TileID::goldOre,
         TileID::silverOre,
         TileID::tinOre,
         TileID::leadOre,
         TileID::tungstenOre,
         TileID::platinumOre,
         TileID::cobaltOre,
         TileID::palladiumOre,
         TileID::mythrilOre,
         TileID::orichalcumOre,
         TileID::adamantiteOre,
         TileID::titaniumOre,
         TileID::chlorophyteOre});
    int numEmpty = 0;
    if (!world.regionPasses(
            pos.x - 10,
            pos.y - 10,
            20,
            20,
            [&oreTiles](Tile &tile) {
                return !tile.guarded &&
                       (trappableTiles.contains(tile.blockID) ||
                        oreTiles.contains(tile.blockID));
            }) ||
        !world.regionPasses(
            pos.x - 9,
            pos.y - 18,
            18,
            14,
            [&numEmpty, &oreTiles](Tile &tile) {
                if (tile.blockID == TileID::empty) {
                    ++numEmpty;
                }
                return !tile.guarded && numEmpty < 12 &&
                       (trappableTiles.contains(tile.blockID) ||
                        oreTiles.contains(tile.blockID));
            })) {
        return false;
    }
    for (int i = -7; i < 7; ++i) {
        for (int j = -7; j < 7; ++j) {
            double threshold = 4 * std::hypot(i, j) / 7 - 3;
            if (rnd.getFineNoise(pos.x + i, pos.y + j - 11) > threshold) {
                Tile &tile = world.getTile(pos.x + i, pos.y + j - 11);
                tile.blockID = TileID::empty;
                tile.liquid = Liquid::lava;
                tile.guarded = true;
            }
        }
    }
    world.getTile(pos).blockID = TileID::explosives;
    placeWire(pos, {x, y}, Wire::red, world);
    return true;
}

void addChestTraps(int x, int y, Random &rnd, World &world)
{
    if (addChestLavaTrap(x, y, rnd, world)) {
        return;
    }
    std::array trapAdders{
        addChestBoulderTraps,
        addChestDartTraps,
        addChestExplosiveTraps};
    std::shuffle(trapAdders.begin(), trapAdders.end(), rnd.getPRNG());
    int numTypes = 0;
    for (const auto &trapAdder : trapAdders) {
        if (trapAdder(x, y, rnd, world)) {
            ++numTypes;
            if (numTypes == 2) {
                break;
            }
        }
    }
}

void maybeAddChestPressureTraps(int x, int y, Random &rnd, World &world)
{
    double threshold = world.conf.forTheWorthy
                           ? 0.0091 * world.conf.traps + 0.0909
                           : 0.0106 * world.conf.traps - 0.059;
    if (rnd.getDouble(0, 1) > threshold) {
        return;
    }
    std::vector<Point> locations;
    for (int i = -2; i < 4; ++i) {
        for (int j = -1; j < 3; ++j) {
            Tile &baseTile = world.getTile(x + i, y + j + 1);
            if (baseTile.blockID != TileID::empty && isTrappable(baseTile) &&
                world.regionPasses(x + i, y + j - 2, 1, 3, [](Tile &tile) {
                    return tile.blockID == TileID::empty;
                })) {
                locations.emplace_back(x + i, y + j);
            }
        }
    }
    if (locations.empty()) {
        return;
    }
    Point loc = rnd.select(locations);
    placePressurePlate(loc.x, loc.y, true, world);
    addChestTraps(loc.x, loc.y, rnd, world);
}

Point selectDetonatorLocation(int x, int y, World &world)
{
    Point loc{-1, -1};
    double minDist = 10;
    for (int i = -9; i < 9; ++i) {
        for (int j = -9; j < 9; ++j) {
            if (std::abs(i) < 4 && std::abs(j) < 4) {
                continue;
            }
            if (world.regionPasses(
                    x + i,
                    y + j + 1,
                    2,
                    1,
                    [](Tile &tile) { return isSolidBlock(tile.blockID); }) &&
                world.regionPasses(x + i, y + j - 4, 2, 5, [](Tile &tile) {
                    return tile.blockID == TileID::empty &&
                           tile.liquid == Liquid::none;
                })) {
                double dist = std::hypot(i, j);
                if (dist < minDist) {
                    minDist = dist;
                    loc = {x + i, y + j - 1};
                }
            }
        }
    }
    return loc;
}

void addOreTraps(std::vector<Point> &&locations, Random &rnd, World &world)
{
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    int numTraps = locations.size() / 20;
    std::vector<Point> usedLocations;
    for (auto [x, y] : locations) {
        if (y < world.getUndergroundLevel()) {
            continue;
        }
        Point detonator = selectDetonatorLocation(x, y, world);
        Tile &tile = world.getTile(x, y - 1);
        if (detonator.x == -1 || tile.blockID != TileID::empty ||
            isLocationUsed(x, y, 40, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        tile.blockID = TileID::explosives;
        world.placeFramedTile(detonator.x, detonator.y, TileID::detonator);
        placeWire({x, y - 1}, {detonator.x, detonator.y + 1}, Wire::red, world);
        --numTraps;
        if (numTraps < 0) {
            break;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Traps.h`
```
#ifndef TRAPS_H
#define TRAPS_H

#include "structures/StructureUtil.h"

class World;
class Random;

void addChestTraps(int x, int y, Random &rnd, World &world);
void maybeAddChestPressureTraps(int x, int y, Random &rnd, World &world);
void addOreTraps(std::vector<Point> &&locations, Random &rnd, World &world);
void genTraps(Random &rnd, World &world);

#endif // TRAPS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Treasure.cpp`
```
#include "structures/Treasure.h"

#include "Config.h"
#include "Random.h"
#include "Util.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/ItemID.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/Traps.h"
#include "structures/UndergroundCabin.h"
#include "structures/data/Altars.h"
#include "structures/data/JungleShrines.h"
#include "vendor/frozen/map.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>

enum class Gem {
    topaz = 18,
    sapphire = 36,
    emerald = 54,
    ruby = 72,
    diamond = 90,
    amber = 108
};

template <typename T, typename U>
bool listContains(const T &list, const U &value)
{
    return std::find(std::begin(list), std::end(list), value) != std::end(list);
}

inline constexpr auto placementAvoidTiles = frozen::make_set<int>({
    TileID::grate,
    TileID::leaf,
    TileID::livingWood,
    TileID::mahoganyLeaf,
    TileID::thinIce,
    TileID::spike,
    TileID::woodenSpike,
    TileID::meteorite,
    TileID::sillyPinkBalloon,
    TileID::sillyPurpleBalloon,
    TileID::sillyGreenBalloon,
});

bool isPlacementCandidate(int x, int y, World &world)
{
    auto isFloorTile = [x, y, &world](const Tile &tile) {
        return isSolidBlock(tile.blockID) && tile.slope == Slope::none &&
               !tile.actuated && !placementAvoidTiles.contains(tile.blockID) &&
               ((tile.blockID != TileID::aetherium &&
                 tile.blockID != TileID::pearlstone &&
                 tile.flag != Flag::border) ||
                y > world.getSurfaceLevel(x)) &&
               (y > 0.45 * world.getUndergroundLevel() ||
                (tile.blockID != TileID::lesion &&
                 tile.blockID != TileID::flesh));
    };
    return isFloorTile(world.getTile(x, y)) &&
           isFloorTile(world.getTile(x + 1, y)) &&
           world.regionPasses(x, y - 3, 2, 3, [](Tile &tile) {
               return tile.blockID == TileID::empty &&
                      tile.liquid != Liquid::lava &&
                      tile.liquid != Liquid::shimmer;
           });
}

int testOrbHeartCandidate(int x, int y, World &world)
{
    if (y < world.getUndergroundLevel() ||
        y > (world.conf.dontDigUp ? world.getCavernLevel()
                                  : world.getUnderworldLevel())) {
        return TileID::empty;
    }
    int tendrilID = TileID::empty;
    for (auto [i, j] : {std::pair{1, 1}, {1, 6}, {6, 1}, {6, 6}}) {
        int cornerID = world.getTile(x + i, y + j).blockID;
        if (cornerID == TileID::lesion || cornerID == TileID::flesh) {
            tendrilID = cornerID;
            break;
        }
    }
    if (tendrilID == TileID::empty) {
        return tendrilID;
    }
    constexpr auto allowedTiles = frozen::make_set<int>(
        {TileID::clay,
         TileID::mud,
         TileID::ebonstone,
         TileID::ebonsand,
         TileID::corruptIce,
         TileID::ebonsandstone,
         TileID::hardenedEbonsand,
         TileID::lesion,
         TileID::crimstone,
         TileID::crimsand,
         TileID::crimsonIce,
         TileID::crimsandstone,
         TileID::hardenedCrimsand,
         TileID::flesh});
    for (int i = 0; i < 8; ++i) {
        for (int j = 0; j < 8; ++j) {
            if (((i == 0 || i == 7) && (j < 2 || j > 5)) ||
                ((j == 0 || j == 7) && (i < 2 || i > 5))) {
                continue;
            }
            if (!allowedTiles.contains(world.getTile(x + i, y + j).blockID)) {
                return TileID::empty;
            }
        }
    }
    return tendrilID;
}

bool attachGemTo(Gem gem, int x, int y, Random &rnd, World &world)
{
    auto [deltaX, deltaY, frameY] = rnd.select(
        {std::tuple{-1, 0, 162}, {1, 0, 108}, {0, -1, 0}, {0, 1, 54}});
    Tile &tile = world.getTile(x + deltaX, y + deltaY);
    if (tile.blockID != TileID::empty) {
        return false;
    }
    tile.blockID = TileID::gem;
    tile.frameX = static_cast<int>(gem);
    tile.frameY = frameY + 18 * (fnv1a32pt(x, y) % 3);
    return true;
}

void placeGems(Random &rnd, World &world)
{
    int numGems = world.conf.gems * world.getWidth() * world.getHeight() /
                  rnd.getInt(65800, 76800);
    int scanDist = world.conf.desertSize * 0.08 * world.getWidth();
    int minX = world.conf.biomes == BiomeLayout::columns
                   ? world.desertCenter - scanDist
                   : 350;
    int maxX = world.conf.biomes == BiomeLayout::columns
                   ? world.desertCenter + scanDist
                   : world.getWidth() - 350;
    constexpr auto validAnchors = frozen::make_set<int>(
        {TileID::sand,
         TileID::hardenedSand,
         TileID::sandstone,
         TileID::ebonsand,
         TileID::hardenedEbonsand,
         TileID::ebonsandstone,
         TileID::crimsand,
         TileID::hardenedCrimsand,
         TileID::crimsandstone,
         TileID::pearlsand,
         TileID::hardenedPearlsand,
         TileID::pearlsandstone,
         TileID::coralstone});
    for (int tries = 800 * numGems; numGems > 0 && tries > 0; --tries) {
        int x = rnd.getInt(minX, maxX);
        int y =
            rnd.getInt(world.getUndergroundLevel(), world.getUnderworldLevel());
        if ((world.conf.biomes != BiomeLayout::columns &&
             world.getBiome(x, y).desert < 0.99) ||
            !validAnchors.contains(world.getTile(x, y).blockID)) {
            continue;
        }
        if (attachGemTo(Gem::amber, x, y, rnd, world)) {
            --numGems;
        }
    }
    std::vector<Point> locations;
    int maxY = (5 * world.getCavernLevel() + world.getUnderworldLevel()) / 6;
    for (int x = 50; x < world.getWidth() - 50; ++x) {
        if (x == 200) {
            x = world.getWidth() - 200;
        }
        for (int y = world.getUndergroundLevel(); y < maxY; ++y) {
            if (validAnchors.contains(world.getTile(x, y).blockID) &&
                !world.regionPasses(x - 1, y - 1, 3, 3, [](Tile &tile) {
                    return tile.blockID != TileID::empty ||
                           tile.liquid == Liquid::none;
                })) {
                locations.emplace_back(x, y);
            }
        }
    }
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    locations.resize(locations.size() / 6);
    for (auto [x, y] : locations) {
        attachGemTo(
            y < world.getCavernLevel()
                ? rnd.select({Gem::topaz, Gem::sapphire, Gem::emerald})
                : rnd.select(
                      {Gem::sapphire, Gem::emerald, Gem::ruby, Gem::diamond}),
            x,
            y,
            rnd,
            world);
    }
}

void placeLifeCrystals(
    int maxBin,
    LocationBins &locations,
    Random &rnd,
    World &world)
{
    int lifeCrystalCount =
        world.conf.lifeCrystals * world.getWidth() * world.getHeight() / 50000;
    int maxDungeonPlacements = 3;
    std::vector<Point> usedLocations;
    while (lifeCrystalCount > 0) {
        int binId = rnd.getInt(0, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        if (y > world.getUndergroundLevel() && y < world.getUnderworldLevel() &&
            isPlacementCandidate(x, y, world)) {
            int probeWall = world.getTile(x, y - 2).wallID;
            if (listContains(WallVariants::dungeon, probeWall)) {
                if (maxDungeonPlacements > 0) {
                    world.placeFramedTile(x, y - 2, TileID::lifeCrystalBoulder);
                    --maxDungeonPlacements;
                } else {
                    continue;
                }
            } else if (
                probeWall == WallID::Unsafe::lihzahrdBrick ||
                isLocationUsed(x, y, 50, usedLocations, 2)) {
                continue;
            } else {
                usedLocations.emplace_back(x, y);
                double threshold = world.conf.traps > 14
                                       ? 0.0076 * world.conf.traps + 0.036
                                       : 0;
                world.placeFramedTile(
                    x,
                    y - 2,
                    rnd.getDouble(0, 1) < threshold ? TileID::lifeCrystalBoulder
                                                    : TileID::lifeCrystal);
            }
            --lifeCrystalCount;
        }
    }
}

void placeFallenLogs(
    int maxBin,
    LocationBins &locations,
    Random &rnd,
    World &world)
{
    int logCount = world.getWidth() / rnd.getInt(1066, 1600);
    while (logCount > 0) {
        int binId = rnd.getInt(0, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        if (y > 0.45 * world.getUndergroundLevel() &&
            y < world.getUndergroundLevel() &&
            world.getTile(x, y).blockID == TileID::grass &&
            isPlacementCandidate(x, y, world) &&
            isPlacementCandidate(x - 1, y, world)) {
            world.placeFramedTile(x - 1, y - 2, TileID::fallenLog);
            --logCount;
        }
    }
}

void placeAltars(int maxBin, LocationBins &locations, Random &rnd, World &world)
{
    int altarCount = std::max(8, world.getWidth() / 200);
    if (world.conf.doubleTrouble || world.conf.dontDigUp) {
        altarCount *= 2;
    }
    constexpr auto corruptTiles = frozen::make_set<int>(
        {TileID::ebonstone,
         TileID::corruptGrass,
         TileID::demonite,
         TileID::ebonsand,
         TileID::corruptJungleGrass,
         TileID::corruptIce,
         TileID::ebonsandstone,
         TileID::hardenedEbonsand,
         TileID::lesion});
    constexpr auto crimsonTiles = frozen::make_set<int>(
        {TileID::crimstone,
         TileID::crimsonGrass,
         TileID::crimtane,
         TileID::crimsand,
         TileID::crimsonJungleGrass,
         TileID::crimsonIce,
         TileID::crimsandstone,
         TileID::hardenedCrimsand,
         TileID::flesh});
    for (int tries = 400 * altarCount; altarCount > 0 && tries > 0; --tries) {
        int binId = rnd.getInt(0, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        if (y < 0.8 * world.getUndergroundLevel() ||
            (world.conf.dontDigUp && y > world.getCavernLevel())) {
            continue;
        }
        Variant type = corruptTiles.contains(world.getTile(x, y).blockID)
                           ? Variant::corruption
                       : crimsonTiles.contains(world.getTile(x, y).blockID)
                           ? Variant::crimson
                           : Variant::none;
        if (type != Variant::none && isPlacementCandidate(x, y, world) &&
            isPlacementCandidate(x - 1, y, world)) {
            world.placeFramedTile(x - 1, y - 2, TileID::altar, type);
            --altarCount;
        }
    }
}

Point selectPurityAltarLocation(
    TileBuffer &altar,
    int lavaLevel,
    Random &rnd,
    World &world)
{
    constexpr auto avoidTiles = frozen::make_set<int>(
        {TileID::obsidianBrick,
         TileID::hellstoneBrick,
         TileID::ebonstoneBrick,
         TileID::lesion,
         TileID::crimstoneBrick,
         TileID::flesh,
         TileID::lamp,
         TileID::blueBrick,
         TileID::greenBrick,
         TileID::pinkBrick});
    int scanHeight = std::max<int>(1.5 * altar.getHeight(), 30);
    int scanY = lavaLevel - scanHeight;
    while (true) {
        int x = rnd.getInt(150, world.getWidth() - 150 - altar.getWidth());
        if (!world.regionPasses(
                x,
                scanY,
                altar.getWidth(),
                scanHeight,
                [&avoidTiles](Tile &tile) {
                    return !avoidTiles.contains(tile.blockID);
                })) {
            continue;
        }
        int y = lavaLevel;
        for (int i : {1, 2, altar.getWidth() - 3, altar.getWidth() - 2}) {
            y = std::min(y, scanWhileEmpty({x + i, scanY}, {0, 1}, world).y);
        }
        y += 2 - altar.getHeight();
        return {x, y};
    }
}

Point scanForAltarOffset(TileBuffer &altar)
{
    for (int i = 0; i < altar.getWidth(); ++i) {
        for (int j = 0; j < altar.getHeight(); ++j) {
            if (altar.getTile(i, j).blockID == TileID::altar) {
                return {i, j};
            }
        }
    }
    return {-1, -1};
}

void placePurityAltars(Random &rnd, World &world)
{
    std::vector<int> altars;
    if (world.conf.doubleTrouble) {
        altars.insert(
            altars.end(),
            Data::corruptAltars.begin(),
            Data::corruptAltars.end());
        std::shuffle(altars.begin(), altars.end(), rnd.getPRNG());
        altars.resize(4);
        altars.insert(
            altars.end(),
            Data::crimsonAltars.begin(),
            Data::crimsonAltars.end());
        std::shuffle(altars.begin() + 4, altars.end(), rnd.getPRNG());
        altars.resize(8);
    } else {
        if (world.isCrimson) {
            altars.insert(
                altars.end(),
                Data::crimsonAltars.begin(),
                Data::crimsonAltars.end());
        } else {
            altars.insert(
                altars.end(),
                Data::corruptAltars.begin(),
                Data::corruptAltars.end());
        }
        std::shuffle(altars.begin(), altars.end(), rnd.getPRNG());
        altars.resize(5);
    }
    int underworldHeight = world.getHeight() - world.getUnderworldLevel();
    int lavaLevel = world.getUnderworldLevel() + 0.46 * underworldHeight;
    for (size_t iter = 0; iter < altars.size(); ++iter) {
        TileBuffer altar = Data::getAltar(altars[iter], world.getFramedTiles());
        auto [x, y] = selectPurityAltarLocation(altar, lavaLevel, rnd, world);
        world.placeBuffer(x, y, altar);
        for (int i = 1; i < altar.getWidth() - 1; ++i) {
            int fillTile =
                world.getTile(x + i, y + altar.getHeight() - 2).blockID;
            for (int j = 1; j < altar.getHeight() - 1; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if ((tile.blockID == TileID::ebonstoneBrick ||
                     tile.blockID == TileID::crimstoneBrick) &&
                    fnv1a32pt(x + i, y + j) % 11 == 0) {
                    tile.blockID = TileID::hellstoneBrick;
                }
            }
            if (fillTile != TileID::ebonstoneBrick &&
                fillTile != TileID::crimstoneBrick) {
                continue;
            }
            int maxJ = altar.getHeight() + 30;
            for (int j = altar.getHeight() - 1; j < maxJ; ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID == TileID::empty) {
                    tile.blockID = fnv1a32pt(x + i, y + j) % 7 == 0
                                       ? TileID::hellstoneBrick
                                       : fillTile;
                    if (y + j == lavaLevel + 1) {
                        maxJ = std::min<int>(
                            maxJ,
                            j + 6 + 5 * rnd.getFineNoise(x + i, lavaLevel));
                    }
                } else {
                    break;
                }
            }
        }
        if (world.conf.hardmode && iter % 4 != 0) {
            auto delta = scanForAltarOffset(altar);
            x += delta.x;
            y += delta.y;
            world.placeFramedTile(
                x,
                y,
                TileID::largePileGroup2,
                Variant::ash,
                world.getTile(x, y).frameX == 0 ? Paint::purple
                                                : Paint::deepRed);
        }
    }
}

void placeOrbHearts(
    int maxBin,
    LocationBins &locations,
    Random &rnd,
    World &world)
{
    int orbHeartCount = world.getWidth() * world.getHeight() / 240000;
    if (world.conf.dontDigUp) {
        orbHeartCount *= 4;
    } else if (world.conf.doubleTrouble) {
        orbHeartCount *= 2;
    }
    for (int tries = 500 * orbHeartCount; orbHeartCount > 0 && tries > 0;
         --tries) {
        int binId = rnd.getInt(0, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        int tendrilID = testOrbHeartCandidate(x, y, world);
        if (tendrilID == TileID::empty) {
            continue;
        }
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 8; ++j) {
                if (((i == 0 || i == 7) && (j < 2 || j > 5)) ||
                    ((j == 0 || j == 7) && (i < 2 || i > 5))) {
                    continue;
                }
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID != tendrilID) {
                    tile.blockID = tendrilID == TileID::lesion
                                       ? TileID::ebonstone
                                       : TileID::crimstone;
                }
            }
        }
        world.placeFramedTile(
            x + 3,
            y + 3,
            TileID::orbHeart,
            tendrilID == TileID::lesion ? Variant::corruption
                                        : Variant::crimson);
        --orbHeartCount;
    }
}

void placeLarvae(int maxBin, LocationBins &locations, Random &rnd, World &world)
{
    int larvaCount = (1 + (world.conf.forTheWorthy ? 0.5 : 0) +
                      (world.conf.traps > 14 ? 0.5 : 0)) *
                     world.getWidth() * world.getHeight() /
                     rnd.getInt(62000, 65000);
    constexpr auto avoidWalls = frozen::make_set<int>(
        {WallID::Unsafe::blueBrick,
         WallID::Unsafe::greenBrick,
         WallID::Unsafe::pinkBrick,
         WallID::Unsafe::blueSlab,
         WallID::Unsafe::greenSlab,
         WallID::Unsafe::pinkSlab,
         WallID::Unsafe::blueTiled,
         WallID::Unsafe::greenTiled,
         WallID::Unsafe::pinkTiled,
         WallID::Unsafe::hive});
    std::vector<Point> usedLocations;
    while (larvaCount > 0) {
        int binId = rnd.getInt(0, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        Tile &tile = world.getTile(x, y - 1);
        if ((!avoidWalls.contains(tile.wallID) || fnv1a32pt(x, y) % 31 < 15) &&
            tile.liquid == Liquid::none &&
            isPlacementCandidate(x - 1, y, world) &&
            isPlacementCandidate(x + 2, y, world) &&
            !isLocationUsed(x, y, 35, usedLocations)) {
            world.placeFramedTile(x, y - 3, TileID::larva);
            usedLocations.emplace_back(x, y);
            --larvaCount;
        }
    }
}

void placeManaCrystals(
    int maxBin,
    LocationBins &locations,
    Random &rnd,
    World &world)
{
    int manaCrystalCount = world.conf.manaCrystals *
                           (world.conf.hiveQueen ? 2 : 1) * world.getWidth() *
                           world.getHeight() / 310000;
    std::vector<Point> usedLocations;
    for (auto &chest : world.getChests()) {
        usedLocations.emplace_back(chest.x, chest.y);
    }
    while (manaCrystalCount > 0) {
        int binId = rnd.getInt(0, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        if (isLocationUsed(x, y, 8, usedLocations)) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        int probeWall = world.getTile(x, y - 2).wallID;
        if ((y > world.getUndergroundLevel() ||
             (world.conf.hiveQueen &&
              std::abs(y - world.getSurfaceLevel(x)) > 15)) &&
            y < world.getUnderworldLevel() &&
            isPlacementCandidate(x, y, world) &&
            !listContains(WallVariants::dungeon, probeWall) &&
            probeWall != WallID::Unsafe::lihzahrdBrick) {
            world.placeFramedTile(x, y - 2, TileID::manaCrystal);
            --manaCrystalCount;
        }
    }
}

Point selectShrineLocation(
    TileBuffer &shrine,
    std::vector<Point> &usedLocations,
    Random &rnd,
    World &world)
{
    int minOpenHeight = -1;
    for (int j = 0; j < shrine.getHeight(); ++j) {
        if (shrine.getTile(0, j).blockPaint == Paint::red ||
            shrine.getTile(shrine.getWidth() - 1, j).blockPaint == Paint::red) {
            minOpenHeight = j;
            break;
        }
    }
    if (minOpenHeight == -1) {
        minOpenHeight = shrine.getHeight();
    }
    constexpr auto clearableTiles = frozen::make_set<int>(
        {TileID::empty,         TileID::dirt,          TileID::mud,
         TileID::jungleGrass,   TileID::stone,         TileID::clay,
         TileID::silt,          TileID::copperOre,     TileID::tinOre,
         TileID::ironOre,       TileID::leadOre,       TileID::silverOre,
         TileID::tungstenOre,   TileID::goldOre,       TileID::platinumOre,
         TileID::cobaltOre,     TileID::palladiumOre,  TileID::mythrilOre,
         TileID::orichalcumOre, TileID::adamantiteOre, TileID::titaniumOre,
         TileID::chlorophyteOre});
    int minX = world.conf.biomes == BiomeLayout::columns
                   ? world.jungleCenter -
                         world.conf.jungleSize * 0.09 * world.getWidth()
                   : 350;
    int maxX = world.conf.biomes == BiomeLayout::columns
                   ? world.jungleCenter +
                         world.conf.jungleSize * 0.09 * world.getWidth()
                   : world.getWidth() - 350;
    for (int numTries = 0; numTries < 10000; ++numTries) {
        int x = rnd.getInt(minX, maxX);
        int y = world.conf.dontDigUp ? rnd.getInt(
                                           world.getSurfaceLevel(x),
                                           std::midpoint(
                                               world.getCavernLevel(),
                                               world.getUnderworldLevel()))
                                     : rnd.getInt(
                                           world.getUndergroundLevel(),
                                           world.getUnderworldLevel());
        if ((world.conf.biomes != BiomeLayout::columns &&
             !isInBiome(x, y, 10, Biome::jungle, world)) ||
            !world.regionPasses(
                x,
                y,
                shrine.getWidth(),
                std::max(minOpenHeight, 3),
                [](Tile &tile) {
                    return tile.blockID == TileID::empty &&
                           (tile.wallID == WallID::empty ||
                            listContains(WallVariants::jungle, tile.wallID) ||
                            listContains(WallVariants::hallow, tile.wallID)) &&
                           (tile.liquid == Liquid::none ||
                            tile.liquid == Liquid::water);
                })) {
            continue;
        }
        if (minOpenHeight == shrine.getHeight()) {
            // Floating shrine.
            if (!world.regionPasses(
                    x,
                    y,
                    shrine.getWidth(),
                    shrine.getHeight(),
                    [](Tile &tile) {
                        return !tile.guarded && tile.wallID != WallID::empty;
                    }) ||
                isLocationUsed(x, y, 40, usedLocations)) {
                continue;
            }
            return {x, y};
        }
        std::vector<int> groundLevel;
        for (int i = 0; i < shrine.getWidth(); ++i) {
            for (int j = minOpenHeight; j < 150; ++j) {
                if (world.getTile(x + i, y + j).blockID != TileID::empty) {
                    groundLevel.push_back(y + j);
                    break;
                }
            }
        }
        if (static_cast<int>(groundLevel.size()) != shrine.getWidth()) {
            // Ground out of scan range.
            continue;
        }
        for (; y <= groundLevel[0]; ++y) {
            bool isValid = true;
            for (int i = 0; i < shrine.getWidth(); ++i) {
                int j = groundLevel[i] - y;
                if (j < 0 || j >= shrine.getHeight() ||
                    ((i == 0 || i == shrine.getWidth() - 1) &&
                     shrine.getTile(i, j).blockPaint != Paint::red)) {
                    isValid = false;
                    break;
                }
            }
            if (!isValid) {
                continue;
            }
            if ( // Ground too thin.
                !world.regionPasses(
                    x,
                    y + shrine.getHeight() - 1,
                    shrine.getWidth(),
                    1,
                    [](Tile &tile) { return tile.blockID != TileID::empty; }) ||
                // Near other shrines.
                isLocationUsed(x, y, 40, usedLocations) ||
                // Restricted tiles.
                !world.regionPasses(
                    x,
                    y,
                    shrine.getWidth(),
                    shrine.getHeight(),
                    [&clearableTiles](Tile &tile) {
                        return !tile.guarded &&
                               clearableTiles.contains(tile.blockID) &&
                               (tile.liquid == Liquid::none ||
                                tile.liquid == Liquid::water);
                    })) {
                break;
            }
            return {x, y};
        }
    }
    return {-1, -1};
}

void placeJungleShrines(Random &rnd, World &world)
{
    int shrineCount = world.conf.chests * (world.conf.hiveQueen ? 1.4 : 1) *
                      world.getWidth() * world.getHeight() /
                      rnd.getInt(590700, 677600);
    std::vector<Point> usedLocations;
    std::vector<int> shrines(Data::shrines.begin(), Data::shrines.end());
    std::shuffle(shrines.begin(), shrines.end(), rnd.getPRNG());
    for (int tries = 2 * shrineCount; shrineCount > 0 && tries > 0; --tries) {
        TileBuffer shrine =
            Data::getShrine(rnd.pool(shrines), world.getFramedTiles());
        auto [x, y] = selectShrineLocation(shrine, usedLocations, rnd, world);
        if (x == -1) {
            continue;
        }
        usedLocations.emplace_back(x, y);
        bool isHallow = !world.regionPasses(
            x,
            y,
            shrine.getWidth(),
            shrine.getHeight(),
            [](Tile &tile) { return tile.blockPaint != Paint::cyan; });
        std::vector<Point> chests = world.placeBuffer(x, y, shrine);
        for (int i = 0; i < shrine.getWidth(); ++i) {
            for (int j = 0; j < shrine.getHeight(); ++j) {
                Tile &tile = world.getTile(x + i, y + j);
                if (tile.blockID == TileID::mud &&
                    world.isExposed(x + i, y + j)) {
                    tile.blockID = TileID::jungleGrass;
                    tile.blockPaint = isHallow ? Paint::cyan : Paint::none;
                }
            }
        }
        for (auto [chestX, chestY] : chests) {
            Tile &tile = world.getTile(chestX, chestY);
            if (tile.blockID == TileID::chest && tile.frameX == 180 &&
                tile.frameY == 0) {
                fillBarrel(world.registerStorage(chestX, chestY), rnd);
            } else {
                Chest &chest = world.placeChest(chestX, chestY, Variant::ivy);
                fillIvyChest(chest, getChestDepth(x, y, world), rnd, world);
            }
        }
        --shrineCount;
    }
}

Variant getChestType(int x, int y, World &world)
{
    Tile &probeTile = world.getTile(x, y - 2);
    if (y < 0.45 * world.getUndergroundLevel()) {
        return Variant::skyware;
    } else if (y > world.getUnderworldLevel()) {
        return Variant::shadow;
    } else if (probeTile.wallID == WallID::Unsafe::hive) {
        return Variant::honey;
    } else if (probeTile.liquid == Liquid::water) {
        return (x < 350 || x > world.getWidth() - 350) &&
                       (y < world.getUndergroundLevel() ||
                        !world.regionPasses(
                            x - 2,
                            y,
                            6,
                            6,
                            [](Tile &tile) {
                                return tile.blockID != TileID::coralstone;
                            }))
                   ? Variant::reef
                   : Variant::water;
    } else if (listContains(WallVariants::dungeon, probeTile.wallID)) {
        return Variant::goldLocked;
    } else if (probeTile.wallID == WallID::Unsafe::lihzahrdBrick) {
        return Variant::lihzahrd;
    }
    constexpr auto blockTypes = frozen::make_map<int, Variant>(
        {{TileID::ash, Variant::ashWood},
         {TileID::ashGrass, Variant::ashWood},
         {TileID::obsidian, Variant::ashWood},
         {TileID::crimstone, Variant::flesh},
         {TileID::crimsonGrass, Variant::flesh},
         {TileID::crimsand, Variant::flesh},
         {TileID::crimsonJungleGrass, Variant::flesh},
         {TileID::crimsonIce, Variant::flesh},
         {TileID::crimsandstone, Variant::flesh},
         {TileID::hardenedCrimsand, Variant::flesh},
         {TileID::flesh, Variant::flesh},
         {TileID::snow, Variant::frozen},
         {TileID::ice, Variant::frozen},
         {TileID::thinIce, Variant::frozen},
         {TileID::slush, Variant::frozen},
         {TileID::ebonstone, Variant::lesion},
         {TileID::corruptGrass, Variant::lesion},
         {TileID::ebonsand, Variant::lesion},
         {TileID::corruptJungleGrass, Variant::lesion},
         {TileID::corruptIce, Variant::lesion},
         {TileID::ebonsandstone, Variant::lesion},
         {TileID::hardenedEbonsand, Variant::lesion},
         {TileID::lesion, Variant::lesion},
         {TileID::granite, Variant::granite},
         {TileID::smoothGranite, Variant::granite},
         {TileID::marble, Variant::marble},
         {TileID::smoothMarble, Variant::marble},
         {TileID::heliumMossStone, Variant::meteorite},
         {TileID::aetherium, Variant::meteorite},
         {TileID::mushroomGrass, Variant::mushroom},
         {TileID::hallowedGrass, Variant::pearlwood},
         {TileID::pearlstone, Variant::pearlwood},
         {TileID::hallowedIce, Variant::pearlwood},
         {TileID::pearlsand, Variant::pearlwood},
         {TileID::hardenedPearlsand, Variant::pearlwood},
         {TileID::pearlsandstone, Variant::pearlwood},
         {TileID::crystalBlock, Variant::pearlwood},
         {TileID::jungleGrass, Variant::richMahogany},
         {TileID::livingMahogany, Variant::richMahogany},
         {TileID::mahoganyLeaf, Variant::richMahogany},
         {TileID::sand, Variant::sandstone},
         {TileID::sandstone, Variant::sandstone},
         {TileID::sandstoneBrick, Variant::sandstone},
         {TileID::hardenedSand, Variant::sandstone},
         {TileID::desertFossil, Variant::sandstone}});
    constexpr auto wallTypes = frozen::make_map<int, Variant>(
        {{WallID::Unsafe::ember, Variant::ashWood},
         {WallID::Unsafe::cinder, Variant::ashWood},
         {WallID::Unsafe::magma, Variant::ashWood},
         {WallID::Unsafe::smoulderingStone, Variant::ashWood},
         {WallID::Unsafe::crimsonGrass, Variant::flesh},
         {WallID::Unsafe::crimsandstone, Variant::flesh},
         {WallID::Unsafe::hardenedCrimsand, Variant::flesh},
         {WallID::Unsafe::crimstone, Variant::flesh},
         {WallID::Unsafe::crimsonCrust, Variant::flesh},
         {WallID::Unsafe::crimsonScab, Variant::flesh},
         {WallID::Unsafe::crimsonTeeth, Variant::flesh},
         {WallID::Unsafe::crimsonBlister, Variant::flesh},
         {WallID::Unsafe::snow, Variant::frozen},
         {WallID::Unsafe::ice, Variant::frozen},
         {WallID::Unsafe::corruptGrass, Variant::lesion},
         {WallID::Unsafe::ebonsandstone, Variant::lesion},
         {WallID::Unsafe::hardenedEbonsand, Variant::lesion},
         {WallID::Unsafe::ebonstone, Variant::lesion},
         {WallID::Unsafe::corruptGrowth, Variant::lesion},
         {WallID::Unsafe::corruptMass, Variant::lesion},
         {WallID::Unsafe::corruptPustule, Variant::lesion},
         {WallID::Unsafe::corruptTendril, Variant::lesion},
         {WallID::Unsafe::granite, Variant::granite},
         {WallID::Unsafe::marble, Variant::marble},
         {WallID::Unsafe::mushroom, Variant::mushroom},
         {WallID::Unsafe::hallowedGrass, Variant::pearlwood},
         {WallID::Unsafe::pearlsandstone, Variant::pearlwood},
         {WallID::Unsafe::hardenedPearlsand, Variant::pearlwood},
         {WallID::Unsafe::hallowedPrism, Variant::pearlwood},
         {WallID::Unsafe::hallowedCavern, Variant::pearlwood},
         {WallID::Unsafe::hallowedShard, Variant::pearlwood},
         {WallID::Unsafe::hallowedCrystalline, Variant::pearlwood},
         {WallID::Unsafe::jungle, Variant::richMahogany},
         {WallID::Unsafe::mud, Variant::richMahogany},
         {WallID::Unsafe::lichenStone, Variant::richMahogany},
         {WallID::Unsafe::leafyJungle, Variant::richMahogany},
         {WallID::Unsafe::ivyStone, Variant::richMahogany},
         {WallID::Unsafe::jungleVine, Variant::richMahogany},
         {WallID::Unsafe::sandstone, Variant::sandstone},
         {WallID::Safe::sandstoneBrick, Variant::sandstone},
         {WallID::Unsafe::hardenedSand, Variant::sandstone}});
    std::map<Variant, int> zoneCounts;
    int radius = 5;
    for (int i = -radius; i < radius; ++i) {
        for (int j = -radius; j < radius; ++j) {
            Tile &tile = world.getTile(x + i, y + j);
            auto blockItr = blockTypes.find(tile.blockID);
            if (blockItr != blockTypes.end()) {
                zoneCounts[blockItr->second] += 1;
            }
            auto wallItr = wallTypes.find(tile.wallID);
            if (wallItr != wallTypes.end()) {
                zoneCounts[wallItr->second] += 1;
            }
        }
    }
    if (zoneCounts[Variant::meteorite] > 0) {
        return Variant::meteorite;
    }
    for (auto [type, count] : zoneCounts) {
        if (count > radius * 4) {
            if (type == Variant::sandstone &&
                (world.conf.dontDigUp ? y > world.getCavernLevel()
                                      : fuzzyIsSurfaceChest(x, y, world))) {
                return Variant::palmWood;
            } else if (type == Variant::pearlwood) {
                for (auto altType :
                     {Variant::mushroom,
                      Variant::marble,
                      Variant::granite,
                      Variant::richMahogany}) {
                    if (zoneCounts[altType] > radius) {
                        return altType;
                    }
                }
            }
            return type;
        }
    }
    for (auto evil : {Variant::flesh, Variant::lesion}) {
        if (zoneCounts[evil] > 2) {
            return evil;
        }
    }
    if (world.conf.dontDigUp) {
        return y > world.getCavernLevel() ? fnv1a32pt(x, y) % 3 == 0
                                                ? Variant::none
                                                : Variant::livingWood
                                          : Variant::gold;
    } else {
        return fuzzyIsSurfaceChest(x, y, world) ? Variant::none : Variant::gold;
    }
}

int scanForSurface(int x, int y, World &world)
{
    while (world.getTile(x, y).blockID != TileID::empty) {
        --y;
    }
    return scanWhileEmpty({x, y}, {0, 1}, world).y;
}

void placeStarterChest(Random &rnd, World &world)
{
    int centerX = world.spawn.x;
    for (int iSwap = 0; iSwap < 20; ++iSwap) {
        int x = iSwap % 2 == 0 ? centerX - iSwap / 2 : centerX + iSwap / 2;
        int surfaceLevel = scanForSurface(x, world.spawn.y, world);
        if (std::abs(surfaceLevel - world.spawn.y) > 5) {
            continue;
        }
        for (int y = surfaceLevel - 4; y < surfaceLevel + 4; ++y) {
            if (isPlacementCandidate(x, y, world)) {
                Variant type = getChestType(x, y, world);
                if (type == Variant::shadow) {
                    type = Variant::ashWood;
                } else if (type == Variant::goldLocked) {
                    type = Variant::none;
                }
                Chest &chest = world.placeChest(x, y - 2, type);
                fillStarterChest(world.conf.equipment, chest, rnd, world);
                return;
            }
        }
    }
}

void placeChest(
    int x,
    int y,
    Variant type,
    Variant origType,
    Random &rnd,
    World &world)
{
    Chest &chest = world.placeChest(x, y - 2, type);
    bool isTrapped = type == Variant::deadMans;
    world.queuedTraps.emplace_back(
        [x, y, isTrapped](Random &rnd, World &world) {
            if (isTrapped) {
                addChestTraps(x, y - 2, rnd, world);
            } else {
                maybeAddChestPressureTraps(x, y - 2, rnd, world);
            }
        });
    Depth depth = getChestDepth(x, y, world);
    int torchID = ItemID::torch;
    switch (type) {
    case Variant::ashWood:
        fillAshWoodChest(chest, depth, rnd, world);
        return;
    case Variant::flesh:
        torchID = ItemID::crimsonTorch;
        break;
    case Variant::frozen:
        fillFrozenChest(chest, depth, rnd, world);
        return;
    case Variant::goldLocked:
        fillDungeonChest(chest, rnd, world);
        return;
    case Variant::granite:
        torchID = ItemID::blueTorch;
        break;
    case Variant::honey:
        fillHoneyChest(chest, depth, rnd, world);
        return;
    case Variant::lesion:
        torchID = ItemID::corruptTorch;
        break;
    case Variant::lihzahrd:
        fillLihzahrdChest(chest, rnd, world);
        return;
    case Variant::livingWood:
        fillLivingWoodChest(chest, rnd, world);
        return;
    case Variant::marble:
        torchID = ItemID::whiteTorch;
        break;
    case Variant::meteorite:
        torchID = ItemID::aetherTorch;
        break;
    case Variant::mushroom:
        fillMushroomChest(chest, depth, rnd, world);
        return;
    case Variant::palmWood:
    case Variant::sandstone:
        fillDesertChest(chest, depth, rnd, world);
        return;
    case Variant::pearlwood:
        fillPearlwoodChest(chest, depth, rnd, world);
        return;
    case Variant::reef:
    case Variant::water:
        fillWaterChest(chest, depth, rnd, world);
        return;
    case Variant::richMahogany:
        fillRichMahoganyChest(chest, depth, rnd, world);
        return;
    case Variant::shadow:
        fillShadowChest(chest, rnd, world);
        return;
    case Variant::skyware:
        if (world.conf.forTheWorthy) {
            world.placeFramedTile(
                chest.x,
                chest.y,
                TileID::chest,
                Variant::goldLocked);
        }
        fillSkywareChest(chest, rnd, world);
        return;
    default:
        break;
    }
    if (isTrapped && origType == Variant::richMahogany) {
        torchID = ItemID::jungleTorch;
    }
    fillChest(chest, depth, torchID, isTrapped, rnd, world);
}

void placeChests(int maxBin, LocationBins &locations, Random &rnd, World &world)
{
    int chestCount =
        world.conf.chests * world.getWidth() * world.getHeight() / 41800 -
        world.getChests().size();
    std::vector<Point> usedLocations{world.spawn};
    for (auto &chest : world.getChests()) {
        usedLocations.emplace_back(chest.x, chest.y);
    }
    while (chestCount > 0) {
        int binId = rnd.getInt(0, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        int surface = world.getSurfaceLevel(x);
        if (!isPlacementCandidate(x, y, world) ||
            isLocationUsed(
                x,
                y,
                y > surface                              ? 20
                : world.conf.dontDigUp                   ? 175
                : y < 0.45 * world.getUndergroundLevel() ? 125
                                                         : 50,
                usedLocations)) {
            continue;
        }
        Variant type = getChestType(x, y, world);
        Variant origType = Variant::none;
        if (y < surface + 3 && y > surface - 8 && type != Variant::reef &&
            type != Variant::water && rnd.getDouble(0, 1) < 0.85) {
            continue;
        } else if (
            y < world.getUndergroundLevel() && type == Variant::goldLocked) {
            continue;
        } else if (type == Variant::shadow) {
            if (world.conf.dontDigUp && x > 0.39 * world.getWidth() &&
                x < 0.61 * world.getWidth()) {
                type = Variant::ashWood;
            } else if (world.getTile(x, y).blockID == TileID::ash) {
                continue;
            }
        } else if (
            type == Variant::gold || (type == Variant::richMahogany &&
                                      y > std::midpoint(
                                              world.getUndergroundLevel(),
                                              world.getCavernLevel()))) {
            int threshold = std::lerp(0, 220, world.conf.traps);
            if (type == Variant::richMahogany) {
                threshold = std::min(300, threshold);
            }
            if (static_cast<int>(99999 * (1 + rnd.getFineNoise(x, y))) % 907 <
                threshold) {
                origType = type;
                type = Variant::deadMans;
            }
        }
        usedLocations.emplace_back(x, y);
        if (type == Variant::gold ||
            (origType == Variant::gold && world.conf.traps > 1.8)) {
            maybePlaceCabinForChest(x, y, rnd, world);
        }
        placeChest(x, y, type, origType, rnd, world);
        --chestCount;
    }
}

Variant getPotType(int x, int y, World &world)
{
    switch (getChestType(x, y, world)) {
    case Variant::flesh:
        return Variant::crimson;
    case Variant::frozen:
        return Variant::tundra;
    case Variant::goldLocked:
        return Variant::dungeon;
    case Variant::honey:
    case Variant::richMahogany:
        return Variant::jungle;
    case Variant::lesion:
        return Variant::corruption;
    case Variant::lihzahrd:
        return Variant::lihzahrd;
    case Variant::marble:
        return Variant::marble;
    case Variant::sandstone:
        return Variant::desert;
    case Variant::shadow:
        return Variant::underworld;
    case Variant::spider:
        return Variant::spider;
    default:
        return Variant::forest;
    }
}

void placePots(int maxBin, LocationBins &locations, Random &rnd, World &world)
{
    int potCount =
        world.conf.pots * world.getWidth() * world.getHeight() / 10000;
    while (potCount > 0) {
        int binId = rnd.getInt(0, maxBin);
        if (locations[binId].empty()) {
            continue;
        }
        auto [x, y] = rnd.select(locations[binId]);
        if (y < 0.85 * world.getUndergroundLevel() ||
            !isPlacementCandidate(x, y, world)) {
            continue;
        }
        world.placeFramedTile(x, y - 2, TileID::pot, getPotType(x, y, world));
        --potCount;
    }
}

void placeDirtiestBlocks(Random &rnd, World &world)
{
    int numBlocks = world.getWidth() * world.getHeight() / 1680000;
    while (numBlocks > 0) {
        int x = rnd.getInt(60, world.getWidth() - 60);
        int y = rnd.getInt(60, world.getHeight() - 60);
        Tile &tile = world.getTile(x, y);
        if (tile.blockID != TileID::dirt || world.isExposed(x, y)) {
            continue;
        }
        tile.blockID = TileID::dirtiestBlock;
        --numBlocks;
    }
}

LocationBins genTreasure(Random &rnd, World &world)
{
    std::cout << "Cataloging ground\n";
    std::vector<std::vector<Point>> rawLocations(world.getWidth());
    parallelFor(
        std::views::iota(50, world.getWidth() - 50),
        [&rawLocations, &world](int x) {
            for (int y = 50; y < world.getHeight() - 50; ++y) {
                if (isPlacementCandidate(x, y, world)) {
                    rawLocations[x].emplace_back(y, 0);
                }
                if (testOrbHeartCandidate(x, y, world) != TileID::empty) {
                    rawLocations[x].emplace_back(y, 1);
                }
            }
        });
    LocationBins flatLocations;
    LocationBins orbHeartLocations;
    for (size_t x = 0; x < rawLocations.size(); ++x) {
        for (auto [y, flag] : rawLocations[x]) {
            if (flag == 0) {
                flatLocations[binLocation(x, y, world.getHeight())]
                    .emplace_back(x, y);
            } else {
                orbHeartLocations[binLocation(x, y, world.getHeight())]
                    .emplace_back(x, y);
            }
        }
    }
    std::cout << "Placing treasures\n";
    if (!world.conf.home && world.conf.equipment != 0) {
        placeStarterChest(rnd, world);
    }
    std::shuffle(
        world.queuedTreasures.begin(),
        world.queuedTreasures.end(),
        rnd.getPRNG());
    for (const auto &applyQueuedTreasure : world.queuedTreasures) {
        applyQueuedTreasure(rnd, world);
    }
    int maxBin =
        binLocation(world.getWidth(), world.getHeight(), world.getHeight());
    placeJungleShrines(rnd, world);
    if (world.conf.hiveQueen) {
        placeLarvae(maxBin, flatLocations, rnd, world);
    }
    placeLifeCrystals(maxBin, flatLocations, rnd, world);
    placeFallenLogs(maxBin, flatLocations, rnd, world);
    if (world.conf.purity) {
        placePurityAltars(rnd, world);
    } else {
        placeAltars(maxBin, flatLocations, rnd, world);
        placeOrbHearts(maxBin, orbHeartLocations, rnd, world);
    }
    placeManaCrystals(maxBin, flatLocations, rnd, world);
    placeChests(maxBin, flatLocations, rnd, world);
    placePots(maxBin, flatLocations, rnd, world);
    placeGems(rnd, world);
    placeDirtiestBlocks(rnd, world);
    return flatLocations;
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Treasure.h`
```
#ifndef TREASURE_H
#define TREASURE_H

#include "structures/StructureUtil.h"

class World;
class Random;

LocationBins genTreasure(Random &rnd, World &world);

#endif // TREASURE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/UndergroundCabin.cpp`
```
#include "structures/UndergroundCabin.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/LootRules.h"
#include "structures/Statues.h"
#include "structures/StructureUtil.h"
#include "structures/data/DynCabin.h"
#include "vendor/frozen/set.h"
#include <algorithm>

inline constexpr auto cabinClearTiles = frozen::make_set<int>({
    TileID::empty,         TileID::dirt,        TileID::stone,
    TileID::clay,          TileID::sand,        TileID::mud,
    TileID::copperOre,     TileID::tinOre,      TileID::ironOre,
    TileID::leadOre,       TileID::silverOre,   TileID::tungstenOre,
    TileID::goldOre,       TileID::platinumOre, TileID::cobaltOre,
    TileID::palladiumOre,  TileID::mythrilOre,  TileID::orichalcumOre,
    TileID::adamantiteOre, TileID::titaniumOre, TileID::chlorophyteOre,
});

bool canPlaceOnCabinGround(int x, int y, int width, int height, World &world)
{
    return world.regionPasses(x, y, width, height, [](Tile &tile) {
        return tile.blockID == TileID::empty;
    }) && world.regionPasses(x, y + height, width, 1, [](Tile &tile) {
        return tile.guarded && isSolidBlock(tile.blockID);
    });
}

void applySupportBeam(int x, int y, World &world)
{
    if (world.getTile(x, y).blockID != TileID::empty) {
        return;
    }
    int supFloor = scanWhileEmpty({x, y}, {0, 1}, world).y;
    ++supFloor;
    if (supFloor - y < 2 || supFloor - y > 24 ||
        !cabinClearTiles.contains(world.getTile(x, supFloor).blockID)) {
        return;
    }
    for (int beamY = y; beamY < supFloor; ++beamY) {
        Tile &tile = world.getTile(x, beamY);
        tile.blockID = TileID::woodenBeam;
        if (!world.conf.unpainted && world.conf.celebration) {
            tile.blockPaint = getDeepRainbowPaint(x, beamY);
        }
    }
}

void addCabinPainting(std::vector<Point> &locations, Random &rnd, World &world)
{
    Painting painting = rnd.pool(
        {Painting::americanExplosive,
         Painting::secrets,
         Painting::strangeDeadFellows,
         Painting::sufficientlyAdvanced,
         Painting::bifrost,
         Painting::bioluminescence,
         Painting::findingGold,
         Painting::forestTroll,
         Painting::aHorribleNightForAlchemy,
         Painting::catSword,
         Painting::crownoDevoursHisLunch,
         Painting::fairyGuides,
         Painting::fatherOfSomeone,
         Painting::guidePicasso,
         Painting::nurseLisa,
         Painting::outcast,
         Painting::rareEnchantment,
         Painting::terrarianGothic});
    auto [pWidth, pHeight] = world.getPaintingDims(painting);
    for (auto [x, y] : locations) {
        if (world.regionPasses(
                x - 1,
                y,
                pWidth + 2,
                pHeight + 1,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) &&
            world.regionPasses(x, y, pWidth, pHeight, [](Tile &tile) {
                return tile.wallID != WallID::empty;
            })) {
            world.placePainting(x, y, painting);
            break;
        }
    }
}

Point addCabinStatue(std::vector<Point> &locations, int statue, World &world)
{
    for (auto [x, y] : locations) {
        if (!world.regionPasses(
                x - 1,
                y,
                4,
                3,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            !world.regionPasses(x, y + 3, 2, 1, [](Tile &tile) {
                return tile.guarded && isSolidBlock(tile.blockID);
            })) {
            continue;
        }
        placeStatue(x, y, statue, world);
        return {x, y};
    }
    return {-1, -1};
}

void addCabinDebris(std::vector<Point> &locations, World &world)
{
    for (auto [x, y] : locations) {
        if (!world.regionPasses(
                x,
                y,
                3,
                2,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            !world.regionPasses(x, y + 2, 3, 1, [](Tile &tile) {
                return isSolidBlock(tile.blockID);
            })) {
            continue;
        }
        world.placeFramedTile(x, y, TileID::largePile, Variant::furniture);
        break;
    }
    for (auto [x, y] : locations) {
        if (!world.regionPasses(
                x,
                y,
                2,
                1,
                [](Tile &tile) { return tile.blockID == TileID::empty; }) ||
            !world.regionPasses(x, y + 1, 2, 1, [](Tile &tile) {
                return isSolidBlock(tile.blockID);
            })) {
            continue;
        }
        world.placeFramedTile(x, y, TileID::smallPile, Variant::furniture);
        break;
    }
    for (auto [x, y] : locations) {
        Tile &tile = world.getTile(x, y);
        if (tile.blockID == TileID::empty && fnv1a32pt(x, y) % 19 == 0) {
            tile.blockID = TileID::cobweb;
        }
    }
}

void addCabinBarrel(std::vector<Point> &locations, Random &rnd, World &world)
{
    for (auto [x, y] : locations) {
        if (canPlaceOnCabinGround(x, y, 2, 2, world)) {
            fillBarrel(world.placeChest(x, y, Variant::barrel), rnd);
            break;
        }
    }
}

void addCabinStation(std::vector<Point> &locations, Random &rnd, World &world)
{
    for (auto [x, y] : locations) {
        if (canPlaceOnCabinGround(x, y, 3, 2, world)) {
            world.placeFramedTile(
                x,
                y,
                rnd.select({TileID::loom, TileID::sharpeningStation}));
            break;
        }
    }
}

void maybePlaceCabinForChest(int x, int y, Random &rnd, World &world)
{
    if (rnd.getDouble(0, 1) > 0.4) {
        return;
    }
    TileBuffer cabin = Data::getCabin(
        rnd.select(Data::cabins),
        rnd.getInt(16, 26),
        world.getFramedTiles());
    int chestX = x;
    int chestY = y - 2;
    x -= cabin.getWidth() / 2 + rnd.getInt(-5, 4);
    y -= cabin.getHeight() - 1;
    if (!world.regionPasses(
            x,
            y,
            cabin.getWidth(),
            cabin.getHeight(),
            [](Tile &tile) {
                return !tile.guarded && cabinClearTiles.contains(tile.blockID);
            })) {
        return;
    }
    std::vector<Point> locations;
    for (int i = 0; i < cabin.getWidth(); ++i) {
        int doorAt = -1;
        for (int j = 0; j < cabin.getHeight(); ++j) {
            Tile &cabinTile = cabin.getTile(i, j);
            if (cabinTile.blockID == TileID::cloud) {
                continue;
            }
            if (!world.conf.unpainted && world.conf.celebration) {
                cabinTile.blockPaint = getDeepRainbowPaint(x + i, y + j);
                cabinTile.wallPaint = cabinTile.blockPaint;
            }
            Tile &tile = world.getTile(x + i, y + j);
            if (std::abs(rnd.getFineNoise(x + 3 * i, y + 3 * j)) > 0.34) {
                if (tile.blockID == TileID::empty &&
                    fnv1a32pt(x + i, y + j) % 5 != 0) {
                    tile = {};
                } else {
                    tile.liquid = Liquid::none;
                    if (isSolidBlock(cabinTile.blockID)) {
                        tile.guarded = true;
                    }
                }
                continue;
            }
            if (cabinTile.blockID == TileID::door) {
                doorAt = j - (cabinTile.frameY % 54) / 18;
            } else {
                tile = cabinTile;
                tile.guarded = true;
                locations.emplace_back(x + i, y + j);
            }
        }
        if (doorAt != -1) {
            if (world.getTile(x + i, y + doorAt - 1).blockID != TileID::empty &&
                world.getTile(x + i, y + doorAt + 3).blockID != TileID::empty) {
                for (int j = doorAt; j < doorAt + 3; ++j) {
                    Tile &tile = world.getTile(x + i, y + j);
                    tile = cabin.getTile(i, j);
                    tile.guarded = true;
                }
            }
        }
        if ((i + y) % 5 == 0) {
            applySupportBeam(x + i, y + cabin.getHeight(), world);
        }
    }
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            world.getTile(chestX + i, chestY + j).blockID = TileID::chest;
        }
    }
    std::shuffle(locations.begin(), locations.end(), rnd.getPRNG());
    addCabinPainting(locations, rnd, world);
    addCabinStatue(locations, rnd.select(StatueVariants::deco), world);
    Point trap =
        addCabinStatue(locations, rnd.select(StatueVariants::enemy), world);
    switch (rnd.getInt(0, 5)) {
    case 0:
        addCabinStation(locations, rnd, world);
        [[fallthrough]];
    case 1:
        addCabinBarrel(locations, rnd, world);
        break;
    case 2:
        addCabinBarrel(locations, rnd, world);
        [[fallthrough]];
    case 3:
        addCabinStation(locations, rnd, world);
        break;
    }
    addCabinDebris(locations, world);
    if (trap.x != -1 && rnd.getDouble(0, 1) < 0.2 * world.conf.traps) {
        world.queuedTraps.emplace_back(
            [chestX, chestY, trap](Random &, World &world) {
                world.placeFramedTile(
                    chestX,
                    chestY,
                    TileID::chestGroup2,
                    Variant::deadMans);
                placeWire(trap, {chestX, chestY}, Wire::red, world);
            });
    }
    for (Point pos : locations) {
        Tile &tile = world.getTile(pos);
        if (tile.blockID == TileID::empty) {
            tile.blockPaint = Paint::none;
        }
        if (tile.wallID == WallID::empty) {
            tile.wallPaint = Paint::none;
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/UndergroundCabin.h`
```
#ifndef UNDERGROUNDCABIN_H
#define UNDERGROUNDCABIN_H

class World;
class Random;

void maybePlaceCabinForChest(int x, int y, Random &rnd, World &world);

#endif // UNDERGROUNDCABIN_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Vines.cpp`
```
#include "structures/Vines.h"

#include "Random.h"
#include "Util.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "vendor/frozen/map.h"
#include "vendor/frozen/set.h"
#include <iostream>

enum class ScanState { n, s, se, see, seee, e, ee, eee, eees };

inline constexpr auto attatchTiles = frozen::make_set<int>(
    {TileID::ice,
     TileID::stone,
     TileID::stoneSlab,
     TileID::hive,
     TileID::pearlstone,
     TileID::ebonstone,
     TileID::crimstone,
     TileID::sandstone,
     TileID::granite,
     TileID::marble,
     TileID::hallowedIce,
     TileID::corruptIce,
     TileID::crimsonIce});

ScanState scanTransition(Tile &tile, ScanState state)
{
    if (tile.blockID == TileID::empty) {
        switch (state) {
        case ScanState::n:
            return ScanState::e;
        case ScanState::s:
        case ScanState::eees:
            return ScanState::se;
        case ScanState::se:
            return ScanState::see;
        case ScanState::see:
            return ScanState::seee;
        case ScanState::seee:
        case ScanState::ee:
        case ScanState::eee:
            return ScanState::eee;
        case ScanState::e:
            return ScanState::ee;
        }
    } else if (
        tile.slope == Slope::none && !tile.actuated &&
        attatchTiles.contains(tile.blockID)) {
        switch (state) {
        case ScanState::n:
        case ScanState::s:
        case ScanState::se:
        case ScanState::see:
        case ScanState::e:
        case ScanState::ee:
        case ScanState::eees:
            return ScanState::s;
        case ScanState::seee:
        case ScanState::eee:
            return ScanState::eees;
        }
    }
    return ScanState::n;
}

inline constexpr auto stalactiteTypes = frozen::make_map<int, int>(
    {{TileID::ice, 0},
     {TileID::stone, 54},
     {TileID::hive, 162},
     {TileID::pearlstone, 216},
     {TileID::ebonstone, 270},
     {TileID::crimstone, 324},
     {TileID::sandstone, 378},
     {TileID::granite, 432},
     {TileID::marble, 486},
     {TileID::hallowedIce, 540},
     {TileID::corruptIce, 594},
     {TileID::crimsonIce, 648}});

void placeStalactite(int x, int y, World &world)
{
    int variation = fnv1a32pt(x, y) % 6;
    int frameX = 18 * variation;
    int frameY = 0;
    int height = 2;
    if (variation > 2) {
        frameX -= 54;
        frameY = 72;
        height = 1;
    }
    Tile &probeTile = world.getTile(x, y);
    int paint = probeTile.blockPaint;
    if (probeTile.wallID == WallID::Unsafe::spider &&
        (probeTile.blockID == TileID::stone ||
         probeTile.blockID == TileID::stoneSlab)) {
        frameX += 108;
        frameY = 0;
        height = 2;
        paint = Paint::none;
    } else {
        auto itr = stalactiteTypes.find(probeTile.blockID);
        if (itr == stalactiteTypes.end()) {
            return;
        }
        frameX += itr->second;
        if (itr->first == TileID::hive) {
            if (probeTile.flag == Flag::border) {
                return;
            }
            frameY = 72;
            height = 1;
        }
    }
    for (int j = 0; j < height; ++j) {
        Tile &tile = world.getTile(x, y + j + 1);
        tile.blockID = TileID::stalactite;
        tile.frameX = frameX;
        tile.frameY = 18 * j + frameY;
        tile.blockPaint = paint;
    }
}

inline constexpr auto stalagmiteTypes = frozen::make_map<int, int>(
    {{TileID::stone, 54},
     {TileID::hive, 162},
     {TileID::pearlstone, 216},
     {TileID::ebonstone, 270},
     {TileID::crimstone, 324},
     {TileID::sandstone, 378},
     {TileID::granite, 432},
     {TileID::marble, 486}});

void placeStalagmite(int x, int y, World &world)
{
    Tile &probeTile = world.getTile(x, y);
    auto itr = stalagmiteTypes.find(probeTile.blockID);
    if (itr == stalagmiteTypes.end() ||
        (itr->first == TileID::hive && probeTile.flag == Flag::border)) {
        return;
    }
    int variation = fnv1a32pt(x, y) % 6;
    int frameX = 18 * variation + itr->second;
    int frameY = 36;
    int height = 2;
    if (variation > 2) {
        frameX -= 54;
        frameY = 90;
        height = 1;
    } else if (itr->first == TileID::hive) {
        frameY = 90;
        height = 1;
    }
    for (int j = 0; j < height; ++j) {
        Tile &tile = world.getTile(x, y + j - height);
        tile.blockID = TileID::stalactite;
        tile.frameX = frameX;
        tile.frameY = 18 * j + frameY;
        tile.blockPaint = probeTile.blockPaint;
    }
}

void genVines(Random &rnd, World &world)
{
    std::cout << "Growing vines\n";
    constexpr auto vineTypes = frozen::make_map<int, int>(
        {{TileID::grass, TileID::vines},
         {TileID::leaf, TileID::vines},
         {TileID::jungleGrass, TileID::jungleVines},
         {TileID::mahoganyLeaf, TileID::vineRope},
         {TileID::lihzahrdBrick, TileID::vineRope},
         {TileID::corruptGrass, TileID::corruptVines},
         {TileID::corruptJungleGrass, TileID::corruptVines},
         {TileID::crimsonGrass, TileID::crimsonVines},
         {TileID::crimsonJungleGrass, TileID::crimsonVines},
         {TileID::hallowedGrass, TileID::hallowedVines},
         {TileID::mushroomGrass, TileID::mushroomVines},
         {TileID::ashGrass, TileID::ashVines}});
    constexpr auto dropperTypes = frozen::make_map<int, int>(
        {{TileID::dirt, TileID::waterDrip},
         {TileID::stone, TileID::waterDrip},
         {TileID::jungleGrass, TileID::waterDrip},
         {TileID::cloud, TileID::waterDrip},
         {TileID::rainCloud, TileID::waterDrip},
         {TileID::granite, TileID::waterDrip},
         {TileID::marble, TileID::waterDrip},
         {TileID::livingMahogany, TileID::waterDrip},
         {TileID::mahoganyLeaf, TileID::waterDrip},
         {TileID::lihzahrdBrick, TileID::waterDrip},
         {TileID::ash, TileID::lavaDrip},
         {TileID::ashGrass, TileID::lavaDrip},
         {TileID::obsidianBrick, TileID::lavaDrip},
         {TileID::hellstoneBrick, TileID::lavaDrip},
         {TileID::sand, TileID::sandDrip},
         {TileID::hardenedSand, TileID::sandDrip},
         {TileID::sandstone, TileID::sandDrip},
         {TileID::ebonsand, TileID::sandDrip},
         {TileID::hardenedEbonsand, TileID::sandDrip},
         {TileID::ebonsandstone, TileID::sandDrip},
         {TileID::crimsand, TileID::sandDrip},
         {TileID::hardenedCrimsand, TileID::sandDrip},
         {TileID::crimsandstone, TileID::sandDrip},
         {TileID::pearlsand, TileID::sandDrip},
         {TileID::hardenedPearlsand, TileID::sandDrip},
         {TileID::pearlsandstone, TileID::sandDrip},
         {TileID::hive, TileID::honeyDrip}});
    int lavaLevel =
        (world.getCavernLevel() + 2 * world.getUnderworldLevel()) / 3;
    parallelFor(std::views::iota(0, world.getWidth()), [&](int x) {
        int vine = TileID::empty;
        int vinePaint = Paint::none;
        int dropper = TileID::empty;
        int vineLen = 0;
        ScanState state = ScanState::n;
        for (int y = 0; y < world.getHeight(); ++y) {
            Tile &tile = world.getTile(x, y);
            state = scanTransition(tile, state);
            int randInt = 99999 * (1 + rnd.getFineNoise(x, y));
            if (vineLen > 0) {
                if (tile.blockID == TileID::empty &&
                    (tile.liquid == Liquid::none ||
                     tile.liquid == Liquid::water)) {
                    tile.blockID = vine;
                    tile.blockPaint = vinePaint;
                    state = ScanState::n;
                    --vineLen;
                    continue;
                } else {
                    vineLen = 0;
                }
            } else if (
                dropper != TileID::empty && tile.blockID == TileID::empty &&
                tile.liquid == Liquid::none &&
                randInt % (dropper == TileID::honeyDrip ? 19 : 67) == 0) {
                tile.blockID = dropper == TileID::waterDrip && y > lavaLevel &&
                                       randInt % 5 != 0
                                   ? TileID::lavaDrip
                                   : dropper;
                dropper = TileID::empty;
                state = ScanState::n;
                continue;
            }
            if (state == ScanState::seee && randInt % 7 == 0) {
                placeStalactite(x, y - 3, world);
                state = ScanState::e;
            } else if (state == ScanState::eees && randInt % 11 == 0) {
                placeStalagmite(x, y, world);
            }
            dropper = TileID::empty;
            if (tile.slope != Slope::none || tile.actuated) {
                continue;
            }
            auto vineItr = vineTypes.find(tile.blockID);
            if (vineItr == vineTypes.end() ||
                (tile.blockID == TileID::lihzahrdBrick ? randInt % 29 != 0
                                                       : randInt % 3 == 0)) {
                auto dropperItr = dropperTypes.find(tile.blockID);
                if (dropperItr != dropperTypes.end()) {
                    dropper = dropperItr->second;
                }
                continue;
            }
            vine = vineItr->second;
            if (vine == TileID::vines && rnd.getCoarseNoise(x, y) > 0.12) {
                vine = TileID::flowerVines;
            }
            vinePaint =
                vine == TileID::vineRope ? Paint::lime : tile.blockPaint;
            vineLen = 4 + randInt % 7;
        }
    });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/Vines.h`
```
#ifndef VINES_H
#define VINES_H

class World;
class Random;

void genVines(Random &rnd, World &world);

#endif // VINES_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Altars.cpp`
```
#include "structures/data/Altars.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> altarData{
// corruptAltar1
{
    5386, 4106, 189, 2, 4097, 152, 0, 4097, 152, 4097, 189, 2, 4097, 152, 4096,
    157, 4097, 152, 4097, 189, 2, 4097, 152, 4096, 157, 4097, 152, 4097, 189,
    2, 4097, 152, 0, 4097, 152, 4097, 189, 2, 4097, 152, 0, 4097, 152, 4097,
    189, 2, 4097, 152, 0, 4097, 152, 4097, 189, 2, 4097, 152, 4096, 157, 4097,
    152, 4097, 189, 1, 36864, 140, 8, 4097, 152, 4096, 157, 4097, 152, 4097,
    189, 4096, 26, 0, 0, 4096, 26, 0, 18, 4096, 140, 4097, 152, 0, 4097, 152,
    4097, 189, 4096, 26, 18, 0, 4096, 26, 18, 18, 4096, 140, 4097, 152, 0,
    4097, 152, 4097, 189, 4096, 26, 36, 0, 4096, 26, 36, 18, 4096, 140, 4097,
    152, 0, 4097, 152, 4097, 189, 1, 36864, 140, 8, 4097, 152, 4096, 157, 4097,
    152, 4097, 189, 2, 4097, 152, 4096, 157, 4097, 152, 4097, 189, 2, 4097,
    152, 0, 4097, 152, 4097, 189, 2, 4097, 152, 0, 4097, 152, 4097, 189, 2,
    4097, 152, 0, 4097, 152, 4097, 189, 2, 4097, 152, 4096, 157, 4097, 152,
    4097, 189, 2, 4097, 152, 4096, 157, 4097, 152, 4097, 189, 2, 4097, 152, 0,
    4097, 152, 4106, 189
},
// corruptAltar2
{
    4874, 4106, 189, 2, 4096, 152, 36864, 152, 40, 2, 4097, 189, 4096, 93, 0,
    1782, 4096, 93, 0, 1800, 4096, 93, 0, 1818, 4097, 152, 2, 4097, 189, 2,
    4097, 152, 2, 4097, 189, 2, 36864, 152, 16, 4097, 152, 1, 4097, 189, 3,
    4097, 152, 1, 4097, 189, 3, 36864, 152, 16, 4097, 152, 0, 4097, 189, 4,
    4098, 152, 4097, 189, 2, 4096, 26, 0, 0, 4096, 26, 0, 18, 4098, 152, 4097,
    189, 2, 4096, 26, 18, 0, 4096, 26, 18, 18, 4098, 152, 4097, 189, 2, 4096,
    26, 36, 0, 4096, 26, 36, 18, 4098, 152, 4097, 189, 4, 4098, 152, 4097, 189,
    3, 36864, 152, 24, 4097, 152, 0, 4097, 189, 3, 4097, 152, 1, 4097, 189, 2,
    36864, 152, 24, 4097, 152, 1, 4097, 189, 2, 4097, 152, 2, 4097, 189, 4096,
    93, 0, 1782, 4096, 93, 0, 1800, 4096, 93, 0, 1818, 4097, 152, 2, 4097, 189,
    2, 4096, 152, 36864, 152, 32, 2, 4106, 189
},
// corruptAltar3
{
    5392, 4112, 189, 2, 4096, 152, 9, 4097, 189, 1, 36864, 152, 8, 4096, 152,
    7, 4097, 152, 4097, 189, 1, 4096, 152, 4096, 140, 8199, 35, 4097, 152,
    4097, 189, 0, 36864, 152, 8, 4096, 152, 4096, 140, 8194, 35, 12288, 4, 0,
    176, 35, 8195, 35, 4097, 152, 4097, 189, 0, 4097, 152, 4096, 140, 8199, 35,
    4097, 152, 4097, 189, 0, 4097, 152, 4096, 140, 7, 4097, 152, 4097, 189,
    36864, 152, 8, 4097, 152, 4096, 140, 7, 4097, 152, 4097, 189, 36864, 152,
    8, 4096, 152, 4096, 140, 36864, 140, 32, 7, 4097, 152, 4097, 189, 4097,
    152, 4096, 140, 4096, 34, 108, 108, 4096, 34, 108, 126, 4096, 34, 108, 144,
    3, 4096, 26, 0, 0, 4096, 26, 0, 18, 4097, 152, 4097, 189, 4097, 152, 4096,
    140, 4096, 34, 126, 108, 4096, 34, 126, 126, 4096, 34, 126, 144, 3, 4096,
    26, 18, 0, 4096, 26, 18, 18, 4097, 152, 4097, 189, 4097, 152, 4096, 140,
    4096, 34, 144, 108, 4096, 34, 144, 126, 4096, 34, 144, 144, 3, 4096, 26,
    36, 0, 4096, 26, 36, 18, 4097, 152, 4097, 189, 36864, 152, 8, 4096, 152,
    4096, 140, 36864, 140, 40, 7, 4097, 152, 4097, 189, 36864, 152, 8, 4097,
    152, 4096, 140, 7, 4097, 152, 4097, 189, 0, 4097, 152, 4096, 140, 7, 4097,
    152, 4097, 189, 0, 4097, 152, 4096, 140, 8199, 35, 4097, 152, 4097, 189, 0,
    36864, 152, 8, 4096, 152, 4096, 140, 8194, 35, 12288, 4, 0, 176, 35, 8195,
    35, 4097, 152, 4097, 189, 1, 4096, 152, 4096, 140, 8199, 35, 4097, 152,
    4097, 189, 1, 36864, 152, 8, 4096, 152, 7, 4097, 152, 4097, 189, 2, 4096,
    152, 9, 4112, 189
},
// corruptAltar4
{
    5396, 4116, 189, 14, 36864, 140, 8, 4096, 140, 4096, 152, 4097, 189, 14,
    36864, 140, 8, 4097, 152, 4097, 189, 14, 4096, 140, 4097, 152, 4097, 189,
    11, 4097, 140, 4099, 152, 4097, 189, 11, 36864, 140, 8, 4100, 152, 4097,
    189, 11, 4096, 140, 4100, 152, 4097, 189, 8, 4097, 140, 4102, 152, 4097,
    189, 8, 36864, 140, 8, 4103, 152, 4097, 189, 6, 4096, 26, 0, 0, 4096, 26,
    0, 18, 4096, 140, 4103, 152, 4097, 189, 6, 4096, 26, 18, 0, 4096, 26, 18,
    18, 4096, 140, 4103, 152, 4097, 189, 0, 36864, 474, 2072, 36864, 474, 2048,
    4096, 19, 90, 666, 4096, 42, 0, 1404, 4096, 42, 0, 1422, 0, 4096, 26, 36,
    0, 4096, 26, 36, 18, 4096, 140, 4103, 152, 4097, 189, 36864, 474, 2072,
    36864, 474, 2048, 36864, 474, 2080, 5, 4096, 140, 4103, 152, 4097, 189,
    36865, 474, 2048, 6, 36864, 140, 8, 4096, 140, 4102, 152, 4097, 189, 36865,
    474, 2048, 9, 4096, 140, 4100, 152, 4097, 189, 36864, 474, 2064, 36864,
    474, 2048, 1, 36864, 474, 2048, 6, 4096, 474, 4100, 152, 4097, 189, 0,
    36864, 474, 2064, 36865, 474, 2048, 36864, 474, 2080, 5, 36864, 474, 2072,
    36864, 474, 2048, 4096, 140, 4099, 152, 4097, 189, 1, 36864, 474, 2064,
    36864, 474, 2048, 4, 36864, 474, 2072, 36865, 474, 2048, 36864, 474, 2080,
    1, 36864, 140, 8, 4097, 152, 4097, 189, 2, 36864, 474, 2064, 36864, 474,
    2048, 36864, 474, 2088, 0, 36864, 474, 2072, 36864, 474, 2048, 36864, 474,
    2080, 4, 4096, 140, 4097, 152, 4097, 189, 4, 36864, 474, 2064, 36864, 474,
    2048, 36864, 474, 2080, 6, 4097, 140, 4096, 152, 4116, 189
},
// corruptAltar5
{
    3852, 4108, 189, 1, 4096, 215, 54, 0, 4096, 215, 54, 18, 4101, 152, 4097,
    189, 1, 4096, 215, 72, 0, 4096, 215, 72, 18, 4096, 140, 4098, 152, 4096,
    140, 4096, 152, 4097, 189, 1, 4096, 215, 90, 0, 4096, 215, 90, 18, 4101,
    152, 4097, 189, 3, 4096, 157, 1, 36864, 157, 24, 36864, 157, 32, 0, 4097,
    189, 3, 4096, 157, 0, 36864, 157, 24, 36864, 157, 32, 1, 4097, 189, 4096,
    26, 0, 0, 4096, 26, 0, 18, 4103, 152, 4097, 189, 4096, 26, 18, 0, 4096, 26,
    18, 18, 4097, 152, 4096, 140, 4096, 152, 4096, 140, 4098, 152, 4097, 189,
    4096, 26, 36, 0, 4096, 26, 36, 18, 4103, 152, 4097, 189, 3, 4096, 157, 0,
    36864, 157, 16, 36864, 157, 40, 1, 4097, 189, 3, 4096, 157, 1, 36864, 157,
    16, 36864, 157, 40, 0, 4097, 189, 1, 4096, 215, 54, 0, 4096, 215, 54, 18,
    4101, 152, 4097, 189, 1, 4096, 215, 72, 0, 4096, 215, 72, 18, 4096, 140,
    4098, 152, 4096, 140, 4096, 152, 4097, 189, 1, 4096, 215, 90, 0, 4096, 215,
    90, 18, 4101, 152, 4108, 189
},
// corruptAltar6
{
    3856, 4112, 189, 2, 4096, 152, 8, 4096, 152, 4097, 189, 4096, 93, 0, 1782,
    4096, 93, 0, 1800, 4096, 93, 0, 1818, 4097, 152, 6, 4097, 152, 4097, 189,
    2, 4098, 152, 36864, 140, 24, 4098, 140, 36864, 140, 40, 4098, 152, 4097,
    189, 3, 4098, 152, 36864, 140, 32, 0, 36864, 140, 16, 4098, 152, 0, 4097,
    189, 3, 36864, 140, 24, 4098, 152, 0, 4098, 152, 36864, 140, 40, 0, 4097,
    189, 1, 4096, 26, 0, 0, 4096, 26, 0, 18, 4096, 140, 36864, 140, 32, 4100,
    152, 36864, 140, 16, 4096, 140, 0, 4097, 189, 1, 4096, 26, 18, 0, 4096, 26,
    18, 18, 4096, 140, 1, 4098, 152, 1, 4096, 140, 0, 4097, 189, 1, 4096, 26,
    36, 0, 4096, 26, 36, 18, 4096, 140, 36864, 140, 40, 4100, 152, 36864, 140,
    24, 4096, 140, 0, 4097, 189, 3, 36864, 140, 16, 4098, 152, 0, 4098, 152,
    36864, 140, 32, 0, 4097, 189, 3, 4098, 152, 36864, 140, 40, 0, 36864, 140,
    24, 4098, 152, 0, 4097, 189, 2, 4098, 152, 36864, 140, 16, 4098, 140,
    36864, 140, 32, 4098, 152, 4097, 189, 4096, 93, 0, 1782, 4096, 93, 0, 1800,
    4096, 93, 0, 1818, 4097, 152, 6, 4097, 152, 4097, 189, 2, 4096, 152, 8,
    4096, 152, 4112, 189
},
// crimsonAltar1
{
    4361, 4105, 189, 2, 8192, 141, 4098, 478, 4097, 189, 1, 8193, 141, 45056,
    478, 234, 8, 4097, 478, 4097, 189, 1, 8193, 141, 45056, 478, 234, 8, 4097,
    478, 4097, 189, 0, 12288, 4, 0, 242, 141, 8193, 141, 4098, 478, 4097, 189,
    1, 8193, 141, 4096, 478, 8192, 234, 4096, 478, 4097, 189, 1, 8192, 141,
    45056, 347, 141, 24, 4096, 347, 4097, 478, 4097, 189, 0, 4096, 26, 54, 0,
    12288, 26, 54, 18, 141, 12288, 347, 141, 4096, 347, 4097, 478, 4097, 189,
    0, 4096, 26, 72, 0, 12288, 26, 72, 18, 141, 12288, 347, 141, 4096, 347,
    4097, 478, 4097, 189, 0, 4096, 26, 90, 0, 12288, 26, 90, 18, 141, 12288,
    347, 141, 4096, 347, 4097, 478, 4097, 189, 1, 8192, 141, 45056, 347, 141,
    16, 4096, 347, 4097, 478, 4097, 189, 1, 8193, 141, 4098, 478, 4097, 189, 0,
    12288, 4, 0, 242, 141, 8193, 141, 45056, 478, 234, 8, 4097, 478, 4097, 189,
    1, 8193, 141, 4098, 478, 4097, 189, 1, 8193, 141, 4096, 478, 8192, 234,
    4096, 478, 4097, 189, 2, 8192, 141, 4098, 478, 4105, 189
},
// crimsonAltar2
{
    4361, 4105, 189, 3, 4098, 347, 4097, 189, 3, 4098, 347, 4097, 189, 3, 4098,
    347, 4097, 189, 0, 36864, 347, 8, 4097, 347, 4098, 478, 4097, 189, 0,
    36864, 347, 8, 4097, 347, 4098, 478, 4097, 189, 0, 36864, 347, 8, 4097,
    347, 4098, 478, 4097, 189, 4096, 26, 54, 0, 4096, 26, 54, 18, 4097, 478,
    4098, 347, 4097, 189, 4096, 26, 72, 0, 4096, 26, 72, 18, 4097, 478, 4098,
    347, 4097, 189, 4096, 26, 90, 0, 4096, 26, 90, 18, 4097, 478, 4098, 347,
    4097, 189, 0, 36864, 347, 8, 4097, 347, 4098, 478, 4097, 189, 0, 36864,
    347, 8, 4097, 347, 4098, 478, 4097, 189, 0, 36864, 347, 8, 4097, 347, 4098,
    478, 4097, 189, 3, 4098, 347, 4097, 189, 3, 4098, 347, 4097, 189, 3, 4098,
    347, 4105, 189
},
// crimsonAltar3
{
    5393, 4113, 189, 4, 36864, 195, 2072, 36864, 195, 2048, 36864, 195, 2088,
    6, 4097, 189, 2, 36864, 195, 2072, 36867, 195, 2048, 0, 36864, 195, 2072,
    36864, 195, 2048, 36864, 195, 2088, 0, 4097, 478, 4097, 189, 2, 36873, 195,
    2048, 4097, 478, 4097, 189, 1, 36864, 195, 2072, 36865, 195, 2048, 0,
    36864, 195, 2064, 36866, 195, 2048, 36864, 195, 2080, 36864, 195, 2064,
    4098, 478, 4097, 189, 0, 36864, 195, 2072, 36866, 195, 2048, 6, 4096, 478,
    4096, 347, 4096, 478, 4097, 189, 36864, 195, 2056, 36866, 195, 2048, 36864,
    195, 2080, 6, 4098, 478, 4097, 189, 0, 36866, 195, 2048, 7, 4098, 478,
    4097, 189, 0, 36866, 195, 2048, 7, 4096, 478, 4096, 347, 4096, 478, 4097,
    189, 36864, 195, 2056, 36865, 195, 2048, 4096, 195, 4096, 34, 0, 486, 4096,
    34, 0, 504, 4096, 34, 0, 522, 2, 4096, 26, 54, 0, 4096, 26, 54, 18, 4098,
    478, 4097, 189, 0, 36865, 195, 2048, 4096, 195, 4096, 34, 18, 486, 4096,
    34, 18, 504, 4096, 34, 18, 522, 2, 4096, 26, 72, 0, 4096, 26, 72, 18, 4098,
    478, 4097, 189, 0, 36865, 195, 2048, 4096, 195, 4096, 34, 36, 486, 4096,
    34, 36, 504, 4096, 34, 36, 522, 2, 4096, 26, 90, 0, 4096, 26, 90, 18, 4098,
    478, 4097, 189, 0, 36864, 195, 2064, 36865, 195, 2048, 7, 4096, 478, 4096,
    347, 4096, 478, 4097, 189, 1, 36867, 195, 2048, 5, 4098, 478, 4097, 189, 1,
    36865, 195, 2048, 36864, 195, 2080, 6, 4098, 478, 4097, 189, 1, 36864, 195,
    2064, 36864, 195, 2048, 36864, 195, 2088, 6, 4096, 478, 4096, 347, 4096,
    478, 4097, 189, 2, 36867, 195, 2048, 36864, 195, 2088, 0, 36864, 195, 2072,
    36865, 195, 2048, 4098, 478, 4097, 189, 2, 36864, 195, 2064, 36867, 195,
    2048, 0, 36866, 195, 2048, 36864, 195, 2080, 4097, 478, 4097, 189, 4,
    36869, 195, 2048, 1, 4097, 478, 4097, 189, 6, 36864, 195, 2064, 36865, 195,
    2048, 36864, 195, 2080, 3, 4113, 189
},
// crimsonAltar4
{
    3851, 4107, 189, 4096, 215, 216, 0, 4096, 215, 216, 18, 4096, 347, 4097,
    478, 36864, 208, 40, 36864, 208, 24, 4097, 478, 4097, 189, 4096, 215, 234,
    0, 4096, 215, 234, 18, 4096, 347, 4097, 478, 4097, 208, 4097, 478, 4097,
    189, 4096, 215, 252, 0, 4096, 215, 252, 18, 4096, 347, 4097, 478, 36864,
    208, 32, 36864, 208, 16, 4097, 478, 4097, 189, 8, 4097, 189, 8, 4097, 189,
    1, 4096, 26, 54, 0, 4096, 26, 54, 18, 4096, 347, 4096, 478, 36864, 208, 40,
    36864, 208, 24, 4096, 478, 4097, 189, 1, 4096, 26, 72, 0, 4096, 26, 72, 18,
    4096, 347, 4096, 478, 4097, 208, 4096, 478, 4097, 189, 1, 4096, 26, 90, 0,
    4096, 26, 90, 18, 4096, 347, 4096, 478, 36864, 208, 32, 36864, 208, 16,
    4096, 478, 4097, 189, 8, 4097, 189, 8, 4097, 189, 4096, 215, 216, 0, 4096,
    215, 216, 18, 4096, 347, 4097, 478, 36864, 208, 40, 36864, 208, 24, 4097,
    478, 4097, 189, 4096, 215, 234, 0, 4096, 215, 234, 18, 4096, 347, 4097,
    478, 4097, 208, 4097, 478, 4097, 189, 4096, 215, 252, 0, 4096, 215, 252,
    18, 4096, 347, 4097, 478, 36864, 208, 32, 36864, 208, 16, 4097, 478, 4107,
    189
},
// crimsonAltar5
{
    4361, 4105, 189, 3, 36864, 347, 40, 1, 4097, 189, 2, 36864, 478, 24, 4096,
    478, 1, 4097, 189, 4096, 93, 0, 162, 4096, 93, 0, 180, 4096, 93, 0, 198,
    4097, 478, 36864, 347, 40, 0, 4097, 189, 2, 36864, 478, 16, 4097, 478, 0,
    4097, 189, 3, 4098, 478, 4097, 189, 3, 4097, 347, 4096, 478, 4097, 189, 1,
    4096, 26, 54, 0, 4096, 26, 54, 18, 4096, 347, 4097, 478, 4097, 189, 1,
    4096, 26, 72, 0, 4096, 26, 72, 18, 4096, 347, 4097, 478, 4097, 189, 1,
    4096, 26, 90, 0, 4096, 26, 90, 18, 4096, 347, 4097, 478, 4097, 189, 3,
    4097, 347, 4096, 478, 4097, 189, 3, 4098, 478, 4097, 189, 2, 36864, 478,
    24, 4097, 478, 0, 4097, 189, 4096, 93, 0, 162, 4096, 93, 0, 180, 4096, 93,
    0, 198, 4097, 478, 36864, 347, 32, 0, 4097, 189, 2, 36864, 478, 16, 4096,
    478, 1, 4097, 189, 3, 36864, 347, 32, 1, 4105, 189
},
// crimsonAltar6
{
    4878, 4110, 189, 9, 36864, 478, 8, 4096, 478, 4097, 189, 9, 4097, 478,
    4097, 189, 6, 36864, 478, 8, 4096, 478, 4096, 208, 4097, 478, 4097, 189, 3,
    4096, 93, 0, 162, 4096, 93, 0, 180, 4096, 93, 0, 198, 4097, 478, 4096, 208,
    4097, 478, 4097, 189, 3, 36864, 478, 8, 4096, 478, 4096, 208, 4097, 478,
    4096, 208, 4097, 478, 4097, 189, 3, 4097, 478, 4096, 208, 4097, 478, 4096,
    208, 4097, 478, 4097, 189, 2, 4096, 208, 4097, 478, 4096, 208, 4097, 478,
    4096, 208, 4097, 478, 4097, 189, 4096, 26, 54, 0, 4096, 26, 54, 18, 4096,
    347, 4096, 208, 4097, 478, 4096, 208, 4097, 478, 4096, 208, 4097, 478,
    4097, 189, 4096, 26, 72, 0, 4096, 26, 72, 18, 4096, 347, 4096, 208, 4097,
    478, 4096, 208, 4097, 478, 4096, 208, 4097, 478, 4097, 189, 4096, 26, 90,
    0, 4096, 26, 90, 18, 4096, 347, 4096, 208, 4097, 478, 4096, 208, 4097, 478,
    4096, 208, 4097, 478, 4097, 189, 2, 4096, 208, 4097, 478, 4096, 208, 4097,
    478, 4096, 208, 4097, 478, 4097, 189, 3, 4097, 478, 4096, 208, 4097, 478,
    4096, 208, 4097, 478, 4097, 189, 3, 36864, 478, 8, 4096, 478, 4096, 208,
    4097, 478, 4096, 208, 4097, 478, 4097, 189, 3, 4096, 93, 0, 162, 4096, 93,
    0, 180, 4096, 93, 0, 198, 4097, 478, 4096, 208, 4097, 478, 4097, 189, 6,
    36864, 478, 8, 4096, 478, 4096, 208, 4097, 478, 4097, 189, 9, 4097, 478,
    4097, 189, 9, 36864, 478, 8, 4096, 478, 4110, 189
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getAltar(int altarId, const std::vector<bool> &framedTiles)
{
    return {altarData[altarId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Altars.h`
```
#ifndef ALTARS_H
#define ALTARS_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto corruptAltars = std::views::iota(0, 6);
inline auto crimsonAltars = std::views::iota(6, 12);

TileBuffer getAltar(int altarId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // ALTARS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Balloons.cpp`
```
#include "structures/data/Balloons.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> balloonData{
// balloon1
{
    1287, 0, 4099, 446, 1, 4100, 446, 36864, 446, 40, 36864, 446, 24, 4107,
    446, 36864, 446, 32, 36864, 446, 16, 0, 4099, 446, 1
},
// balloon2
{
    1289, 0, 4100, 446, 2, 4102, 446, 36864, 446, 24, 4112, 446, 36864, 446,
    16, 4096, 446, 0, 4100, 446, 2
},
// balloon3
{
    1287, 0, 4099, 446, 1, 4101, 446, 36864, 446, 24, 4108, 446, 36864, 446,
    16, 0, 4099, 446, 1
},
// balloon4
{
    1803, 1, 4099, 446, 5, 4102, 446, 2, 4104, 446, 36864, 446, 24, 4116, 446,
    36864, 446, 16, 4096, 446, 0, 4102, 446, 4, 4099, 446, 4
},
// balloon5
{
    1802, 0, 4100, 446, 3, 4103, 446, 1, 4104, 446, 36864, 446, 24, 4114, 446,
    36864, 446, 16, 4103, 446, 2, 4100, 446, 3
},
// balloon6
{
    2316, 1, 4100, 446, 5, 4103, 446, 2, 4105, 446, 1, 4105, 446, 36864, 446,
    24, 4118, 446, 36864, 446, 16, 4106, 446, 2, 4103, 446, 4, 4100, 446, 4
},
// balloon7
{
    2317, 1, 4099, 446, 7, 4102, 446, 4, 4105, 446, 2, 4105, 446, 36864, 446,
    40, 36864, 446, 24, 4119, 446, 36864, 446, 32, 36864, 446, 16, 4106, 446,
    3, 4102, 446, 6, 4099, 446, 6
},
// balloon8
{
    2316, 1, 4099, 446, 6, 4102, 446, 3, 4105, 446, 1, 4106, 446, 36864, 446,
    24, 4118, 446, 36864, 446, 16, 4105, 446, 2, 4102, 446, 5, 4099, 446, 5
},
// balloon9
{
    2832, 2, 4100, 446, 9, 4103, 446, 6, 4105, 446, 5, 4107, 446, 2, 36864,
    446, 8, 4108, 446, 36864, 446, 24, 4096, 446, 36864, 446, 8, 4110, 446,
    36864, 446, 8, 4108, 446, 36864, 446, 16, 4096, 446, 0, 4107, 446, 3, 4105,
    446, 6, 4103, 446, 8, 4100, 446, 7
},
// balloon10
{
    2317, 1, 4100, 446, 6, 4103, 446, 3, 4106, 446, 1, 4106, 446, 36864, 446,
    40, 36864, 446, 24, 4119, 446, 36864, 446, 32, 36864, 446, 16, 4106, 446,
    2, 4103, 446, 5, 4100, 446, 5
},
// balloon11
{
    2832, 2, 4101, 446, 8, 4104, 446, 5, 4107, 446, 3, 4108, 446, 1, 36864,
    446, 8, 4108, 446, 36864, 446, 40, 36864, 446, 24, 36864, 446, 8, 4110,
    446, 36864, 446, 8, 4108, 446, 36864, 446, 32, 36864, 446, 16, 0, 4108,
    446, 2, 4107, 446, 4, 4104, 446, 7, 4101, 446, 6
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer
getBalloon(int id, int tileId, int paint, const std::vector<bool> &framedTiles)
{
    TileBuffer data{balloonData[id].data(), framedTiles};
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &tile = data.getTile(i, j);
            if (tile.blockID != TileID::empty) {
                tile.blockID = tileId;
                tile.blockPaint = paint;
            }
        }
    }
    return data;
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Balloons.h`
```
#ifndef BALLOONS_H
#define BALLOONS_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto balloons = std::views::iota(0, 11);

TileBuffer
getBalloon(int id, int tileId, int paint, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // BALLOONS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Boats.cpp`
```
#include "structures/data/Boats.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> boatData{
// frozenBoat1
{
    20514, 12, 20480, 158, 28, 53248, 158, 28, 24, 30, 20482, 158, 28, 30,
    53248, 158, 28, 16, 20482, 158, 28, 53248, 158, 28, 40, 29, 20487, 158, 28,
    53248, 158, 28, 40, 26, 53248, 158, 28, 16, 20484, 158, 28, 4097, 321,
    36864, 321, 40, 28, 53248, 158, 28, 16, 20480, 158, 28, 4098, 321, 36864,
    321, 40, 27, 4096, 213, 53248, 158, 28, 16, 20480, 158, 28, 4099, 321,
    36864, 321, 40, 23, 4099, 213, 61440, 158, 150, 28, 16, 4100, 321, 36864,
    321, 40, 22, 4098, 213, 0, 8192, 150, 4099, 321, 20481, 321, 26, 21, 4098,
    213, 0, 8192, 245, 8192, 150, 4096, 321, 20480, 321, 26, 24576, 42, 7168,
    20482, 321, 26, 53248, 321, 26, 40, 19, 4098, 213, 1, 8192, 245, 8192, 150,
    20481, 321, 26, 24576, 42, 7168, 61440, 321, 42, 7168, 16, 20480, 321, 26,
    4096, 321, 20480, 321, 26, 19, 4098, 213, 1, 8192, 245, 8192, 150, 20480,
    321, 26, 4096, 321, 24577, 42, 7168, 61440, 321, 42, 7168, 16, 4096, 321,
    20480, 321, 26, 53248, 321, 26, 40, 17, 4098, 213, 3, 8192, 150, 4097, 321,
    24578, 42, 7168, 61440, 321, 42, 7168, 16, 4097, 321, 17, 4097, 213, 4,
    8192, 150, 4097, 321, 24579, 42, 7168, 4097, 321, 36864, 321, 40, 15, 4098,
    213, 4, 8192, 150, 4097, 321, 24579, 42, 7168, 61440, 321, 42, 7168, 16,
    4097, 321, 14, 4098, 213, 4, 8192, 245, 8192, 150, 4097, 321, 24580, 42,
    7168, 4097, 321, 13, 4099, 213, 4, 8192, 245, 8192, 150, 4097, 321, 24580,
    42, 7168, 4097, 321, 12, 4099, 213, 5, 8192, 245, 8192, 150, 4097, 321,
    24580, 42, 7168, 61440, 321, 42, 7168, 16, 4096, 321, 36864, 321, 40, 11,
    4098, 213, 7, 8192, 150, 4097, 321, 24581, 42, 7168, 4097, 321, 10, 4099,
    213, 7, 8192, 150, 4097, 321, 24578, 42, 7168, 28672, 105, 216, 0, 42,
    7168, 28672, 105, 216, 18, 42, 7168, 28672, 105, 216, 36, 42, 7168, 4097,
    321, 10, 4098, 213, 8, 8192, 150, 4097, 321, 24578, 42, 7168, 28672, 105,
    234, 0, 42, 7168, 28672, 105, 234, 18, 42, 7168, 28672, 105, 234, 36, 42,
    7168, 4097, 321, 9, 4098, 213, 8, 8192, 245, 8192, 150, 4097, 321, 24581,
    42, 7168, 61440, 321, 42, 7168, 16, 4096, 321, 36864, 321, 40, 8, 4097,
    213, 9, 12288, 213, 245, 8192, 150, 4097, 321, 24579, 42, 7168, 28672, 240,
    432, 54, 42, 7168, 28672, 240, 432, 72, 42, 7168, 28672, 240, 432, 90, 42,
    7168, 4097, 321, 8, 4097, 213, 7, 4097, 213, 12288, 213, 245, 8192, 150,
    4097, 321, 24579, 42, 7168, 28672, 240, 450, 54, 42, 7168, 28672, 240, 450,
    72, 42, 7168, 28672, 240, 450, 90, 42, 7168, 4096, 321, 20480, 321, 26, 8,
    8198, 148, 1, 4098, 213, 0, 8192, 150, 4097, 321, 24579, 42, 7168, 28672,
    240, 468, 54, 42, 7168, 28672, 240, 468, 72, 42, 7168, 28672, 240, 468, 90,
    42, 7168, 20481, 321, 26, 53248, 321, 26, 40, 8, 8197, 148, 0, 4097, 213,
    2, 8192, 150, 4097, 321, 28678, 575, 42, 7196, 4096, 321, 20481, 321, 26,
    8, 8199, 148, 3, 8192, 150, 45056, 321, 149, 16, 4096, 321, 24582, 42,
    7168, 61440, 321, 42, 7168, 16, 4096, 321, 20480, 321, 26, 6, 8193, 148,
    24583, 148, 3328, 2, 28672, 240, 648, 54, 245, 26, 28672, 240, 648, 72,
    150, 26, 28672, 240, 648, 90, 149, 26, 4096, 321, 24582, 42, 7168, 28672,
    178, 36, 0, 42, 7168, 4097, 321, 7, 24584, 148, 3328, 2, 28672, 240, 666,
    54, 245, 26, 28672, 240, 666, 72, 150, 26, 28672, 240, 666, 90, 149, 26,
    4096, 321, 24581, 42, 7168, 28672, 376, 72, 0, 42, 7168, 28672, 376, 72,
    18, 42, 7168, 4097, 321, 7, 24584, 148, 3328, 2, 28672, 240, 684, 54, 245,
    26, 28672, 240, 684, 72, 150, 26, 28672, 240, 684, 90, 149, 26, 4096, 321,
    24581, 42, 7168, 28672, 376, 90, 0, 42, 7168, 28672, 376, 90, 18, 42, 7168,
    4097, 321, 5, 4098, 213, 24576, 148, 3328, 8197, 148, 4, 8192, 150, 45056,
    321, 149, 24, 4096, 321, 24581, 42, 7168, 28673, 331, 42, 7168, 4097, 321,
    5, 4098, 213, 24576, 148, 3328, 8198, 148, 3, 8192, 150, 4097, 321, 24581,
    42, 7168, 28673, 331, 42, 7168, 4097, 321, 4, 4098, 213, 1, 8198, 148, 3,
    8192, 150, 45056, 321, 149, 16, 4096, 321, 24582, 42, 7168, 28672, 331, 42,
    7168, 4097, 321, 4, 4098, 213, 0, 8196, 148, 24579, 148, 3328, 1, 28672,
    240, 648, 54, 245, 13, 28672, 240, 648, 72, 150, 13, 28672, 240, 648, 90,
    149, 13, 4096, 321, 24582, 42, 7168, 28672, 178, 36, 18, 42, 7168, 4097,
    321, 3, 4098, 213, 0, 8194, 148, 24581, 148, 3328, 2, 28672, 240, 666, 54,
    245, 13, 28672, 240, 666, 72, 150, 13, 28672, 240, 666, 90, 149, 13, 4096,
    321, 24580, 42, 7168, 28672, 240, 432, 54, 42, 7168, 28672, 240, 432, 72,
    42, 7168, 28672, 240, 432, 90, 42, 7168, 4097, 321, 3, 4098, 213, 1, 24584,
    148, 3328, 1, 28672, 240, 684, 54, 245, 13, 28672, 240, 684, 72, 150, 13,
    28672, 240, 684, 90, 149, 13, 4096, 321, 24580, 42, 7168, 28672, 240, 450,
    54, 42, 7168, 28672, 240, 450, 72, 42, 7168, 28672, 240, 450, 90, 42, 7168,
    4097, 321, 1, 4099, 213, 1, 24582, 148, 3328, 8193, 148, 24576, 148, 3328,
    2, 8192, 150, 45056, 321, 149, 24, 4096, 321, 24580, 42, 7168, 28672, 240,
    468, 54, 42, 7168, 28672, 240, 468, 72, 42, 7168, 28672, 240, 468, 90, 42,
    7168, 4097, 321, 1, 4098, 213, 2, 24578, 148, 3328, 8198, 148, 2, 8192,
    150, 4097, 321, 28679, 575, 42, 7196, 4097, 321, 0, 4099, 213, 2, 24577,
    148, 3328, 8199, 148, 2, 8192, 150, 45056, 321, 149, 16, 4096, 321, 24576,
    42, 7168, 28672, 242, 0, 792, 42, 7168, 28672, 242, 0, 810, 42, 7168,
    28672, 242, 0, 828, 42, 7168, 28672, 242, 0, 846, 42, 7168, 24578, 42,
    7168, 4097, 321, 0, 4098, 213, 4, 24576, 148, 3328, 8199, 148, 1, 28672,
    240, 648, 54, 245, 26, 28672, 240, 648, 72, 150, 26, 28672, 240, 648, 90,
    149, 26, 4096, 321, 24576, 42, 7168, 28672, 242, 18, 792, 42, 7168, 28672,
    242, 18, 810, 42, 7168, 28672, 242, 18, 828, 42, 7168, 28672, 242, 18, 846,
    42, 7168, 24576, 42, 7168, 28672, 89, 0, 0, 42, 7168, 28672, 89, 0, 18, 42,
    7168, 4097, 321, 4098, 213, 6, 8198, 148, 2, 28672, 240, 666, 54, 245, 26,
    28672, 240, 666, 72, 150, 26, 28672, 240, 666, 90, 149, 26, 4096, 321,
    24576, 42, 7168, 28672, 242, 36, 792, 42, 7168, 28672, 242, 36, 810, 42,
    7168, 28672, 242, 36, 828, 42, 7168, 28672, 242, 36, 846, 42, 7168, 24576,
    42, 7168, 28672, 89, 18, 0, 42, 7168, 28672, 89, 18, 18, 42, 7168, 4097,
    321, 4097, 213, 7, 8194, 148, 24579, 148, 3328, 2, 28672, 240, 684, 54,
    245, 26, 28672, 240, 684, 72, 150, 26, 28672, 240, 684, 90, 149, 26, 4096,
    321, 24576, 42, 7168, 28672, 242, 54, 792, 42, 7168, 28672, 242, 54, 810,
    42, 7168, 28672, 242, 54, 828, 42, 7168, 28672, 242, 54, 846, 42, 7168,
    24576, 42, 7168, 28672, 89, 36, 0, 42, 7168, 28672, 89, 36, 18, 42, 7168,
    4097, 321, 4097, 213, 7, 24582, 148, 3328, 3, 8192, 150, 45056, 321, 149,
    24, 4096, 321, 24576, 42, 7168, 28672, 242, 72, 792, 42, 7168, 28672, 242,
    72, 810, 42, 7168, 28672, 242, 72, 828, 42, 7168, 28672, 242, 72, 846, 42,
    7168, 24578, 42, 7168, 4097, 321, 24585, 43, 7168, 24582, 148, 3328, 24579,
    43, 7168, 8192, 150, 28672, 321, 43, 7168, 4096, 321, 24576, 42, 7168,
    28672, 242, 90, 792, 42, 7168, 28672, 242, 90, 810, 42, 7168, 28672, 242,
    90, 828, 42, 7168, 28672, 242, 90, 846, 42, 7168, 24576, 42, 7168, 28672,
    89, 0, 0, 42, 7168, 28672, 89, 0, 18, 42, 7168, 4097, 321, 4098, 213, 5,
    24578, 148, 3328, 8195, 148, 24576, 148, 3328, 3, 8192, 150, 45056, 321,
    149, 16, 4096, 321, 24581, 42, 7168, 28672, 89, 18, 0, 42, 7168, 28672, 89,
    18, 18, 42, 7168, 4097, 321, 4098, 213, 5, 24577, 148, 3328, 8197, 148, 2,
    28672, 240, 648, 54, 245, 13, 28672, 240, 648, 72, 150, 13, 28672, 240,
    648, 90, 149, 13, 4096, 321, 24581, 42, 7168, 28672, 89, 36, 0, 42, 7168,
    28672, 89, 36, 18, 42, 7168, 4097, 321, 0, 4097, 213, 5, 24576, 148, 3328,
    8198, 148, 2, 28672, 240, 666, 54, 245, 13, 28672, 240, 666, 72, 150, 13,
    28672, 240, 666, 90, 149, 13, 4096, 321, 24583, 42, 7168, 4097, 321, 0,
    4098, 213, 4, 24576, 148, 3328, 8198, 148, 2, 28672, 240, 684, 54, 245, 13,
    28672, 240, 684, 72, 150, 13, 28672, 240, 684, 90, 149, 13, 4096, 321,
    24581, 42, 7168, 28672, 89, 0, 0, 42, 7168, 28672, 89, 0, 18, 42, 7168,
    4097, 321, 1, 4098, 213, 3, 8200, 148, 2, 8192, 150, 45056, 321, 149, 24,
    4096, 321, 24581, 42, 7168, 28672, 89, 18, 0, 42, 7168, 28672, 89, 18, 18,
    42, 7168, 4097, 321, 1, 4098, 213, 4, 8194, 148, 24580, 148, 3328, 2, 8192,
    150, 20481, 321, 26, 24581, 42, 7168, 28672, 89, 36, 0, 42, 7168, 28672,
    89, 36, 18, 42, 7168, 4097, 321, 2, 4098, 213, 2, 8193, 148, 24582, 148,
    3328, 2, 8192, 150, 61440, 321, 149, 26, 16, 20480, 321, 26, 24583, 42,
    7168, 4097, 321, 3, 4098, 213, 0, 8192, 148, 24584, 148, 3328, 1, 28672,
    240, 648, 54, 245, 26, 28672, 240, 648, 72, 150, 26, 28672, 240, 648, 90,
    149, 26, 4096, 321, 24582, 42, 7168, 61440, 321, 42, 7168, 24, 4097, 321,
    4, 4098, 213, 1, 24578, 148, 3328, 8194, 148, 24577, 148, 3328, 1, 28672,
    240, 666, 54, 245, 26, 28672, 240, 666, 72, 150, 26, 28672, 240, 666, 90,
    149, 26, 4096, 321, 28678, 575, 42, 7196, 4096, 321, 20480, 321, 26, 4096,
    321, 5, 4097, 213, 1, 24577, 148, 3328, 8197, 148, 1, 28672, 240, 684, 54,
    245, 26, 28672, 240, 684, 72, 150, 26, 28672, 240, 684, 90, 149, 26, 4096,
    321, 24579, 42, 7168, 28672, 105, 684, 0, 42, 7168, 28672, 105, 684, 18,
    42, 7168, 28672, 105, 684, 36, 42, 7168, 20481, 321, 26, 4096, 321, 5,
    4097, 213, 1, 24576, 148, 3328, 8198, 148, 2, 8192, 150, 45056, 321, 149,
    24, 4096, 321, 24579, 42, 7168, 28672, 105, 702, 0, 42, 7168, 28672, 105,
    702, 18, 42, 7168, 28672, 105, 702, 36, 42, 7168, 20482, 321, 26, 6, 4097,
    213, 0, 8199, 148, 2, 8192, 150, 4097, 321, 24582, 42, 7168, 4096, 321,
    20481, 321, 26, 6, 4097, 213, 8200, 148, 2, 8192, 150, 4097, 321, 24582,
    42, 7168, 4096, 321, 20480, 321, 26, 4096, 321, 7, 4096, 213, 0, 8199, 148,
    1, 8192, 245, 8192, 150, 4096, 321, 45056, 321, 149, 32, 24582, 42, 7168,
    4096, 321, 20480, 321, 26, 4096, 321, 9, 8194, 148, 24580, 148, 3328, 1,
    8192, 245, 8192, 150, 4096, 387, 0, 0, 8192, 149, 24582, 42, 7168, 4096,
    321, 20480, 321, 26, 36864, 321, 32, 8, 24583, 148, 3328, 2, 8192, 245,
    8192, 150, 4096, 387, 18, 0, 8192, 149, 24582, 42, 7168, 4096, 321, 20480,
    321, 26, 10, 24579, 148, 3328, 1, 8192, 148, 24576, 148, 3328, 4097, 213,
    0, 8192, 150, 4096, 321, 45056, 321, 149, 40, 24582, 42, 7168, 4096, 321,
    20480, 321, 26, 10, 4097, 213, 2, 8193, 148, 0, 4097, 213, 0, 8192, 150,
    4097, 321, 24582, 42, 7168, 4097, 321, 10, 4098, 213, 5, 4097, 213, 8192,
    150, 4097, 321, 24580, 42, 7168, 28672, 21, 396, 0, 42, 7168, 28672, 21,
    396, 18, 42, 7168, 4097, 321, 10, 4098, 213, 6, 12288, 213, 245, 8192, 150,
    4097, 321, 24580, 42, 7168, 28672, 21, 414, 0, 42, 7168, 28672, 21, 414,
    18, 42, 7168, 4097, 321, 11, 4097, 213, 6, 8192, 245, 8192, 150, 4097, 321,
    28678, 575, 42, 7196, 4097, 321, 11, 4098, 213, 5, 8192, 245, 8192, 150,
    4097, 321, 24582, 42, 7168, 4097, 321, 12, 4098, 213, 5, 8192, 150, 4097,
    321, 24581, 42, 7168, 61440, 321, 42, 7168, 24, 4096, 321, 36864, 321, 32,
    13, 4097, 213, 5, 8192, 150, 20480, 321, 26, 4096, 321, 24581, 42, 7168,
    4097, 321, 14, 4098, 213, 3, 4096, 376, 648, 0, 12288, 376, 648, 18, 150,
    20481, 321, 26, 24581, 42, 7168, 4097, 321, 15, 4097, 213, 3, 12288, 376,
    666, 0, 245, 12288, 376, 666, 18, 150, 20481, 321, 26, 24580, 42, 7168,
    61440, 321, 42, 7168, 24, 4096, 321, 36864, 321, 32, 15, 4098, 213, 2,
    8192, 245, 8192, 150, 20481, 321, 26, 24580, 42, 7168, 20481, 321, 26, 17,
    4098, 213, 1, 8192, 245, 8192, 150, 20480, 321, 26, 4096, 321, 24579, 42,
    7168, 61440, 321, 42, 7194, 24, 20480, 321, 26, 53248, 321, 26, 32, 18,
    4097, 213, 1, 4096, 376, 648, 0, 12288, 376, 648, 18, 150, 4097, 321,
    24578, 42, 7168, 61440, 321, 42, 7168, 24, 4096, 321, 53248, 321, 26, 32,
    20, 4097, 213, 0, 4096, 376, 666, 0, 12288, 376, 666, 18, 150, 4097, 321,
    24578, 42, 7168, 4097, 321, 21, 4097, 213, 1, 8192, 150, 4097, 321, 24577,
    42, 7168, 61440, 321, 42, 7168, 24, 4096, 321, 36864, 321, 32, 22, 4097,
    213, 8192, 245, 8192, 150, 4097, 321, 24576, 42, 7168, 61440, 321, 42,
    7168, 24, 4096, 321, 36864, 321, 32, 24, 4096, 213, 12288, 213, 245, 8192,
    150, 4099, 321, 36864, 321, 32, 26, 12288, 213, 245, 8192, 150, 4097, 321,
    36864, 321, 32, 28, 4098, 321, 36864, 321, 32, 29, 4096, 321, 12
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getBoat(Boat boatId, const std::vector<bool> &framedTiles)
{
    return {boatData[static_cast<int>(boatId)].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Boats.h`
```
#ifndef BOATS_H
#define BOATS_H

#include "TileBuffer.h"

namespace Data
{

enum class Boat { frozen = 0 };

TileBuffer getBoat(Boat boatId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // BOATS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Bridges.cpp`
```
#include "structures/data/Bridges.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> bridgeData{
// underworldBridge1
{
    12299, 0, 8193, 245, 4097, 75, 6, 8193, 245, 4097, 75, 6, 8193, 245, 4097,
    75, 5, 8194, 245, 4097, 75, 6, 8193, 245, 4097, 75, 5, 4096, 93, 0, 1242,
    12288, 93, 0, 1260, 245, 12288, 93, 0, 1278, 245, 4097, 75, 6, 8193, 245,
    4097, 75, 5, 8194, 245, 4097, 75, 6, 8193, 245, 4097, 75, 36864, 75, 40, 5,
    8193, 245, 4098, 75, 5, 8193, 245, 4098, 75, 4, 8194, 245, 4098, 75, 5,
    8193, 245, 4098, 75, 5, 8193, 245, 4098, 75, 36864, 75, 40, 4, 8193, 245,
    4099, 75, 3, 8194, 245, 4099, 75, 4, 8193, 245, 4099, 75, 36864, 75, 40, 2,
    4096, 93, 0, 1242, 12288, 93, 0, 1260, 245, 12288, 93, 0, 1278, 245, 4100,
    75, 3, 8193, 245, 4100, 75, 36864, 75, 40, 1, 8194, 245, 4101, 75, 36864,
    75, 40, 1, 8193, 245, 4103, 75, 0, 8193, 245, 4103, 75, 0, 8193, 245, 4099,
    75, 45056, 546, 145, 24, 12288, 546, 145, 45056, 546, 145, 40, 4096, 177,
    8194, 245, 4099, 75, 12288, 546, 145, 12288, 546, 73, 12288, 546, 145,
    8192, 145, 0, 8193, 245, 4099, 75, 45056, 546, 145, 16, 12288, 546, 145,
    45056, 546, 145, 32, 4096, 177, 0, 8193, 245, 4103, 75, 0, 8193, 245, 4103,
    75, 8194, 245, 4101, 75, 36864, 75, 32, 1, 8193, 245, 4100, 75, 36864, 75,
    32, 1, 4096, 93, 0, 1242, 12288, 93, 0, 1260, 245, 12288, 93, 0, 1278, 245,
    4100, 75, 3, 8193, 245, 4099, 75, 36864, 75, 32, 2, 8194, 245, 4099, 75, 4,
    8193, 245, 4099, 75, 4, 8193, 245, 4098, 75, 36864, 75, 32, 4, 8193, 245,
    4098, 75, 4, 8194, 245, 4098, 75, 5, 8193, 245, 4098, 75, 5, 8193, 245,
    4098, 75, 5, 8193, 245, 4097, 75, 36864, 75, 32, 4, 8194, 245, 4097, 75, 6,
    8193, 245, 4097, 75, 5, 4096, 93, 0, 1242, 12288, 93, 0, 1260, 245, 12288,
    93, 0, 1278, 245, 4097, 75, 6, 8193, 245, 4097, 75, 5, 8194, 245, 4097, 75,
    6, 8193, 245, 4097, 75, 6, 8193, 245, 4097, 75, 6, 8193, 245, 4097, 75, 5,
    8194, 245, 4097, 75, 5
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getBridge(const std::vector<bool> &framedTiles)
{
    return {bridgeData[0].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Bridges.h`
```
#ifndef BRIDGES_H
#define BRIDGES_H

#include "TileBuffer.h"

namespace Data
{

TileBuffer getBridge(const std::vector<bool> &framedTiles);

} // namespace Data

#endif // BRIDGES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Buildings.cpp`
```
#include "structures/data/Buildings.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> buildingData{
// desertTomb1
{
    13340, 15, 53248, 274, 14, 24, 20490, 274, 14, 15, 20491, 274, 14, 7,
    53248, 274, 14, 24, 20498, 274, 14, 7, 20499, 274, 14, 53248, 274, 14, 24,
    20521, 274, 14, 28681, 274, 34, 3598, 20497, 274, 14, 28672, 274, 34, 3598,
    24583, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28679, 274, 34,
    3598, 61440, 274, 34, 3598, 32, 24583, 34, 3584, 28672, 274, 34, 3598,
    20489, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 28673, 239, 108, 0,
    34, 3584, 28672, 19, 54, 756, 34, 3584, 28672, 376, 720, 0, 34, 3584,
    28672, 376, 720, 18, 34, 3584, 28672, 151, 34, 3598, 28672, 91, 108, 0, 34,
    3584, 28672, 91, 108, 18, 34, 3584, 28672, 91, 108, 36, 34, 3584, 24581,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28675, 274, 34, 3598,
    61440, 274, 34, 3598, 32, 24576, 34, 3584, 28673, 239, 108, 0, 34, 3584,
    28672, 19, 18, 756, 34, 3584, 28672, 376, 738, 0, 34, 3584, 28672, 376,
    738, 18, 34, 3584, 28672, 151, 34, 3598, 24584, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 24582, 34, 3584, 28672, 105,
    396, 216, 34, 3584, 28672, 105, 396, 234, 34, 3584, 61440, 105, 396, 252,
    34, 3584, 64, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584, 28672, 274,
    34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 91, 90, 0, 34, 3584,
    28672, 91, 90, 18, 34, 3584, 28672, 91, 90, 36, 34, 3584, 24579, 34, 3584,
    28672, 105, 414, 216, 34, 3584, 28672, 105, 414, 234, 34, 3584, 28672, 105,
    414, 252, 34, 3584, 61440, 151, 34, 3598, 64, 24583, 34, 3584, 61440, 19,
    144, 756, 34, 3584, 24, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274,
    34, 3598, 24585, 34, 3584, 61440, 151, 34, 3598, 64, 24582, 34, 3584,
    61440, 19, 144, 756, 34, 3584, 24, 24576, 34, 3584, 28672, 274, 34, 3598,
    20485, 274, 14, 28672, 274, 34, 3598, 24584, 34, 3584, 61440, 135, 0, 54,
    34, 3584, 64, 61440, 151, 34, 3598, 64, 24581, 34, 3584, 61440, 19, 144,
    756, 34, 3584, 24, 24577, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14,
    28672, 274, 34, 3598, 24585, 34, 3584, 61440, 19, 54, 756, 34, 3584, 64,
    24580, 34, 3584, 61440, 19, 144, 756, 34, 3584, 24, 24578, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584,
    61440, 19, 0, 756, 34, 3584, 64, 24579, 34, 3584, 61440, 19, 144, 756, 34,
    3584, 24, 24579, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 24585, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64, 24578, 34,
    3584, 61440, 19, 144, 756, 34, 3584, 24, 24577, 34, 3584, 28672, 506, 0, 0,
    34, 3584, 28672, 506, 0, 18, 34, 3584, 28672, 506, 0, 36, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584,
    61440, 19, 0, 756, 34, 3584, 64, 24577, 34, 3584, 61440, 19, 144, 756, 34,
    3584, 24, 24578, 34, 3584, 28672, 506, 18, 0, 34, 3584, 28672, 506, 18, 18,
    34, 3584, 28672, 506, 18, 36, 34, 3584, 28672, 274, 34, 3598, 20485, 274,
    14, 28672, 274, 34, 3598, 24585, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64,
    24576, 34, 3584, 61440, 19, 144, 756, 34, 3584, 24, 24582, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34, 3586,
    28672, 34, 162, 378, 34, 3584, 28672, 34, 162, 396, 34, 3584, 28672, 34,
    162, 414, 34, 3584, 24581, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64,
    61440, 19, 144, 756, 34, 3584, 24, 24583, 34, 3584, 28672, 274, 34, 3598,
    20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34, 180,
    378, 34, 3584, 28672, 34, 180, 396, 34, 3584, 28672, 34, 180, 414, 34,
    3584, 24581, 34, 3584, 61440, 19, 450, 756, 34, 3584, 88, 24584, 34, 3584,
    28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34,
    3586, 28672, 34, 198, 378, 34, 3584, 28672, 34, 198, 396, 34, 3584, 28672,
    34, 198, 414, 34, 3584, 24581, 34, 3584, 61440, 151, 34, 3598, 64, 28680,
    577, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24585, 34, 3584, 61440, 151, 34, 3598, 64, 28672, 91, 54, 0, 34, 3584,
    28672, 91, 54, 18, 34, 3584, 28672, 91, 54, 36, 34, 3584, 24578, 34, 3584,
    28672, 93, 18, 2052, 34, 3584, 28672, 93, 18, 2070, 34, 3584, 61440, 93,
    18, 2088, 34, 3584, 64, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672,
    274, 34, 3598, 24577, 34, 3584, 8193, 34, 24578, 34, 3584, 8192, 34, 24577,
    34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 61440, 274, 34, 3598,
    64, 20485, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 8192, 34, 24577,
    34, 3584, 8192, 34, 24577, 34, 3584, 8192, 34, 24577, 34, 3584, 61440, 151,
    34, 3598, 64, 24582, 34, 3584, 28672, 79, 72, 1368, 34, 3584, 28672, 79,
    72, 1386, 34, 3584, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274,
    34, 3598, 8192, 34, 24579, 34, 3584, 8196, 34, 61440, 151, 34, 3598, 64,
    24582, 34, 3584, 28672, 79, 90, 1368, 34, 3584, 28672, 79, 90, 1386, 34,
    3584, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 8192,
    34, 24579, 34, 3584, 8196, 34, 61440, 151, 34, 3598, 64, 24582, 34, 3584,
    28672, 79, 108, 1368, 34, 3584, 28672, 79, 108, 1386, 34, 3584, 61440, 274,
    34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 8192,
    34, 24577, 34, 3584, 8192, 34, 24577, 34, 3584, 8192, 34, 24577, 34, 3584,
    61440, 151, 34, 3598, 64, 24582, 34, 3584, 28672, 79, 126, 1368, 34, 3584,
    28672, 79, 126, 1386, 34, 3584, 61440, 274, 34, 3598, 64, 20485, 274, 14,
    28672, 274, 34, 3598, 24577, 34, 3584, 8193, 34, 24578, 34, 3584, 8192, 34,
    24577, 34, 3584, 61440, 151, 34, 3598, 64, 24583, 34, 3584, 61440, 135, 0,
    126, 34, 3612, 64, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274,
    34, 3598, 24584, 34, 3584, 61440, 135, 0, 54, 34, 3584, 64, 61440, 151, 34,
    3598, 64, 28672, 91, 54, 0, 34, 3584, 28672, 91, 54, 18, 34, 3584, 28672,
    91, 54, 36, 34, 3584, 24578, 34, 3584, 28672, 93, 18, 2052, 34, 3584,
    28672, 93, 18, 2070, 34, 3584, 61440, 93, 18, 2088, 34, 3584, 64, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34, 3586,
    28672, 34, 162, 378, 34, 3584, 28672, 34, 162, 396, 34, 3584, 28672, 34,
    162, 414, 34, 3584, 24581, 34, 3584, 61440, 151, 34, 3598, 64, 28680, 577,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    28672, 45, 34, 3586, 28672, 34, 180, 378, 34, 3584, 28672, 34, 180, 396,
    34, 3584, 28672, 34, 180, 414, 34, 3584, 24581, 34, 3584, 61440, 151, 34,
    3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 28672, 45, 34, 3586, 28672, 34, 198, 378, 34, 3584, 28672,
    34, 198, 396, 34, 3584, 28672, 34, 198, 414, 34, 3584, 24581, 34, 3584,
    61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598, 20485,
    274, 14, 28672, 274, 34, 3598, 24584, 34, 3584, 28672, 332, 34, 3584,
    61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598, 20485,
    274, 14, 28672, 274, 34, 3598, 24584, 34, 3584, 28672, 332, 34, 3584,
    61440, 151, 34, 3598, 64, 24581, 34, 3584, 28672, 506, 36, 0, 34, 3584,
    28672, 506, 36, 18, 34, 3584, 28672, 506, 36, 36, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28673, 332,
    34, 3584, 61440, 151, 34, 3598, 64, 24581, 34, 3584, 28672, 506, 54, 0, 34,
    3584, 28672, 506, 54, 18, 34, 3584, 28672, 506, 54, 36, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584,
    28673, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584,
    28672, 467, 360, 0, 34, 3584, 28672, 467, 360, 18, 34, 3584, 61440, 151,
    34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 24583, 34, 3584, 28672, 467, 378, 0, 34, 3584, 28672, 467,
    378, 18, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274,
    34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28673,
    332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 91, 90, 0, 34, 3584,
    28672, 91, 90, 18, 34, 3584, 28672, 91, 90, 36, 34, 3584, 24580, 34, 3584,
    28673, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24584, 34, 3584,
    28672, 332, 34, 3584, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584,
    28672, 274, 34, 3598, 20485, 274, 14, 28675, 274, 34, 3598, 61440, 274, 34,
    3598, 40, 24578, 34, 3584, 28672, 105, 396, 54, 34, 3584, 28672, 105, 396,
    72, 34, 3584, 28672, 105, 396, 90, 34, 3584, 61440, 151, 34, 3598, 64,
    24584, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28672, 274, 34,
    3598, 24578, 34, 3584, 28672, 105, 414, 54, 34, 3584, 28672, 105, 414, 72,
    34, 3584, 61440, 105, 414, 90, 34, 3584, 64, 61440, 151, 34, 3598, 64,
    28672, 91, 108, 0, 34, 3584, 28672, 91, 108, 18, 34, 3584, 28672, 91, 108,
    36, 34, 3584, 24581, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28679,
    274, 34, 3598, 61440, 274, 34, 3598, 40, 24583, 34, 3584, 28672, 274, 34,
    3598, 20497, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28672, 274,
    34, 3598, 20497, 274, 14, 28681, 274, 34, 3598, 20482, 274, 14, 53248, 274,
    14, 16, 20506, 274, 14, 7, 20499, 274, 14, 7, 53248, 274, 14, 16, 20498,
    274, 14, 15, 20491, 274, 14, 15, 53248, 274, 14, 16, 20490, 274, 14
},
// desertTomb2
{
    13340, 15, 53248, 274, 14, 24, 20490, 274, 14, 15, 20491, 274, 14, 7,
    53248, 274, 14, 24, 20498, 274, 14, 7, 20499, 274, 14, 53248, 274, 14, 24,
    20521, 274, 14, 28681, 274, 34, 3598, 20497, 274, 14, 28672, 274, 34, 3598,
    24583, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28679, 274, 34,
    3598, 61440, 274, 34, 3598, 32, 24583, 34, 3584, 28672, 274, 34, 3598,
    20489, 274, 14, 28672, 274, 34, 3598, 24578, 34, 3584, 28672, 105, 396,
    216, 34, 3584, 28672, 105, 396, 234, 34, 3584, 61440, 105, 396, 252, 34,
    3584, 64, 61440, 151, 34, 3598, 64, 28672, 91, 108, 0, 34, 3584, 28672, 91,
    108, 18, 34, 3584, 28672, 91, 108, 36, 34, 3584, 24581, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28675, 274, 34, 3598, 61440, 274, 34, 3598,
    32, 24578, 34, 3584, 28672, 105, 414, 216, 34, 3584, 28672, 105, 414, 234,
    34, 3584, 28672, 105, 414, 252, 34, 3584, 61440, 151, 34, 3598, 64, 24584,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24584, 34, 3584, 28672, 332, 34, 3584, 61440, 151, 34, 3598, 64, 28680,
    577, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    28672, 91, 90, 0, 34, 3584, 28672, 91, 90, 18, 34, 3584, 28672, 91, 90, 36,
    34, 3584, 24580, 34, 3584, 28673, 332, 34, 3584, 61440, 151, 34, 3598, 64,
    24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 24583, 34, 3584, 28673, 332, 34, 3584, 61440, 151, 34, 3598, 64,
    24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 24583, 34, 3584, 28672, 467, 360, 0, 34, 3584, 28672, 467, 360, 18,
    34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598,
    20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28672, 467, 378, 0,
    34, 3584, 28672, 467, 378, 18, 34, 3584, 61440, 151, 34, 3598, 64, 24584,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24583, 34, 3584, 28673, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34,
    3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583,
    34, 3584, 28673, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24581, 34, 3584,
    28672, 506, 0, 0, 34, 3584, 28672, 506, 0, 18, 34, 3584, 28672, 506, 0, 36,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24584, 34, 3584, 28672, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24581, 34,
    3584, 28672, 506, 18, 0, 34, 3584, 28672, 506, 18, 18, 34, 3584, 28672,
    506, 18, 36, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274,
    34, 3598, 24584, 34, 3584, 28672, 332, 34, 3584, 61440, 151, 34, 3598, 64,
    24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 28672, 45, 34, 3586, 28672, 34, 162, 378, 34, 3584, 28672, 34, 162,
    396, 34, 3584, 28672, 34, 162, 414, 34, 3584, 24581, 34, 3584, 61440, 151,
    34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 28672, 45, 34, 3586, 28672, 34, 180, 378, 34, 3584, 28672,
    34, 180, 396, 34, 3584, 28672, 34, 180, 414, 34, 3584, 24581, 34, 3584,
    61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598, 20485,
    274, 14, 28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34, 198, 378,
    34, 3584, 28672, 34, 198, 396, 34, 3584, 28672, 34, 198, 414, 34, 3584,
    24581, 34, 3584, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24584, 34, 3584,
    61440, 135, 0, 54, 34, 3584, 64, 61440, 151, 34, 3598, 64, 28672, 91, 54,
    0, 34, 3584, 28672, 91, 54, 18, 34, 3584, 28672, 91, 54, 36, 34, 3584,
    24578, 34, 3584, 28672, 93, 18, 2052, 34, 3584, 28672, 93, 18, 2070, 34,
    3584, 61440, 93, 18, 2088, 34, 3584, 64, 28672, 274, 34, 3598, 20485, 274,
    14, 28672, 274, 34, 3598, 24577, 34, 3584, 8193, 34, 24578, 34, 3584, 8192,
    34, 24577, 34, 3584, 61440, 151, 34, 3598, 64, 24583, 34, 3584, 61440, 135,
    0, 126, 34, 3612, 64, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274,
    34, 3598, 24576, 34, 3584, 8192, 34, 24577, 34, 3584, 8192, 34, 24577, 34,
    3584, 8192, 34, 24577, 34, 3584, 61440, 151, 34, 3598, 64, 24582, 34, 3584,
    28672, 79, 0, 1368, 34, 3584, 28672, 79, 0, 1386, 34, 3584, 61440, 274, 34,
    3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 8192, 34, 24579, 34, 3584,
    8196, 34, 61440, 151, 34, 3598, 64, 24582, 34, 3584, 28672, 79, 18, 1368,
    34, 3584, 28672, 79, 18, 1386, 34, 3584, 61440, 274, 34, 3598, 64, 20485,
    274, 14, 28672, 274, 34, 3598, 8192, 34, 24579, 34, 3584, 8196, 34, 61440,
    151, 34, 3598, 64, 24582, 34, 3584, 28672, 79, 36, 1368, 34, 3584, 28672,
    79, 36, 1386, 34, 3584, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672,
    274, 34, 3598, 24576, 34, 3584, 8192, 34, 24577, 34, 3584, 8192, 34, 24577,
    34, 3584, 8192, 34, 24577, 34, 3584, 61440, 151, 34, 3598, 64, 24582, 34,
    3584, 28672, 79, 54, 1368, 34, 3584, 28672, 79, 54, 1386, 34, 3584, 61440,
    274, 34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 24577, 34, 3584,
    8193, 34, 24578, 34, 3584, 8192, 34, 24577, 34, 3584, 61440, 151, 34, 3598,
    64, 24584, 34, 3584, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274,
    34, 3598, 24585, 34, 3584, 61440, 151, 34, 3598, 64, 28672, 91, 54, 0, 34,
    3584, 28672, 91, 54, 18, 34, 3584, 28672, 91, 54, 36, 34, 3584, 24578, 34,
    3584, 28672, 93, 18, 2052, 34, 3584, 28672, 93, 18, 2070, 34, 3584, 61440,
    93, 18, 2088, 34, 3584, 64, 61440, 274, 34, 3598, 64, 20485, 274, 14,
    28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34, 162, 378, 34, 3584,
    28672, 34, 162, 396, 34, 3584, 28672, 34, 162, 414, 34, 3584, 24581, 34,
    3584, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584, 28672, 274, 34, 3598,
    20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34, 180,
    378, 34, 3584, 28672, 34, 180, 396, 34, 3584, 28672, 34, 180, 414, 34,
    3584, 24581, 34, 3584, 61440, 19, 468, 756, 34, 3584, 80, 24584, 34, 3584,
    28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34,
    3586, 28672, 34, 198, 378, 34, 3584, 28672, 34, 198, 396, 34, 3584, 28672,
    34, 198, 414, 34, 3584, 24581, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64,
    61440, 19, 180, 756, 34, 3584, 16, 24583, 34, 3584, 28672, 274, 34, 3598,
    20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584, 61440, 19, 0, 756,
    34, 3584, 64, 24576, 34, 3584, 61440, 19, 180, 756, 34, 3584, 16, 24582,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24585, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64, 24577, 34, 3584, 61440,
    19, 180, 756, 34, 3584, 16, 24578, 34, 3584, 28672, 506, 36, 0, 34, 3584,
    28672, 506, 36, 18, 34, 3584, 28672, 506, 36, 36, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584, 61440, 19, 0,
    756, 34, 3584, 64, 24578, 34, 3584, 61440, 19, 180, 756, 34, 3584, 16,
    24577, 34, 3584, 28672, 506, 54, 0, 34, 3584, 28672, 506, 54, 18, 34, 3584,
    28672, 506, 54, 36, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 24585, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64, 24579, 34,
    3584, 61440, 19, 180, 756, 34, 3584, 16, 24579, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584, 61440, 19, 72,
    756, 34, 3584, 64, 24580, 34, 3584, 61440, 19, 180, 756, 34, 3584, 16,
    24578, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 24584, 34, 3584, 61440, 135, 0, 54, 34, 3584, 64, 61440, 151, 34,
    3598, 64, 24581, 34, 3584, 61440, 19, 180, 756, 34, 3584, 16, 24577, 34,
    3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585,
    34, 3584, 61440, 151, 34, 3598, 64, 24582, 34, 3584, 61440, 19, 180, 756,
    34, 3584, 16, 24576, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 28672, 91, 90, 0, 34, 3584, 28672, 91, 90, 18, 34, 3584,
    28672, 91, 90, 36, 34, 3584, 24579, 34, 3584, 28672, 105, 396, 54, 34,
    3584, 28672, 105, 396, 72, 34, 3584, 28672, 105, 396, 90, 34, 3584, 61440,
    151, 34, 3598, 64, 24583, 34, 3584, 61440, 19, 180, 756, 34, 3584, 16,
    28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24582, 34,
    3584, 28672, 105, 414, 54, 34, 3584, 28672, 105, 414, 72, 34, 3584, 61440,
    105, 414, 90, 34, 3584, 64, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584,
    28672, 274, 34, 3598, 20485, 274, 14, 28675, 274, 34, 3598, 61440, 274, 34,
    3598, 40, 24576, 34, 3584, 28673, 239, 108, 0, 34, 3584, 28672, 19, 36,
    756, 34, 3584, 28672, 376, 720, 0, 34, 3584, 28672, 376, 720, 18, 34, 3584,
    28672, 151, 34, 3598, 24584, 34, 3584, 28672, 274, 34, 3598, 20489, 274,
    14, 28672, 274, 34, 3598, 24576, 34, 3584, 28673, 239, 108, 0, 34, 3584,
    28672, 19, 72, 756, 34, 3584, 28672, 376, 738, 0, 34, 3584, 28672, 376,
    738, 18, 34, 3584, 28672, 151, 34, 3598, 28672, 91, 108, 0, 34, 3584,
    28672, 91, 108, 18, 34, 3584, 28672, 91, 108, 36, 34, 3584, 24581, 34,
    3584, 28672, 274, 34, 3598, 20489, 274, 14, 28679, 274, 34, 3598, 61440,
    274, 34, 3598, 40, 24583, 34, 3584, 28672, 274, 34, 3598, 20497, 274, 14,
    28672, 274, 34, 3598, 24583, 34, 3584, 28672, 274, 34, 3598, 20497, 274,
    14, 28681, 274, 34, 3598, 20482, 274, 14, 53248, 274, 14, 16, 20506, 274,
    14, 7, 20499, 274, 14, 7, 53248, 274, 14, 16, 20498, 274, 14, 15, 20491,
    274, 14, 15, 53248, 274, 14, 16, 20490, 274, 14
},
// desertTomb3
{
    13340, 15, 53248, 274, 14, 24, 20490, 274, 14, 15, 20491, 274, 14, 7,
    53248, 274, 14, 24, 20498, 274, 14, 7, 20499, 274, 14, 53248, 274, 14, 24,
    20521, 274, 14, 28681, 274, 34, 3598, 20497, 274, 14, 28672, 274, 34, 3598,
    24583, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28679, 274, 34,
    3598, 61440, 274, 34, 3598, 32, 24583, 34, 3584, 28672, 274, 34, 3598,
    20489, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 28673, 239, 108, 0,
    34, 3584, 28672, 19, 54, 756, 34, 3584, 28672, 376, 720, 0, 34, 3584,
    28672, 376, 720, 18, 34, 3584, 28672, 151, 34, 3598, 28672, 91, 108, 0, 34,
    3584, 28672, 91, 108, 18, 34, 3584, 28672, 91, 108, 36, 34, 3584, 24581,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28675, 274, 34, 3598,
    61440, 274, 34, 3598, 32, 24576, 34, 3584, 28673, 239, 108, 0, 34, 3584,
    28672, 19, 18, 756, 34, 3584, 28672, 376, 738, 0, 34, 3584, 28672, 376,
    738, 18, 34, 3584, 28672, 151, 34, 3598, 24584, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 24582, 34, 3584, 28672, 105,
    396, 216, 34, 3584, 28672, 105, 396, 234, 34, 3584, 61440, 105, 396, 252,
    34, 3584, 64, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584, 28672, 274,
    34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 91, 90, 0, 34, 3584,
    28672, 91, 90, 18, 34, 3584, 28672, 91, 90, 36, 34, 3584, 24579, 34, 3584,
    28672, 105, 414, 216, 34, 3584, 28672, 105, 414, 234, 34, 3584, 28672, 105,
    414, 252, 34, 3584, 61440, 151, 34, 3598, 64, 24583, 34, 3584, 61440, 19,
    144, 756, 34, 3584, 24, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274,
    34, 3598, 24585, 34, 3584, 61440, 151, 34, 3598, 64, 24582, 34, 3584,
    61440, 19, 144, 756, 34, 3584, 24, 24576, 34, 3584, 28672, 274, 34, 3598,
    20485, 274, 14, 28672, 274, 34, 3598, 24584, 34, 3584, 61440, 135, 0, 54,
    34, 3584, 64, 61440, 151, 34, 3598, 64, 24581, 34, 3584, 61440, 19, 144,
    756, 34, 3584, 24, 24577, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14,
    28672, 274, 34, 3598, 24585, 34, 3584, 61440, 19, 54, 756, 34, 3584, 64,
    24580, 34, 3584, 61440, 19, 144, 756, 34, 3584, 24, 24578, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584,
    61440, 19, 0, 756, 34, 3584, 64, 24579, 34, 3584, 61440, 19, 144, 756, 34,
    3584, 24, 24579, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 24585, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64, 24578, 34,
    3584, 61440, 19, 144, 756, 34, 3584, 24, 24577, 34, 3584, 28672, 506, 0, 0,
    34, 3584, 28672, 506, 0, 18, 34, 3584, 28672, 506, 0, 36, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584,
    61440, 19, 0, 756, 34, 3584, 64, 24577, 34, 3584, 61440, 19, 144, 756, 34,
    3584, 24, 24578, 34, 3584, 28672, 506, 18, 0, 34, 3584, 28672, 506, 18, 18,
    34, 3584, 28672, 506, 18, 36, 34, 3584, 28672, 274, 34, 3598, 20485, 274,
    14, 28672, 274, 34, 3598, 28672, 45, 34, 3598, 28672, 34, 162, 378, 34,
    3584, 28672, 34, 162, 396, 34, 3584, 28672, 34, 162, 414, 34, 3584, 24581,
    34, 3584, 61440, 19, 0, 756, 34, 3584, 64, 24576, 34, 3584, 61440, 19, 144,
    756, 34, 3584, 24, 24582, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14,
    28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34, 180, 378, 34, 3584,
    28672, 34, 180, 396, 34, 3584, 12288, 34, 180, 414, 34, 24581, 34, 3584,
    61440, 19, 0, 756, 34, 3584, 64, 61440, 19, 144, 756, 34, 3584, 24, 24583,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    28672, 45, 34, 3586, 28672, 34, 198, 378, 34, 3584, 28672, 34, 198, 396,
    34, 3584, 12288, 34, 198, 414, 34, 24581, 34, 3584, 61440, 19, 450, 756,
    34, 3584, 88, 24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 24577, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24580,
    34, 3584, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 8192, 34,
    24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8196, 34, 61440, 151, 34, 3598,
    64, 28672, 91, 54, 0, 34, 3584, 28672, 91, 54, 18, 34, 3584, 28672, 91, 54,
    36, 34, 3584, 24578, 34, 3584, 28672, 93, 18, 2052, 34, 3584, 28672, 93,
    18, 2070, 34, 3584, 61440, 93, 18, 2088, 34, 3584, 64, 61440, 274, 34,
    3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 8192, 34,
    24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8196, 34, 61440, 151, 34, 3598,
    64, 24584, 34, 3584, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274,
    34, 3598, 8192, 34, 24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34,
    24576, 34, 3584, 8192, 34, 24578, 34, 3584, 61440, 151, 34, 3598, 64,
    24582, 34, 3584, 28672, 79, 72, 1368, 34, 3584, 28672, 79, 72, 1386, 34,
    3584, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 8192,
    34, 24576, 34, 3584, 8194, 34, 24576, 34, 3584, 8193, 34, 24577, 34, 3584,
    61440, 151, 34, 3598, 64, 24582, 34, 3584, 28672, 79, 90, 1368, 34, 3584,
    28672, 79, 90, 1386, 34, 3584, 61440, 274, 34, 3598, 64, 20485, 274, 14,
    28672, 274, 34, 3598, 8192, 34, 24576, 34, 3584, 8194, 34, 24576, 34, 3584,
    8194, 34, 24576, 34, 3584, 61440, 151, 34, 3598, 64, 24582, 34, 3584,
    28672, 79, 108, 1368, 34, 3584, 28672, 79, 108, 1386, 34, 3584, 61440, 274,
    34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 8192, 34, 24576, 34,
    3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34,
    24576, 34, 3584, 8193, 34, 61440, 151, 34, 3598, 64, 24582, 34, 3584,
    28672, 79, 126, 1368, 34, 3584, 28672, 79, 126, 1386, 34, 3584, 61440, 274,
    34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 8192,
    34, 24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24578, 34, 3584,
    8192, 34, 61440, 151, 34, 3598, 64, 24583, 34, 3584, 61440, 135, 0, 126,
    34, 3612, 64, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274, 34,
    3598, 24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24576, 34,
    3584, 8192, 34, 24578, 34, 3584, 45056, 135, 0, 54, 34, 64, 61440, 151, 34,
    3598, 64, 28672, 91, 54, 0, 34, 3584, 28672, 91, 54, 18, 34, 3584, 28672,
    91, 54, 36, 34, 3584, 24578, 34, 3584, 28672, 93, 18, 2052, 34, 3584,
    28672, 93, 18, 2070, 34, 3584, 61440, 93, 18, 2088, 34, 3584, 64, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24577, 34, 3584, 8192,
    34, 24576, 34, 3584, 8192, 34, 24577, 34, 3584, 8192, 34, 24576, 34, 3584,
    8192, 34, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34,
    162, 378, 34, 3584, 28672, 34, 162, 396, 34, 3584, 12288, 34, 162, 414, 34,
    24579, 34, 3584, 8193, 34, 61440, 151, 34, 3598, 64, 24584, 34, 3584,
    28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34,
    3586, 28672, 34, 180, 378, 34, 3584, 28672, 34, 180, 396, 34, 3584, 12288,
    34, 180, 414, 34, 24581, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34,
    3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672,
    45, 34, 3598, 28672, 34, 198, 378, 34, 3584, 28672, 34, 198, 396, 34, 3584,
    28672, 34, 198, 414, 34, 3584, 24580, 34, 3584, 28672, 332, 34, 3584,
    61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598, 20485,
    274, 14, 28672, 274, 34, 3598, 24584, 34, 3584, 28672, 332, 34, 3584,
    61440, 151, 34, 3598, 64, 24581, 34, 3584, 28672, 506, 36, 0, 34, 3584,
    28672, 506, 36, 18, 34, 3584, 28672, 506, 36, 36, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28673, 332,
    34, 3584, 61440, 151, 34, 3598, 64, 24581, 34, 3584, 28672, 506, 54, 0, 34,
    3584, 28672, 506, 54, 18, 34, 3584, 28672, 506, 54, 36, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584,
    28673, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584,
    28672, 467, 360, 0, 34, 3584, 28672, 467, 360, 18, 34, 3584, 61440, 151,
    34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 24583, 34, 3584, 28672, 467, 378, 0, 34, 3584, 28672, 467,
    378, 18, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274,
    34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28673,
    332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 91, 90, 0, 34, 3584,
    28672, 91, 90, 18, 34, 3584, 28672, 91, 90, 36, 34, 3584, 24580, 34, 3584,
    28673, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24584, 34, 3584,
    28672, 332, 34, 3584, 61440, 151, 34, 3598, 64, 28680, 577, 34, 3584,
    28672, 274, 34, 3598, 20485, 274, 14, 28675, 274, 34, 3598, 61440, 274, 34,
    3598, 40, 24578, 34, 3584, 28672, 105, 396, 54, 34, 3584, 28672, 105, 396,
    72, 34, 3584, 28672, 105, 396, 90, 34, 3584, 61440, 151, 34, 3598, 64,
    24584, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28672, 274, 34,
    3598, 24578, 34, 3584, 28672, 105, 414, 54, 34, 3584, 28672, 105, 414, 72,
    34, 3584, 61440, 105, 414, 90, 34, 3584, 64, 61440, 151, 34, 3598, 64,
    28672, 91, 108, 0, 34, 3584, 28672, 91, 108, 18, 34, 3584, 28672, 91, 108,
    36, 34, 3584, 24581, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28679,
    274, 34, 3598, 61440, 274, 34, 3598, 40, 24583, 34, 3584, 28672, 274, 34,
    3598, 20497, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28672, 274,
    34, 3598, 20497, 274, 14, 28681, 274, 34, 3598, 20482, 274, 14, 53248, 274,
    14, 16, 20506, 274, 14, 7, 20499, 274, 14, 7, 53248, 274, 14, 16, 20498,
    274, 14, 15, 20491, 274, 14, 15, 53248, 274, 14, 16, 20490, 274, 14
},
// desertTomb4
{
    13340, 15, 53248, 274, 14, 24, 20490, 274, 14, 15, 20491, 274, 14, 7,
    53248, 274, 14, 24, 20498, 274, 14, 7, 20499, 274, 14, 53248, 274, 14, 24,
    20521, 274, 14, 28681, 274, 34, 3598, 20497, 274, 14, 28672, 274, 34, 3598,
    24583, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28679, 274, 34,
    3598, 61440, 274, 34, 3598, 32, 24583, 34, 3584, 28672, 274, 34, 3598,
    20489, 274, 14, 28672, 274, 34, 3598, 24578, 34, 3584, 28672, 105, 396,
    216, 34, 3584, 28672, 105, 396, 234, 34, 3584, 61440, 105, 396, 252, 34,
    3584, 64, 61440, 151, 34, 3598, 64, 28672, 91, 108, 0, 34, 3584, 28672, 91,
    108, 18, 34, 3584, 28672, 91, 108, 36, 34, 3584, 24581, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28675, 274, 34, 3598, 61440, 274, 34, 3598,
    32, 24578, 34, 3584, 28672, 105, 414, 216, 34, 3584, 28672, 105, 414, 234,
    34, 3584, 28672, 105, 414, 252, 34, 3584, 61440, 151, 34, 3598, 64, 24584,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24584, 34, 3584, 28672, 332, 34, 3584, 61440, 151, 34, 3598, 64, 28680,
    577, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    28672, 91, 90, 0, 34, 3584, 28672, 91, 90, 18, 34, 3584, 28672, 91, 90, 36,
    34, 3584, 24580, 34, 3584, 28673, 332, 34, 3584, 61440, 151, 34, 3598, 64,
    24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 24583, 34, 3584, 28673, 332, 34, 3584, 61440, 151, 34, 3598, 64,
    24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 24583, 34, 3584, 28672, 467, 360, 0, 34, 3584, 28672, 467, 360, 18,
    34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34, 3598,
    20485, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28672, 467, 378, 0,
    34, 3584, 28672, 467, 378, 18, 34, 3584, 61440, 151, 34, 3598, 64, 24584,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24583, 34, 3584, 28673, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34,
    3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24583,
    34, 3584, 28673, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24581, 34, 3584,
    28672, 506, 0, 0, 34, 3584, 28672, 506, 0, 18, 34, 3584, 28672, 506, 0, 36,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24584, 34, 3584, 28672, 332, 34, 3584, 61440, 151, 34, 3598, 64, 24581, 34,
    3584, 28672, 506, 18, 0, 34, 3584, 28672, 506, 18, 18, 34, 3584, 28672,
    506, 18, 36, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274,
    34, 3598, 28672, 45, 34, 3598, 28672, 34, 162, 378, 34, 3584, 28672, 34,
    162, 396, 34, 3584, 28672, 34, 162, 414, 34, 3584, 24580, 34, 3584, 28672,
    332, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34,
    180, 378, 34, 3584, 28672, 34, 180, 396, 34, 3584, 12288, 34, 180, 414, 34,
    24581, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34,
    198, 378, 34, 3584, 28672, 34, 198, 396, 34, 3584, 12288, 34, 198, 414, 34,
    24581, 34, 3584, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 28672, 274, 34,
    3598, 20485, 274, 14, 28672, 274, 34, 3598, 24577, 34, 3584, 8192, 34,
    24576, 34, 3584, 8192, 34, 24580, 34, 3584, 61440, 151, 34, 3598, 64,
    28680, 577, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24576, 34,
    3584, 8195, 34, 45056, 135, 0, 54, 34, 64, 61440, 151, 34, 3598, 64, 28672,
    91, 54, 0, 34, 3584, 28672, 91, 54, 18, 34, 3584, 28672, 91, 54, 36, 34,
    3584, 24578, 34, 3584, 28672, 93, 18, 2052, 34, 3584, 28672, 93, 18, 2070,
    34, 3584, 61440, 93, 18, 2088, 34, 3584, 64, 28672, 274, 34, 3598, 20485,
    274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 8192, 34, 24576, 34, 3584,
    8192, 34, 24576, 34, 3584, 8196, 34, 61440, 151, 34, 3598, 64, 24583, 34,
    3584, 61440, 135, 0, 126, 34, 3612, 64, 61440, 274, 34, 3598, 64, 20485,
    274, 14, 28672, 274, 34, 3598, 8192, 34, 24576, 34, 3584, 8192, 34, 24576,
    34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24578, 34, 3584, 61440, 151,
    34, 3598, 64, 24582, 34, 3584, 28672, 79, 0, 1368, 34, 3584, 28672, 79, 0,
    1386, 34, 3584, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274, 34,
    3598, 8192, 34, 24576, 34, 3584, 8194, 34, 24576, 34, 3584, 8193, 34,
    24577, 34, 3584, 61440, 151, 34, 3598, 64, 24582, 34, 3584, 28672, 79, 18,
    1368, 34, 3584, 28672, 79, 18, 1386, 34, 3584, 61440, 274, 34, 3598, 64,
    20485, 274, 14, 28672, 274, 34, 3598, 8192, 34, 24576, 34, 3584, 8194, 34,
    24576, 34, 3584, 8194, 34, 24576, 34, 3584, 61440, 151, 34, 3598, 64,
    24582, 34, 3584, 28672, 79, 36, 1368, 34, 3584, 28672, 79, 36, 1386, 34,
    3584, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 8192,
    34, 24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24576, 34, 3584,
    8192, 34, 24576, 34, 3584, 8193, 34, 61440, 151, 34, 3598, 64, 24582, 34,
    3584, 28672, 79, 54, 1368, 34, 3584, 28672, 79, 54, 1386, 34, 3584, 61440,
    274, 34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584,
    8192, 34, 24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24578, 34,
    3584, 8192, 34, 61440, 151, 34, 3598, 64, 24584, 34, 3584, 61440, 274, 34,
    3598, 64, 20485, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 8192, 34,
    24576, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24578, 34, 3584,
    8192, 34, 61440, 151, 34, 3598, 64, 28672, 91, 54, 0, 34, 3584, 28672, 91,
    54, 18, 34, 3584, 28672, 91, 54, 36, 34, 3584, 24578, 34, 3584, 28672, 93,
    18, 2052, 34, 3584, 28672, 93, 18, 2070, 34, 3584, 61440, 93, 18, 2088, 34,
    3584, 64, 61440, 274, 34, 3598, 64, 20485, 274, 14, 28672, 274, 34, 3598,
    24577, 34, 3584, 8192, 34, 24576, 34, 3584, 8192, 34, 24577, 34, 3584,
    8192, 34, 24576, 34, 3584, 8192, 34, 61440, 151, 34, 3598, 64, 28680, 577,
    34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    28672, 45, 34, 3586, 28672, 34, 162, 378, 34, 3584, 28672, 34, 162, 396,
    34, 3584, 12288, 34, 162, 414, 34, 24579, 34, 3584, 8193, 34, 61440, 19,
    468, 756, 34, 3584, 80, 24584, 34, 3584, 28672, 274, 34, 3598, 20485, 274,
    14, 28672, 274, 34, 3598, 28672, 45, 34, 3586, 28672, 34, 180, 378, 34,
    3584, 28672, 34, 180, 396, 34, 3584, 12288, 34, 180, 414, 34, 24581, 34,
    3584, 61440, 19, 0, 756, 34, 3584, 64, 61440, 19, 180, 756, 34, 3584, 16,
    24583, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 28672, 45, 34, 3598, 28672, 34, 198, 378, 34, 3584, 28672, 34, 198,
    396, 34, 3584, 28672, 34, 198, 414, 34, 3584, 24581, 34, 3584, 61440, 19,
    0, 756, 34, 3584, 64, 24576, 34, 3584, 61440, 19, 180, 756, 34, 3584, 16,
    24582, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 24585, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64, 24577, 34, 3584,
    61440, 19, 180, 756, 34, 3584, 16, 24578, 34, 3584, 28672, 506, 36, 0, 34,
    3584, 28672, 506, 36, 18, 34, 3584, 28672, 506, 36, 36, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584,
    61440, 19, 0, 756, 34, 3584, 64, 24578, 34, 3584, 61440, 19, 180, 756, 34,
    3584, 16, 24577, 34, 3584, 28672, 506, 54, 0, 34, 3584, 28672, 506, 54, 18,
    34, 3584, 28672, 506, 54, 36, 34, 3584, 28672, 274, 34, 3598, 20485, 274,
    14, 28672, 274, 34, 3598, 24585, 34, 3584, 61440, 19, 0, 756, 34, 3584, 64,
    24579, 34, 3584, 61440, 19, 180, 756, 34, 3584, 16, 24579, 34, 3584, 28672,
    274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598, 24585, 34, 3584,
    61440, 19, 72, 756, 34, 3584, 64, 24580, 34, 3584, 61440, 19, 180, 756, 34,
    3584, 16, 24578, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672,
    274, 34, 3598, 24584, 34, 3584, 61440, 135, 0, 54, 34, 3584, 64, 61440,
    151, 34, 3598, 64, 24581, 34, 3584, 61440, 19, 180, 756, 34, 3584, 16,
    24577, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34,
    3598, 24585, 34, 3584, 61440, 151, 34, 3598, 64, 24582, 34, 3584, 61440,
    19, 180, 756, 34, 3584, 16, 24576, 34, 3584, 28672, 274, 34, 3598, 20485,
    274, 14, 28672, 274, 34, 3598, 28672, 91, 90, 0, 34, 3584, 28672, 91, 90,
    18, 34, 3584, 28672, 91, 90, 36, 34, 3584, 24579, 34, 3584, 28672, 105,
    396, 54, 34, 3584, 28672, 105, 396, 72, 34, 3584, 28672, 105, 396, 90, 34,
    3584, 61440, 151, 34, 3598, 64, 24583, 34, 3584, 61440, 19, 180, 756, 34,
    3584, 16, 28672, 274, 34, 3598, 20485, 274, 14, 28672, 274, 34, 3598,
    24582, 34, 3584, 28672, 105, 414, 54, 34, 3584, 28672, 105, 414, 72, 34,
    3584, 61440, 105, 414, 90, 34, 3584, 64, 61440, 151, 34, 3598, 64, 28680,
    577, 34, 3584, 28672, 274, 34, 3598, 20485, 274, 14, 28675, 274, 34, 3598,
    61440, 274, 34, 3598, 40, 24576, 34, 3584, 28673, 239, 108, 0, 34, 3584,
    28672, 19, 36, 756, 34, 3584, 28672, 376, 720, 0, 34, 3584, 28672, 376,
    720, 18, 34, 3584, 28672, 151, 34, 3598, 24584, 34, 3584, 28672, 274, 34,
    3598, 20489, 274, 14, 28672, 274, 34, 3598, 24576, 34, 3584, 28673, 239,
    108, 0, 34, 3584, 28672, 19, 72, 756, 34, 3584, 28672, 376, 738, 0, 34,
    3584, 28672, 376, 738, 18, 34, 3584, 28672, 151, 34, 3598, 28672, 91, 108,
    0, 34, 3584, 28672, 91, 108, 18, 34, 3584, 28672, 91, 108, 36, 34, 3584,
    24581, 34, 3584, 28672, 274, 34, 3598, 20489, 274, 14, 28679, 274, 34,
    3598, 61440, 274, 34, 3598, 40, 24583, 34, 3584, 28672, 274, 34, 3598,
    20497, 274, 14, 28672, 274, 34, 3598, 24583, 34, 3584, 28672, 274, 34,
    3598, 20497, 274, 14, 28681, 274, 34, 3598, 20482, 274, 14, 53248, 274, 14,
    16, 20506, 274, 14, 7, 20499, 274, 14, 7, 53248, 274, 14, 16, 20498, 274,
    14, 15, 20491, 274, 14, 15, 53248, 274, 14, 16, 20490, 274, 14
},
// spiderHall1
{
    26923, 23, 36864, 273, 24, 4105, 273, 36864, 273, 40, 2, 4099, 273, 23,
    4096, 273, 12297, 273, 147, 4096, 273, 4096, 42, 0, 0, 4096, 42, 0, 18, 0,
    4099, 273, 11, 36864, 273, 24, 4107, 273, 12298, 273, 147, 8194, 147,
    12290, 273, 147, 4096, 273, 11, 4096, 273, 12310, 273, 147, 12288, 10, 36,
    702, 147, 12288, 10, 36, 720, 147, 12288, 10, 18, 738, 147, 12290, 273,
    147, 4096, 273, 11, 4096, 273, 12302, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12302, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 21, 540, 0,
    147, 12288, 21, 540, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 21, 558, 0,
    147, 12288, 21, 558, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147,
    8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8195, 147, 12288, 101, 270, 0, 147, 12288, 101, 270, 18, 147, 12288, 101,
    270, 36, 147, 12288, 101, 270, 54, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8195, 147, 12288, 101,
    288, 0, 147, 12288, 101, 288, 18, 147, 12288, 101, 288, 36, 147, 12288,
    101, 288, 54, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273,
    11, 4096, 273, 12290, 273, 147, 8195, 147, 12288, 101, 306, 0, 147, 12288,
    101, 306, 18, 147, 12288, 101, 306, 36, 147, 12288, 101, 306, 54, 147,
    12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 45056, 38, 147, 2088, 8200,
    147, 45056, 38, 147, 2072, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 45056, 38, 5, 2048, 8200, 5,
    45056, 38, 5, 2048, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273,
    147, 8195, 147, 12288, 101, 270, 0, 147, 12288, 101, 270, 18, 147, 12288,
    101, 270, 36, 147, 12288, 101, 270, 54, 147, 12291, 273, 147, 45056, 38, 5,
    2048, 8200, 5, 45056, 38, 5, 2048, 12290, 273, 147, 4096, 273, 11, 4096,
    273, 12290, 273, 147, 8195, 147, 12288, 101, 288, 0, 147, 12288, 101, 288,
    18, 147, 12288, 101, 288, 36, 147, 12288, 101, 288, 54, 147, 12291, 273,
    147, 45056, 38, 5, 2048, 8200, 5, 45056, 38, 5, 2048, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8195, 147, 12288, 101, 306, 0,
    147, 12288, 101, 306, 18, 147, 12288, 101, 306, 36, 147, 12288, 101, 306,
    54, 147, 12291, 273, 147, 45056, 38, 147, 2080, 8200, 147, 45056, 38, 147,
    2064, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199,
    147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147,
    8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8197, 147, 12288, 186, 1350, 0, 147, 12288, 186, 1350, 18, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8197, 147, 12288, 186, 1368, 0, 147, 12288, 186, 1368, 18, 147, 12291, 273,
    147, 8200, 147, 12288, 15, 18, 680, 147, 12288, 15, 18, 698, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 186,
    1386, 0, 147, 12288, 186, 1386, 18, 147, 12291, 273, 147, 12288, 34, 54,
    108, 147, 12288, 34, 54, 126, 147, 12288, 34, 54, 144, 147, 8197, 147,
    12288, 14, 756, 0, 147, 12288, 14, 756, 18, 147, 12290, 273, 147, 4096,
    273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 12288, 34,
    72, 108, 147, 12288, 34, 72, 126, 147, 12288, 34, 72, 144, 147, 8197, 147,
    12288, 14, 774, 0, 147, 12288, 14, 774, 18, 147, 12290, 273, 147, 4096,
    273, 11, 4096, 273, 12290, 273, 147, 8195, 147, 12288, 101, 270, 0, 147,
    12288, 101, 270, 18, 147, 12288, 101, 270, 36, 147, 12288, 101, 270, 54,
    147, 12291, 273, 147, 12288, 34, 90, 108, 147, 12288, 34, 90, 126, 147,
    12288, 34, 90, 144, 147, 8197, 147, 12288, 14, 792, 0, 147, 12288, 14, 792,
    18, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8195,
    147, 12288, 101, 288, 0, 147, 12288, 101, 288, 18, 147, 12288, 101, 288,
    36, 147, 12288, 101, 288, 54, 147, 12291, 273, 147, 8200, 147, 12288, 15,
    0, 680, 147, 12288, 15, 0, 698, 147, 12290, 273, 147, 4096, 273, 11, 4096,
    273, 12290, 273, 147, 8195, 147, 12288, 101, 306, 0, 147, 12288, 101, 306,
    18, 147, 12288, 101, 306, 36, 147, 12288, 101, 306, 54, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 9,
    36864, 273, 24, 4097, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147,
    8202, 147, 12290, 273, 147, 4096, 273, 7, 36864, 273, 24, 4097, 273, 12291,
    273, 147, 45056, 273, 147, 32, 8199, 147, 12291, 273, 147, 8202, 147,
    12290, 273, 147, 4096, 273, 6, 36864, 273, 24, 4096, 273, 12292, 273, 147,
    45056, 273, 147, 32, 8200, 147, 12291, 273, 147, 8201, 147, 45056, 19, 144,
    774, 147, 24, 12290, 273, 147, 4096, 273, 4, 36864, 273, 24, 4097, 273,
    12291, 273, 147, 45056, 273, 147, 32, 8202, 147, 12291, 273, 147, 8200,
    147, 45056, 19, 144, 774, 147, 24, 8192, 147, 12290, 273, 147, 4096, 273,
    4, 4096, 273, 12291, 273, 147, 45056, 273, 147, 32, 8204, 147, 12291, 273,
    147, 8199, 147, 45056, 19, 144, 774, 147, 24, 8193, 147, 12290, 273, 147,
    4096, 273, 3, 36864, 273, 24, 12290, 273, 147, 45056, 273, 147, 32, 8206,
    147, 12291, 273, 147, 8198, 147, 45056, 19, 144, 774, 147, 24, 8194, 147,
    12290, 273, 147, 4096, 273, 2, 36864, 273, 24, 4096, 273, 12289, 273, 147,
    45056, 273, 147, 32, 8207, 147, 12291, 273, 147, 8197, 147, 45056, 19, 144,
    774, 147, 24, 8195, 147, 12290, 273, 147, 4096, 273, 2, 4096, 273, 12289,
    273, 147, 45056, 273, 147, 32, 8208, 147, 12290, 273, 147, 45056, 273, 147,
    32, 8196, 147, 45056, 19, 144, 774, 147, 24, 8196, 147, 12290, 273, 147,
    4096, 273, 1, 36864, 273, 24, 12290, 273, 147, 8209, 147, 45056, 19, 180,
    774, 147, 16, 8198, 147, 45056, 19, 144, 774, 147, 24, 8197, 147, 12290,
    273, 147, 4096, 273, 1, 4096, 273, 12289, 273, 147, 45056, 273, 147, 32,
    8210, 147, 45056, 19, 180, 774, 147, 16, 8196, 147, 45056, 19, 144, 774,
    147, 24, 8198, 147, 12290, 273, 147, 4096, 273, 1, 4096, 273, 12289, 273,
    147, 8212, 147, 45056, 19, 180, 774, 147, 16, 8194, 147, 45056, 19, 144,
    774, 147, 24, 8199, 147, 12290, 273, 147, 4096, 273, 0, 36864, 273, 24,
    12290, 273, 147, 8213, 147, 45056, 19, 180, 774, 147, 16, 8193, 147, 12288,
    19, 216, 774, 147, 8199, 147, 12290, 273, 147, 4096, 273, 0, 4096, 273,
    12289, 273, 147, 45056, 273, 147, 32, 8214, 147, 45056, 19, 180, 774, 147,
    16, 8192, 147, 12288, 19, 0, 774, 147, 8197, 147, 12288, 186, 1242, 0, 147,
    12288, 186, 1242, 18, 147, 12290, 273, 147, 4096, 273, 36864, 273, 8,
    12290, 273, 147, 8216, 147, 45056, 19, 180, 774, 147, 16, 12288, 19, 0,
    774, 147, 8197, 147, 12288, 186, 1260, 0, 147, 12288, 186, 1260, 18, 147,
    12290, 273, 147, 4097, 273, 12290, 273, 147, 12288, 34, 54, 1080, 147,
    12288, 34, 54, 1098, 147, 12288, 34, 54, 1116, 147, 8214, 147, 12288, 19,
    0, 774, 147, 8197, 147, 12288, 186, 1278, 0, 147, 12288, 186, 1278, 18,
    147, 12290, 273, 147, 4097, 273, 12290, 273, 147, 12288, 34, 72, 1080, 147,
    12288, 34, 72, 1098, 147, 12288, 34, 72, 1116, 147, 8214, 147, 12288, 19,
    0, 774, 147, 8199, 147, 12290, 273, 147, 4097, 273, 12290, 273, 147, 12288,
    34, 90, 1080, 147, 12288, 34, 90, 1098, 147, 12288, 34, 90, 1116, 147,
    8214, 147, 12288, 19, 0, 774, 147, 8199, 147, 12290, 273, 147, 4096, 273,
    36864, 273, 8, 12290, 273, 147, 8216, 147, 45056, 19, 144, 774, 147, 24,
    12288, 19, 0, 774, 147, 8199, 147, 12290, 273, 147, 4096, 273, 0, 4096,
    273, 12289, 273, 147, 45056, 273, 147, 40, 8214, 147, 45056, 19, 144, 774,
    147, 24, 8192, 147, 12288, 19, 0, 774, 147, 8199, 147, 12290, 273, 147,
    4096, 273, 0, 36864, 273, 16, 12290, 273, 147, 8213, 147, 45056, 19, 144,
    774, 147, 24, 8193, 147, 12288, 19, 234, 774, 147, 8199, 147, 12290, 273,
    147, 4096, 273, 1, 4096, 273, 12289, 273, 147, 8212, 147, 45056, 19, 144,
    774, 147, 24, 8194, 147, 45056, 19, 180, 774, 147, 16, 8199, 147, 12290,
    273, 147, 4096, 273, 1, 4096, 273, 12289, 273, 147, 8211, 147, 45056, 19,
    144, 774, 147, 24, 8196, 147, 45056, 19, 180, 774, 147, 16, 8198, 147,
    12290, 273, 147, 4096, 273, 1, 36864, 273, 16, 12289, 273, 147, 45056, 273,
    147, 40, 8209, 147, 45056, 19, 144, 774, 147, 24, 8198, 147, 45056, 19,
    180, 774, 147, 16, 8197, 147, 12290, 273, 147, 4096, 273, 2, 4096, 273,
    12289, 273, 147, 45056, 273, 147, 40, 8208, 147, 12290, 273, 147, 45056,
    273, 147, 40, 8196, 147, 45056, 19, 180, 774, 147, 16, 8196, 147, 12290,
    273, 147, 4096, 273, 2, 36864, 273, 16, 4096, 273, 12289, 273, 147, 45056,
    273, 147, 40, 8207, 147, 12291, 273, 147, 8197, 147, 45056, 19, 180, 774,
    147, 16, 8195, 147, 12290, 273, 147, 4096, 273, 3, 36864, 273, 16, 12290,
    273, 147, 45056, 273, 147, 40, 8206, 147, 12291, 273, 147, 8198, 147,
    45056, 19, 180, 774, 147, 16, 8194, 147, 12290, 273, 147, 4096, 273, 4,
    4096, 273, 12291, 273, 147, 45056, 273, 147, 40, 8204, 147, 12291, 273,
    147, 8199, 147, 45056, 19, 180, 774, 147, 16, 8193, 147, 12290, 273, 147,
    4096, 273, 4, 36864, 273, 16, 4097, 273, 12291, 273, 147, 45056, 273, 147,
    40, 8202, 147, 12291, 273, 147, 8200, 147, 45056, 19, 180, 774, 147, 16,
    8192, 147, 12290, 273, 147, 4096, 273, 6, 36864, 273, 16, 4096, 273, 12292,
    273, 147, 45056, 273, 147, 40, 8200, 147, 12291, 273, 147, 8201, 147,
    45056, 19, 180, 774, 147, 16, 12290, 273, 147, 4096, 273, 7, 36864, 273,
    16, 4097, 273, 12291, 273, 147, 45056, 273, 147, 40, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 9, 36864, 273, 16, 4097, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147,
    8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8200, 147, 12288,
    15, 18, 680, 147, 12288, 15, 18, 698, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8200, 147, 12288,
    186, 1350, 0, 147, 12288, 186, 1350, 18, 147, 12290, 273, 147, 4096, 273,
    11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8200, 147,
    12288, 186, 1368, 0, 147, 12288, 186, 1368, 18, 147, 12290, 273, 147, 4096,
    273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 15, 18, 680, 147,
    12288, 15, 18, 698, 147, 12291, 273, 147, 8200, 147, 12288, 186, 1386, 0,
    147, 12288, 186, 1386, 18, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8197, 147, 12288, 14, 756, 0, 147, 12288, 14, 756, 18,
    147, 12291, 273, 147, 8200, 147, 12288, 14, 756, 0, 147, 12288, 14, 756,
    18, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8197,
    147, 12288, 14, 774, 0, 147, 12288, 14, 774, 18, 147, 12291, 273, 147,
    8200, 147, 12288, 14, 774, 0, 147, 12288, 14, 774, 18, 147, 12290, 273,
    147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8196, 147, 12288, 50, 72,
    0, 147, 12288, 14, 792, 0, 147, 12288, 14, 792, 18, 147, 12291, 273, 147,
    8200, 147, 12288, 14, 792, 0, 147, 12288, 14, 792, 18, 147, 12290, 273,
    147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 12288, 34, 54, 108, 147,
    12288, 34, 54, 126, 147, 12288, 34, 54, 144, 147, 8192, 147, 12288, 101,
    270, 0, 147, 12288, 101, 270, 18, 147, 12288, 101, 270, 36, 147, 12288,
    101, 270, 54, 147, 12291, 273, 147, 8200, 147, 12288, 15, 0, 680, 147,
    12288, 15, 0, 698, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290,
    273, 147, 12288, 34, 72, 108, 147, 12288, 34, 72, 126, 147, 12288, 34, 72,
    144, 147, 8192, 147, 12288, 101, 288, 0, 147, 12288, 101, 288, 18, 147,
    12288, 101, 288, 36, 147, 12288, 101, 288, 54, 147, 12291, 273, 147, 8202,
    147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 12288, 34,
    90, 108, 147, 12288, 34, 90, 126, 147, 12288, 34, 90, 144, 147, 8192, 147,
    12288, 101, 306, 0, 147, 12288, 101, 306, 18, 147, 12288, 101, 306, 36,
    147, 12288, 101, 306, 54, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 14, 756, 0,
    147, 12288, 14, 756, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 14, 774, 0,
    147, 12288, 14, 774, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 14, 792, 0,
    147, 12288, 14, 792, 18, 147, 12291, 273, 147, 45056, 38, 147, 2088, 8200,
    147, 45056, 38, 147, 2072, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 45056, 38, 5, 2048, 8200, 5,
    45056, 38, 5, 2048, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273,
    147, 8199, 147, 12291, 273, 147, 45056, 38, 5, 2048, 8200, 5, 45056, 38, 5,
    2048, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8197,
    147, 12288, 50, 36, 0, 147, 12288, 18, 540, 0, 147, 12291, 273, 147, 45056,
    38, 5, 2048, 8200, 5, 45056, 38, 5, 2048, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8197, 147, 12288, 50, 18, 0, 147, 12288, 18,
    558, 0, 147, 12291, 273, 147, 45056, 38, 147, 2080, 8200, 147, 45056, 38,
    147, 2064, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8197, 147, 12288, 50, 54, 0, 147, 12288, 18,
    540, 0, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8197, 147, 12288, 50, 0, 0, 147, 12288, 18,
    558, 0, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8197, 147, 12288, 15, 0, 680, 147, 12288, 15,
    0, 698, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8197, 147, 12288, 21, 540, 0, 147, 12288, 21,
    540, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8197, 147, 12288, 21, 558, 0, 147, 12288, 21,
    558, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12302, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12302, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12302, 273, 147, 4100, 273, 12290, 273, 147, 12288, 10, 18, 702,
    147, 12288, 10, 18, 720, 147, 12288, 10, 36, 738, 147, 12290, 273, 147,
    4096, 273, 11, 36864, 273, 16, 4107, 273, 12290, 273, 147, 4100, 273,
    12290, 273, 147, 8194, 147, 12290, 273, 147, 4096, 273, 23, 4096, 273,
    12290, 273, 147, 4103, 273, 4096, 42, 0, 0, 4096, 42, 0, 18, 0, 4099, 273,
    23, 36864, 273, 16, 4105, 273, 36864, 273, 32, 2, 4099, 273
},
// spiderHall2
{
    26923, 23, 36864, 273, 24, 4105, 273, 36864, 273, 40, 2, 4099, 273, 23,
    4096, 273, 12297, 273, 147, 4096, 273, 4096, 42, 0, 0, 4096, 42, 0, 18, 0,
    4099, 273, 11, 36864, 273, 24, 4107, 273, 12298, 273, 147, 8194, 147,
    12290, 273, 147, 4096, 273, 11, 4096, 273, 12310, 273, 147, 12288, 10, 0,
    702, 147, 12288, 10, 18, 720, 147, 12288, 10, 18, 738, 147, 12290, 273,
    147, 4096, 273, 11, 4096, 273, 12302, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12302, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 21, 540, 0,
    147, 12288, 21, 540, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 21, 558, 0,
    147, 12288, 21, 558, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147,
    8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8195, 147, 12288, 101, 270, 0, 147, 12288, 101, 270, 18, 147, 12288, 101,
    270, 36, 147, 12288, 101, 270, 54, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8195, 147, 12288, 101,
    288, 0, 147, 12288, 101, 288, 18, 147, 12288, 101, 288, 36, 147, 12288,
    101, 288, 54, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273,
    11, 4096, 273, 12290, 273, 147, 8195, 147, 12288, 101, 306, 0, 147, 12288,
    101, 306, 18, 147, 12288, 101, 306, 36, 147, 12288, 101, 306, 54, 147,
    12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 45056, 38, 147, 2088, 8200,
    147, 45056, 38, 147, 2072, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 45056, 38, 5, 2048, 8200, 5,
    45056, 38, 5, 2048, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273,
    147, 8195, 147, 12288, 101, 270, 0, 147, 12288, 101, 270, 18, 147, 12288,
    101, 270, 36, 147, 12288, 101, 270, 54, 147, 12291, 273, 147, 45056, 38, 5,
    2048, 8200, 5, 45056, 38, 5, 2048, 12290, 273, 147, 4096, 273, 11, 4096,
    273, 12290, 273, 147, 8195, 147, 12288, 101, 288, 0, 147, 12288, 101, 288,
    18, 147, 12288, 101, 288, 36, 147, 12288, 101, 288, 54, 147, 12291, 273,
    147, 45056, 38, 5, 2048, 8200, 5, 45056, 38, 5, 2048, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8195, 147, 12288, 101, 306, 0,
    147, 12288, 101, 306, 18, 147, 12288, 101, 306, 36, 147, 12288, 101, 306,
    54, 147, 12291, 273, 147, 45056, 38, 147, 2080, 8200, 147, 45056, 38, 147,
    2064, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199,
    147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8195, 147, 12288, 101, 270, 0,
    147, 12288, 101, 270, 18, 147, 12288, 101, 270, 36, 147, 12288, 101, 270,
    54, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096,
    273, 12290, 273, 147, 8195, 147, 12288, 101, 288, 0, 147, 12288, 101, 288,
    18, 147, 12288, 101, 288, 36, 147, 12288, 101, 288, 54, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8195, 147, 12288, 101, 306, 0, 147, 12288, 101, 306, 18, 147, 12288, 101,
    306, 36, 147, 12288, 101, 306, 54, 147, 12291, 273, 147, 8200, 147, 12288,
    15, 18, 680, 147, 12288, 15, 18, 698, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 12288, 34, 54, 108,
    147, 12288, 34, 54, 126, 147, 12288, 34, 54, 144, 147, 8197, 147, 12288,
    14, 756, 0, 147, 12288, 14, 756, 18, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 12288, 34, 72, 108,
    147, 12288, 34, 72, 126, 147, 12288, 34, 72, 144, 147, 8197, 147, 12288,
    14, 774, 0, 147, 12288, 14, 774, 18, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8195, 147, 12288, 101, 270, 0, 147, 12288, 101,
    270, 18, 147, 12288, 101, 270, 36, 147, 12288, 101, 270, 54, 147, 12291,
    273, 147, 12288, 34, 90, 108, 147, 12288, 34, 90, 126, 147, 12288, 34, 90,
    144, 147, 8197, 147, 12288, 14, 792, 0, 147, 12288, 14, 792, 18, 147,
    12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8195, 147,
    12288, 101, 288, 0, 147, 12288, 101, 288, 18, 147, 12288, 101, 288, 36,
    147, 12288, 101, 288, 54, 147, 12291, 273, 147, 8200, 147, 12288, 15, 0,
    680, 147, 12288, 15, 0, 698, 147, 12290, 273, 147, 4096, 273, 11, 4096,
    273, 12290, 273, 147, 8195, 147, 12288, 101, 306, 0, 147, 12288, 101, 306,
    18, 147, 12288, 101, 306, 36, 147, 12288, 101, 306, 54, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8197, 147, 12288, 186, 1350, 0, 147, 12288, 186, 1350, 18, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8197, 147, 12288, 186, 1368, 0, 147, 12288, 186, 1368, 18, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8197, 147, 12288, 186, 1386, 0, 147, 12288, 186, 1386, 18, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 9,
    36864, 273, 24, 4097, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147,
    8202, 147, 12290, 273, 147, 4096, 273, 7, 36864, 273, 24, 4097, 273, 12291,
    273, 147, 45056, 273, 147, 32, 8199, 147, 12291, 273, 147, 8202, 147,
    12290, 273, 147, 4096, 273, 6, 36864, 273, 24, 4096, 273, 12292, 273, 147,
    45056, 273, 147, 32, 8200, 147, 12291, 273, 147, 8201, 147, 45056, 19, 144,
    774, 147, 24, 12290, 273, 147, 4096, 273, 4, 36864, 273, 24, 4097, 273,
    12291, 273, 147, 45056, 273, 147, 32, 8202, 147, 12291, 273, 147, 8200,
    147, 45056, 19, 144, 774, 147, 24, 8192, 147, 12290, 273, 147, 4096, 273,
    4, 4096, 273, 12291, 273, 147, 45056, 273, 147, 32, 8204, 147, 12291, 273,
    147, 8199, 147, 45056, 19, 144, 774, 147, 24, 8193, 147, 12290, 273, 147,
    4096, 273, 3, 36864, 273, 24, 12290, 273, 147, 45056, 273, 147, 32, 8206,
    147, 12291, 273, 147, 8198, 147, 45056, 19, 144, 774, 147, 24, 8194, 147,
    12290, 273, 147, 4096, 273, 2, 36864, 273, 24, 4096, 273, 12289, 273, 147,
    45056, 273, 147, 32, 8207, 147, 12291, 273, 147, 8197, 147, 45056, 19, 144,
    774, 147, 24, 8195, 147, 12290, 273, 147, 4096, 273, 2, 4096, 273, 12289,
    273, 147, 45056, 273, 147, 32, 8208, 147, 12290, 273, 147, 45056, 273, 147,
    32, 8196, 147, 45056, 19, 144, 774, 147, 24, 8196, 147, 12290, 273, 147,
    4096, 273, 1, 36864, 273, 24, 12290, 273, 147, 8209, 147, 45056, 19, 180,
    774, 147, 16, 8198, 147, 45056, 19, 144, 774, 147, 24, 8197, 147, 12290,
    273, 147, 4096, 273, 1, 4096, 273, 12289, 273, 147, 45056, 273, 147, 32,
    8210, 147, 45056, 19, 180, 774, 147, 16, 8196, 147, 45056, 19, 144, 774,
    147, 24, 8198, 147, 12290, 273, 147, 4096, 273, 1, 4096, 273, 12289, 273,
    147, 8212, 147, 45056, 19, 180, 774, 147, 16, 8194, 147, 45056, 19, 144,
    774, 147, 24, 8199, 147, 12290, 273, 147, 4096, 273, 0, 36864, 273, 24,
    12290, 273, 147, 8213, 147, 45056, 19, 180, 774, 147, 16, 8193, 147, 12288,
    19, 216, 774, 147, 8199, 147, 12290, 273, 147, 4096, 273, 0, 4096, 273,
    12289, 273, 147, 45056, 273, 147, 32, 8214, 147, 45056, 19, 180, 774, 147,
    16, 8192, 147, 12288, 19, 0, 774, 147, 8199, 147, 12290, 273, 147, 4096,
    273, 36864, 273, 8, 12290, 273, 147, 8216, 147, 45056, 19, 180, 774, 147,
    16, 12288, 19, 0, 774, 147, 8199, 147, 12290, 273, 147, 4097, 273, 12290,
    273, 147, 12288, 34, 54, 1080, 147, 12288, 34, 54, 1098, 147, 12288, 34,
    54, 1116, 147, 8214, 147, 12288, 19, 0, 774, 147, 8199, 147, 12290, 273,
    147, 4097, 273, 12290, 273, 147, 12288, 34, 72, 1080, 147, 12288, 34, 72,
    1098, 147, 12288, 34, 72, 1116, 147, 8214, 147, 12288, 19, 0, 774, 147,
    8199, 147, 12290, 273, 147, 4097, 273, 12290, 273, 147, 12288, 34, 90,
    1080, 147, 12288, 34, 90, 1098, 147, 12288, 34, 90, 1116, 147, 8214, 147,
    12288, 19, 0, 774, 147, 8199, 147, 12290, 273, 147, 4096, 273, 36864, 273,
    8, 12290, 273, 147, 8216, 147, 45056, 19, 144, 774, 147, 24, 12288, 19, 0,
    774, 147, 8197, 147, 12288, 186, 1188, 0, 147, 12288, 186, 1188, 18, 147,
    12290, 273, 147, 4096, 273, 0, 4096, 273, 12289, 273, 147, 45056, 273, 147,
    40, 8214, 147, 45056, 19, 144, 774, 147, 24, 8192, 147, 12288, 19, 0, 774,
    147, 8197, 147, 12288, 186, 1206, 0, 147, 12288, 186, 1206, 18, 147, 12290,
    273, 147, 4096, 273, 0, 36864, 273, 16, 12290, 273, 147, 8213, 147, 45056,
    19, 144, 774, 147, 24, 8193, 147, 12288, 19, 234, 774, 147, 8197, 147,
    12288, 186, 1224, 0, 147, 12288, 186, 1224, 18, 147, 12290, 273, 147, 4096,
    273, 1, 4096, 273, 12289, 273, 147, 8212, 147, 45056, 19, 144, 774, 147,
    24, 8194, 147, 45056, 19, 180, 774, 147, 16, 8199, 147, 12290, 273, 147,
    4096, 273, 1, 4096, 273, 12289, 273, 147, 8211, 147, 45056, 19, 144, 774,
    147, 24, 8196, 147, 45056, 19, 180, 774, 147, 16, 8198, 147, 12290, 273,
    147, 4096, 273, 1, 36864, 273, 16, 12289, 273, 147, 45056, 273, 147, 40,
    8209, 147, 45056, 19, 144, 774, 147, 24, 8198, 147, 45056, 19, 180, 774,
    147, 16, 8197, 147, 12290, 273, 147, 4096, 273, 2, 4096, 273, 12289, 273,
    147, 45056, 273, 147, 40, 8208, 147, 12290, 273, 147, 45056, 273, 147, 40,
    8196, 147, 45056, 19, 180, 774, 147, 16, 8196, 147, 12290, 273, 147, 4096,
    273, 2, 36864, 273, 16, 4096, 273, 12289, 273, 147, 45056, 273, 147, 40,
    8207, 147, 12291, 273, 147, 8197, 147, 45056, 19, 180, 774, 147, 16, 8195,
    147, 12290, 273, 147, 4096, 273, 3, 36864, 273, 16, 12290, 273, 147, 45056,
    273, 147, 40, 8206, 147, 12291, 273, 147, 8198, 147, 45056, 19, 180, 774,
    147, 16, 8194, 147, 12290, 273, 147, 4096, 273, 4, 4096, 273, 12291, 273,
    147, 45056, 273, 147, 40, 8204, 147, 12291, 273, 147, 8199, 147, 45056, 19,
    180, 774, 147, 16, 8193, 147, 12290, 273, 147, 4096, 273, 4, 36864, 273,
    16, 4097, 273, 12291, 273, 147, 45056, 273, 147, 40, 8202, 147, 12291, 273,
    147, 8200, 147, 45056, 19, 180, 774, 147, 16, 8192, 147, 12290, 273, 147,
    4096, 273, 6, 36864, 273, 16, 4096, 273, 12292, 273, 147, 45056, 273, 147,
    40, 8200, 147, 12291, 273, 147, 8201, 147, 45056, 19, 180, 774, 147, 16,
    12290, 273, 147, 4096, 273, 7, 36864, 273, 16, 4097, 273, 12291, 273, 147,
    45056, 273, 147, 40, 8199, 147, 12291, 273, 147, 8202, 147, 12290, 273,
    147, 4096, 273, 9, 36864, 273, 16, 4097, 273, 12290, 273, 147, 8199, 147,
    12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147,
    8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8199, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8197, 147, 12288, 15, 18, 680, 147, 12288, 15, 18, 698, 147, 12291, 273,
    147, 8200, 147, 12288, 15, 18, 680, 147, 12288, 15, 18, 698, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 14,
    756, 0, 147, 12288, 14, 756, 18, 147, 12291, 273, 147, 12288, 34, 54, 108,
    147, 12288, 34, 54, 126, 147, 12288, 34, 54, 144, 147, 8197, 147, 12288,
    14, 756, 0, 147, 12288, 14, 756, 18, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8197, 147, 12288, 14, 774, 0, 147, 12288, 14,
    774, 18, 147, 12291, 273, 147, 12288, 34, 72, 108, 147, 12288, 34, 72, 126,
    147, 12288, 34, 72, 144, 147, 8197, 147, 12288, 14, 774, 0, 147, 12288, 14,
    774, 18, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8196, 147, 12288, 50, 72, 0, 147, 12288, 14, 792, 0, 147, 12288, 14, 792,
    18, 147, 12291, 273, 147, 12288, 34, 90, 108, 147, 12288, 34, 90, 126, 147,
    12288, 34, 90, 144, 147, 8197, 147, 12288, 14, 792, 0, 147, 12288, 14, 792,
    18, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8195,
    147, 12288, 101, 270, 0, 147, 12288, 101, 270, 18, 147, 12288, 101, 270,
    36, 147, 12288, 101, 270, 54, 147, 12291, 273, 147, 8200, 147, 12288, 15,
    0, 680, 147, 12288, 15, 0, 698, 147, 12290, 273, 147, 4096, 273, 11, 4096,
    273, 12290, 273, 147, 8195, 147, 12288, 101, 288, 0, 147, 12288, 101, 288,
    18, 147, 12288, 101, 288, 36, 147, 12288, 101, 288, 54, 147, 12291, 273,
    147, 8202, 147, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147,
    8195, 147, 12288, 101, 306, 0, 147, 12288, 101, 306, 18, 147, 12288, 101,
    306, 36, 147, 12288, 101, 306, 54, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 186,
    1350, 0, 147, 12288, 186, 1350, 18, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 186,
    1368, 0, 147, 12288, 186, 1368, 18, 147, 12291, 273, 147, 8202, 147, 12290,
    273, 147, 4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 186,
    1386, 0, 147, 12288, 186, 1386, 18, 147, 12291, 273, 147, 45056, 38, 147,
    2088, 8200, 147, 45056, 38, 147, 2072, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12290, 273, 147, 8199, 147, 12291, 273, 147, 45056, 38, 5, 2048,
    8200, 5, 45056, 38, 5, 2048, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 45056, 38, 5, 2048, 8200, 5,
    45056, 38, 5, 2048, 12290, 273, 147, 4096, 273, 11, 4096, 273, 12290, 273,
    147, 8197, 147, 12288, 50, 36, 0, 147, 12288, 18, 540, 0, 147, 12291, 273,
    147, 45056, 38, 5, 2048, 8200, 5, 45056, 38, 5, 2048, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 50, 18, 0,
    147, 12288, 18, 558, 0, 147, 12291, 273, 147, 45056, 38, 147, 2080, 8200,
    147, 45056, 38, 147, 2064, 12290, 273, 147, 4096, 273, 11, 4096, 273,
    12290, 273, 147, 8199, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 50, 54, 0,
    147, 12288, 18, 540, 0, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147,
    4096, 273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 50, 0, 0, 147,
    12288, 18, 558, 0, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096,
    273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 15, 0, 680, 147,
    12288, 15, 0, 698, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096,
    273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 21, 540, 0, 147,
    12288, 21, 540, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096,
    273, 11, 4096, 273, 12290, 273, 147, 8197, 147, 12288, 21, 558, 0, 147,
    12288, 21, 558, 18, 147, 12291, 273, 147, 8202, 147, 12290, 273, 147, 4096,
    273, 11, 4096, 273, 12302, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273,
    11, 4096, 273, 12302, 273, 147, 8202, 147, 12290, 273, 147, 4096, 273, 11,
    4096, 273, 12302, 273, 147, 4100, 273, 12290, 273, 147, 12288, 10, 36, 702,
    147, 12288, 10, 36, 720, 147, 12288, 10, 36, 738, 147, 12290, 273, 147,
    4096, 273, 11, 36864, 273, 16, 4107, 273, 12290, 273, 147, 4100, 273,
    12290, 273, 147, 8194, 147, 12290, 273, 147, 4096, 273, 23, 4096, 273,
    12290, 273, 147, 4103, 273, 4096, 42, 0, 0, 4096, 42, 0, 18, 0, 4099, 273,
    23, 36864, 273, 16, 4105, 273, 36864, 273, 32, 2, 4099, 273
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer
getBuilding(Building buildingId, const std::vector<bool> &framedTiles)
{
    return {buildingData[static_cast<int>(buildingId)].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Buildings.h`
```
#ifndef BUILDINGS_H
#define BUILDINGS_H

#include "TileBuffer.h"

namespace Data
{

enum class Building {
    desertTomb1 = 0,
    desertTomb2,
    desertTomb3,
    desertTomb4,
    spiderHall1,
    spiderHall2
};

TileBuffer
getBuilding(Building buildingId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // BUILDINGS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/DecoGems.cpp`
```
#include "structures/data/DecoGems.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> gemData{
// gem1
{
    514, 36867, 267, 2048
},
// gem2
{
    514, 36864, 267, 2072, 36864, 267, 2088, 36864, 267, 2064, 36864, 267, 2080
},
// gem3
{
    515, 36864, 267, 2072, 36864, 267, 2048, 36864, 267, 2088, 36864, 267,
    2064, 36864, 267, 2048, 36864, 267, 2080
},
// gem4
{
    771, 36864, 267, 2072, 36864, 267, 2048, 36864, 267, 2088, 36866, 267,
    2048, 36864, 267, 2064, 36864, 267, 2048, 36864, 267, 2080
},
// gem5
{
    514, 36864, 267, 2072, 36865, 267, 2048, 36864, 267, 2080
},
// gem6
{
    514, 36864, 267, 2048, 36864, 267, 2088, 36864, 267, 2064, 36864, 267, 2048
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getDecoGem(int gemId, const std::vector<bool> &framedTiles)
{
    return {gemData[gemId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/DecoGems.h`
```
#ifndef DECOGEMS_H
#define DECOGEMS_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto gems = std::views::iota(0, 6);

TileBuffer getDecoGem(int gemId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // DECOGEMS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/DungeonRooms.cpp`
```
#include "structures/data/DungeonRooms.h"

#include "ids/WallID.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> roomData{
// dungeonEntranceLeft
{
    21278, 7, 4100, 41, 5, 4103, 189, 4098, 41, 7, 4096, 41, 12290, 41, 7,
    4096, 41, 8, 4100, 189, 4096, 41, 12289, 41, 7, 7, 4098, 41, 12288, 41, 7,
    4096, 41, 10, 4098, 189, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7,
    4096, 41, 11, 4097, 189, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7,
    4097, 41, 10, 4097, 189, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12290, 41, 7,
    8203, 7, 12288, 189, 7, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7, 8203, 7,
    12288, 189, 7, 12290, 41, 7, 7, 4098, 41, 12290, 41, 7, 8203, 7, 12288,
    189, 7, 12290, 41, 7, 7, 4096, 41, 12292, 41, 7, 8204, 7, 12290, 41, 7, 7,
    4098, 41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 9, 4096, 41,
    12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41,
    7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096,
    41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13,
    4096, 41, 12289, 41, 7, 7, 4098, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41,
    12289, 41, 7, 7, 4096, 41, 12290, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41,
    7, 7, 4098, 41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 9,
    4096, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7,
    8204, 7, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7, 8203, 7, 28672, 189, 7,
    1, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 7, 4098,
    41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 7, 4096, 41, 12290,
    41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 7, 4098, 41, 12288, 41, 7,
    4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41,
    13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096,
    41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289,
    41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 7,
    4098, 41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 7, 4096, 41,
    12292, 41, 7, 8204, 7, 12290, 41, 7, 7, 4098, 41, 12290, 41, 7, 8204, 7,
    12290, 41, 7, 9, 4096, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 9, 4096,
    41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 9, 4096, 41, 12288, 41, 7, 4097,
    41, 12, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13,
    4096, 41, 12289, 41, 7, 7, 4098, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41,
    12289, 41, 7, 7, 4096, 41, 12290, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41,
    7, 7, 4098, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9,
    4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41,
    12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41,
    7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12290, 41, 7, 8204,
    7, 12290, 41, 7, 7, 4098, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 7, 4096,
    41, 12292, 41, 7, 8204, 7, 12290, 41, 7, 7, 4098, 41, 12290, 41, 7, 8204,
    7, 12290, 41, 7, 9, 4096, 41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289,
    41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7,
    4106, 41, 12288, 41, 7, 4106, 41, 36864, 41, 40, 2, 4096, 41, 12289, 41, 7,
    4096, 41, 12309, 41, 7, 4096, 41, 4096, 10, 18, 0, 4096, 10, 18, 18, 4096,
    10, 0, 36, 4096, 41, 12289, 41, 7, 4096, 41, 12309, 41, 7, 45056, 41, 7,
    32, 8194, 7, 12290, 41, 7, 4099, 41, 12289, 41, 7, 8202, 7, 12288, 50, 72,
    0, 7, 12288, 19, 108, 0, 7, 8192, 7, 12288, 50, 0, 0, 7, 12288, 19, 54, 0,
    7, 8196, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8205, 7, 12288, 50,
    18, 0, 7, 12288, 19, 18, 0, 7, 8196, 7, 12290, 41, 7, 2, 4096, 41, 12289,
    41, 7, 8212, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290,
    41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 4099, 41, 12289,
    41, 7, 8212, 7, 12290, 41, 7, 4096, 41, 12292, 41, 7, 8212, 7, 12290, 41,
    7, 4096, 41, 12292, 41, 7, 8212, 7, 12290, 41, 7, 4099, 41, 12289, 41, 7,
    8212, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 2,
    4096, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7,
    8212, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7,
    4099, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 4096, 41, 12292, 41, 7,
    8212, 7, 12290, 41, 7, 4096, 41, 12292, 41, 7, 8212, 7, 12290, 41, 7, 4099,
    41, 12289, 41, 7, 8212, 7, 12288, 19, 54, 0, 7, 12289, 41, 7, 2, 4096, 41,
    12289, 41, 7, 8212, 7, 12288, 19, 0, 0, 7, 12289, 41, 7, 2, 4096, 41,
    12289, 41, 7, 8212, 7, 12288, 19, 0, 0, 7, 12289, 41, 7, 2, 4096, 41,
    12289, 41, 7, 8211, 7, 28672, 189, 7, 10, 12288, 19, 0, 0, 7, 12289, 41, 7,
    2, 4096, 41, 12289, 41, 7, 8212, 7, 12288, 19, 0, 0, 7, 12289, 41, 7, 4099,
    41, 12289, 41, 7, 8212, 7, 12288, 19, 0, 0, 7, 12289, 41, 7, 4096, 41,
    12292, 41, 7, 8212, 7, 12288, 19, 72, 0, 7, 12289, 41, 7, 4096, 41, 12292,
    41, 7, 8212, 7, 12290, 41, 7, 4099, 41, 12289, 41, 7, 8212, 7, 12290, 41,
    7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 2, 4096, 41, 12289,
    41, 7, 8212, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8208, 7, 12288,
    101, 0, 0, 7, 12288, 101, 0, 18, 7, 12288, 101, 0, 36, 7, 12288, 101, 0,
    54, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8205, 7, 12288, 50, 36, 0,
    7, 12288, 19, 36, 0, 7, 8192, 7, 12288, 101, 18, 0, 7, 12288, 101, 18, 18,
    7, 12288, 101, 18, 36, 7, 12288, 101, 18, 54, 7, 12290, 41, 7, 4099, 41,
    12289, 41, 7, 8202, 7, 12288, 50, 54, 0, 7, 12288, 19, 126, 0, 7, 8192, 7,
    12288, 50, 0, 0, 7, 12288, 19, 72, 0, 7, 8192, 7, 12288, 101, 36, 0, 7,
    12288, 101, 36, 18, 7, 12288, 101, 36, 36, 7, 12288, 101, 36, 54, 7, 12290,
    41, 7, 4096, 41, 12316, 41, 7, 4096, 41, 12316, 41, 7, 4125, 41
},
// dungeonEntranceRight
{
    21278, 4126, 41, 12316, 41, 7, 4096, 41, 12316, 41, 7, 4099, 41, 12289, 41,
    7, 8202, 7, 12288, 50, 54, 0, 7, 12288, 19, 108, 0, 7, 8192, 7, 12288, 50,
    0, 0, 7, 12288, 19, 54, 0, 7, 8192, 7, 12288, 101, 0, 0, 7, 12288, 101, 0,
    18, 7, 12288, 101, 0, 36, 7, 12288, 101, 0, 54, 7, 12290, 41, 7, 2, 4096,
    41, 12289, 41, 7, 8205, 7, 12288, 50, 36, 0, 7, 12288, 19, 18, 0, 7, 8192,
    7, 12288, 101, 18, 0, 7, 12288, 101, 18, 18, 7, 12288, 101, 18, 36, 7,
    12288, 101, 18, 54, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8208, 7,
    12288, 101, 36, 0, 7, 12288, 101, 36, 18, 7, 12288, 101, 36, 36, 7, 12288,
    101, 36, 54, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290,
    41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 4099, 41, 12289,
    41, 7, 8212, 7, 12290, 41, 7, 4096, 41, 12292, 41, 7, 8212, 7, 12290, 41,
    7, 4096, 41, 12292, 41, 7, 8212, 7, 12288, 19, 54, 0, 7, 12289, 41, 7,
    4099, 41, 12289, 41, 7, 8212, 7, 12288, 19, 0, 0, 7, 12289, 41, 7, 2, 4096,
    41, 12289, 41, 7, 8212, 7, 12288, 19, 0, 0, 7, 12289, 41, 7, 2, 4096, 41,
    12289, 41, 7, 8211, 7, 28672, 189, 7, 10, 12288, 19, 0, 0, 7, 12289, 41, 7,
    2, 4096, 41, 12289, 41, 7, 8212, 7, 12288, 19, 0, 0, 7, 12289, 41, 7, 2,
    4096, 41, 12289, 41, 7, 8212, 7, 12288, 19, 0, 0, 7, 12289, 41, 7, 4099,
    41, 12289, 41, 7, 8212, 7, 12288, 19, 72, 0, 7, 12289, 41, 7, 4096, 41,
    12292, 41, 7, 8212, 7, 12290, 41, 7, 4096, 41, 12292, 41, 7, 8212, 7,
    12290, 41, 7, 4099, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 2, 4096, 41,
    12289, 41, 7, 8212, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7,
    12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 2, 4096,
    41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 4099, 41, 12289, 41, 7, 8212, 7,
    12290, 41, 7, 4096, 41, 12292, 41, 7, 8212, 7, 12290, 41, 7, 4096, 41,
    12292, 41, 7, 8212, 7, 12290, 41, 7, 4099, 41, 12289, 41, 7, 8212, 7,
    12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 2, 4096,
    41, 12289, 41, 7, 8212, 7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8212,
    7, 12290, 41, 7, 2, 4096, 41, 12289, 41, 7, 8205, 7, 12288, 50, 18, 0, 7,
    12288, 19, 36, 0, 7, 8196, 7, 12290, 41, 7, 4099, 41, 12289, 41, 7, 8202,
    7, 12288, 50, 72, 0, 7, 12288, 19, 126, 0, 7, 8192, 7, 12288, 50, 0, 0, 7,
    12288, 19, 72, 0, 7, 8196, 7, 12290, 41, 7, 4096, 41, 12309, 41, 7, 45056,
    41, 7, 40, 8194, 7, 12290, 41, 7, 4096, 41, 12309, 41, 7, 4096, 41, 4096,
    10, 0, 0, 4096, 10, 18, 18, 4096, 10, 18, 36, 4096, 41, 12289, 41, 7, 4106,
    41, 12288, 41, 7, 4106, 41, 36864, 41, 32, 2, 4096, 41, 12289, 41, 7, 9,
    4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41,
    12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 7, 4098, 41, 12290, 41,
    7, 8204, 7, 12290, 41, 7, 7, 4096, 41, 12292, 41, 7, 8204, 7, 12290, 41, 7,
    7, 4098, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 9, 4096, 41, 12290, 41,
    7, 8204, 7, 12290, 41, 7, 9, 4096, 41, 12288, 41, 7, 4097, 41, 12, 4096,
    41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289,
    41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 7,
    4098, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 7, 4096, 41,
    12290, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 7, 4098, 41, 12288, 41,
    7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096,
    41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4097, 41, 12,
    4096, 41, 12289, 41, 7, 9, 4096, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7,
    9, 4096, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 7, 4098, 41, 12290, 41,
    7, 8204, 7, 12290, 41, 7, 7, 4096, 41, 12292, 41, 7, 8204, 7, 12290, 41, 7,
    7, 4098, 41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 9, 4096,
    41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288,
    41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7,
    4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41,
    13, 4096, 41, 12289, 41, 7, 7, 4098, 41, 12288, 41, 7, 4096, 41, 13, 4096,
    41, 12289, 41, 7, 7, 4096, 41, 12290, 41, 7, 4096, 41, 13, 4096, 41, 12289,
    41, 7, 7, 4098, 41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 9,
    4096, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7,
    8203, 7, 28672, 189, 7, 1, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7, 8204,
    7, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7, 8204, 7, 12290, 41, 7, 7, 4098,
    41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 7, 4096, 41, 12290,
    41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 7, 4098, 41, 12288, 41, 7,
    4096, 41, 13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41,
    13, 4096, 41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096,
    41, 12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289,
    41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 13, 4096, 41, 12289, 41, 7, 7,
    4098, 41, 12288, 41, 7, 4097, 41, 12, 4096, 41, 12289, 41, 7, 7, 4096, 41,
    12292, 41, 7, 8204, 7, 12290, 41, 7, 7, 4098, 41, 12290, 41, 7, 8203, 7,
    12288, 189, 7, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7, 8203, 7, 12288,
    189, 7, 12290, 41, 7, 9, 4096, 41, 12290, 41, 7, 8203, 7, 12288, 189, 7,
    12290, 41, 7, 9, 4096, 41, 12288, 41, 7, 4097, 41, 10, 4097, 189, 4096, 41,
    12289, 41, 7, 9, 4096, 41, 12288, 41, 7, 4096, 41, 11, 4097, 189, 4096, 41,
    12289, 41, 7, 7, 4098, 41, 12288, 41, 7, 4096, 41, 10, 4098, 189, 4096, 41,
    12289, 41, 7, 7, 4096, 41, 12290, 41, 7, 4096, 41, 8, 4100, 189, 4096, 41,
    12289, 41, 7, 7, 4100, 41, 5, 4103, 189, 4098, 41
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getDungeonRoom(
    Room roomId,
    Variant furnitureSet,
    const std::vector<bool> &framedTiles)
{
    TileBuffer data{roomData[static_cast<int>(roomId)].data(), framedTiles};
    int themeBrick = TileID::blueBrick;
    int themeWall = WallID::Unsafe::blueBrick;
    if (furnitureSet == Variant::greenDungeon) {
        themeBrick = TileID::greenBrick;
        themeWall = WallID::Unsafe::greenBrick;
    } else if (furnitureSet == Variant::pinkDungeon) {
        themeBrick = TileID::pinkBrick;
        themeWall = WallID::Unsafe::pinkBrick;
    }
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &tile = data.getTile(i, j);
            if (tile.blockID == TileID::blueBrick) {
                tile.blockID = themeBrick;
            } else {
                convertFurniture(tile, furnitureSet);
            }
            if (tile.wallID == WallID::Unsafe::blueBrick) {
                tile.wallID = themeWall;
            }
        }
    }
    return data;
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/DungeonRooms.h`
```
#ifndef DUNGEONROOMS_H
#define DUNGEONROOMS_H

#include "structures/data/Furniture.h"

namespace Data
{

enum class Room { entranceLeft = 0, entranceRight };

TileBuffer getDungeonRoom(
    Room roomId,
    Variant furnitureSet,
    const std::vector<bool> &framedTiles);

} // namespace Data

#endif // DUNGEONROOMS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/DynCabin.cpp`
```
#include "structures/data/Homes.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> cabinLeftData{
// cabinLeft1
{
    519, 36864, 30, 24, 4097, 30, 4096, 10, 72, 432, 4096, 10, 54, 450, 4096,
    10, 72, 468, 4096, 38, 4096, 30, 45056, 30, 5, 32, 8192, 5, 8192, 27, 8193,
    4, 4096, 38
},
// cabinLeft2
{
    777, 4103, 189, 4096, 39, 4096, 189, 4096, 312, 4098, 39, 4096, 10, 36, 0,
    4096, 10, 0, 18, 4096, 10, 0, 36, 4096, 39, 36864, 312, 8, 4096, 312, 4096,
    39, 24576, 5, 3328, 8192, 6, 24576, 5, 3328, 8192, 6, 24576, 5, 3328, 4096,
    39
},
// cabinLeft3
{
    521, 4096, 189, 4096, 313, 4102, 189, 36864, 313, 8, 4096, 313, 4098, 175,
    4096, 10, 18, 810, 4096, 10, 18, 828, 4096, 10, 0, 846, 4096, 30
},
// cabinLeft4
{
    520, 4099, 38, 4096, 10, 18, 756, 4096, 10, 36, 774, 4096, 10, 0, 792,
    4097, 38, 8193, 5, 8192, 27, 8193, 4, 8192, 5, 4096, 38
},
// cabinLeft5
{
    776, 20483, 176, 28, 20480, 10, 54, 432, 28, 20480, 10, 90, 450, 28, 20480,
    10, 90, 468, 28, 20481, 176, 28, 24581, 46, 7168, 20481, 176, 28, 24576,
    46, 7168, 24578, 4, 7168, 24577, 46, 7168, 20480, 176, 28
},
};

std::vector<std::vector<uint16_t>> cabinCenterData{
// cabinCenter1
{
    263, 4096, 30, 8193, 5, 8192, 27, 8193, 4, 4096, 38
},
// cabinCenter2
{
    521, 4097, 312, 4096, 39, 8192, 6, 24576, 5, 3328, 8192, 6, 24576, 5, 3328,
    8192, 6, 4096, 39, 4097, 312, 4096, 39, 24576, 5, 3328, 8192, 6, 24576, 5,
    3328, 8192, 6, 24576, 5, 3328, 4096, 39
},
// cabinCenter3
{
    265, 4097, 313, 4096, 175, 8193, 45, 8192, 5, 8192, 27, 8192, 4, 4096, 30
},
// cabinCenter4
{
    264, 4096, 38, 8192, 5, 8192, 126, 8192, 27, 8193, 4, 8192, 5, 4096, 38
},
// cabinCenter5
{
    264, 20480, 176, 28, 24576, 46, 7168, 24576, 4, 7168, 24576, 21, 7168,
    24576, 4, 7168, 24577, 46, 7168, 20480, 176, 28
},
};

std::vector<std::vector<uint16_t>> cabinRightData{
// cabinRight1
{
    519, 4096, 30, 45056, 30, 5, 40, 8192, 5, 8192, 27, 8193, 4, 4096, 38,
    36864, 30, 16, 4097, 30, 4096, 10, 90, 432, 4096, 10, 90, 450, 4096, 10,
    90, 468, 4096, 38
},
// cabinRight2
{
    1033, 4097, 312, 4096, 39, 8192, 6, 24576, 5, 3328, 8192, 6, 24576, 5,
    3328, 8192, 6, 4096, 39, 36864, 312, 8, 4096, 312, 4096, 39, 24576, 5,
    3328, 8192, 6, 24576, 5, 3328, 8192, 6, 24576, 5, 3328, 4096, 39, 4096,
    189, 4096, 312, 4098, 39, 4096, 10, 0, 0, 4096, 10, 0, 18, 4096, 10, 0, 36,
    4096, 39, 4103, 189, 4096, 39
},
// cabinRight3
{
    521, 36864, 313, 8, 4096, 313, 4098, 175, 4096, 10, 36, 810, 4096, 10, 0,
    828, 4096, 10, 0, 846, 4096, 30, 4096, 189, 4096, 313, 4102, 189
},
// cabinRight4
{
    520, 4096, 38, 8193, 5, 8192, 27, 8193, 4, 8192, 5, 4100, 38, 4096, 10, 18,
    756, 4096, 10, 18, 774, 4096, 10, 36, 792, 4096, 38
},
// cabinRight5
{
    776, 20480, 176, 28, 24576, 46, 7168, 24578, 4, 7168, 24577, 46, 7168,
    20481, 176, 28, 24581, 46, 7168, 20484, 176, 28, 20480, 10, 90, 432, 28,
    20480, 10, 90, 450, 28, 20480, 10, 72, 468, 28, 20480, 176, 28
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer
getCabin(int cabinId, int targetWidth, const std::vector<bool> &framedTiles)
{
    TileBuffer left = {cabinLeftData[cabinId].data(), framedTiles};
    TileBuffer center = {cabinCenterData[cabinId].data(), framedTiles};
    TileBuffer right = {cabinRightData[cabinId].data(), framedTiles};
    int width = left.getWidth() + right.getWidth();
    while (width < targetWidth) {
        width += center.getWidth();
    }
    int x = left.getWidth();
    left.resize(width, left.getHeight());
    for (; x < width - right.getWidth(); x += center.getWidth()) {
        for (int i = 0; i < center.getWidth(); ++i) {
            for (int j = 0; j < center.getHeight(); ++j) {
                left.getTile(x + i, j) = center.getTile(i, j);
            }
        }
    }
    for (int i = 0; i < right.getWidth(); ++i) {
        for (int j = 0; j < right.getHeight(); ++j) {
            left.getTile(x + i, j) = right.getTile(i, j);
        }
    }
    return left;
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/DynCabin.h`
```
#ifndef DYNCABIN_H
#define DYNCABIN_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto cabins = std::views::iota(0, 5);

TileBuffer
getCabin(int cabinId, int targetWidth, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // DYNCABIN_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Furniture.cpp`
```
#include "structures/data/Furniture.h"

#include "vendor/frozen/map.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> furnitureData{
// furniture1
{
    1798, 4, 4096, 189, 1, 4096, 93, 0, 0, 4096, 93, 0, 18, 4096, 93, 0, 36,
    4096, 189, 2, 4096, 89, 0, 0, 4096, 89, 0, 18, 4096, 189, 2, 4096, 89, 18,
    0, 4096, 89, 18, 18, 4096, 189, 2, 4096, 89, 36, 0, 4096, 89, 36, 18, 4096,
    189, 1, 4096, 93, 0, 0, 4096, 93, 0, 18, 4096, 93, 0, 36, 4096, 189, 4,
    4096, 189
},
// furniture2
{
    1030, 4097, 189, 3, 4096, 189, 4, 4096, 189, 4096, 42, 0, 0, 4096, 42, 0,
    18, 2, 4096, 189, 4
},
// furniture3
{
    1030, 4096, 189, 4, 4096, 189, 4096, 42, 0, 0, 4096, 42, 0, 18, 2, 4096,
    189, 4, 4097, 189, 3
},
// furniture4
{
    1798, 4096, 189, 4, 4096, 189, 4096, 42, 0, 0, 4096, 42, 0, 18, 2, 4096,
    189, 4, 4096, 189, 4, 4096, 189, 4, 4096, 189, 4096, 42, 0, 0, 4096, 42, 0,
    18, 2, 4096, 189, 4
},
// furniture5
{
    1541, 2, 4096, 18, 0, 0, 4096, 189, 1, 4096, 33, 0, 0, 4096, 18, 18, 0,
    4096, 189, 1, 4096, 87, 0, 0, 4096, 87, 0, 18, 4096, 189, 1, 4096, 87, 18,
    0, 4096, 87, 18, 18, 4096, 189, 1, 4096, 87, 36, 0, 4096, 87, 36, 18, 4096,
    189, 3, 4096, 189
},
// furniture6
{
    1286, 4, 4096, 189, 2, 4096, 15, 18, 0, 4096, 15, 18, 18, 4096, 189, 2,
    4096, 14, 0, 0, 4096, 14, 0, 18, 4096, 189, 0, 4096, 100, 0, 0, 4096, 100,
    0, 18, 4096, 14, 18, 0, 4096, 14, 18, 18, 4096, 189, 0, 4096, 100, 18, 0,
    4096, 100, 18, 18, 4096, 14, 36, 0, 4096, 14, 36, 18, 4096, 189
},
// furniture7
{
    1798, 0, 4096, 101, 0, 0, 4096, 101, 0, 18, 4096, 101, 0, 36, 4096, 101, 0,
    54, 4096, 189, 0, 4096, 101, 18, 0, 4096, 101, 18, 18, 4096, 101, 18, 36,
    4096, 101, 18, 54, 4096, 189, 0, 4096, 101, 36, 0, 4096, 101, 36, 18, 4096,
    101, 36, 36, 4096, 101, 36, 54, 4096, 189, 0, 4096, 33, 0, 0, 4096, 19, 90,
    0, 1, 4096, 189, 0, 4096, 101, 0, 0, 4096, 101, 0, 18, 4096, 101, 0, 36,
    4096, 101, 0, 54, 4096, 189, 0, 4096, 101, 18, 0, 4096, 101, 18, 18, 4096,
    101, 18, 36, 4096, 101, 18, 54, 4096, 189, 0, 4096, 101, 36, 0, 4096, 101,
    36, 18, 4096, 101, 36, 36, 4096, 101, 36, 54, 4096, 189
},
// furniture8
{
    2053, 1, 4098, 189, 1, 4096, 79, 72, 0, 4096, 79, 72, 18, 4096, 189, 1,
    4096, 79, 90, 0, 4096, 79, 90, 18, 4096, 189, 1, 4096, 79, 108, 0, 4096,
    79, 108, 18, 4096, 189, 1, 4096, 79, 126, 0, 4096, 79, 126, 18, 4096, 189,
    1, 4096, 21, 0, 0, 4096, 21, 0, 18, 4096, 189, 1, 4096, 21, 18, 0, 4096,
    21, 18, 18, 4096, 189, 3, 4096, 189
},
// furniture9
{
    1287, 4096, 189, 5, 4096, 189, 4096, 34, 0, 0, 4096, 34, 0, 18, 4096, 34,
    0, 36, 2, 4096, 189, 4096, 34, 18, 0, 4096, 34, 18, 18, 4096, 34, 18, 36,
    2, 4096, 189, 4096, 34, 36, 0, 4096, 34, 36, 18, 4096, 34, 36, 36, 2, 4096,
    189, 5
},
// furniture10
{
    1031, 0, 4096, 104, 0, 0, 4096, 104, 0, 18, 4096, 104, 0, 36, 4096, 104, 0,
    54, 4096, 104, 0, 72, 4096, 189, 0, 4096, 104, 18, 0, 4096, 104, 18, 18,
    4096, 104, 18, 36, 4096, 104, 18, 54, 4096, 104, 18, 72, 4096, 189, 2,
    4096, 105, 0, 162, 4096, 105, 0, 180, 4096, 105, 0, 198, 4096, 189, 2,
    4096, 105, 18, 162, 4096, 105, 18, 180, 4096, 105, 18, 198, 4096, 189
},
// furniture11
{
    1797, 0, 4096, 105, 0, 0, 4096, 105, 0, 18, 4096, 105, 0, 36, 4096, 189, 0,
    4096, 105, 18, 0, 4096, 105, 18, 18, 4096, 105, 18, 36, 4096, 189, 1, 4096,
    90, 0, 0, 4096, 90, 0, 18, 4096, 189, 1, 4096, 90, 18, 0, 4096, 90, 18, 18,
    4096, 189, 1, 4096, 90, 36, 0, 4096, 90, 36, 18, 4096, 189, 1, 4096, 90,
    54, 0, 4096, 90, 54, 18, 4096, 189, 0, 4096, 93, 0, 0, 4096, 93, 0, 18,
    4096, 93, 0, 36, 4096, 189
},
// furniture12
{
    1030, 4, 4096, 189, 1, 4096, 105, 0, 0, 4096, 105, 0, 18, 4096, 105, 0, 36,
    4096, 189, 1, 4096, 105, 18, 0, 4096, 105, 18, 18, 4096, 105, 18, 36, 4096,
    189, 4, 4096, 189
},
// furniture13
{
    2053, 1, 4096, 88, 0, 0, 4096, 88, 0, 18, 4096, 189, 0, 4096, 33, 0, 0,
    4096, 88, 18, 0, 4096, 88, 18, 18, 4096, 189, 1, 4096, 88, 36, 0, 4096, 88,
    36, 18, 4096, 189, 3, 4096, 189, 1, 4096, 79, 0, 0, 4096, 79, 0, 18, 4096,
    189, 1, 4096, 79, 18, 0, 4096, 79, 18, 18, 4096, 189, 1, 4096, 79, 36, 0,
    4096, 79, 36, 18, 4096, 189, 1, 4096, 79, 54, 0, 4096, 79, 54, 18, 4096,
    189
},
// furniture14
{
    1285, 2, 4097, 189, 1, 4096, 497, 18, 0, 4096, 497, 18, 18, 4096, 189, 3,
    4096, 189, 1, 4096, 172, 0, 0, 4096, 172, 0, 18, 4096, 189, 1, 4096, 172,
    18, 0, 4096, 172, 18, 18, 4096, 189
},
// furniture15
{
    1542, 0, 4096, 101, 0, 0, 4096, 101, 0, 18, 4096, 101, 0, 36, 4096, 101, 0,
    54, 4096, 189, 0, 4096, 101, 18, 0, 4096, 101, 18, 18, 4096, 101, 18, 36,
    4096, 101, 18, 54, 4096, 189, 0, 4096, 101, 36, 0, 4096, 101, 36, 18, 4096,
    101, 36, 36, 4096, 101, 36, 54, 4096, 189, 2, 4096, 89, 0, 0, 4096, 89, 0,
    18, 4096, 189, 2, 4096, 89, 18, 0, 4096, 89, 18, 18, 4096, 189, 2, 4096,
    89, 36, 0, 4096, 89, 36, 18, 4096, 189
},
// furniture16
{
    775, 4098, 189, 4, 36864, 19, 90, 0, 8, 4096, 42, 0, 0, 4096, 42, 0, 18, 9
},
// furniture17
{
    775, 7, 36864, 19, 90, 0, 8, 4096, 42, 0, 0, 4096, 42, 0, 18, 2, 4098, 189,
    3
},
// furniture18
{
    1029, 1, 4096, 172, 0, 0, 4096, 172, 0, 18, 4096, 189, 1, 4096, 172, 18, 0,
    4096, 172, 18, 18, 4096, 189, 0, 4096, 100, 0, 0, 4096, 100, 0, 18, 4096,
    18, 0, 0, 4096, 189, 0, 4096, 100, 18, 0, 4096, 100, 18, 18, 4096, 18, 18,
    0, 4096, 189
},
// furniture19
{
    775, 2, 4096, 93, 0, 0, 4096, 93, 0, 18, 4096, 93, 0, 36, 4096, 189, 0,
    4096, 104, 0, 0, 4096, 104, 0, 18, 4096, 104, 0, 36, 4096, 104, 0, 54,
    4096, 104, 0, 72, 4096, 189, 0, 4096, 104, 18, 0, 4096, 104, 18, 18, 4096,
    104, 18, 36, 4096, 104, 18, 54, 4096, 104, 18, 72, 4096, 189
},
// furniture20
{
    1286, 2, 4096, 87, 0, 0, 4096, 87, 0, 18, 4096, 189, 2, 4096, 87, 18, 0,
    4096, 87, 18, 18, 4096, 189, 2, 4096, 87, 36, 0, 4096, 87, 36, 18, 4096,
    189, 1, 4096, 105, 0, 162, 4096, 105, 0, 180, 4096, 105, 0, 198, 4096, 189,
    1, 4096, 105, 18, 162, 4096, 105, 18, 180, 4096, 105, 18, 198, 4096, 189
},
// furniture21
{
    1798, 4, 4096, 189, 2, 4096, 15, 18, 0, 4096, 15, 18, 18, 4096, 189, 2,
    4096, 14, 0, 0, 4096, 14, 0, 18, 4096, 189, 2, 4096, 14, 18, 0, 4096, 14,
    18, 18, 4096, 189, 2, 4096, 14, 36, 0, 4096, 14, 36, 18, 4096, 189, 2,
    4096, 15, 0, 0, 4096, 15, 0, 18, 4096, 189, 4, 4096, 189
},
// furniture22
{
    1799, 4096, 189, 5, 4096, 189, 5, 4096, 189, 4096, 34, 0, 0, 4096, 34, 0,
    18, 4096, 34, 0, 36, 2, 4096, 189, 4096, 34, 18, 0, 4096, 34, 18, 18, 4096,
    34, 18, 36, 2, 4096, 189, 4096, 34, 36, 0, 4096, 34, 36, 18, 4096, 34, 36,
    36, 2, 4096, 189, 5, 4096, 189, 5
},
// furniture23
{
    1542, 4, 4096, 189, 4, 4096, 189, 2, 4096, 15, 0, 0, 4096, 15, 0, 18, 4096,
    189, 0, 4096, 101, 0, 0, 4096, 101, 0, 18, 4096, 101, 0, 36, 4096, 101, 0,
    54, 4096, 189, 0, 4096, 101, 18, 0, 4096, 101, 18, 18, 4096, 101, 18, 36,
    4096, 101, 18, 54, 4096, 189, 0, 4096, 101, 36, 0, 4096, 101, 36, 18, 4096,
    101, 36, 36, 4096, 101, 36, 54, 4096, 189
},
// furniture24
{
    1797, 1, 4096, 90, 72, 0, 4096, 90, 72, 18, 4096, 189, 1, 4096, 90, 90, 0,
    4096, 90, 90, 18, 4096, 189, 1, 4096, 90, 108, 0, 4096, 90, 108, 18, 4096,
    189, 1, 4096, 90, 126, 0, 4096, 90, 126, 18, 4096, 189, 0, 4096, 93, 0, 0,
    4096, 93, 0, 18, 4096, 93, 0, 36, 4096, 189, 3, 4096, 189, 1, 4096, 497, 0,
    0, 4096, 497, 0, 18, 4096, 189
},
// furniture25
{
    1797, 3, 4096, 189, 2, 4096, 18, 0, 0, 4096, 189, 2, 4096, 18, 18, 0, 4096,
    189, 1, 4096, 89, 0, 0, 4096, 89, 0, 18, 4096, 189, 1, 4096, 89, 18, 0,
    4096, 89, 18, 18, 4096, 189, 1, 4096, 89, 36, 0, 4096, 89, 36, 18, 4096,
    189, 3, 4096, 189
},
// furniture26
{
    773, 1, 4096, 33, 0, 0, 4096, 18, 0, 0, 4096, 189, 2, 4096, 18, 18, 0,
    4096, 189, 1, 4096, 15, 0, 0, 4096, 15, 0, 18, 4096, 189
},
// furniture27
{
    2310, 4, 4096, 189, 0, 4096, 101, 0, 0, 4096, 101, 0, 18, 4096, 101, 0, 36,
    4096, 101, 0, 54, 4096, 189, 0, 4096, 101, 18, 0, 4096, 101, 18, 18, 4096,
    101, 18, 36, 4096, 101, 18, 54, 4096, 189, 0, 4096, 101, 36, 0, 4096, 101,
    36, 18, 4096, 101, 36, 36, 4096, 101, 36, 54, 4096, 189, 4, 4096, 189, 2,
    4096, 88, 0, 0, 4096, 88, 0, 18, 4096, 189, 2, 4096, 88, 18, 0, 4096, 88,
    18, 18, 4096, 189, 2, 4096, 88, 36, 0, 4096, 88, 36, 18, 4096, 189, 4,
    4096, 189
},
// furniture28
{
    1799, 5, 4096, 189, 0, 4096, 104, 0, 0, 4096, 104, 0, 18, 4096, 104, 0, 36,
    4096, 104, 0, 54, 4096, 104, 0, 72, 4096, 189, 0, 4096, 104, 18, 0, 4096,
    104, 18, 18, 4096, 104, 18, 36, 4096, 104, 18, 54, 4096, 104, 18, 72, 4096,
    189, 3, 4096, 87, 0, 0, 4096, 87, 0, 18, 4096, 189, 3, 4096, 87, 18, 0,
    4096, 87, 18, 18, 4096, 189, 3, 4096, 87, 36, 0, 4096, 87, 36, 18, 4096,
    189, 5, 4096, 189
},
// furniture29
{
    1542, 4, 4096, 189, 2, 4096, 14, 0, 0, 4096, 14, 0, 18, 4096, 189, 2, 4096,
    14, 18, 0, 4096, 14, 18, 18, 4096, 189, 2, 4096, 14, 36, 0, 4096, 14, 36,
    18, 4096, 189, 2, 4096, 15, 0, 0, 4096, 15, 0, 18, 4096, 189, 4, 4096, 189
},
};

std::vector<std::vector<uint16_t>> lanternData{
// chainLantern1
{
    263, 4099, 214, 4096, 19, 90, 162, 4096, 42, 0, 144, 4096, 42, 0, 162
},
// chainLantern2
{
    263, 4099, 214, 4096, 19, 90, 162, 4096, 42, 0, 216, 4096, 42, 0, 234
},
// chainLantern3
{
    263, 4099, 214, 4096, 19, 90, 162, 4096, 42, 18, 900, 4096, 42, 18, 918
},
};
// clang-format on
} // namespace

namespace Data
{

inline constexpr auto frameDetail =
    frozen::make_map<std::pair<int, Variant>, std::pair<int, int>>({
        // Base: Metal Bathtub
        {{TileID::bathtub, Variant::blueDungeon}, {0, 756}},
        {{TileID::bathtub, Variant::greenDungeon}, {0, 792}},
        {{TileID::bathtub, Variant::pinkDungeon}, {0, 828}},
        {{TileID::bathtub, Variant::mushroom}, {0, 648}},
        {{TileID::bathtub, Variant::obsidian}, {0, 900}},
        // Base: Wooden Bed
        {{TileID::bed, Variant::blueDungeon}, {0, 180}},
        {{TileID::bed, Variant::greenDungeon}, {0, 216}},
        {{TileID::bed, Variant::pinkDungeon}, {0, 252}},
        {{TileID::bed, Variant::mushroom}, {0, 828}},
        {{TileID::bed, Variant::obsidian}, {0, 288}},
        // Base: Wooden Bench
        {{TileID::bench, Variant::blueDungeon}, {324, 0}},
        {{TileID::bench, Variant::greenDungeon}, {378, 0}},
        {{TileID::bench, Variant::pinkDungeon}, {432, 0}},
        {{TileID::bench, Variant::mushroom}, {918, 0}},
        {{TileID::bench, Variant::obsidian}, {540, 0}},
        // Base: Wooden Bookcase
        {{TileID::bookcase, Variant::blueDungeon}, {54, 0}},
        {{TileID::bookcase, Variant::greenDungeon}, {108, 0}},
        {{TileID::bookcase, Variant::pinkDungeon}, {162, 0}},
        {{TileID::bookcase, Variant::mushroom}, {1296, 0}},
        {{TileID::bookcase, Variant::obsidian}, {216, 0}},
        // Base: Candelabra
        {{TileID::candelabra, Variant::blueDungeon}, {0, 792}},
        {{TileID::candelabra, Variant::greenDungeon}, {0, 828}},
        {{TileID::candelabra, Variant::pinkDungeon}, {0, 864}},
        {{TileID::candelabra, Variant::mushroom}, {36, 684}},
        {{TileID::candelabra, Variant::obsidian}, {0, 900}},
        {{TileID::candelabra, Variant::ashWood}, {0, 1512}},
        {{TileID::candelabra, Variant::balloon}, {0, 1476}},
        {{TileID::candelabra, Variant::boreal}, {0, 720}},
        {{TileID::candelabra, Variant::forest}, {0, 0}},
        {{TileID::candelabra, Variant::granite}, {0, 1044}},
        {{TileID::candelabra, Variant::honey}, {0, 144}},
        {{TileID::candelabra, Variant::livingWood}, {0, 468}},
        {{TileID::candelabra, Variant::mahogany}, {0, 252}},
        {{TileID::candelabra, Variant::marble}, {0, 1080}},
        {{TileID::candelabra, Variant::palm}, {0, 648}},
        {{TileID::candelabra, Variant::skyware}, {0, 396}},
        // Base: Candle
        {{TileID::candle, Variant::blueDungeon}, {0, 22}},
        {{TileID::candle, Variant::greenDungeon}, {0, 44}},
        {{TileID::candle, Variant::pinkDungeon}, {0, 66}},
        {{TileID::candle, Variant::mushroom}, {18, 418}},
        {{TileID::candle, Variant::obsidian}, {0, 550}},
        {{TileID::candle, Variant::ashWood}, {0, 902}},
        {{TileID::candle, Variant::balloon}, {0, 880}},
        {{TileID::candle, Variant::boreal}, {0, 440}},
        {{TileID::candle, Variant::forest}, {0, 0}},
        {{TileID::candle, Variant::granite}, {0, 616}},
        {{TileID::candle, Variant::honey}, {0, 484}},
        {{TileID::candle, Variant::livingWood}, {0, 308}},
        {{TileID::candle, Variant::mahogany}, {0, 198}},
        {{TileID::candle, Variant::marble}, {0, 638}},
        {{TileID::candle, Variant::palm}, {0, 396}},
        {{TileID::candle, Variant::skyware}, {0, 264}},
        // Base: Wooden Chair
        {{TileID::chair, Variant::blueDungeon}, {0, 520}},
        {{TileID::chair, Variant::greenDungeon}, {0, 560}},
        {{TileID::chair, Variant::pinkDungeon}, {0, 600}},
        {{TileID::chair, Variant::mushroom}, {0, 360}},
        {{TileID::chair, Variant::obsidian}, {0, 640}},
        {{TileID::chair, Variant::ashWood}, {0, 1880}},
        {{TileID::chair, Variant::balloon}, {0, 1840}},
        {{TileID::chair, Variant::boreal}, {0, 1200}},
        {{TileID::chair, Variant::forest}, {0, 0}},
        {{TileID::chair, Variant::granite}, {0, 1360}},
        {{TileID::chair, Variant::honey}, {0, 880}},
        {{TileID::chair, Variant::livingWood}, {0, 200}},
        {{TileID::chair, Variant::mahogany}, {0, 120}},
        {{TileID::chair, Variant::marble}, {0, 1400}},
        {{TileID::chair, Variant::palm}, {0, 1160}},
        {{TileID::chair, Variant::skyware}, {0, 400}},
        // Base: Copper Chandelier
        {{TileID::chandelier, Variant::blueDungeon}, {0, 1458}},
        {{TileID::chandelier, Variant::greenDungeon}, {0, 1512}},
        {{TileID::chandelier, Variant::pinkDungeon}, {0, 1566}},
        {{TileID::chandelier, Variant::mushroom}, {54, 1296}},
        {{TileID::chandelier, Variant::obsidian}, {0, 1728}},
        {{TileID::chandelier, Variant::ashWood}, {108, 594}},
        {{TileID::chandelier, Variant::balloon}, {108, 540}},
        {{TileID::chandelier, Variant::boreal}, {0, 1350}},
        {{TileID::chandelier, Variant::forest}, {0, 0}},
        {{TileID::chandelier, Variant::granite}, {0, 1890}},
        {{TileID::chandelier, Variant::honey}, {0, 540}},
        {{TileID::chandelier, Variant::livingWood}, {0, 972}},
        {{TileID::chandelier, Variant::mahogany}, {0, 648}},
        {{TileID::chandelier, Variant::marble}, {0, 1944}},
        {{TileID::chandelier, Variant::palm}, {0, 1242}},
        {{TileID::chandelier, Variant::skyware}, {0, 810}},
        // Base: Wooden Chest
        {{TileID::chest, Variant::blueDungeon}, {1404, 0}},
        {{TileID::chest, Variant::greenDungeon}, {1260, 0}},
        {{TileID::chest, Variant::pinkDungeon}, {1332, 0}},
        {{TileID::chest, Variant::obsidian}, {1584, 0}},
        {{TileID::chest, Variant::ashWood}, {576, 0}},
        {{TileID::chest, Variant::balloon}, {540, 0}},
        {{TileID::chest, Variant::boreal}, {1188, 0}},
        {{TileID::chest, Variant::forest}, {0, 0}},
        {{TileID::chest, Variant::granite}, {1800, 0}},
        {{TileID::chest, Variant::honey}, {1044, 0}},
        {{TileID::chest, Variant::livingWood}, {432, 0}},
        {{TileID::chest, Variant::mahogany}, {288, 0}},
        {{TileID::chest, Variant::marble}, {1836, 0}},
        {{TileID::chest, Variant::palm}, {1116, 0}},
        {{TileID::chest, Variant::skyware}, {468, 0}},
        // Base: Grandfather Clock
        {{TileID::clock, Variant::blueDungeon}, {1080, 0}},
        {{TileID::clock, Variant::greenDungeon}, {1116, 0}},
        {{TileID::clock, Variant::pinkDungeon}, {1152, 0}},
        {{TileID::clock, Variant::obsidian}, {612, 0}},
        // Base: Wooden Door
        {{TileID::door, Variant::blueDungeon}, {0, 864}},
        {{TileID::door, Variant::greenDungeon}, {0, 918}},
        {{TileID::door, Variant::pinkDungeon}, {0, 972}},
        {{TileID::door, Variant::obsidian}, {0, 1026}},
        {{TileID::door, Variant::ashWood}, {54, 648}},
        {{TileID::door, Variant::balloon}, {54, 594}},
        {{TileID::door, Variant::boreal}, {0, 1620}},
        {{TileID::door, Variant::forest}, {0, 0}},
        {{TileID::door, Variant::granite}, {0, 1836}},
        {{TileID::door, Variant::honey}, {0, 1188}},
        {{TileID::door, Variant::livingWood}, {0, 378}},
        {{TileID::door, Variant::mahogany}, {0, 108}},
        {{TileID::door, Variant::marble}, {0, 1890}},
        {{TileID::door, Variant::palm}, {0, 1566}},
        {{TileID::door, Variant::skyware}, {0, 486}},
        // Base: Wooden Dresser
        {{TileID::dresser, Variant::blueDungeon}, {270, 0}},
        {{TileID::dresser, Variant::greenDungeon}, {324, 0}},
        {{TileID::dresser, Variant::pinkDungeon}, {378, 0}},
        {{TileID::dresser, Variant::mushroom}, {918, 0}},
        {{TileID::dresser, Variant::obsidian}, {486, 0}},
        // Base: Tiki Torch
        {{TileID::lamp, Variant::blueDungeon}, {0, 1296}},
        {{TileID::lamp, Variant::greenDungeon}, {0, 1350}},
        {{TileID::lamp, Variant::pinkDungeon}, {0, 1404}},
        {{TileID::lamp, Variant::mushroom}, {18, 1026}},
        {{TileID::lamp, Variant::obsidian}, {0, 1242}},
        {{TileID::lamp, Variant::ashWood}, {0, 2268}},
        {{TileID::lamp, Variant::balloon}, {0, 2214}},
        {{TileID::lamp, Variant::boreal}, {0, 1080}},
        {{TileID::lamp, Variant::forest}, {0, 216}},
        {{TileID::lamp, Variant::granite}, {0, 1566}},
        {{TileID::lamp, Variant::honey}, {0, 594}},
        {{TileID::lamp, Variant::livingWood}, {0, 702}},
        {{TileID::lamp, Variant::mahogany}, {0, 324}},
        {{TileID::lamp, Variant::marble}, {0, 1620}},
        {{TileID::lamp, Variant::palm}, {0, 972}},
        {{TileID::lamp, Variant::skyware}, {0, 486}},
        // Base: Chain Lantern
        {{TileID::lantern, Variant::blueDungeon}, {0, 36}},
        {{TileID::lantern, Variant::greenDungeon}, {0, 216}},
        {{TileID::lantern, Variant::pinkDungeon}, {0, 180}},
        {{TileID::lantern, Variant::mushroom}, {18, 1008}},
        {{TileID::lantern, Variant::obsidian}, {0, 1152}},
        {{TileID::lantern, Variant::ashWood}, {0, 1728}},
        {{TileID::lantern, Variant::balloon}, {0, 1692}},
        {{TileID::lantern, Variant::boreal}, {0, 1044}},
        {{TileID::lantern, Variant::forest}, {0, 108}},
        {{TileID::lantern, Variant::granite}, {0, 1260}},
        {{TileID::lantern, Variant::honey}, {0, 468}},
        {{TileID::lantern, Variant::livingWood}, {0, 792}},
        {{TileID::lantern, Variant::mahogany}, {0, 576}},
        {{TileID::lantern, Variant::marble}, {0, 1296}},
        {{TileID::lantern, Variant::palm}, {0, 972}},
        {{TileID::lantern, Variant::skyware}, {0, 720}},
        // Base: Wooden Piano
        {{TileID::piano, Variant::blueDungeon}, {594, 0}},
        {{TileID::piano, Variant::greenDungeon}, {648, 0}},
        {{TileID::piano, Variant::pinkDungeon}, {702, 0}},
        {{TileID::piano, Variant::mushroom}, {1188, 0}},
        {{TileID::piano, Variant::obsidian}, {810, 0}},
        // Base: Wood Platform
        {{TileID::platform, Variant::blueDungeon}, {0, 108}},
        {{TileID::platform, Variant::greenDungeon}, {0, 144}},
        {{TileID::platform, Variant::pinkDungeon}, {0, 126}},
        {{TileID::platform, Variant::mushroom}, {0, 324}},
        {{TileID::platform, Variant::obsidian}, {0, 234}},
        {{TileID::platform, Variant::ashWood}, {0, 846}},
        {{TileID::platform, Variant::balloon}, {0, 828}},
        {{TileID::platform, Variant::boreal}, {0, 342}},
        {{TileID::platform, Variant::forest}, {0, 0}},
        {{TileID::platform, Variant::granite}, {0, 504}},
        {{TileID::platform, Variant::honey}, {0, 432}},
        {{TileID::platform, Variant::livingWood}, {0, 414}},
        {{TileID::platform, Variant::mahogany}, {0, 36}},
        {{TileID::platform, Variant::marble}, {0, 522}},
        {{TileID::platform, Variant::palm}, {0, 306}},
        {{TileID::platform, Variant::skyware}, {0, 396}},
        // Base: Wooden Sink
        {{TileID::sink, Variant::blueDungeon}, {0, 380}},
        {{TileID::sink, Variant::greenDungeon}, {0, 418}},
        {{TileID::sink, Variant::pinkDungeon}, {0, 456}},
        {{TileID::sink, Variant::mushroom}, {0, 912}},
        {{TileID::sink, Variant::obsidian}, {0, 494}},
        // Base: Armor Statue
        {{TileID::statue, Variant::blueDungeon}, {1656, 0}},
        {{TileID::statue, Variant::greenDungeon}, {1692, 0}},
        {{TileID::statue, Variant::pinkDungeon}, {1728, 0}},
        {{TileID::statue, Variant::obsidian}, {1764, 0}},
        // Base: Wooden Table
        {{TileID::table, Variant::blueDungeon}, {540, 0}},
        {{TileID::table, Variant::greenDungeon}, {594, 0}},
        {{TileID::table, Variant::pinkDungeon}, {648, 0}},
        {{TileID::table, Variant::mushroom}, {1458, 0}},
        {{TileID::table, Variant::obsidian}, {702, 0}},
        {{TileID::table, Variant::ashWood}, {594, 0}},
        {{TileID::table, Variant::balloon}, {540, 0}},
        {{TileID::table, Variant::boreal}, {1512, 0}},
        {{TileID::table, Variant::forest}, {0, 0}},
        {{TileID::table, Variant::granite}, {1782, 0}},
        {{TileID::table, Variant::honey}, {1026, 0}},
        {{TileID::table, Variant::livingWood}, {324, 0}},
        {{TileID::table, Variant::mahogany}, {108, 0}},
        {{TileID::table, Variant::marble}, {1836, 0}},
        {{TileID::table, Variant::palm}, {1404, 0}},
        {{TileID::table, Variant::skyware}, {378, 0}},
        // Base: Ebonwood Toilet
        {{TileID::toilet, Variant::blueDungeon}, {0, 440}},
        {{TileID::toilet, Variant::greenDungeon}, {0, 480}},
        {{TileID::toilet, Variant::pinkDungeon}, {0, 520}},
        {{TileID::toilet, Variant::mushroom}, {0, 280}},
        {{TileID::toilet, Variant::obsidian}, {0, 560}},
        // Base: Wooden Work Bench
        {{TileID::workBench, Variant::blueDungeon}, {396, 0}},
        {{TileID::workBench, Variant::greenDungeon}, {432, 0}},
        {{TileID::workBench, Variant::pinkDungeon}, {468, 0}},
        {{TileID::workBench, Variant::mushroom}, {252, 0}},
        {{TileID::workBench, Variant::obsidian}, {504, 0}},
    });

bool convertFurniture(Tile &tile, Variant furnitureSet)
{
    auto itr = frameDetail.find(std::pair{tile.blockID, furnitureSet});
    if (itr == frameDetail.end()) {
        return false;
    }
    auto [frameX, frameY] = itr->second;
    tile.frameX += frameX;
    tile.frameY += frameY;
    if (furnitureSet == Variant::ashWood || furnitureSet == Variant::balloon) {
        if (tile.blockID == TileID::chest) {
            tile.blockID = TileID::chestGroup2;
        } else if (tile.blockID == TileID::table) {
            tile.blockID = TileID::tableGroup2;
        }
    }
    return true;
}

TileBuffer
getFurniture(int id, Variant furnitureSet, const std::vector<bool> &framedTiles)
{
    TileBuffer data{furnitureData[id].data(), framedTiles};
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &tile = data.getTile(i, j);
            if (tile.blockID == TileID::cloud) {
                continue;
            }
            if (!convertFurniture(tile, furnitureSet)) {
                tile.blockID = TileID::empty;
                tile.frameX = 0;
                tile.frameY = 0;
            }
        }
    }
    return data;
}

TileBuffer
getChainLantern(::Variant lanternStyle, const std::vector<bool> &framedTiles)
{
    switch (lanternStyle) {
    case ::Variant::alchemy:
        return {lanternData[0].data(), framedTiles};
    case ::Variant::oilRagSconce:
        return {lanternData[1].data(), framedTiles};
    case ::Variant::bone:
        return {lanternData[2].data(), framedTiles};
    default:
        return {};
    }
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Furniture.h`
```
#ifndef FURNITURE_H
#define FURNITURE_H

#include "TileBuffer.h"
#include "ids/TileVariant.h"
#include <ranges>

namespace Data
{

enum class Variant {
    blueDungeon,
    greenDungeon,
    pinkDungeon,
    mushroom,
    obsidian,
    ashWood,
    balloon,
    boreal,
    forest,
    granite,
    honey,
    livingWood,
    mahogany,
    marble,
    palm,
    skyware,
};

inline auto furnitureLayouts = std::views::iota(0, 29);

bool convertFurniture(Tile &tile, Variant furnitureSet);

TileBuffer getFurniture(
    int id,
    Variant furnitureSet,
    const std::vector<bool> &framedTiles);

TileBuffer
getChainLantern(::Variant lanternStyle, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // FURNITURE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Homes.cpp`
```
#include "structures/data/Homes.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> homeData{
// house1
{
    8477, 4110, 189, 20480, 189, 1, 4109, 189, 19, 36864, 19, 144, 0, 24, 4097,
    0, 3, 4097, 189, 18, 36864, 19, 144, 0, 24, 0, 4098, 0, 2, 4097, 189, 17,
    36864, 19, 144, 0, 24, 1, 4098, 0, 2, 4097, 189, 16, 36864, 19, 144, 0, 24,
    2, 4099, 0, 1, 4097, 189, 15, 36864, 19, 144, 0, 24, 3, 4099, 0, 1, 4097,
    189, 5, 36864, 38, 8, 7, 36864, 19, 144, 0, 24, 4, 4099, 0, 1, 4097, 189,
    5, 4096, 38, 4096, 42, 0, 0, 4096, 42, 0, 18, 4, 36864, 19, 144, 0, 24, 5,
    4100, 0, 0, 4097, 189, 4, 36864, 38, 8, 4096, 38, 4099, 30, 4096, 10, 18,
    0, 4096, 10, 36, 18, 4096, 10, 36, 36, 4096, 30, 4101, 124, 4100, 0, 0,
    4097, 189, 4, 4097, 38, 4096, 30, 12288, 21, 0, 0, 5, 12288, 21, 0, 18, 5,
    12288, 19, 54, 0, 4, 8193, 4, 8192, 27, 4096, 30, 8197, 1, 4100, 0, 0,
    4097, 189, 3, 36864, 38, 8, 4097, 38, 4096, 30, 12288, 21, 18, 0, 5, 12288,
    21, 18, 18, 5, 12288, 19, 18, 0, 4, 8193, 4, 8192, 27, 4096, 30, 8197, 1,
    4100, 0, 0, 4097, 189, 3, 4098, 38, 4096, 30, 8193, 5, 8194, 4, 8192, 27,
    4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 2, 36864, 38, 8, 4098, 38, 4096,
    30, 8193, 5, 8194, 4, 8192, 27, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 2,
    4099, 38, 4096, 30, 8193, 5, 8194, 4, 8192, 27, 4096, 30, 8197, 1, 4101, 0,
    4097, 189, 1, 36864, 38, 8, 4099, 38, 4096, 30, 8193, 5, 8194, 4, 8192, 27,
    4096, 30, 8197, 1, 4101, 0, 4097, 189, 4096, 490, 0, 0, 4096, 490, 0, 18,
    4100, 38, 4096, 30, 12288, 34, 0, 0, 5, 12288, 34, 0, 18, 5, 12288, 34, 0,
    36, 4, 8192, 4, 12288, 14, 0, 0, 4, 12288, 14, 0, 18, 27, 4096, 30, 8197,
    1, 4101, 0, 4097, 189, 4096, 490, 18, 0, 4096, 490, 18, 18, 4100, 38, 4096,
    30, 12288, 34, 18, 0, 5, 12288, 34, 18, 18, 5, 12288, 34, 18, 36, 4, 8192,
    4, 12288, 14, 18, 0, 4, 12288, 14, 18, 18, 27, 4096, 30, 12293, 124, 1,
    4101, 0, 4097, 189, 2, 36864, 38, 8, 4098, 38, 4096, 30, 12288, 34, 36, 0,
    5, 12288, 34, 36, 18, 5, 12288, 34, 36, 36, 4, 8192, 4, 12288, 14, 36, 0,
    4, 12288, 14, 36, 18, 27, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 3, 4098,
    38, 4096, 30, 8193, 5, 8193, 4, 12288, 15, 0, 0, 4, 12288, 15, 0, 18, 27,
    4096, 30, 8197, 1, 4101, 0, 4097, 189, 3, 4098, 38, 4096, 30, 8193, 5,
    8194, 4, 8192, 27, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 3, 36864, 38, 8,
    4097, 38, 4096, 30, 8193, 5, 8194, 4, 8192, 27, 4096, 30, 8197, 1, 4101, 0,
    4097, 189, 4, 4097, 38, 4096, 30, 8193, 5, 8194, 4, 8192, 27, 4096, 30,
    8197, 1, 4100, 0, 0, 4097, 189, 4, 4097, 38, 4096, 30, 8193, 5, 8194, 4,
    8192, 27, 4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 4, 36864, 38, 8, 4096,
    38, 4096, 30, 8193, 5, 8194, 4, 8192, 27, 4096, 30, 8197, 1, 4100, 0, 0,
    4097, 189, 5, 4096, 38, 4099, 30, 4096, 10, 36, 0, 4096, 10, 36, 18, 4096,
    10, 36, 36, 4096, 30, 4101, 124, 4100, 0, 0, 4097, 189, 5, 4096, 38, 4096,
    42, 0, 0, 4096, 42, 0, 18, 4, 36864, 19, 180, 0, 16, 5, 4100, 0, 0, 4097,
    189, 5, 36864, 38, 8, 7, 36864, 19, 180, 0, 16, 4, 4099, 0, 1, 4097, 189,
    15, 36864, 19, 180, 0, 16, 3, 4099, 0, 1, 4097, 189, 16, 36864, 19, 180, 0,
    16, 2, 4099, 0, 1, 4097, 189, 17, 36864, 19, 180, 0, 16, 1, 4098, 0, 2,
    4097, 189, 18, 36864, 19, 180, 0, 16, 0, 4098, 0, 2, 4097, 189, 19, 36864,
    19, 180, 0, 16, 4097, 0, 3, 4125, 189
},
// house2
{
    10784, 4113, 189, 20480, 189, 1, 4109, 189, 22, 36864, 19, 144, 0, 24,
    4097, 0, 3, 4097, 189, 21, 36864, 19, 144, 0, 24, 0, 4098, 0, 2, 4097, 189,
    20, 36864, 19, 144, 0, 24, 1, 4098, 0, 2, 4097, 189, 19, 36864, 19, 144, 0,
    24, 2, 4099, 0, 1, 4097, 189, 18, 36864, 19, 144, 0, 24, 3, 4099, 0, 1,
    4097, 189, 17, 36864, 19, 144, 0, 24, 4, 4099, 0, 1, 4097, 189, 9, 36864,
    30, 24, 5, 36864, 19, 144, 0, 24, 5, 4100, 0, 0, 4097, 189, 9, 4096, 30, 5,
    4096, 30, 4101, 124, 4100, 0, 0, 4097, 189, 9, 4096, 30, 4096, 19, 90, 0,
    4, 4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 9, 4096, 30, 4101, 124, 4096,
    30, 8197, 1, 4100, 0, 0, 4097, 189, 9, 4096, 30, 4096, 19, 90, 0, 4, 4096,
    30, 8197, 1, 4100, 0, 0, 4097, 189, 9, 4096, 30, 2, 4096, 93, 0, 0, 4096,
    93, 0, 18, 4096, 93, 0, 36, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 9, 4096,
    30, 5, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 9, 4096, 30, 5, 4096, 30,
    8197, 1, 4101, 0, 4097, 189, 2, 36864, 19, 36, 0, 8, 4098, 30, 4101, 38,
    36864, 38, 40, 2, 4096, 38, 12288, 38, 5, 8196, 5, 4101, 0, 4097, 189, 2,
    36864, 19, 0, 0, 8, 8192, 4, 12288, 30, 4, 8192, 4, 4102, 38, 4096, 10, 36,
    0, 4096, 10, 18, 18, 4096, 10, 0, 36, 4096, 38, 12288, 38, 5, 8196, 5,
    4101, 0, 4097, 189, 2, 36864, 19, 0, 0, 8, 12288, 30, 4, 8192, 4, 12288,
    30, 4, 4097, 38, 45056, 38, 4, 32, 8196, 4, 8193, 27, 4096, 38, 12288, 38,
    5, 8196, 5, 4101, 0, 4097, 189, 2, 36864, 19, 18, 0, 8, 8192, 4, 12288, 30,
    4, 8192, 4, 4097, 38, 8197, 4, 8193, 27, 4096, 38, 12288, 38, 5, 8196, 5,
    4101, 0, 4097, 189, 4096, 406, 0, 0, 4096, 406, 0, 18, 4096, 406, 0, 36,
    4096, 38, 12288, 30, 4, 8192, 4, 12288, 30, 4, 4097, 38, 8197, 5, 12288,
    405, 0, 0, 27, 12288, 405, 0, 18, 27, 4096, 38, 12288, 38, 5, 8196, 5,
    4101, 0, 4097, 189, 4096, 406, 18, 0, 4096, 406, 18, 18, 4096, 406, 18, 36,
    4096, 38, 8192, 4, 12288, 30, 4, 8192, 4, 4097, 38, 8197, 5, 12288, 405,
    18, 0, 27, 12288, 405, 18, 18, 27, 4096, 38, 12288, 38, 5, 8196, 5, 4101,
    0, 4097, 189, 4096, 406, 36, 0, 4096, 406, 36, 18, 4096, 406, 36, 36, 4096,
    38, 12288, 30, 4, 8192, 4, 12288, 30, 4, 4097, 38, 8197, 5, 12288, 405, 36,
    0, 27, 12288, 405, 36, 18, 27, 4096, 38, 12288, 38, 5, 8196, 5, 4101, 0,
    4097, 189, 2, 36864, 19, 36, 0, 8, 8192, 4, 12288, 30, 4, 8192, 4, 4097,
    38, 8197, 4, 8193, 27, 4096, 38, 12288, 38, 5, 8196, 5, 4101, 0, 4097, 189,
    2, 36864, 19, 0, 0, 8, 12288, 30, 4, 8192, 4, 12288, 30, 4, 4097, 38, 8197,
    4, 12288, 15, 18, 0, 27, 12288, 15, 18, 18, 27, 4096, 38, 12288, 38, 5,
    8196, 5, 4101, 0, 4097, 189, 2, 36864, 19, 0, 0, 8, 8192, 4, 12288, 30, 4,
    8192, 4, 4097, 38, 8197, 4, 12288, 14, 0, 0, 27, 12288, 14, 0, 18, 27,
    4096, 38, 12288, 38, 5, 8196, 5, 4101, 0, 4097, 189, 2, 36864, 19, 0, 0, 8,
    12288, 30, 4, 8192, 4, 12288, 30, 4, 4097, 38, 8197, 4, 12288, 14, 18, 0,
    27, 12288, 14, 18, 18, 27, 4096, 38, 12288, 38, 5, 8196, 5, 4101, 0, 4097,
    189, 2, 36864, 19, 0, 0, 8, 8192, 4, 12288, 30, 4, 8192, 4, 4097, 38, 8196,
    4, 12288, 33, 0, 0, 4, 12288, 14, 36, 0, 27, 12288, 14, 36, 18, 27, 4096,
    38, 12288, 38, 5, 8196, 5, 4101, 0, 4097, 189, 2, 36864, 19, 0, 0, 8,
    12288, 30, 4, 8192, 4, 12288, 30, 4, 4097, 38, 8197, 4, 8193, 27, 4096, 38,
    12288, 38, 5, 8196, 5, 4101, 0, 4097, 189, 2, 36864, 19, 0, 0, 8, 8192, 4,
    12288, 30, 4, 8192, 4, 4097, 38, 8192, 4, 12288, 21, 0, 0, 4, 12288, 21, 0,
    18, 4, 12288, 19, 36, 0, 4, 8193, 4, 8193, 27, 4096, 38, 12288, 38, 5,
    8196, 5, 4101, 0, 4097, 189, 2, 36864, 19, 0, 0, 8, 12288, 30, 4, 8192, 4,
    12288, 30, 4, 4097, 38, 45056, 38, 4, 40, 12288, 21, 18, 0, 4, 12288, 21,
    18, 18, 4, 12288, 19, 72, 0, 4, 8193, 4, 8193, 27, 4096, 38, 12288, 38, 5,
    8196, 5, 4101, 0, 4097, 189, 2, 36864, 19, 0, 0, 8, 8192, 4, 12288, 30, 4,
    8192, 4, 4102, 38, 4096, 10, 18, 0, 4096, 10, 0, 18, 4096, 10, 0, 36, 4096,
    38, 12288, 38, 5, 8196, 5, 4100, 0, 0, 4097, 189, 2, 36864, 19, 18, 0, 8,
    4098, 30, 4101, 38, 36864, 38, 32, 2, 4096, 38, 12288, 38, 5, 8196, 5,
    4100, 0, 0, 4097, 189, 9, 4096, 30, 4096, 42, 0, 0, 4096, 42, 0, 18, 3,
    4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 9, 36864, 30, 16, 5, 4096, 30,
    4101, 124, 4100, 0, 0, 4097, 189, 16, 36864, 19, 180, 0, 16, 5, 4100, 0, 0,
    4097, 189, 17, 36864, 19, 180, 0, 16, 4, 4099, 0, 1, 4097, 189, 18, 36864,
    19, 180, 0, 16, 3, 4099, 0, 1, 4097, 189, 19, 36864, 19, 180, 0, 16, 2,
    4099, 0, 1, 4097, 189, 20, 36864, 19, 180, 0, 16, 1, 4098, 0, 2, 4097, 189,
    21, 36864, 19, 180, 0, 16, 0, 4098, 0, 2, 4097, 189, 22, 36864, 19, 180, 0,
    16, 4097, 0, 3, 4128, 189
},
// house3
{
    9502, 4111, 189, 20480, 189, 1, 4109, 189, 20, 36864, 19, 144, 0, 24, 4097,
    0, 3, 4097, 189, 19, 36864, 19, 144, 0, 24, 0, 4098, 0, 2, 4097, 189, 18,
    36864, 19, 144, 0, 24, 1, 4098, 0, 2, 4097, 189, 17, 36864, 19, 144, 0, 24,
    2, 4099, 0, 1, 4097, 189, 16, 36864, 19, 144, 0, 24, 3, 4099, 0, 1, 4097,
    189, 15, 36864, 19, 144, 0, 24, 4, 4099, 0, 1, 4097, 189, 14, 36864, 19,
    144, 0, 24, 5, 4100, 0, 0, 4097, 189, 14, 4096, 30, 4101, 124, 4100, 0, 0,
    4097, 189, 14, 4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 4, 36864, 38, 24,
    4096, 38, 4099, 30, 36864, 30, 40, 2, 4096, 30, 8197, 1, 4100, 0, 0, 4097,
    189, 3, 36864, 38, 24, 36864, 38, 32, 12288, 38, 5, 4100, 30, 4096, 10, 0,
    0, 4096, 10, 36, 18, 4096, 10, 36, 36, 4096, 30, 8197, 1, 4100, 0, 0, 4097,
    189, 2, 36864, 38, 24, 36864, 38, 32, 8192, 5, 12288, 38, 5, 4096, 30,
    8192, 27, 8197, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 1, 36864, 38, 24,
    36864, 38, 32, 8193, 5, 4096, 38, 4096, 30, 12288, 34, 0, 0, 27, 12288, 34,
    0, 18, 4, 12288, 34, 0, 36, 4, 8193, 4, 12288, 14, 0, 0, 4, 12288, 14, 0,
    18, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 0, 36864, 38, 24, 36864, 38,
    32, 8193, 5, 45056, 38, 5, 24, 12288, 38, 5, 4096, 30, 12288, 34, 18, 0,
    27, 12288, 34, 18, 18, 4, 12288, 34, 18, 36, 4, 8193, 4, 12288, 14, 18, 0,
    4, 12288, 14, 18, 18, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 36864, 38,
    8, 4096, 38, 8193, 5, 45056, 38, 5, 24, 45056, 38, 5, 32, 12288, 38, 5,
    4096, 30, 12288, 34, 36, 0, 27, 12288, 34, 36, 18, 4, 12288, 34, 36, 36, 4,
    8193, 4, 12288, 14, 36, 0, 4, 12288, 14, 36, 18, 4, 4096, 30, 8197, 1,
    4101, 0, 4097, 189, 36864, 38, 8, 4096, 38, 8192, 5, 45056, 38, 5, 24,
    45056, 38, 5, 32, 8192, 5, 4096, 38, 4096, 30, 8192, 27, 8195, 4, 12288,
    15, 0, 0, 4, 12288, 15, 0, 18, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 0,
    4096, 38, 45056, 38, 5, 24, 45056, 38, 5, 32, 8193, 5, 4096, 38, 4096, 30,
    45056, 19, 36, 0, 27, 8, 8194, 21, 12288, 19, 36, 0, 4, 8193, 4, 4096, 30,
    8197, 1, 4101, 0, 4097, 189, 0, 36864, 38, 8, 4096, 38, 8193, 5, 45056, 38,
    5, 24, 4096, 38, 4096, 30, 45056, 19, 0, 0, 27, 8, 8194, 21, 12288, 19, 0,
    0, 4, 8193, 4, 4096, 30, 12293, 124, 1, 4101, 0, 4097, 189, 1, 4096, 38,
    8192, 5, 45056, 38, 5, 24, 45056, 38, 5, 32, 12288, 38, 5, 4096, 30, 45056,
    19, 0, 0, 27, 8, 8194, 21, 12288, 19, 0, 0, 4, 12288, 21, 0, 0, 4, 12288,
    21, 0, 18, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 1, 36864, 38, 8, 4096,
    38, 45056, 38, 5, 32, 8192, 5, 12288, 38, 5, 4096, 30, 45056, 19, 0, 0, 27,
    8, 8192, 21, 12288, 83, 0, 0, 21, 12288, 78, 0, 0, 21, 12288, 19, 0, 0, 4,
    12288, 21, 18, 0, 4, 12288, 21, 18, 18, 4, 4096, 30, 8197, 1, 4101, 0,
    4097, 189, 2, 4096, 38, 8193, 5, 12288, 38, 5, 4096, 30, 45056, 19, 18, 0,
    27, 8, 8194, 21, 12288, 19, 18, 0, 4, 8193, 4, 4096, 30, 8197, 1, 4101, 0,
    4097, 189, 2, 36864, 38, 8, 36864, 38, 40, 45056, 38, 5, 24, 12288, 38, 5,
    4096, 30, 8192, 27, 8197, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 3,
    4096, 38, 45056, 38, 5, 32, 12288, 38, 5, 4096, 30, 8192, 27, 8197, 4,
    4096, 30, 8197, 1, 4101, 0, 4097, 189, 3, 36864, 38, 8, 36864, 38, 40,
    12288, 38, 5, 4096, 30, 8192, 27, 8197, 4, 4096, 30, 8197, 1, 4101, 0,
    4097, 189, 4, 4096, 38, 12288, 38, 5, 4100, 30, 4096, 10, 36, 0, 4096, 10,
    18, 18, 4096, 10, 0, 36, 4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 4,
    36864, 38, 8, 4096, 38, 4099, 30, 36864, 30, 32, 2, 4096, 30, 8197, 1,
    4100, 0, 0, 4097, 189, 14, 4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 11,
    4096, 93, 0, 0, 4096, 93, 0, 18, 4096, 93, 0, 36, 4096, 30, 4101, 124,
    4100, 0, 0, 4097, 189, 14, 36864, 19, 180, 0, 16, 5, 4100, 0, 0, 4097, 189,
    15, 36864, 19, 180, 0, 16, 4, 4099, 0, 1, 4097, 189, 16, 36864, 19, 180, 0,
    16, 3, 4099, 0, 1, 4097, 189, 17, 36864, 19, 180, 0, 16, 2, 4099, 0, 1,
    4097, 189, 18, 36864, 19, 180, 0, 16, 1, 4098, 0, 2, 4097, 189, 19, 36864,
    19, 180, 0, 16, 0, 4098, 0, 2, 4097, 189, 20, 36864, 19, 180, 0, 16, 4097,
    0, 3, 4126, 189
},
// house4
{
    8990, 4111, 189, 20480, 189, 1, 4109, 189, 20, 36864, 19, 144, 0, 24, 4097,
    0, 3, 4097, 189, 19, 36864, 19, 144, 0, 24, 0, 4098, 0, 2, 4097, 189, 18,
    36864, 19, 144, 0, 24, 1, 4098, 0, 2, 4097, 189, 17, 36864, 19, 144, 0, 24,
    2, 4099, 0, 1, 4097, 189, 16, 36864, 19, 144, 0, 24, 3, 4099, 0, 1, 4097,
    189, 15, 36864, 19, 144, 0, 24, 4, 4099, 0, 1, 4097, 189, 14, 36864, 19,
    144, 0, 24, 5, 4100, 0, 0, 4097, 189, 7, 36864, 30, 24, 4096, 42, 0, 0,
    4096, 42, 0, 18, 3, 4096, 38, 4101, 124, 4100, 0, 0, 4097, 189, 6, 36864,
    19, 144, 0, 24, 4096, 30, 4098, 38, 4096, 10, 36, 0, 4096, 10, 18, 18,
    4096, 10, 36, 36, 4096, 38, 8192, 27, 8196, 1, 4100, 0, 0, 4097, 189, 5,
    36864, 19, 144, 0, 24, 36864, 38, 24, 4096, 38, 45056, 38, 4, 32, 8196, 4,
    4096, 38, 8192, 27, 8196, 1, 4100, 0, 0, 4097, 189, 4, 36865, 19, 144, 0,
    24, 12288, 38, 4, 4096, 38, 8197, 4, 4096, 38, 8192, 27, 8196, 1, 4100, 0,
    0, 4097, 189, 3, 36865, 19, 144, 0, 24, 45056, 19, 144, 0, 4, 24, 12288,
    38, 4, 4096, 38, 8195, 4, 12288, 15, 18, 0, 4, 12288, 15, 18, 18, 4, 4096,
    38, 8192, 27, 8196, 1, 4101, 0, 4097, 189, 2, 36864, 30, 8, 45058, 19, 144,
    0, 4, 24, 12288, 38, 4, 4096, 38, 8195, 4, 12288, 14, 0, 0, 4, 12288, 14,
    0, 18, 4, 4096, 38, 8192, 27, 8196, 1, 4101, 0, 4097, 189, 2, 36864, 30, 8,
    45058, 19, 144, 0, 4, 24, 12288, 38, 4, 4096, 38, 8193, 4, 12288, 100, 0,
    0, 4, 12288, 100, 0, 18, 4, 12288, 14, 18, 0, 4, 12288, 14, 18, 18, 4,
    4096, 38, 8192, 27, 8196, 1, 4101, 0, 4097, 189, 2, 36864, 30, 8, 45058,
    19, 144, 0, 4, 24, 12288, 38, 4, 4096, 38, 8193, 4, 12288, 100, 18, 0, 4,
    12288, 100, 18, 18, 4, 12288, 14, 36, 0, 4, 12288, 14, 36, 18, 4, 4096, 38,
    8192, 27, 8196, 1, 4101, 0, 4097, 189, 2, 36864, 30, 8, 45058, 19, 144, 0,
    4, 24, 12288, 38, 4, 4096, 38, 8197, 4, 4096, 38, 8192, 27, 8196, 1, 4101,
    0, 4097, 189, 2, 36864, 30, 8, 12288, 19, 252, 0, 4, 12288, 30, 4, 12288,
    19, 252, 0, 4, 12288, 38, 4, 4096, 38, 8197, 4, 4096, 38, 12288, 124, 27,
    12292, 124, 1, 4101, 0, 4097, 189, 4096, 406, 0, 0, 4096, 406, 0, 18, 4096,
    406, 0, 36, 4096, 38, 45058, 19, 180, 0, 4, 16, 12288, 38, 4, 4096, 38,
    8195, 5, 12288, 405, 0, 0, 4, 12288, 405, 0, 18, 4, 4096, 38, 8192, 27,
    8196, 1, 4101, 0, 4097, 189, 4096, 406, 18, 0, 4096, 406, 18, 18, 4096,
    406, 18, 36, 4096, 38, 45058, 19, 180, 0, 4, 16, 12288, 38, 4, 4096, 38,
    8195, 5, 12288, 405, 18, 0, 4, 12288, 405, 18, 18, 4, 4096, 38, 8192, 27,
    8196, 1, 4101, 0, 4097, 189, 4096, 406, 36, 0, 4096, 406, 36, 18, 4096,
    406, 36, 36, 4096, 38, 45058, 19, 180, 0, 4, 16, 12288, 38, 4, 4096, 38,
    8195, 5, 12288, 405, 36, 0, 4, 12288, 405, 36, 18, 4, 4096, 38, 8192, 27,
    8196, 1, 4101, 0, 4097, 189, 2, 36864, 30, 8, 45058, 19, 180, 0, 4, 16,
    12288, 38, 4, 4096, 38, 8197, 4, 4096, 38, 8192, 27, 8196, 1, 4101, 0,
    4097, 189, 3, 36865, 19, 180, 0, 16, 45056, 19, 180, 0, 4, 16, 12288, 38,
    4, 4096, 38, 8195, 4, 12288, 21, 0, 0, 4, 12288, 21, 0, 18, 4, 4096, 38,
    8192, 27, 8196, 1, 4101, 0, 4097, 189, 4, 36865, 19, 180, 0, 16, 12288, 38,
    4, 4096, 38, 8195, 4, 12288, 21, 18, 0, 4, 12288, 21, 18, 18, 4, 4096, 38,
    8192, 27, 8196, 1, 4100, 0, 0, 4097, 189, 5, 36864, 19, 180, 0, 16, 36864,
    38, 16, 4096, 38, 45056, 38, 4, 40, 8196, 4, 4096, 38, 8192, 27, 8196, 1,
    4100, 0, 0, 4097, 189, 6, 36864, 19, 180, 0, 16, 4096, 30, 4098, 38, 4096,
    10, 0, 0, 4096, 10, 18, 18, 4096, 10, 18, 36, 4096, 38, 8192, 27, 8196, 1,
    4100, 0, 0, 4097, 189, 7, 36864, 30, 16, 4096, 42, 0, 0, 4096, 42, 0, 18,
    3, 4096, 38, 4101, 124, 4100, 0, 0, 4097, 189, 14, 36864, 19, 180, 0, 16,
    5, 4100, 0, 0, 4097, 189, 15, 36864, 19, 180, 0, 16, 4, 4099, 0, 1, 4097,
    189, 16, 36864, 19, 180, 0, 16, 3, 4099, 0, 1, 4097, 189, 17, 36864, 19,
    180, 0, 16, 2, 4099, 0, 1, 4097, 189, 18, 36864, 19, 180, 0, 16, 1, 4098,
    0, 2, 4097, 189, 19, 36864, 19, 180, 0, 16, 0, 4098, 0, 2, 4097, 189, 20,
    36864, 19, 180, 0, 16, 4097, 0, 3, 4126, 189
},
// house5
{
    8988, 4109, 189, 20480, 189, 1, 4109, 189, 18, 36864, 19, 144, 0, 24, 4097,
    0, 3, 4097, 189, 17, 36864, 19, 144, 0, 24, 0, 4098, 0, 2, 4097, 189, 16,
    36864, 19, 144, 0, 24, 1, 4098, 0, 2, 4097, 189, 15, 36864, 19, 144, 0, 24,
    2, 4099, 0, 1, 4097, 189, 14, 36864, 19, 144, 0, 24, 3, 4099, 0, 1, 4097,
    189, 13, 36864, 19, 144, 0, 24, 4, 4099, 0, 1, 4097, 189, 4, 4096, 38,
    4096, 124, 4096, 30, 4096, 42, 0, 0, 4096, 42, 0, 18, 2, 36864, 19, 144, 0,
    24, 5, 4100, 0, 0, 4097, 189, 4, 4096, 38, 8192, 5, 4096, 30, 36864, 30,
    40, 3, 4096, 30, 4101, 124, 4100, 0, 0, 4097, 189, 4, 4096, 38, 12288, 124,
    5, 4098, 30, 4096, 10, 36, 0, 4096, 10, 18, 18, 4096, 10, 18, 36, 4096, 30,
    8197, 1, 4100, 0, 0, 4097, 189, 4, 4096, 38, 8192, 5, 4096, 30, 8196, 4,
    4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 4, 4096, 38, 12288, 124, 5, 4096,
    30, 12292, 124, 4, 4096, 30, 8197, 1, 4100, 0, 0, 4097, 189, 3, 36864, 38,
    24, 36864, 38, 32, 45056, 30, 5, 24, 45056, 30, 27, 32, 45056, 19, 180, 0,
    4, 16, 8195, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 2, 36864, 38, 24,
    36864, 38, 32, 45056, 30, 5, 24, 45056, 30, 27, 32, 8192, 27, 12288, 33, 0,
    0, 4, 12288, 19, 18, 0, 4, 8194, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189,
    1, 36864, 38, 24, 36864, 38, 32, 45056, 30, 5, 24, 45056, 30, 4, 32, 8193,
    27, 8194, 4, 12288, 21, 0, 0, 4, 12288, 21, 0, 18, 4, 4096, 30, 8197, 1,
    4101, 0, 4097, 189, 0, 36864, 38, 24, 36864, 38, 32, 45056, 30, 5, 24,
    45056, 30, 27, 32, 8192, 4, 8193, 27, 8194, 4, 12288, 21, 18, 0, 4, 12288,
    21, 18, 18, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 36864, 38, 24, 36864,
    38, 32, 45056, 30, 5, 24, 45056, 30, 27, 32, 8192, 27, 45056, 54, 21, 32,
    8192, 21, 45056, 54, 21, 16, 8196, 4, 4096, 30, 8197, 1, 4101, 0, 4097,
    189, 4096, 38, 12288, 124, 5, 4096, 30, 8193, 27, 8194, 21, 8196, 4, 4096,
    30, 12293, 124, 1, 4101, 0, 4097, 189, 36864, 38, 16, 36864, 38, 40, 45056,
    30, 5, 16, 45056, 30, 27, 40, 8192, 27, 45056, 54, 21, 40, 8192, 21, 45056,
    54, 21, 24, 8194, 4, 12288, 14, 0, 0, 4, 12288, 14, 0, 18, 4, 4096, 30,
    8197, 1, 4101, 0, 4097, 189, 0, 36864, 38, 16, 36864, 38, 40, 45056, 30, 5,
    16, 45056, 30, 27, 40, 8192, 4, 8193, 27, 8194, 4, 12288, 14, 18, 0, 4,
    12288, 14, 18, 18, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 1, 36864, 38,
    16, 36864, 38, 40, 45056, 30, 5, 16, 45056, 30, 4, 40, 8193, 27, 8194, 4,
    12288, 14, 36, 0, 4, 12288, 14, 36, 18, 4, 4096, 30, 8197, 1, 4101, 0,
    4097, 189, 2, 36864, 38, 16, 36864, 38, 40, 45056, 30, 5, 16, 45056, 30,
    27, 40, 8192, 27, 12288, 33, 0, 0, 4, 12288, 19, 36, 0, 4, 8192, 4, 12288,
    15, 0, 0, 4, 12288, 15, 0, 18, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 3,
    36864, 38, 16, 36864, 38, 40, 45056, 30, 5, 16, 45056, 30, 27, 40, 45056,
    19, 144, 0, 4, 24, 8195, 4, 4096, 30, 8197, 1, 4101, 0, 4097, 189, 4, 4096,
    38, 12288, 124, 5, 4096, 30, 12292, 124, 4, 4096, 30, 8197, 1, 4100, 0, 0,
    4097, 189, 4, 4096, 38, 8192, 5, 4096, 30, 8196, 4, 4096, 30, 8197, 1,
    4100, 0, 0, 4097, 189, 4, 4096, 38, 12288, 124, 5, 4098, 30, 4096, 10, 36,
    0, 4096, 10, 18, 18, 4096, 10, 0, 36, 4096, 30, 8197, 1, 4100, 0, 0, 4097,
    189, 4, 4096, 38, 8192, 5, 4096, 30, 36864, 30, 32, 3, 4096, 30, 4101, 124,
    4100, 0, 0, 4097, 189, 4, 4096, 38, 4096, 124, 4096, 30, 4096, 42, 0, 0,
    4096, 42, 0, 18, 2, 36864, 19, 180, 0, 16, 5, 4100, 0, 0, 4097, 189, 13,
    36864, 19, 180, 0, 16, 4, 4099, 0, 1, 4097, 189, 14, 36864, 19, 180, 0, 16,
    3, 4099, 0, 1, 4097, 189, 15, 36864, 19, 180, 0, 16, 2, 4099, 0, 1, 4097,
    189, 16, 36864, 19, 180, 0, 16, 1, 4098, 0, 2, 4097, 189, 17, 36864, 19,
    180, 0, 16, 0, 4098, 0, 2, 4097, 189, 18, 36864, 19, 180, 0, 16, 4097, 0,
    3, 4124, 189
},
// house6
{
    8731, 4108, 189, 20480, 189, 1, 4109, 189, 17, 36864, 19, 144, 0, 24, 4097,
    0, 3, 4097, 189, 16, 36864, 19, 144, 0, 24, 0, 4098, 0, 2, 4097, 189, 15,
    36864, 19, 144, 0, 24, 1, 4098, 0, 2, 4097, 189, 14, 36864, 19, 144, 0, 24,
    2, 4099, 0, 1, 4097, 189, 13, 36864, 19, 144, 0, 24, 3, 4099, 0, 1, 4097,
    189, 12, 36864, 19, 144, 0, 24, 4, 4099, 0, 1, 4097, 189, 1, 4099, 0, 5,
    36864, 19, 144, 0, 24, 5, 4100, 0, 0, 4097, 189, 1, 4097, 0, 12288, 38, 5,
    4096, 0, 5, 4096, 38, 4101, 124, 4100, 0, 0, 4097, 189, 1, 4097, 0, 12288,
    38, 5, 4099, 38, 4096, 10, 0, 0, 4096, 10, 18, 18, 4096, 10, 18, 36, 4096,
    38, 8197, 1, 4100, 0, 0, 4097, 189, 1, 4096, 0, 12289, 38, 5, 8192, 5,
    45056, 30, 5, 24, 45056, 30, 5, 32, 8195, 5, 4096, 38, 8197, 1, 4100, 0, 0,
    4097, 189, 1, 4096, 0, 12289, 38, 5, 45056, 30, 5, 24, 45056, 30, 5, 32,
    8196, 5, 4096, 38, 8197, 1, 4100, 0, 0, 4097, 189, 1, 4097, 0, 12288, 38,
    5, 45056, 30, 27, 32, 8192, 5, 8192, 4, 8192, 5, 8192, 4, 8192, 5, 8192, 4,
    4096, 38, 8197, 1, 4101, 0, 4097, 189, 1, 4097, 0, 12288, 38, 5, 8192, 27,
    8195, 4, 12288, 21, 0, 0, 4, 12288, 21, 0, 18, 4, 4096, 38, 8197, 1, 4101,
    0, 4097, 189, 1, 4096, 0, 12289, 38, 5, 8192, 27, 8195, 4, 12288, 21, 18,
    0, 4, 12288, 21, 18, 18, 4, 4096, 38, 8197, 1, 4101, 0, 4097, 189, 1, 4096,
    0, 12289, 38, 5, 8192, 27, 8197, 4, 4096, 38, 8197, 1, 4101, 0, 4097, 189,
    1, 4097, 0, 12288, 38, 5, 8192, 27, 8197, 4, 4096, 38, 8197, 1, 4101, 0,
    4097, 189, 1, 4097, 0, 12288, 38, 5, 8192, 27, 8195, 4, 12288, 15, 18, 0,
    4, 12288, 15, 18, 18, 4, 4096, 38, 8197, 1, 4101, 0, 4097, 189, 1, 4096, 0,
    12289, 38, 5, 12288, 34, 0, 0, 27, 12288, 34, 0, 18, 4, 12288, 34, 0, 36,
    4, 8193, 4, 12288, 14, 0, 0, 4, 12288, 14, 0, 18, 4, 4096, 38, 8197, 1,
    4101, 0, 4097, 189, 1, 4096, 0, 12289, 38, 5, 12288, 34, 18, 0, 27, 12288,
    34, 18, 18, 4, 12288, 34, 18, 36, 4, 8193, 4, 12288, 14, 18, 0, 4, 12288,
    14, 18, 18, 4, 4096, 38, 8197, 1, 4101, 0, 4097, 189, 1, 4097, 0, 12288,
    38, 5, 12288, 34, 36, 0, 27, 12288, 34, 36, 18, 4, 12288, 34, 36, 36, 4,
    8193, 4, 12288, 14, 36, 0, 4, 12288, 14, 36, 18, 4, 4096, 38, 8197, 1,
    4101, 0, 4097, 189, 1, 4097, 0, 12288, 38, 5, 45056, 30, 27, 40, 8192, 5,
    8192, 4, 8192, 5, 8192, 4, 8192, 5, 8192, 4, 4096, 38, 8197, 1, 4101, 0,
    4097, 189, 1, 4096, 0, 12289, 38, 5, 45056, 30, 5, 16, 45056, 30, 5, 40,
    8196, 5, 4096, 38, 8197, 1, 4100, 0, 0, 4097, 189, 1, 4096, 0, 12289, 38,
    5, 8192, 5, 45056, 30, 5, 16, 45056, 30, 5, 40, 8195, 5, 4096, 38, 8197, 1,
    4100, 0, 0, 4097, 189, 1, 4097, 0, 12288, 38, 5, 4099, 38, 4096, 10, 18, 0,
    4096, 10, 36, 18, 4096, 10, 36, 36, 4096, 38, 8197, 1, 4100, 0, 0, 4097,
    189, 1, 4097, 0, 12288, 38, 5, 4096, 0, 5, 4096, 38, 4101, 124, 4100, 0, 0,
    4097, 189, 1, 4099, 0, 5, 36864, 19, 180, 0, 16, 5, 4100, 0, 0, 4097, 189,
    12, 36864, 19, 180, 0, 16, 4, 4099, 0, 1, 4097, 189, 13, 36864, 19, 180, 0,
    16, 3, 4099, 0, 1, 4097, 189, 14, 36864, 19, 180, 0, 16, 2, 4099, 0, 1,
    4097, 189, 15, 36864, 19, 180, 0, 16, 1, 4098, 0, 2, 4097, 189, 16, 36864,
    19, 180, 0, 16, 0, 4098, 0, 2, 4097, 189, 17, 36864, 19, 180, 0, 16, 4097,
    0, 3, 4123, 189
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getHome(int homeId, const std::vector<bool> &framedTiles)
{
    return {homeData[homeId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Homes.h`
```
#ifndef HOMES_H
#define HOMES_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto homes = std::views::iota(0, 6);

TileBuffer getHome(int homeId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // HOMES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Igloos.cpp`
```
#include "structures/data/Igloos.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> iglooData{
// igloo1
{
    11290, 4107, 189, 20485, 189, 1, 4104, 189, 11, 4109, 189, 12, 4096, 189,
    4097, 147, 4105, 189, 12, 4099, 147, 4104, 189, 11, 53248, 152, 26, 24,
    4099, 147, 4104, 189, 9, 53248, 152, 26, 24, 20482, 152, 26, 4099, 147,
    4103, 189, 8, 53248, 152, 26, 24, 20483, 152, 26, 4099, 147, 4103, 189, 8,
    20485, 152, 26, 4098, 147, 4103, 189, 7, 53248, 152, 26, 24, 20480, 152,
    26, 28672, 152, 34, 6682, 28672, 79, 72, 0, 34, 6656, 28672, 79, 72, 18,
    34, 6656, 20481, 152, 26, 4098, 147, 4103, 189, 6, 53248, 152, 26, 24,
    20480, 152, 26, 28672, 152, 34, 6682, 24576, 34, 6656, 28672, 79, 90, 0,
    34, 6656, 28672, 79, 90, 18, 34, 6656, 20481, 152, 26, 4098, 147, 4103,
    189, 6, 20481, 152, 26, 61440, 152, 34, 6682, 32, 24576, 34, 6656, 28672,
    79, 108, 0, 34, 6656, 28672, 79, 108, 18, 34, 6656, 20481, 152, 26, 4098,
    147, 4103, 189, 5, 53248, 152, 26, 24, 20480, 152, 26, 61440, 152, 34,
    6682, 32, 24577, 34, 6656, 28672, 79, 126, 0, 34, 6656, 28672, 79, 126, 18,
    34, 6656, 20481, 152, 26, 4098, 147, 4103, 189, 4, 53248, 152, 26, 24,
    20480, 152, 26, 61440, 152, 34, 6682, 32, 24579, 34, 6656, 28672, 18, 828,
    0, 34, 6656, 20481, 152, 26, 4099, 147, 4102, 189, 3, 36864, 147, 8, 20480,
    152, 26, 28672, 152, 34, 26, 24579, 34, 6656, 28672, 13, 72, 0, 34, 6656,
    28672, 18, 846, 0, 34, 6656, 20481, 152, 26, 4099, 147, 4102, 189, 3,
    53248, 152, 26, 24, 20480, 152, 26, 61440, 152, 34, 6682, 32, 24581, 34,
    6656, 20481, 152, 26, 4098, 147, 4103, 189, 2, 53248, 152, 26, 24, 20480,
    152, 26, 61440, 152, 34, 6682, 32, 24581, 34, 6656, 61440, 152, 34, 6682,
    24, 20481, 152, 26, 4098, 147, 4103, 189, 2, 20480, 152, 26, 28672, 152,
    34, 6682, 28672, 42, 0, 216, 34, 6656, 28672, 42, 0, 234, 34, 6656, 24578,
    34, 6656, 28672, 21, 396, 0, 34, 6656, 28672, 21, 396, 18, 34, 6656, 28672,
    152, 34, 6682, 20480, 152, 26, 4099, 147, 4103, 189, 1, 53248, 152, 26, 24,
    20480, 152, 26, 61440, 152, 34, 6682, 32, 24580, 34, 6656, 28672, 21, 414,
    0, 34, 6656, 28672, 21, 414, 18, 34, 6656, 28672, 152, 34, 26, 20480, 152,
    26, 4099, 147, 4103, 189, 0, 36864, 147, 8, 20481, 152, 26, 24582, 34,
    6656, 61440, 152, 34, 6682, 24, 28672, 152, 34, 26, 20480, 152, 26, 4100,
    147, 4102, 189, 0, 36864, 147, 8, 20481, 152, 26, 24580, 34, 6656, 28672,
    94, 0, 0, 34, 6656, 28672, 94, 0, 18, 34, 6656, 28673, 152, 34, 26, 20480,
    152, 26, 4100, 147, 4102, 189, 1, 20481, 152, 26, 61440, 152, 34, 6682, 40,
    24579, 34, 6656, 28672, 94, 18, 0, 34, 6656, 28672, 94, 18, 18, 34, 6656,
    28672, 152, 34, 6682, 28672, 152, 34, 26, 20480, 152, 26, 4100, 147, 4102,
    189, 1, 53248, 152, 26, 16, 20481, 152, 26, 24581, 34, 6656, 28672, 152,
    34, 6682, 28672, 152, 34, 26, 20480, 152, 26, 4101, 147, 4101, 189, 2,
    20481, 152, 26, 28672, 42, 0, 216, 34, 6656, 28672, 42, 0, 234, 34, 6656,
    24579, 34, 6656, 61440, 152, 34, 6682, 16, 28672, 152, 34, 26, 20482, 152,
    26, 4099, 147, 4101, 189, 2, 53248, 152, 26, 16, 20480, 152, 26, 24582, 34,
    6656, 61440, 152, 34, 6682, 16, 20482, 152, 26, 4100, 147, 4100, 189, 3,
    53248, 152, 26, 16, 20480, 152, 26, 61440, 152, 34, 6682, 40, 24581, 34,
    6656, 61440, 152, 34, 6682, 16, 20483, 152, 26, 4099, 147, 4099, 189, 4,
    20481, 152, 26, 61440, 152, 34, 6682, 40, 24582, 34, 6656, 61440, 152, 34,
    6682, 16, 20482, 152, 26, 4099, 147, 4098, 189, 4, 53248, 152, 26, 16,
    20481, 152, 26, 61440, 152, 34, 6682, 40, 24582, 34, 6656, 61440, 152, 34,
    6682, 16, 20481, 152, 26, 4099, 147, 4098, 189, 5, 53248, 152, 26, 16,
    20482, 152, 26, 61440, 152, 34, 6682, 40, 24581, 34, 6656, 20482, 152, 26,
    4098, 147, 4098, 189, 6, 53248, 152, 26, 16, 20482, 152, 26, 61440, 152,
    34, 6682, 40, 24580, 34, 6656, 20482, 152, 26, 4098, 147, 4098, 189, 8,
    53248, 152, 26, 16, 20481, 152, 26, 61440, 152, 34, 6682, 40, 24578, 34,
    6656, 61440, 147, 34, 6656, 8, 20482, 152, 26, 4098, 147, 4098, 189, 9,
    53248, 152, 26, 16, 20481, 152, 26, 24578, 34, 6656, 61440, 147, 34, 6656,
    8, 28672, 152, 34, 26, 20481, 152, 26, 4098, 147, 4098, 189, 12, 24578, 34,
    6656, 61440, 147, 34, 6656, 8, 20481, 152, 26, 4099, 147, 4098, 189, 12,
    24578, 34, 6656, 61440, 152, 34, 6682, 24, 20481, 152, 26, 4098, 147, 4099,
    189, 13, 24576, 34, 6656, 61440, 152, 34, 6682, 24, 20481, 152, 26, 4099,
    147, 4099, 189, 13, 61440, 152, 34, 6682, 24, 20482, 152, 26, 4098, 147,
    4100, 189, 12, 53248, 152, 26, 24, 20482, 152, 26, 4099, 147, 4100, 189,
    12, 4102, 147, 4101, 189, 12, 4102, 147, 4101, 189, 12, 4102, 147, 4101,
    189, 9, 4096, 93, 0, 1080, 4096, 93, 0, 1098, 4096, 93, 0, 1116, 4101, 147,
    4102, 189, 12, 4096, 189, 4099, 147, 4103, 189, 11, 4098, 189, 4097, 147,
    4104, 189, 10, 4119, 189, 20487, 189, 1, 4103, 189
},
// igloo2
{
    10011, 4110, 189, 20484, 189, 1, 4103, 189, 14, 4098, 189, 4098, 147, 4101,
    189, 15, 4096, 189, 4100, 147, 4100, 189, 16, 4101, 147, 4099, 189, 16,
    20480, 152, 26, 4102, 147, 4097, 189, 14, 24577, 45, 6656, 20481, 152, 26,
    4101, 147, 4097, 189, 13, 24578, 45, 6656, 61440, 152, 45, 6682, 8, 20482,
    152, 26, 4099, 147, 4097, 189, 10, 20481, 152, 26, 24580, 45, 6656, 20482,
    152, 26, 4099, 147, 4097, 189, 10, 20481, 152, 26, 24576, 45, 6656, 28672,
    4, 0, 22, 45, 6656, 24579, 45, 6656, 20482, 152, 26, 4098, 147, 4097, 189,
    9, 36864, 147, 24, 20481, 152, 26, 28672, 152, 45, 26, 24580, 45, 6656,
    61440, 152, 45, 6682, 16, 20481, 152, 26, 4098, 147, 4097, 189, 9, 4097,
    147, 20481, 152, 26, 28672, 152, 45, 26, 61440, 152, 45, 6682, 40, 24579,
    45, 6656, 20480, 152, 26, 28672, 152, 45, 26, 20480, 152, 26, 4097, 147,
    4097, 189, 10, 4096, 147, 20482, 152, 26, 28672, 152, 45, 6682, 24579, 45,
    6656, 61440, 152, 45, 6682, 8, 28672, 152, 45, 6682, 20481, 152, 26, 4096,
    147, 4097, 189, 10, 4098, 147, 20480, 152, 26, 28672, 152, 45, 6682, 28672,
    152, 45, 26, 24579, 45, 6656, 28672, 152, 45, 6682, 20481, 152, 26, 4096,
    147, 4097, 189, 10, 36864, 147, 8, 4097, 147, 20482, 152, 26, 24580, 45,
    6656, 20481, 152, 26, 4096, 147, 4097, 189, 11, 36864, 147, 8, 4097, 147,
    20480, 152, 26, 28672, 152, 45, 26, 28672, 152, 45, 6682, 24579, 45, 6656,
    28672, 152, 45, 6682, 20480, 152, 26, 4096, 147, 4097, 189, 10, 36864, 147,
    24, 4096, 147, 20482, 152, 26, 28673, 152, 45, 6682, 24579, 45, 6656,
    20481, 152, 26, 4096, 147, 4097, 189, 8, 36864, 147, 24, 4097, 147, 20482,
    152, 26, 28672, 152, 45, 6682, 61440, 152, 45, 6656, 32, 24580, 45, 6656,
    20481, 152, 26, 4096, 147, 4097, 189, 6, 36864, 147, 24, 4096, 147, 20484,
    152, 26, 28673, 152, 45, 6656, 24580, 45, 6656, 28672, 152, 45, 6682,
    20481, 152, 26, 4096, 147, 4097, 189, 5, 36864, 147, 8, 4096, 147, 20484,
    152, 26, 61440, 152, 45, 6656, 32, 24581, 45, 6656, 61440, 152, 45, 6682,
    24, 28672, 152, 45, 26, 20481, 152, 26, 4096, 147, 4097, 189, 4, 36864,
    147, 24, 4096, 147, 20482, 152, 26, 28672, 152, 45, 6682, 24579, 45, 6656,
    28672, 4, 0, 22, 45, 6656, 24579, 45, 6656, 28672, 152, 45, 6682, 20481,
    152, 26, 4097, 147, 4097, 189, 3, 36864, 147, 24, 20482, 152, 26, 28672,
    152, 45, 6682, 24585, 45, 6656, 61440, 152, 45, 6682, 8, 20481, 152, 26,
    4098, 147, 4097, 189, 2, 36864, 147, 24, 4096, 147, 20480, 152, 26, 28673,
    152, 45, 6682, 24579, 45, 6656, 28672, 18, 828, 0, 45, 6656, 28672, 19, 36,
    630, 45, 6656, 24580, 45, 6656, 28672, 152, 45, 6682, 20480, 152, 26, 4099,
    147, 4097, 189, 1, 36864, 147, 24, 4096, 147, 20481, 152, 26, 28672, 152,
    45, 26, 24580, 45, 6656, 28672, 18, 846, 0, 45, 6656, 28672, 19, 18, 630,
    45, 6656, 24579, 45, 6656, 28672, 152, 45, 6682, 20481, 152, 26, 4099, 147,
    4097, 189, 1, 4096, 147, 20482, 152, 26, 28672, 152, 45, 6682, 24577, 45,
    6656, 28672, 79, 0, 864, 45, 6656, 28672, 79, 0, 882, 45, 6656, 28672, 19,
    36, 630, 45, 6656, 24576, 45, 6656, 28672, 21, 396, 0, 45, 6656, 28672, 21,
    396, 18, 45, 6656, 28672, 19, 36, 630, 45, 6656, 24577, 45, 6656, 28672,
    152, 45, 6682, 20481, 152, 26, 4099, 147, 4097, 189, 1, 4097, 147, 20480,
    152, 26, 28672, 152, 45, 6682, 24578, 45, 6656, 28672, 79, 18, 864, 45,
    6656, 28672, 79, 18, 882, 45, 6656, 28672, 19, 0, 630, 45, 6656, 24576, 45,
    6656, 28672, 21, 414, 0, 45, 6656, 28672, 21, 414, 18, 45, 6656, 28672, 19,
    18, 630, 45, 6656, 24576, 45, 6656, 61440, 152, 45, 6682, 24, 28672, 152,
    45, 6682, 20480, 152, 26, 4100, 147, 4097, 189, 1, 36864, 147, 8, 4096,
    147, 20480, 152, 26, 28672, 152, 45, 6682, 24578, 45, 6656, 28672, 79, 36,
    864, 45, 6656, 28672, 79, 36, 882, 45, 6656, 28672, 19, 0, 630, 45, 6656,
    24580, 45, 6656, 28672, 152, 45, 6682, 20481, 152, 26, 4100, 147, 4097,
    189, 2, 4096, 147, 20480, 152, 26, 28673, 152, 45, 6682, 24577, 45, 6656,
    28672, 79, 54, 864, 45, 6656, 28672, 79, 54, 882, 45, 6656, 28672, 19, 18,
    630, 45, 6656, 24580, 45, 6656, 28672, 152, 45, 26, 20480, 152, 26, 4101,
    147, 4097, 189, 0, 36864, 147, 24, 4096, 147, 20481, 152, 26, 28672, 152,
    45, 6682, 24581, 45, 6656, 28672, 104, 216, 0, 45, 6656, 28672, 104, 216,
    18, 45, 6656, 28672, 104, 216, 36, 45, 6656, 28672, 104, 216, 54, 45, 6656,
    28672, 104, 216, 72, 45, 6656, 20481, 152, 26, 4100, 147, 4098, 189, 0,
    36864, 147, 8, 4096, 147, 20481, 152, 26, 24580, 45, 6656, 28672, 4, 0, 22,
    45, 6656, 24576, 45, 6656, 28672, 104, 234, 0, 45, 6656, 28672, 104, 234,
    18, 45, 6656, 28672, 104, 234, 36, 45, 6656, 28672, 104, 234, 54, 45, 6656,
    28672, 104, 234, 72, 45, 6656, 20481, 152, 26, 4099, 147, 4099, 189, 1,
    4096, 147, 20481, 152, 26, 61440, 152, 45, 6682, 40, 24584, 45, 6656,
    61440, 152, 45, 6682, 8, 20482, 152, 26, 4099, 147, 4099, 189, 2, 20482,
    152, 26, 24582, 45, 6656, 61440, 152, 45, 6682, 24, 28672, 152, 45, 6682,
    20482, 152, 26, 4099, 147, 4100, 189, 1, 36864, 147, 8, 4096, 147, 20481,
    152, 26, 24576, 45, 6656, 28672, 152, 45, 6682, 61440, 152, 45, 6682, 40,
    24577, 45, 6656, 61440, 152, 45, 6682, 8, 20481, 152, 26, 28672, 152, 45,
    6682, 20480, 152, 26, 4101, 147, 4100, 189, 3, 20490, 152, 26, 4102, 147,
    4100, 189, 3, 20488, 152, 26, 4104, 147, 4100, 189, 4, 36864, 147, 8, 4096,
    147, 20483, 152, 26, 4105, 147, 4101, 189, 12, 4103, 147, 4101, 189, 14,
    4097, 189, 4099, 147, 4101, 189, 14, 4098, 189, 4097, 147, 4116, 189,
    20484, 189, 1, 4102, 189
},
// igloo3
{
    8467, 4106, 189, 20483, 189, 1, 4100, 189, 10, 4103, 189, 11, 4102, 189, 9,
    20481, 177, 26, 4098, 147, 4099, 189, 7, 36864, 147, 8, 20481, 177, 26,
    28672, 177, 47, 6682, 4099, 147, 4098, 189, 6, 36864, 147, 8, 20481, 177,
    26, 28672, 177, 47, 6682, 24576, 47, 6656, 4099, 147, 4098, 189, 6, 20481,
    177, 26, 28672, 177, 47, 6682, 28672, 21, 180, 0, 47, 6656, 28672, 21, 180,
    18, 47, 6656, 4099, 147, 4098, 189, 4, 53248, 177, 26, 8, 20481, 177, 26,
    61440, 177, 47, 6682, 32, 24576, 47, 6656, 28672, 21, 198, 0, 47, 6656,
    28672, 21, 198, 18, 47, 6656, 4099, 147, 4098, 189, 3, 53248, 177, 26, 8,
    20481, 177, 26, 24578, 47, 6656, 28672, 21, 396, 0, 47, 6656, 28672, 21,
    396, 18, 47, 6656, 4100, 147, 4097, 189, 3, 20481, 177, 26, 24579, 47,
    6656, 28672, 21, 414, 0, 47, 6656, 28672, 21, 414, 18, 47, 6656, 4100, 147,
    4097, 189, 2, 53248, 177, 26, 24, 20480, 177, 26, 61440, 177, 47, 6682, 32,
    24578, 47, 6656, 28672, 240, 432, 54, 47, 6656, 28672, 240, 432, 72, 47,
    6656, 28672, 240, 432, 90, 47, 6656, 4100, 147, 4097, 189, 2, 20480, 177,
    26, 28672, 177, 47, 6682, 24579, 47, 6656, 28672, 240, 450, 54, 47, 6656,
    28672, 240, 450, 72, 47, 6656, 28672, 240, 450, 90, 47, 6656, 4100, 147,
    4097, 189, 1, 53248, 177, 26, 8, 20480, 177, 26, 28672, 177, 47, 6682,
    28672, 42, 0, 216, 47, 6656, 28672, 42, 0, 234, 47, 6656, 24577, 47, 6656,
    28672, 240, 468, 54, 47, 6656, 28672, 240, 468, 72, 47, 6656, 28672, 240,
    468, 90, 47, 6656, 4100, 147, 4097, 189, 0, 53248, 177, 26, 8, 20481, 177,
    26, 61440, 177, 47, 6682, 32, 24581, 47, 6656, 28672, 147, 47, 6656, 4100,
    147, 4097, 189, 0, 20481, 177, 26, 24582, 47, 6656, 61440, 147, 47, 6656,
    8, 28672, 147, 47, 6656, 4100, 147, 4097, 189, 0, 20481, 177, 26, 24581,
    47, 6656, 61440, 147, 47, 6656, 8, 12288, 147, 47, 28672, 147, 47, 6656,
    4100, 147, 4097, 189, 0, 53248, 177, 26, 16, 20480, 177, 26, 28672, 177,
    47, 6682, 61440, 177, 47, 6682, 40, 24579, 47, 6656, 28672, 147, 47, 6656,
    12288, 147, 47, 28672, 147, 47, 6656, 4100, 147, 4097, 189, 1, 20481, 177,
    26, 28672, 177, 47, 6682, 28672, 42, 0, 216, 47, 6656, 28672, 42, 0, 234,
    47, 6656, 24577, 47, 6656, 28674, 147, 47, 6656, 4100, 147, 4097, 189, 2,
    20480, 177, 26, 28672, 177, 47, 6682, 24580, 47, 6656, 12288, 147, 47,
    28672, 147, 47, 6656, 4100, 147, 4097, 189, 2, 53248, 177, 26, 8, 20480,
    177, 26, 28672, 177, 47, 6682, 24579, 47, 6656, 28673, 147, 47, 6656, 4100,
    147, 4097, 189, 3, 53248, 177, 26, 16, 20480, 177, 26, 61440, 177, 47,
    6682, 40, 24578, 47, 6656, 61440, 147, 47, 6656, 8, 28672, 147, 47, 6656,
    4100, 147, 4097, 189, 4, 20480, 177, 26, 28672, 177, 47, 6682, 24579, 47,
    6656, 28672, 147, 47, 6656, 4100, 147, 4097, 189, 3, 36864, 147, 8, 20480,
    177, 26, 28672, 177, 47, 6682, 24579, 47, 6656, 61440, 147, 47, 6656, 8,
    4100, 147, 4097, 189, 4, 20481, 177, 26, 61440, 177, 47, 6682, 40, 24579,
    47, 6656, 4100, 147, 4097, 189, 5, 20480, 177, 26, 28672, 177, 47, 6682,
    24579, 47, 6656, 4100, 147, 4097, 189, 5, 53248, 177, 26, 8, 20480, 177,
    26, 28672, 177, 47, 6682, 24578, 47, 6656, 4099, 147, 4098, 189, 6, 20480,
    177, 26, 28672, 177, 47, 6682, 24578, 47, 6656, 4099, 147, 4098, 189, 6,
    53248, 177, 26, 8, 20480, 177, 26, 24578, 47, 6656, 4099, 147, 4098, 189,
    7, 20480, 177, 26, 2, 4099, 147, 4098, 189, 11, 4098, 147, 4099, 189, 11,
    4096, 189, 4097, 147, 4099, 189, 10, 4098, 189, 4096, 147, 4109, 189,
    20484, 189, 1, 4098, 189
},
// igloo4
{
    9495, 4104, 189, 20484, 189, 1, 4105, 189, 8, 4109, 189, 9, 4096, 189,
    4098, 147, 4104, 189, 9, 4100, 147, 4103, 189, 9, 4102, 147, 4101, 189, 8,
    20485, 151, 26, 4098, 147, 4100, 189, 8, 20485, 151, 26, 4099, 147, 4099,
    189, 8, 20480, 151, 26, 24577, 34, 6656, 20483, 151, 26, 4099, 147, 4098,
    189, 8, 20480, 387, 0, 0, 26, 24579, 34, 6656, 20483, 151, 26, 4097, 147,
    4098, 189, 8, 20480, 387, 18, 0, 26, 24580, 34, 6656, 20482, 151, 26, 4097,
    147, 4098, 189, 8, 20480, 151, 26, 28672, 151, 34, 6682, 24579, 34, 6656,
    20482, 151, 26, 4097, 147, 4098, 189, 7, 36864, 147, 8, 20481, 151, 26,
    24579, 34, 6656, 20482, 151, 26, 4097, 147, 4098, 189, 6, 36864, 147, 8,
    4096, 147, 20481, 151, 26, 24578, 34, 6656, 61440, 151, 34, 6682, 8, 20482,
    151, 26, 4097, 147, 4098, 189, 6, 36864, 147, 8, 4096, 147, 20480, 151, 26,
    28672, 151, 34, 6682, 24579, 34, 6656, 20481, 151, 26, 4099, 147, 4097,
    189, 5, 36864, 147, 24, 20482, 151, 26, 24580, 34, 6656, 20481, 151, 26,
    4099, 147, 4097, 189, 3, 36864, 147, 8, 20484, 151, 26, 24580, 34, 6656,
    20481, 151, 26, 4099, 147, 4097, 189, 2, 20483, 151, 26, 28672, 151, 34,
    6682, 24577, 34, 6656, 28672, 33, 0, 440, 34, 6656, 28672, 19, 90, 342, 34,
    6656, 24576, 34, 6656, 28672, 89, 1296, 0, 34, 6656, 28672, 89, 1296, 18,
    34, 6656, 20481, 151, 26, 4099, 147, 4097, 189, 1, 20482, 151, 26, 24583,
    34, 6656, 28672, 89, 1314, 0, 34, 6656, 28672, 89, 1314, 18, 34, 6656,
    28672, 151, 34, 6682, 20480, 151, 26, 4098, 147, 4098, 189, 1, 20480, 151,
    26, 28673, 151, 34, 6682, 24577, 34, 6656, 28672, 242, 0, 864, 34, 6656,
    28672, 242, 0, 882, 34, 6656, 28672, 242, 0, 900, 34, 6656, 28672, 242, 0,
    918, 34, 6656, 24577, 34, 6656, 28672, 89, 1332, 0, 34, 6656, 28672, 89,
    1332, 18, 34, 6656, 28672, 151, 34, 6682, 20480, 151, 26, 4099, 147, 4097,
    189, 0, 53248, 151, 26, 8, 20480, 151, 26, 28672, 151, 34, 6682, 24578, 34,
    6656, 28672, 242, 18, 864, 34, 6656, 28672, 242, 18, 882, 34, 6656, 28672,
    242, 18, 900, 34, 6656, 28672, 242, 18, 918, 34, 6656, 24580, 34, 6656,
    20481, 151, 26, 4098, 147, 4097, 189, 0, 20482, 151, 26, 24578, 34, 6656,
    28672, 242, 36, 864, 34, 6656, 28672, 242, 36, 882, 34, 6656, 28672, 242,
    36, 900, 34, 6656, 28672, 242, 36, 918, 34, 6656, 24579, 34, 6656, 61440,
    151, 34, 6682, 8, 28672, 151, 34, 26, 20480, 151, 26, 4098, 147, 4097, 189,
    0, 20482, 151, 26, 24578, 34, 6656, 28672, 242, 54, 864, 34, 6656, 28672,
    242, 54, 882, 34, 6656, 28672, 242, 54, 900, 34, 6656, 28672, 242, 54, 918,
    34, 6656, 24579, 34, 6656, 61440, 151, 34, 6682, 8, 28672, 151, 34, 6682,
    20480, 151, 26, 4098, 147, 4097, 189, 0, 20482, 151, 26, 24578, 34, 6656,
    28672, 242, 72, 864, 34, 6656, 28672, 242, 72, 882, 34, 6656, 28672, 242,
    72, 900, 34, 6656, 28672, 242, 72, 918, 34, 6656, 24578, 34, 6656, 28672,
    21, 396, 0, 34, 6656, 28672, 21, 396, 18, 34, 6656, 20481, 151, 26, 4098,
    147, 4097, 189, 1, 20481, 151, 26, 28672, 151, 34, 6682, 24577, 34, 6656,
    28672, 242, 90, 864, 34, 6656, 28672, 242, 90, 882, 34, 6656, 28672, 242,
    90, 900, 34, 6656, 28672, 242, 90, 918, 34, 6656, 24578, 34, 6656, 28672,
    21, 414, 0, 34, 6656, 28672, 21, 414, 18, 34, 6656, 20481, 151, 26, 4098,
    147, 4097, 189, 1, 20481, 151, 26, 28672, 151, 34, 6682, 24578, 34, 6656,
    28672, 100, 0, 720, 34, 6656, 28672, 100, 0, 738, 34, 6656, 28672, 19, 36,
    342, 34, 6656, 24579, 34, 6656, 61440, 151, 34, 6682, 8, 20481, 151, 26,
    4098, 147, 4097, 189, 1, 20482, 151, 26, 24578, 34, 6656, 28672, 100, 18,
    720, 34, 6656, 28672, 100, 18, 738, 34, 6656, 28672, 19, 18, 342, 34, 6656,
    24579, 34, 6656, 28672, 151, 34, 6682, 20481, 151, 26, 4097, 147, 4098,
    189, 1, 53248, 151, 26, 8, 20481, 151, 26, 28672, 151, 34, 6682, 24584, 34,
    6656, 20481, 151, 26, 4098, 147, 4098, 189, 2, 20482, 151, 26, 28672, 151,
    34, 6682, 24582, 34, 6656, 28672, 151, 34, 6682, 20481, 151, 26, 4098, 147,
    4098, 189, 3, 53248, 151, 26, 8, 20480, 151, 26, 28675, 151, 34, 6682,
    24578, 34, 6656, 28672, 151, 34, 6682, 20482, 151, 26, 4098, 147, 4098,
    189, 4, 20481, 151, 26, 28674, 151, 34, 6682, 24576, 34, 6656, 28674, 151,
    34, 6682, 20481, 151, 26, 4098, 147, 4099, 189, 5, 20483, 151, 26, 28674,
    151, 34, 6682, 20482, 151, 26, 4098, 147, 4099, 189, 6, 4097, 147, 20484,
    151, 26, 4100, 147, 4099, 189, 7, 4097, 147, 20483, 151, 26, 4098, 147,
    4101, 189, 7, 4104, 147, 4101, 189, 8, 4096, 189, 4101, 147, 4102, 189, 7,
    4098, 189, 4098, 147, 4111, 189, 20484, 189, 1, 4105, 189
},
// igloo5
{
    9494, 4102, 189, 20485, 189, 1, 4105, 189, 6, 4099, 189, 4098, 147, 4103,
    189, 8, 4096, 189, 4100, 147, 4102, 189, 9, 4101, 147, 4101, 189, 9, 36864,
    147, 8, 4100, 147, 4101, 189, 9, 36864, 147, 8, 4101, 147, 4100, 189, 9,
    4097, 147, 20480, 273, 26, 4100, 147, 4099, 189, 9, 20480, 273, 26, 4096,
    147, 20480, 273, 26, 4100, 147, 4099, 189, 9, 20482, 273, 26, 4096, 147,
    20480, 273, 26, 4098, 147, 4099, 189, 9, 61440, 273, 147, 6682, 8, 28672,
    273, 147, 6682, 28672, 273, 147, 26, 28672, 273, 147, 6682, 20480, 273, 26,
    4099, 147, 4098, 189, 8, 24579, 147, 6656, 61440, 273, 147, 6682, 8, 28672,
    273, 147, 6682, 20480, 273, 26, 4098, 147, 4098, 189, 9, 24580, 147, 6656,
    28672, 273, 147, 6682, 20480, 273, 26, 4097, 147, 4098, 189, 8, 20480, 273,
    26, 24580, 147, 6656, 28672, 273, 147, 26, 20480, 273, 26, 4098, 147, 4097,
    189, 7, 36864, 147, 8, 20481, 273, 26, 24580, 147, 6656, 28672, 273, 147,
    6682, 4098, 147, 4097, 189, 7, 20482, 273, 26, 24579, 147, 6656, 61440,
    273, 147, 6682, 8, 20480, 273, 26, 4098, 147, 4097, 189, 7, 4096, 147,
    20481, 273, 26, 28672, 273, 147, 26, 24578, 147, 6656, 61440, 273, 147,
    6682, 8, 28672, 273, 147, 6682, 20481, 273, 26, 4096, 147, 4097, 189, 7,
    36864, 147, 8, 4096, 147, 20480, 273, 26, 28672, 273, 147, 26, 24578, 147,
    6656, 28673, 273, 147, 6682, 20481, 273, 26, 4096, 147, 4097, 189, 7,
    20482, 273, 26, 28672, 273, 147, 6682, 24578, 147, 6656, 28672, 273, 147,
    6682, 20480, 273, 26, 4098, 147, 4097, 189, 4, 20485, 273, 26, 28672, 273,
    147, 26, 24578, 147, 6656, 28672, 273, 147, 26, 28672, 273, 147, 6682,
    4098, 147, 4097, 189, 2, 20483, 273, 26, 24576, 147, 6656, 61440, 273, 147,
    6682, 8, 28672, 273, 147, 6682, 24576, 147, 6656, 28672, 19, 54, 342, 147,
    6682, 24578, 147, 6656, 28672, 273, 147, 6682, 20481, 273, 26, 4097, 147,
    4097, 189, 1, 53248, 273, 26, 8, 20480, 273, 26, 28672, 273, 147, 6682,
    24581, 147, 6656, 28672, 19, 0, 342, 147, 6682, 24576, 147, 6656, 28672,
    21, 396, 0, 147, 6656, 28672, 21, 396, 18, 147, 6656, 28672, 273, 147,
    6682, 4099, 147, 4097, 189, 1, 20482, 273, 26, 24581, 147, 6656, 28672, 19,
    0, 342, 147, 6682, 24576, 147, 6656, 28672, 21, 414, 0, 147, 6656, 28672,
    21, 414, 18, 147, 6656, 28672, 273, 147, 6682, 20480, 273, 26, 4098, 147,
    4097, 189, 1, 20481, 273, 26, 28672, 273, 147, 6682, 24577, 147, 6656,
    28672, 100, 0, 720, 147, 6682, 28672, 100, 0, 738, 147, 6682, 28672, 19,
    36, 342, 147, 6682, 24576, 147, 6656, 28672, 19, 0, 342, 147, 6682, 24578,
    147, 6656, 28672, 273, 147, 6682, 20480, 273, 26, 4098, 147, 4097, 189, 0,
    36864, 147, 8, 4096, 147, 12288, 273, 147, 28672, 273, 147, 6682, 24577,
    147, 6656, 28672, 100, 18, 720, 147, 6682, 28672, 100, 18, 738, 147, 6682,
    28672, 19, 18, 342, 147, 6682, 24576, 147, 6656, 28672, 19, 0, 342, 147,
    6682, 24577, 147, 6656, 61440, 273, 147, 6682, 8, 28672, 273, 147, 6682,
    20480, 273, 26, 4098, 147, 4097, 189, 0, 36864, 147, 8, 4096, 147, 20481,
    273, 26, 24581, 147, 6656, 28672, 19, 0, 342, 147, 6682, 24577, 147, 6656,
    28673, 273, 147, 6682, 20480, 273, 26, 4098, 147, 4097, 189, 1, 36864, 147,
    8, 20481, 273, 26, 24581, 147, 6656, 28672, 19, 0, 342, 147, 6682, 24576,
    147, 6656, 61440, 273, 147, 6682, 8, 28672, 273, 147, 6682, 4100, 147,
    4097, 189, 1, 36864, 147, 8, 20481, 273, 26, 28672, 273, 147, 6682, 24578,
    147, 6656, 28672, 21, 180, 0, 147, 6656, 28672, 21, 180, 18, 147, 6656,
    28672, 19, 0, 342, 147, 6682, 24576, 147, 6656, 28672, 273, 147, 6682,
    28672, 147, 147, 6656, 4099, 147, 4098, 189, 2, 53248, 273, 26, 8, 20482,
    273, 26, 28672, 273, 147, 6682, 24576, 147, 6656, 28672, 21, 198, 0, 147,
    6656, 28672, 21, 198, 18, 147, 6656, 28672, 19, 72, 342, 147, 6682, 61440,
    273, 147, 6682, 8, 28672, 273, 147, 6682, 28672, 147, 147, 6656, 4098, 147,
    4099, 189, 4, 20486, 273, 26, 28673, 273, 147, 6682, 4099, 147, 4099, 189,
    6, 53248, 273, 26, 8, 20484, 273, 26, 4098, 147, 4101, 189, 8, 4098, 147,
    20480, 273, 26, 4098, 147, 4101, 189, 8, 36864, 147, 8, 4101, 147, 4101,
    189, 8, 4101, 147, 4102, 189, 8, 4098, 147, 4105, 189, 7, 4109, 189, 7,
    4116, 189, 20483, 189, 1, 4105, 189
},
// igloo6
{
    11547, 4110, 189, 20485, 189, 1, 4102, 189, 14, 4099, 189, 4096, 147, 4100,
    161, 4097, 189, 15, 4097, 189, 4097, 147, 4099, 161, 4096, 147, 4097, 189,
    14, 4097, 189, 4098, 147, 4097, 161, 4098, 147, 4097, 189, 10, 36864, 147,
    8, 4097, 147, 20482, 274, 26, 4103, 147, 4097, 189, 8, 36864, 147, 8, 4096,
    147, 20485, 274, 26, 4096, 147, 4096, 161, 4101, 147, 4097, 189, 6, 20489,
    274, 26, 4096, 147, 4097, 161, 4100, 147, 4097, 189, 5, 20482, 274, 26,
    28674, 274, 147, 26, 61440, 274, 147, 6682, 32, 28672, 33, 0, 440, 147,
    6656, 28672, 19, 108, 342, 147, 6656, 28672, 274, 147, 6682, 20480, 274,
    26, 4097, 147, 4096, 161, 4100, 147, 4097, 189, 2, 53248, 274, 26, 24,
    20483, 274, 26, 61440, 274, 147, 6682, 32, 24579, 147, 6656, 28672, 89,
    1296, 0, 147, 6656, 28672, 89, 1296, 18, 147, 6656, 28672, 274, 147, 6682,
    20480, 274, 26, 4097, 147, 4097, 161, 4099, 147, 4097, 189, 2, 20481, 274,
    26, 28673, 151, 147, 6682, 28672, 274, 147, 6682, 24580, 147, 6656, 28672,
    89, 1314, 0, 147, 6656, 28672, 89, 1314, 18, 147, 6656, 28672, 274, 147,
    6682, 20480, 274, 26, 4097, 147, 4097, 161, 4099, 147, 4097, 189, 2, 20480,
    274, 26, 28672, 274, 147, 6682, 28672, 91, 36, 0, 147, 6656, 28672, 91, 36,
    18, 147, 6656, 28672, 91, 36, 36, 147, 6656, 24580, 147, 6656, 28672, 89,
    1332, 0, 147, 6656, 28672, 89, 1332, 18, 147, 6656, 28672, 274, 147, 6682,
    20480, 274, 26, 4097, 147, 4096, 161, 4100, 147, 4097, 189, 1, 53248, 274,
    26, 8, 20480, 274, 26, 28672, 274, 147, 6682, 28672, 91, 36, 0, 147, 6656,
    28672, 91, 36, 18, 147, 6656, 28672, 91, 36, 36, 147, 6656, 24582, 147,
    6656, 28672, 274, 147, 6682, 20480, 274, 26, 4103, 147, 4097, 189, 1,
    20481, 274, 26, 28672, 274, 147, 6682, 28672, 91, 36, 0, 147, 6656, 28672,
    91, 36, 18, 147, 6656, 28672, 91, 36, 36, 147, 6656, 24581, 147, 6656,
    61440, 274, 147, 6682, 8, 28672, 274, 147, 6682, 20480, 274, 26, 4103, 147,
    4097, 189, 0, 36864, 147, 8, 20481, 274, 26, 61440, 274, 147, 6682, 32,
    24584, 147, 6656, 28673, 274, 147, 26, 20480, 274, 26, 4098, 147, 4096,
    161, 4099, 147, 4097, 189, 36864, 147, 8, 4096, 147, 20481, 274, 26, 24581,
    147, 6656, 28672, 93, 0, 1080, 147, 6656, 28672, 93, 0, 1098, 147, 6656,
    28672, 93, 0, 1116, 147, 6656, 28672, 321, 147, 6656, 28672, 274, 147, 26,
    20480, 274, 26, 4099, 147, 4097, 161, 4098, 147, 4097, 189, 0, 4096, 147,
    20481, 274, 26, 24582, 147, 6656, 28672, 21, 396, 0, 147, 6656, 28672, 21,
    396, 18, 147, 6656, 28672, 321, 147, 6656, 28672, 274, 147, 6682, 20480,
    274, 26, 4099, 147, 4098, 161, 4097, 147, 4097, 189, 0, 36864, 147, 8,
    20480, 274, 26, 28672, 274, 147, 6682, 24582, 147, 6656, 28672, 21, 414, 0,
    147, 6656, 28672, 21, 414, 18, 147, 6656, 28672, 321, 147, 6656, 28672,
    274, 147, 6682, 20480, 274, 26, 4099, 147, 4099, 161, 4096, 147, 4097, 189,
    0, 20481, 274, 26, 28672, 274, 147, 6682, 24581, 147, 6656, 28672, 93, 0,
    1080, 147, 6656, 28672, 93, 0, 1098, 147, 6656, 28672, 93, 0, 1116, 147,
    6656, 28672, 321, 147, 6656, 28672, 274, 147, 26, 20481, 274, 26, 4098,
    147, 4099, 161, 4096, 147, 4097, 189, 0, 20481, 274, 26, 61440, 274, 147,
    6682, 32, 24585, 147, 6656, 28672, 274, 147, 6682, 20481, 274, 26, 4098,
    147, 4099, 161, 4096, 147, 4097, 189, 0, 20481, 274, 26, 28672, 91, 36, 0,
    147, 6656, 28672, 91, 36, 18, 147, 6656, 28672, 91, 36, 36, 147, 6656,
    24577, 147, 6656, 28672, 242, 216, 504, 147, 6656, 28672, 242, 216, 522,
    147, 6656, 28672, 242, 216, 540, 147, 6656, 28672, 242, 216, 558, 147,
    6656, 24577, 147, 6656, 28672, 274, 147, 6682, 20481, 274, 26, 4098, 147,
    4098, 161, 4097, 147, 4097, 189, 36864, 147, 8, 20481, 274, 26, 28672, 91,
    36, 0, 147, 6656, 28672, 91, 36, 18, 147, 6656, 28672, 91, 36, 36, 147,
    6656, 24577, 147, 6656, 28672, 242, 234, 504, 147, 6656, 28672, 242, 234,
    522, 147, 6656, 28672, 242, 234, 540, 147, 6656, 28672, 242, 234, 558, 147,
    6656, 24577, 147, 6656, 61440, 274, 147, 6682, 8, 20481, 274, 26, 4098,
    147, 4097, 161, 4098, 147, 4097, 189, 36864, 147, 8, 20481, 274, 26, 28672,
    91, 36, 0, 147, 6656, 28672, 91, 36, 18, 147, 6656, 28672, 91, 36, 36, 147,
    6656, 24577, 147, 6656, 28672, 242, 252, 504, 147, 6656, 28672, 242, 252,
    522, 147, 6656, 28672, 242, 252, 540, 147, 6656, 28672, 242, 252, 558, 147,
    6656, 24578, 147, 6656, 20481, 274, 26, 4103, 147, 4097, 189, 0, 20481,
    274, 26, 28672, 274, 147, 6682, 24579, 147, 6656, 28672, 242, 270, 504,
    147, 6656, 28672, 242, 270, 522, 147, 6656, 28672, 242, 270, 540, 147,
    6656, 28672, 242, 270, 558, 147, 6656, 24578, 147, 6656, 28672, 274, 147,
    6682, 20481, 274, 26, 4102, 147, 4097, 189, 0, 20482, 274, 26, 24579, 147,
    6656, 28672, 242, 288, 504, 147, 6656, 28672, 242, 288, 522, 147, 6656,
    28672, 242, 288, 540, 147, 6656, 28672, 242, 288, 558, 147, 6656, 24578,
    147, 6656, 28672, 274, 147, 26, 20481, 274, 26, 4102, 147, 4097, 189, 1,
    20482, 274, 26, 28672, 274, 147, 6682, 61440, 274, 147, 6682, 40, 24576,
    147, 6656, 28672, 242, 306, 504, 147, 6656, 28672, 242, 306, 522, 147,
    6656, 28672, 242, 306, 540, 147, 6656, 28672, 242, 306, 558, 147, 6656,
    24579, 147, 6656, 28672, 274, 147, 26, 20483, 274, 26, 4099, 147, 4097,
    189, 1, 20483, 274, 26, 28672, 274, 147, 6682, 24584, 147, 6656, 61440,
    274, 147, 6682, 16, 20483, 274, 26, 4099, 147, 4097, 189, 2, 20484, 274,
    26, 24585, 147, 6656, 28672, 274, 147, 6682, 20481, 274, 26, 4099, 147,
    4097, 189, 3, 36864, 147, 8, 20483, 274, 26, 28673, 274, 147, 6682, 24581,
    147, 6656, 28672, 21, 180, 0, 147, 6656, 28672, 21, 180, 18, 147, 6656,
    20482, 274, 26, 4098, 147, 4097, 189, 4, 4096, 147, 20483, 274, 26, 28673,
    274, 147, 6682, 61440, 274, 147, 6682, 40, 24579, 147, 6656, 28672, 21,
    198, 0, 147, 6656, 28672, 21, 198, 18, 147, 6656, 28672, 274, 147, 6682,
    20481, 274, 26, 4098, 147, 4097, 189, 7, 36864, 147, 8, 20483, 274, 26,
    28672, 274, 147, 6682, 24580, 147, 6656, 20482, 274, 26, 4098, 147, 4097,
    189, 8, 36864, 147, 8, 4096, 147, 20482, 274, 26, 61440, 274, 147, 6682,
    40, 24580, 147, 6656, 20481, 274, 26, 4098, 147, 4097, 189, 9, 4096, 147,
    20482, 274, 26, 61440, 274, 147, 6682, 32, 24579, 147, 6656, 61440, 274,
    147, 6682, 8, 20481, 274, 26, 4098, 147, 4097, 189, 8, 20482, 274, 26,
    28672, 151, 147, 6682, 28672, 274, 147, 6682, 28672, 91, 36, 0, 147, 6656,
    28672, 91, 36, 18, 147, 6656, 28672, 91, 36, 36, 147, 6656, 24577, 147,
    6656, 20482, 274, 26, 4098, 147, 4097, 189, 7, 20481, 274, 26, 28673, 274,
    147, 6682, 61440, 274, 147, 6682, 32, 24581, 147, 6656, 20482, 274, 26,
    4098, 147, 4097, 189, 6, 20481, 274, 26, 28673, 274, 147, 6682, 28672, 91,
    36, 0, 147, 6656, 28672, 91, 36, 18, 147, 6656, 28672, 91, 36, 36, 147,
    6656, 24580, 147, 6656, 20482, 274, 26, 4098, 147, 4097, 189, 6, 24585,
    147, 6656, 61440, 274, 147, 6682, 8, 20483, 274, 26, 4097, 147, 4096, 161,
    4097, 189, 6, 24582, 147, 6656, 28672, 274, 147, 6682, 20485, 274, 26,
    4098, 147, 4096, 161, 4097, 189, 7, 24580, 147, 6656, 20486, 274, 26,
    20480, 151, 26, 4098, 147, 4096, 161, 4097, 189, 8, 24577, 147, 6656,
    61440, 274, 147, 6682, 24, 20483, 274, 26, 4102, 147, 4097, 161, 4097, 189,
    8, 24577, 147, 6656, 20482, 274, 26, 53248, 274, 26, 32, 4102, 147, 4098,
    161, 4097, 189, 7, 53248, 274, 26, 8, 20483, 274, 26, 1, 4101, 147, 4098,
    161, 4096, 147, 4097, 189, 8, 53248, 274, 26, 8, 20481, 274, 26, 53248,
    274, 26, 32, 1, 4099, 147, 4100, 161, 4096, 147, 4097, 189, 13, 4097, 189,
    4098, 147, 4099, 161, 4097, 147, 4097, 189, 11, 4100, 189, 4098, 147, 4097,
    161, 4098, 147, 4108, 189, 20486, 189, 1, 4103, 189
},
// igloo7
{
    8724, 4103, 189, 20485, 189, 1, 4102, 189, 7, 4099, 189, 4101, 147, 4097,
    189, 7, 4097, 189, 4103, 147, 4097, 189, 7, 4096, 189, 4104, 147, 4097,
    189, 8, 4101, 147, 4096, 161, 4097, 147, 4097, 189, 8, 24576, 34, 6656,
    20481, 273, 26, 4098, 147, 4097, 161, 4096, 147, 4097, 189, 8, 24576, 34,
    6656, 28672, 273, 34, 6682, 20482, 273, 26, 4097, 147, 4097, 161, 4097,
    189, 7, 24577, 34, 6656, 61440, 273, 34, 6682, 8, 20483, 273, 26, 4096,
    147, 4097, 161, 4097, 189, 6, 24580, 34, 6656, 28672, 273, 34, 6682, 20481,
    273, 26, 4096, 147, 4097, 161, 4097, 189, 2, 36864, 147, 8, 20482, 273, 26,
    24581, 34, 6656, 28672, 273, 34, 6682, 20480, 273, 26, 4096, 147, 4096,
    161, 4096, 147, 4097, 189, 2, 36864, 147, 8, 4096, 147, 20481, 273, 26,
    61440, 273, 34, 6682, 40, 24580, 34, 6656, 28672, 273, 34, 6682, 20480,
    273, 26, 4096, 147, 4097, 161, 4097, 189, 3, 36864, 147, 8, 4096, 147,
    20480, 273, 26, 28672, 273, 34, 6682, 24579, 34, 6656, 61440, 273, 34,
    6682, 24, 20481, 273, 26, 4097, 147, 4096, 161, 4097, 189, 4, 20481, 273,
    26, 61440, 273, 34, 6682, 32, 24579, 34, 6656, 28672, 273, 34, 6682, 20481,
    273, 26, 4097, 147, 4096, 161, 4097, 189, 3, 53248, 273, 26, 8, 20480, 273,
    26, 28672, 273, 34, 6682, 24579, 34, 6656, 61440, 273, 34, 6682, 8, 20481,
    273, 26, 4097, 147, 4097, 161, 4097, 189, 1, 36864, 147, 8, 20481, 273, 26,
    28672, 273, 34, 6682, 24580, 34, 6656, 28672, 273, 34, 6682, 20481, 273,
    26, 4099, 147, 4097, 189, 0, 36864, 147, 8, 20481, 273, 26, 28672, 273, 34,
    6682, 24580, 34, 6656, 61440, 273, 34, 6682, 24, 20481, 273, 26, 4098, 147,
    4096, 161, 4096, 147, 4097, 189, 0, 36864, 147, 8, 20481, 273, 26, 24578,
    34, 6656, 28672, 33, 0, 440, 34, 6656, 28672, 14, 1512, 0, 34, 6656, 28672,
    14, 1512, 18, 34, 6656, 28672, 273, 34, 6682, 20481, 273, 26, 4098, 147,
    4096, 161, 4096, 147, 4097, 189, 0, 20481, 273, 26, 28672, 273, 34, 6682,
    24579, 34, 6656, 28672, 14, 1530, 0, 34, 6656, 28672, 14, 1530, 18, 34,
    6656, 28672, 273, 34, 6682, 20480, 273, 26, 4099, 147, 4096, 161, 4096,
    147, 4097, 189, 36864, 147, 8, 20480, 273, 26, 28672, 273, 34, 6682, 24580,
    34, 6656, 28672, 14, 1548, 0, 34, 6656, 28672, 14, 1548, 18, 34, 6656,
    28672, 273, 34, 6682, 20480, 273, 26, 4099, 147, 4096, 161, 4096, 147,
    4097, 189, 4096, 147, 20480, 273, 26, 28672, 273, 34, 6682, 24580, 34,
    6656, 28672, 15, 0, 1200, 34, 6656, 28672, 15, 0, 1218, 34, 6656, 28672,
    273, 34, 6682, 20480, 273, 26, 4098, 147, 4097, 161, 4096, 147, 4097, 189,
    36864, 147, 16, 20480, 273, 26, 28672, 273, 34, 6682, 24582, 34, 6656,
    28672, 273, 34, 6682, 20480, 273, 26, 4098, 147, 4097, 161, 4096, 147,
    4097, 189, 0, 20480, 273, 26, 28672, 273, 34, 6682, 24582, 34, 6656, 28672,
    273, 34, 6682, 20480, 273, 26, 4101, 147, 4097, 189, 0, 53248, 273, 26, 8,
    20480, 273, 26, 28672, 273, 34, 6682, 28672, 42, 0, 1044, 34, 6656, 28672,
    42, 0, 1062, 34, 6656, 24577, 34, 6656, 28672, 21, 396, 0, 34, 6656, 28672,
    21, 396, 18, 34, 6656, 28672, 273, 34, 6682, 20480, 273, 26, 4101, 147,
    4097, 189, 1, 53248, 273, 26, 8, 20480, 273, 26, 28672, 273, 34, 6682,
    24578, 34, 6656, 28672, 21, 414, 0, 34, 6656, 28672, 21, 414, 18, 34, 6656,
    28672, 273, 34, 6682, 20480, 273, 26, 4101, 147, 4097, 189, 1, 36864, 147,
    8, 20480, 273, 26, 28672, 273, 34, 6682, 24578, 34, 6656, 28672, 79, 0,
    864, 34, 6656, 28672, 79, 0, 882, 34, 6656, 28672, 273, 34, 6682, 20480,
    273, 26, 4098, 147, 4097, 161, 4096, 147, 4097, 189, 2, 20481, 273, 26,
    28672, 273, 34, 6682, 24577, 34, 6656, 28672, 79, 18, 864, 34, 6656, 28672,
    79, 18, 882, 34, 6656, 28672, 273, 34, 6682, 20480, 273, 26, 4097, 147,
    4099, 161, 4097, 189, 2, 36864, 147, 8, 20480, 273, 26, 28672, 273, 34,
    6682, 24577, 34, 6656, 28672, 79, 36, 864, 34, 6656, 28672, 79, 36, 882,
    34, 6656, 28672, 273, 34, 6682, 20480, 273, 26, 4097, 147, 4098, 161, 4096,
    147, 4097, 189, 2, 36864, 147, 8, 20481, 273, 26, 28673, 273, 34, 6682,
    28672, 79, 54, 864, 34, 6656, 28672, 79, 54, 882, 34, 6656, 28672, 273, 34,
    6682, 20480, 273, 26, 4097, 147, 4098, 161, 4096, 147, 4097, 189, 4, 53248,
    273, 26, 8, 20480, 273, 26, 28674, 273, 34, 6682, 20481, 273, 26, 4098,
    147, 4097, 161, 4096, 147, 4097, 189, 6, 20484, 273, 26, 4097, 147, 4098,
    161, 4096, 147, 4097, 189, 7, 53248, 273, 26, 16, 20481, 273, 26, 4098,
    147, 4098, 161, 4096, 147, 4097, 189, 9, 4096, 189, 4098, 147, 4097, 161,
    4097, 147, 4097, 189, 8, 4098, 189, 4096, 147, 4098, 161, 4097, 147, 4105,
    189, 20484, 189, 1, 4101, 189
},
// igloo8
{
    14876, 4107, 189, 20492, 189, 1, 4122, 189, 4098, 147, 4102, 189, 7, 4101,
    189, 4102, 147, 4101, 189, 9, 4097, 189, 4105, 147, 4099, 189, 12, 4096,
    189, 4105, 147, 4098, 189, 12, 4096, 215, 162, 0, 4096, 215, 162, 18, 4105,
    147, 4097, 189, 13, 4096, 215, 180, 0, 4096, 215, 180, 18, 4105, 147, 4097,
    189, 13, 4096, 215, 198, 0, 4096, 215, 198, 18, 4105, 147, 4097, 189, 15,
    4105, 147, 4097, 189, 15, 36864, 147, 8, 4104, 147, 4097, 189, 10, 4096, 4,
    44, 198, 3, 36864, 147, 8, 4104, 147, 4097, 189, 9, 4097, 148, 3, 36864,
    147, 24, 4104, 147, 4097, 189, 9, 4097, 148, 8195, 84, 4105, 147, 4097,
    189, 8, 36864, 147, 8, 4097, 148, 8197, 84, 4103, 147, 4097, 189, 8, 4096,
    147, 4097, 148, 8196, 84, 24577, 39, 6656, 4102, 147, 4097, 189, 7, 36864,
    147, 24, 4099, 148, 8194, 84, 24578, 39, 6656, 28672, 147, 39, 6656, 4101,
    147, 4097, 189, 6, 36864, 147, 8, 4096, 147, 4100, 148, 8192, 84, 24579,
    39, 6656, 61440, 147, 39, 6656, 8, 12288, 147, 39, 4100, 147, 4097, 189, 6,
    4096, 147, 4101, 148, 8192, 84, 24580, 39, 6656, 4101, 147, 4097, 189, 5,
    4103, 148, 8192, 31, 24580, 39, 6656, 28672, 147, 39, 6656, 4100, 147,
    4097, 189, 4, 36864, 147, 8, 4099, 148, 24576, 159, 6656, 8196, 31, 24579,
    39, 6656, 61440, 147, 39, 6656, 8, 4100, 147, 4097, 189, 4, 4098, 148,
    24576, 159, 6656, 8192, 31, 24576, 159, 6656, 8196, 31, 24581, 39, 6656,
    4099, 147, 4097, 189, 4, 4097, 148, 24576, 159, 6656, 8192, 31, 24576, 159,
    6656, 8197, 31, 24581, 39, 6656, 8192, 84, 24576, 39, 6656, 8192, 84, 4096,
    147, 4097, 189, 3, 4098, 148, 24576, 159, 6656, 8192, 31, 24576, 159, 6656,
    8195, 31, 12288, 148, 31, 8192, 31, 24580, 39, 6656, 8192, 84, 24576, 39,
    6656, 8192, 84, 24576, 39, 6656, 4096, 147, 4097, 189, 2, 4099, 148, 8192,
    31, 24576, 159, 6656, 8192, 31, 24576, 159, 6656, 8192, 31, 12288, 21, 396,
    0, 31, 12288, 21, 396, 18, 31, 12288, 148, 31, 8192, 31, 24580, 39, 6656,
    8192, 84, 24576, 39, 6656, 8192, 84, 24576, 39, 6656, 4096, 147, 4097, 189,
    2, 4097, 148, 8192, 31, 24576, 159, 6656, 8192, 31, 24576, 159, 6656, 8192,
    31, 24576, 159, 6656, 8192, 31, 12288, 21, 414, 0, 31, 12288, 21, 414, 18,
    31, 12288, 148, 31, 24576, 39, 6656, 8192, 31, 24580, 39, 6656, 8192, 84,
    24576, 39, 6656, 8192, 84, 4096, 147, 4097, 189, 1, 36864, 147, 24, 4097,
    148, 24576, 159, 6656, 8192, 31, 24576, 159, 6656, 8192, 31, 24576, 159,
    6656, 8195, 31, 12288, 148, 31, 28672, 42, 0, 1044, 31, 6656, 12288, 42, 0,
    1062, 31, 24580, 39, 6656, 8192, 84, 24576, 39, 6656, 8192, 84, 4096, 147,
    4097, 189, 1, 4096, 147, 4097, 148, 24576, 159, 6656, 8192, 31, 24576, 159,
    6656, 8192, 31, 24576, 159, 6656, 8195, 31, 12288, 148, 31, 24576, 39,
    6656, 8192, 31, 24579, 39, 6656, 8192, 84, 24576, 39, 6656, 12288, 89,
    1296, 0, 84, 28672, 89, 1296, 18, 39, 6656, 4096, 147, 4097, 189, 0, 36864,
    147, 8, 4096, 147, 4097, 148, 8192, 31, 24576, 159, 6656, 8192, 31, 24576,
    159, 6656, 8192, 31, 24576, 159, 6656, 8195, 31, 24576, 39, 6656, 8192, 31,
    24579, 39, 6656, 8192, 84, 24576, 39, 6656, 12288, 89, 1314, 0, 84, 28672,
    89, 1314, 18, 39, 6656, 4096, 147, 4097, 189, 0, 4097, 147, 4097, 148,
    8192, 31, 24576, 159, 6656, 8192, 31, 24576, 159, 6656, 8192, 31, 24576,
    159, 6656, 8195, 31, 24576, 39, 6656, 8192, 31, 24580, 39, 6656, 8192, 84,
    28672, 89, 1332, 0, 39, 6656, 12288, 89, 1332, 18, 84, 4096, 147, 4097,
    189, 0, 36864, 147, 16, 4098, 148, 24576, 159, 6656, 8192, 31, 24576, 159,
    6656, 8192, 31, 24576, 159, 6656, 8198, 31, 24580, 39, 6656, 8192, 84,
    28672, 33, 0, 440, 39, 6656, 12288, 18, 828, 0, 84, 4096, 147, 4097, 189,
    1, 4099, 148, 8192, 31, 24576, 159, 6656, 8192, 31, 24576, 159, 6656, 8198,
    31, 24579, 39, 6656, 8192, 84, 24576, 39, 6656, 8192, 84, 28672, 18, 846,
    0, 39, 6656, 4096, 147, 4097, 189, 1, 4099, 148, 24576, 159, 6656, 8192,
    31, 24576, 159, 6656, 8192, 31, 24576, 159, 6656, 8197, 31, 24579, 39,
    6656, 8192, 84, 24576, 39, 6656, 8192, 84, 24576, 39, 6656, 4096, 147,
    4097, 189, 2, 4099, 148, 8192, 31, 24576, 159, 6656, 8192, 31, 24576, 159,
    6656, 8197, 31, 24580, 39, 6656, 8192, 84, 24576, 39, 6656, 8192, 84, 4096,
    147, 4097, 189, 2, 4099, 148, 24576, 159, 6656, 8192, 31, 24576, 159, 6656,
    8197, 31, 24581, 39, 6656, 8192, 84, 24576, 39, 6656, 8192, 84, 4096, 147,
    4097, 189, 3, 4098, 148, 24576, 159, 6656, 8192, 31, 24576, 159, 6656,
    8198, 31, 24579, 39, 6656, 8192, 84, 24576, 39, 6656, 8192, 84, 24576, 39,
    6656, 4096, 147, 4097, 189, 4, 4097, 148, 12288, 148, 31, 24576, 159, 6656,
    8192, 31, 24576, 159, 6656, 8197, 31, 24579, 39, 6656, 8192, 84, 24576, 39,
    6656, 8192, 84, 24576, 39, 6656, 4096, 147, 4097, 189, 4, 36864, 147, 8,
    4097, 148, 24576, 159, 6656, 8192, 31, 24576, 159, 6656, 8197, 31, 24580,
    39, 6656, 8192, 84, 24576, 39, 6656, 4097, 147, 4097, 189, 4, 36864, 147,
    8, 4099, 148, 8197, 31, 24581, 39, 6656, 8192, 84, 4098, 147, 4097, 189, 6,
    4099, 148, 8196, 31, 24580, 39, 6656, 61440, 147, 39, 6656, 8, 4099, 147,
    4097, 189, 7, 4098, 148, 8195, 31, 24578, 39, 6656, 28672, 93, 0, 1080, 39,
    6656, 28672, 93, 0, 1098, 39, 6656, 28672, 93, 0, 1116, 39, 6656, 4100,
    147, 4097, 189, 8, 4098, 148, 8193, 31, 24581, 39, 6656, 28672, 147, 39,
    6656, 4100, 147, 4097, 189, 8, 36864, 147, 8, 4097, 148, 8193, 31, 24580,
    39, 6656, 4102, 147, 4097, 189, 9, 4098, 148, 8193, 31, 24576, 39, 6656,
    12288, 148, 39, 4104, 147, 4097, 189, 10, 4101, 148, 4104, 147, 4097, 189,
    11, 4100, 148, 4104, 147, 4097, 189, 13, 4098, 148, 4104, 147, 4097, 189,
    15, 4105, 147, 4097, 189, 15, 36864, 147, 8, 4104, 147, 4097, 189, 16,
    36864, 147, 8, 4103, 147, 4097, 189, 16, 36864, 147, 8, 4103, 147, 4097,
    189, 16, 36864, 147, 8, 4103, 147, 4097, 189, 17, 4103, 147, 4097, 189, 16,
    4096, 189, 4103, 147, 4097, 189, 15, 4097, 189, 4103, 147, 4097, 189, 15,
    4098, 189, 4102, 147, 4097, 189, 14, 4100, 189, 4101, 147, 4097, 189, 10,
    4104, 189, 4101, 147, 4112, 189, 20487, 189, 1, 4099, 189
},
// igloo9
{
    13855, 4112, 189, 20487, 189, 1, 4102, 189, 16, 4109, 189, 17, 4108, 189,
    18, 4098, 189, 4097, 147, 4102, 189, 19, 4096, 189, 4098, 147, 4102, 189,
    19, 4096, 189, 4098, 147, 4102, 189, 19, 4100, 147, 4101, 189, 19, 4100,
    147, 4101, 189, 17, 53248, 273, 26, 24, 20480, 273, 26, 20481, 274, 26,
    4098, 147, 4101, 189, 13, 36864, 147, 8, 20484, 273, 26, 20481, 274, 26,
    4098, 147, 4101, 189, 12, 53248, 273, 26, 24, 20485, 273, 26, 20481, 274,
    26, 4098, 147, 4101, 189, 10, 53248, 273, 26, 24, 20485, 273, 26, 28672,
    21, 180, 0, 147, 6656, 28672, 21, 180, 18, 147, 6656, 20481, 274, 26, 4098,
    147, 4101, 189, 9, 20484, 273, 26, 61440, 273, 34, 6682, 32, 24577, 34,
    6656, 28672, 21, 198, 0, 147, 6656, 28672, 21, 198, 18, 147, 6656, 20481,
    274, 26, 4098, 147, 4101, 189, 6, 36864, 147, 8, 4096, 147, 20483, 273, 26,
    28672, 273, 34, 6682, 24577, 34, 6656, 28672, 94, 0, 0, 34, 6656, 28672,
    94, 0, 18, 34, 6656, 28672, 19, 36, 342, 147, 6656, 28672, 18, 828, 0, 147,
    6656, 20481, 274, 26, 4098, 147, 4101, 189, 6, 36864, 147, 8, 20483, 273,
    26, 24579, 34, 6656, 28672, 94, 18, 0, 34, 6656, 28672, 94, 18, 18, 147,
    6656, 28672, 19, 18, 342, 147, 6656, 28672, 18, 846, 0, 147, 6656, 20481,
    274, 26, 4098, 147, 4101, 189, 6, 20482, 273, 26, 61440, 273, 34, 6682, 32,
    24581, 34, 6656, 24578, 147, 6656, 20481, 274, 26, 4099, 147, 4100, 189, 5,
    53248, 273, 26, 24, 20480, 273, 26, 28672, 273, 34, 6682, 24582, 34, 6656,
    24579, 147, 6656, 20481, 274, 26, 4099, 147, 4100, 189, 5, 20481, 273, 26,
    24581, 34, 6656, 24579, 147, 6656, 28672, 15, 18, 1200, 147, 6656, 28672,
    15, 18, 1218, 147, 6656, 20481, 274, 26, 4099, 147, 4100, 189, 4, 20482,
    273, 26, 24580, 34, 6656, 24582, 147, 6656, 20481, 274, 26, 4099, 147,
    4100, 189, 3, 36864, 147, 24, 20482, 273, 26, 24581, 34, 6656, 24579, 147,
    6656, 28672, 96, 0, 0, 147, 6656, 28672, 96, 0, 18, 147, 6656, 20481, 274,
    26, 4099, 147, 4100, 189, 3, 20483, 273, 26, 24577, 147, 6656, 61440, 19,
    90, 342, 147, 6656, 4096, 28672, 42, 0, 216, 34, 6656, 28672, 42, 0, 234,
    34, 6656, 24576, 34, 6656, 24579, 147, 6656, 28672, 96, 18, 0, 34, 6656,
    28672, 96, 18, 18, 34, 6656, 20481, 274, 26, 4099, 147, 4100, 189, 3,
    20482, 273, 26, 24578, 34, 6656, 24577, 147, 6656, 24578, 34, 6656, 24578,
    147, 6656, 24577, 34, 6656, 20481, 274, 26, 4099, 147, 4100, 189, 2, 20483,
    273, 26, 24578, 34, 6656, 24578, 147, 6656, 24577, 34, 6656, 24578, 147,
    6656, 28672, 15, 0, 1200, 34, 6656, 28672, 15, 0, 1218, 34, 6656, 20481,
    274, 26, 4099, 147, 4100, 189, 1, 4096, 147, 20482, 273, 26, 61440, 273,
    34, 6682, 32, 24578, 34, 6656, 24578, 147, 6656, 24577, 34, 6656, 24578,
    147, 6656, 24577, 34, 6656, 20481, 274, 26, 4100, 147, 4099, 189, 0, 36864,
    147, 8, 4096, 147, 20482, 273, 26, 24579, 34, 6656, 24578, 147, 6656,
    24577, 34, 6656, 24578, 147, 6656, 24577, 34, 6656, 20481, 274, 26, 4100,
    147, 4099, 189, 1, 36864, 147, 8, 20482, 273, 26, 24579, 34, 6656, 24579,
    147, 6656, 24576, 34, 6656, 24579, 147, 6656, 24576, 34, 6656, 20481, 274,
    26, 4100, 147, 4099, 189, 1, 36864, 147, 8, 20482, 273, 26, 24579, 34,
    6656, 24579, 147, 6656, 24576, 34, 6656, 24579, 147, 6656, 24576, 34, 6656,
    20481, 274, 26, 4100, 147, 4099, 189, 2, 20483, 273, 26, 24579, 34, 6656,
    24577, 147, 6656, 24576, 34, 6656, 24579, 147, 6656, 28672, 21, 396, 0,
    147, 6656, 28672, 21, 396, 18, 147, 6656, 20481, 274, 26, 4100, 147, 4099,
    189, 3, 20482, 273, 26, 24582, 34, 6656, 24579, 147, 6656, 28672, 21, 414,
    0, 147, 6656, 28672, 21, 414, 18, 147, 6656, 20481, 274, 26, 4100, 147,
    4099, 189, 3, 36864, 147, 8, 20481, 273, 26, 28672, 91, 0, 0, 34, 6656,
    28672, 91, 0, 18, 34, 6656, 28672, 91, 0, 36, 34, 6656, 24579, 34, 6656,
    24579, 147, 6656, 61440, 274, 147, 6682, 24, 20483, 274, 26, 4099, 147,
    4099, 189, 2, 36864, 147, 8, 4096, 147, 20482, 273, 26, 28672, 91, 36, 0,
    34, 6656, 28672, 91, 36, 18, 34, 6656, 28672, 91, 36, 36, 34, 6656, 24577,
    34, 6656, 24579, 147, 6656, 28672, 274, 147, 6682, 28672, 274, 147, 26,
    20485, 274, 26, 4097, 147, 4099, 189, 4, 20483, 273, 26, 28672, 91, 18, 0,
    34, 6656, 28672, 91, 18, 18, 34, 6656, 28672, 91, 18, 36, 34, 6656, 24577,
    34, 6656, 24578, 147, 6656, 61440, 274, 147, 6682, 16, 20486, 274, 26,
    4098, 147, 4098, 189, 5, 53248, 273, 26, 16, 20482, 273, 26, 28672, 91, 54,
    0, 34, 6656, 28672, 91, 54, 18, 34, 6656, 28672, 91, 54, 36, 34, 6656,
    24577, 34, 6656, 24582, 147, 6656, 61440, 274, 147, 6682, 16, 20482, 274,
    26, 4097, 147, 4098, 189, 5, 36864, 147, 8, 20483, 273, 26, 24579, 34,
    6656, 24583, 147, 6656, 28672, 274, 147, 6682, 20481, 274, 26, 4097, 147,
    4098, 189, 7, 20483, 273, 26, 61440, 273, 34, 6682, 40, 24579, 34, 6656,
    24581, 147, 6656, 61440, 274, 147, 6682, 16, 20482, 274, 26, 4096, 147,
    4098, 189, 8, 20484, 273, 26, 24579, 34, 6656, 24581, 147, 6656, 20482,
    274, 26, 4096, 147, 4098, 189, 9, 36864, 147, 16, 20482, 273, 26, 28672,
    273, 34, 6682, 61440, 273, 34, 6682, 40, 24577, 34, 6656, 24580, 147, 6656,
    24576, 34, 6656, 28672, 274, 147, 26, 20481, 274, 26, 4097, 147, 4097, 189,
    11, 53248, 273, 26, 16, 20482, 273, 26, 24578, 34, 6656, 24579, 147, 6656,
    24576, 34, 6656, 61440, 274, 34, 6682, 8, 20481, 274, 26, 4097, 147, 4097,
    189, 12, 20482, 273, 26, 28674, 273, 34, 6682, 28672, 273, 147, 6682,
    24578, 147, 6656, 24576, 34, 6656, 61440, 274, 34, 6682, 8, 20481, 274, 26,
    4097, 147, 4097, 189, 12, 20482, 273, 26, 28674, 273, 34, 6682, 28672, 273,
    147, 6682, 24578, 147, 6656, 24576, 34, 6656, 61440, 274, 34, 6682, 8,
    20481, 274, 26, 4097, 147, 4097, 189, 12, 20482, 273, 26, 28674, 273, 34,
    6682, 61440, 273, 147, 6682, 32, 24578, 147, 6656, 24576, 34, 6656, 61440,
    274, 34, 6682, 8, 20481, 274, 26, 4097, 147, 4097, 189, 11, 36864, 147, 8,
    20481, 273, 26, 28672, 273, 147, 6682, 24578, 34, 6656, 24580, 147, 6656,
    28672, 274, 34, 26, 20481, 274, 26, 4097, 147, 4097, 189, 11, 36864, 147,
    8, 20482, 273, 26, 24577, 34, 6656, 24581, 147, 6656, 20482, 274, 26, 4097,
    147, 4097, 189, 11, 36864, 147, 8, 20482, 273, 26, 24577, 34, 6656, 24580,
    147, 6656, 61440, 274, 147, 6682, 24, 20482, 274, 26, 4097, 147, 4097, 189,
    12, 20482, 273, 26, 24576, 34, 6656, 24580, 147, 6656, 28672, 274, 147,
    6682, 20482, 274, 26, 4097, 147, 4098, 189, 12, 20482, 273, 26, 28672, 42,
    0, 216, 34, 6656, 28672, 42, 0, 234, 147, 6656, 24578, 147, 6656, 28672,
    274, 147, 6682, 20482, 274, 26, 4098, 147, 4098, 189, 12, 20482, 273, 26,
    24579, 147, 6656, 61440, 274, 147, 6682, 8, 28672, 274, 147, 26, 20482,
    274, 26, 4097, 147, 4099, 189, 11, 36864, 147, 24, 20481, 273, 26, 53248,
    273, 26, 32, 3, 53248, 274, 26, 8, 20482, 274, 26, 4097, 147, 4100, 189,
    11, 36864, 147, 16, 4098, 147, 3, 20482, 274, 26, 4098, 147, 4100, 189, 19,
    20481, 274, 26, 4098, 147, 4101, 189, 19, 4099, 147, 4102, 189, 19, 4096,
    189, 4097, 147, 4103, 189, 18, 4098, 189, 4096, 147, 4121, 189, 20484, 189,
    1, 4102, 189
},
// igloo10
{
    12064, 4113, 189, 20484, 189, 1, 4105, 189, 17, 4098, 189, 4097, 147, 4104,
    189, 18, 4096, 189, 4098, 147, 4104, 189, 18, 4099, 147, 4104, 189, 15,
    20485, 274, 26, 4098, 147, 4102, 189, 12, 36864, 147, 8, 20488, 274, 26,
    4097, 147, 4102, 189, 11, 20491, 274, 26, 4097, 147, 4101, 189, 10, 20484,
    274, 26, 8194, 249, 12288, 21, 180, 0, 249, 12288, 21, 180, 18, 249, 28672,
    274, 249, 26, 20481, 274, 26, 4097, 147, 4101, 189, 10, 20483, 274, 26,
    8195, 249, 12288, 21, 198, 0, 249, 12288, 21, 198, 18, 249, 28672, 274,
    249, 26, 20481, 274, 26, 4098, 147, 4100, 189, 7, 36864, 147, 8, 20484,
    274, 26, 8198, 249, 61440, 274, 249, 26, 8, 20481, 274, 26, 4098, 147,
    4100, 189, 7, 36864, 147, 8, 20482, 274, 26, 28672, 274, 249, 26, 8200,
    249, 20481, 274, 26, 4099, 147, 4099, 189, 7, 20483, 274, 26, 8199, 249,
    12288, 215, 162, 36, 249, 12288, 215, 162, 54, 249, 20481, 274, 26, 4099,
    147, 4099, 189, 6, 36864, 147, 24, 20481, 274, 26, 28673, 274, 249, 26,
    8199, 249, 12288, 215, 180, 36, 249, 12288, 215, 180, 54, 249, 20481, 274,
    26, 4099, 147, 4099, 189, 6, 20481, 274, 26, 28672, 274, 249, 26, 8197,
    249, 12288, 240, 378, 54, 249, 12288, 240, 378, 72, 249, 12288, 240, 378,
    90, 249, 8192, 249, 12288, 215, 198, 36, 249, 12288, 215, 198, 54, 249,
    20481, 274, 26, 4099, 147, 4099, 189, 5, 36864, 147, 8, 20481, 274, 26,
    28672, 274, 249, 26, 8197, 249, 12288, 240, 396, 54, 249, 12288, 240, 396,
    72, 249, 12288, 240, 396, 90, 249, 8194, 249, 20481, 274, 26, 4099, 147,
    4099, 189, 5, 20481, 274, 26, 28672, 274, 249, 26, 8195, 249, 8193, 266,
    8192, 249, 12288, 240, 414, 54, 249, 12288, 240, 414, 72, 249, 12288, 240,
    414, 90, 249, 8193, 249, 61440, 274, 249, 26, 8, 20481, 274, 26, 4099, 147,
    4099, 189, 5, 4096, 162, 20480, 274, 26, 8195, 249, 8193, 266, 8194, 249,
    12288, 240, 486, 54, 249, 12288, 240, 486, 72, 249, 12288, 240, 486, 90,
    249, 8192, 249, 28672, 274, 249, 26, 20481, 274, 26, 4099, 147, 4099, 189,
    5, 4096, 162, 12288, 162, 266, 8196, 266, 8195, 249, 12288, 240, 504, 54,
    249, 12288, 240, 504, 72, 249, 12288, 240, 504, 90, 249, 61440, 274, 249,
    26, 8, 20482, 274, 26, 4099, 147, 4099, 189, 4, 36864, 162, 8, 4096, 162,
    12288, 162, 266, 8195, 266, 8192, 249, 8192, 266, 8194, 249, 12288, 240,
    522, 54, 249, 12288, 240, 522, 72, 249, 12288, 240, 522, 90, 249, 28672,
    274, 249, 26, 20482, 274, 26, 4098, 147, 4100, 189, 4, 4097, 162, 12288,
    162, 266, 8193, 266, 8201, 249, 28672, 274, 249, 26, 20482, 274, 26, 4098,
    147, 4100, 189, 4, 4096, 162, 12289, 162, 266, 8195, 266, 8197, 249, 12288,
    21, 396, 0, 249, 12288, 21, 396, 18, 249, 20483, 274, 26, 4098, 147, 4100,
    189, 3, 4096, 147, 4096, 162, 12289, 162, 266, 8196, 266, 8195, 249, 12288,
    19, 36, 342, 249, 12288, 21, 414, 0, 249, 12288, 21, 414, 18, 249, 20482,
    274, 26, 4099, 147, 4100, 189, 3, 4096, 147, 4096, 162, 12288, 162, 266,
    28672, 274, 266, 26, 8194, 249, 8192, 266, 8195, 249, 12288, 33, 0, 0, 249,
    12288, 19, 18, 342, 249, 8192, 249, 61440, 274, 249, 26, 8, 20482, 274, 26,
    4099, 147, 4100, 189, 3, 36864, 162, 16, 12288, 162, 266, 28672, 274, 266,
    26, 28672, 274, 249, 26, 8199, 249, 12288, 283, 0, 0, 249, 12288, 283, 0,
    18, 249, 12288, 283, 0, 36, 249, 28672, 274, 249, 26, 20482, 274, 26, 4099,
    147, 4100, 189, 3, 20482, 274, 26, 28672, 274, 249, 26, 8199, 249, 12288,
    283, 18, 0, 249, 12288, 283, 18, 18, 249, 12288, 283, 18, 36, 249, 28672,
    274, 249, 26, 20481, 274, 26, 4100, 147, 4100, 189, 3, 20482, 274, 26,
    8200, 249, 12288, 283, 36, 0, 249, 12288, 283, 36, 18, 249, 12288, 283, 36,
    36, 249, 20482, 274, 26, 4100, 147, 4100, 189, 2, 20483, 274, 26, 8197,
    249, 12288, 240, 270, 54, 249, 12288, 240, 270, 72, 249, 12288, 240, 270,
    90, 249, 8193, 249, 28672, 274, 249, 26, 20482, 274, 26, 4100, 147, 4100,
    189, 1, 36864, 147, 8, 20483, 274, 26, 8197, 249, 12288, 240, 288, 54, 249,
    12288, 240, 288, 72, 249, 12288, 240, 288, 90, 249, 8192, 249, 61440, 274,
    249, 26, 8, 28672, 274, 249, 26, 20483, 274, 26, 4100, 147, 4099, 189, 1,
    4096, 147, 20483, 274, 26, 8197, 249, 12288, 240, 306, 54, 249, 12288, 240,
    306, 72, 249, 12288, 240, 306, 90, 249, 8192, 249, 28672, 274, 249, 26,
    20486, 274, 26, 4098, 147, 4099, 189, 0, 36864, 147, 8, 4096, 147, 20483,
    274, 26, 8201, 249, 28672, 274, 249, 26, 20486, 274, 26, 4098, 147, 4099,
    189, 1, 36864, 147, 8, 20483, 274, 26, 8201, 249, 61440, 274, 249, 26, 16,
    20486, 274, 26, 4098, 147, 4099, 189, 1, 36864, 147, 8, 20484, 274, 26,
    8205, 249, 20482, 274, 26, 4099, 147, 4098, 189, 4, 20483, 274, 26, 28672,
    274, 249, 26, 8203, 249, 20482, 274, 26, 4099, 147, 4098, 189, 4, 36864,
    147, 8, 20482, 274, 26, 28675, 274, 249, 26, 61440, 274, 249, 26, 40, 8199,
    249, 20482, 274, 26, 4100, 147, 4097, 189, 5, 36864, 147, 16, 20490, 274,
    26, 61440, 274, 249, 26, 40, 8194, 249, 20482, 274, 26, 4100, 147, 4097,
    189, 8, 20488, 274, 26, 61440, 274, 249, 26, 32, 8194, 249, 20482, 274, 26,
    4100, 147, 4097, 189, 16, 8196, 249, 20482, 274, 26, 4100, 147, 4097, 189,
    15, 8197, 249, 20482, 274, 26, 4099, 147, 4098, 189, 14, 8198, 249, 20482,
    274, 26, 4099, 147, 4098, 189, 14, 20489, 274, 26, 4098, 147, 4099, 189,
    13, 36864, 147, 8, 20489, 274, 26, 4098, 147, 4099, 189, 13, 36864, 147, 8,
    20489, 274, 26, 4097, 147, 4100, 189, 18, 4102, 147, 4101, 189, 18, 4096,
    189, 4101, 147, 4101, 189, 17, 4098, 189, 4098, 147, 4103, 189, 16, 4100,
    189, 4096, 147, 4120, 189, 20486, 189, 1, 4103, 189
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getIgloo(int iglooId, const std::vector<bool> &framedTiles)
{
    return {iglooData[iglooId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Igloos.h`
```
#ifndef IGLOOS_H
#define IGLOOS_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto igloos = std::views::iota(0, 10);

TileBuffer getIgloo(int iglooId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // IGLOOS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/JungleShrines.cpp`
```
#include "structures/data/JungleShrines.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> shrineData{
// jungleShrine1
{
    3356, 4112, 189, 20480, 189, 1, 4113, 189, 8, 4096, 59, 4107, 189, 14,
    4096, 59, 4107, 189, 2, 4096, 156, 10, 4096, 59, 4106, 189, 2, 36864, 156,
    8, 4096, 156, 36864, 156, 40, 1, 4103, 120, 4105, 59, 4098, 189, 2, 36864,
    156, 16, 4096, 156, 36864, 156, 32, 4096, 156, 4100, 120, 8192, 24, 12288,
    215, 702, 0, 24, 12288, 215, 702, 18, 24, 12288, 59, 24, 45063, 59, 24,
    1088, 4096, 59, 4098, 189, 3, 36864, 156, 8, 0, 36864, 156, 32, 4100, 120,
    8192, 24, 12288, 215, 720, 0, 24, 12288, 215, 720, 18, 24, 12288, 59, 24,
    45061, 59, 24, 1088, 12288, 21, 360, 0, 24, 12288, 21, 360, 18, 24, 4096,
    59, 4097, 189, 2, 36864, 156, 8, 4096, 156, 36864, 156, 32, 36864, 156, 40,
    36864, 156, 8, 4100, 120, 45056, 136, 36, 0, 24, 64, 12288, 215, 738, 0,
    24, 12288, 215, 738, 18, 24, 45056, 59, 24, 64, 45061, 59, 24, 1088, 12288,
    21, 378, 0, 24, 12288, 21, 378, 18, 24, 4096, 59, 4097, 189, 1, 4097, 156,
    36864, 156, 32, 2, 4100, 120, 36866, 120, 64, 36864, 59, 64, 4104, 59,
    4097, 189, 2, 36864, 156, 40, 11, 4096, 59, 4107, 189, 14, 4096, 59, 4109,
    189, 10, 4097, 189, 4096, 59, 4119, 189, 20483, 189, 1, 4105, 189
},
// jungleShrine2
{
    2056, 4104, 189, 1, 8193, 315, 1, 4097, 189, 0, 8195, 315, 0, 4097, 189,
    8192, 315, 12288, 21, 360, 0, 315, 12288, 21, 360, 18, 315, 12288, 19, 36,
    792, 315, 8193, 315, 4097, 189, 8192, 315, 12288, 21, 378, 0, 315, 12288,
    21, 378, 18, 315, 12288, 19, 18, 792, 315, 8193, 315, 4097, 189, 0, 8195,
    315, 0, 4097, 189, 1, 8193, 315, 1, 4104, 189
},
// jungleShrine3
{
    2569, 4102, 189, 20481, 189, 1, 4096, 189, 1, 8194, 73, 8192, 60, 4096, 59,
    4097, 189, 8194, 73, 8194, 60, 4096, 59, 4097, 189, 8192, 73, 8196, 60,
    4096, 59, 4097, 189, 8193, 60, 12288, 21, 288, 0, 60, 12288, 21, 288, 18,
    60, 12288, 19, 36, 36, 60, 8192, 60, 4096, 59, 4097, 189, 8193, 60, 12288,
    21, 306, 0, 60, 12288, 21, 306, 18, 60, 12288, 19, 18, 36, 60, 8192, 60,
    4096, 59, 4097, 189, 8192, 73, 8196, 60, 4096, 59, 4097, 189, 0, 8193, 73,
    8194, 60, 4096, 59, 4097, 189, 1, 8194, 73, 8192, 60, 4096, 59, 4103, 189,
    20481, 189, 1
},
// jungleShrine4
{
    2569, 4101, 189, 20481, 189, 1, 4097, 189, 4, 4096, 383, 4096, 59, 4097,
    189, 3, 4096, 158, 4096, 383, 4096, 59, 4097, 189, 2, 4096, 383, 4096, 158,
    4096, 383, 4096, 59, 4097, 189, 4096, 21, 288, 0, 4096, 21, 288, 18, 4096,
    158, 4096, 383, 4096, 158, 4096, 383, 4096, 59, 4097, 189, 4096, 21, 306,
    0, 4096, 21, 306, 18, 4096, 158, 4096, 383, 4096, 158, 4096, 383, 4096, 59,
    4097, 189, 2, 4096, 383, 4096, 158, 4096, 383, 4096, 59, 4097, 189, 3,
    4096, 158, 4096, 383, 4096, 59, 4097, 189, 4, 4096, 383, 4096, 59, 4102,
    189, 20481, 189, 1, 4096, 189
},
// jungleShrine5
{
    2569, 4098, 189, 20484, 189, 1, 4101, 189, 4098, 59, 4098, 189, 4101, 59,
    4097, 189, 4097, 59, 1, 4096, 4, 0, 462, 4096, 119, 4096, 59, 4097, 189,
    4096, 59, 1, 4096, 21, 360, 0, 4096, 21, 360, 18, 4096, 120, 4096, 59,
    4097, 189, 4096, 59, 1, 4096, 21, 378, 0, 4096, 21, 378, 18, 4096, 119,
    4096, 59, 4097, 189, 4096, 59, 4096, 4, 0, 462, 4096, 119, 4096, 120, 4096,
    119, 4096, 120, 4096, 59, 4097, 189, 4102, 59, 4097, 189, 4102, 59, 4097,
    189, 20486, 189, 1, 4096, 189
},
// jungleShrine6
{
    4624, 4097, 189, 20480, 189, 1, 4103, 189, 20483, 189, 1, 4106, 189, 1,
    4108, 189, 4, 4104, 189, 6, 4096, 59, 4098, 189, 4100, 120, 36870, 120,
    2048, 4096, 59, 4098, 189, 4096, 120, 8194, 24, 4096, 120, 6, 4096, 59,
    4098, 189, 4096, 120, 8192, 24, 12288, 21, 360, 0, 24, 12288, 21, 360, 18,
    24, 4096, 120, 6, 4096, 59, 4098, 189, 4096, 120, 8192, 24, 12288, 21, 378,
    0, 24, 12288, 21, 378, 18, 24, 4096, 120, 6, 4096, 59, 4098, 189, 4096,
    120, 8194, 24, 4096, 120, 6, 4096, 59, 4098, 189, 4096, 120, 8194, 24,
    4096, 120, 6, 4096, 59, 4098, 189, 4096, 120, 8194, 24, 4096, 120, 6, 4096,
    59, 4098, 189, 4096, 19, 54, 36, 8194, 24, 4096, 120, 6, 4096, 59, 4098,
    189, 4096, 19, 72, 36, 8194, 24, 4096, 120, 6, 4096, 59, 4098, 189, 4100,
    120, 36870, 120, 2048, 4096, 59, 4103, 189, 6, 4096, 59, 4104, 189, 4,
    4106, 189, 1, 4103, 189, 20480, 189, 1, 4102, 189, 20484, 189, 1, 4096, 189
},
// jungleShrine7
{
    3339, 4102, 189, 20483, 189, 1, 4096, 189, 6, 4097, 59, 4097, 189, 6, 4097,
    59, 4097, 189, 2, 4100, 383, 4096, 59, 4097, 189, 0, 8192, 73, 4096, 383,
    12292, 383, 78, 4096, 59, 4097, 189, 0, 8193, 73, 8194, 78, 8192, 73, 8192,
    78, 4096, 59, 4097, 189, 0, 8195, 73, 8192, 78, 12288, 21, 360, 0, 78,
    12288, 21, 360, 18, 78, 4096, 59, 4097, 189, 0, 8192, 73, 8195, 78, 12288,
    21, 378, 0, 78, 12288, 21, 378, 18, 78, 4096, 59, 4097, 189, 0, 8192, 73,
    12293, 383, 78, 4096, 59, 4097, 189, 1, 4101, 383, 4096, 59, 4097, 189, 6,
    4097, 59, 4097, 189, 7, 4096, 59, 4103, 189, 20483, 189, 1
},
// jungleShrine8
{
    2566, 4099, 189, 20481, 189, 1, 4099, 189, 4096, 383, 4100, 189, 4096, 383,
    4099, 189, 4097, 383, 4097, 189, 4096, 21, 360, 0, 4096, 21, 360, 18, 4097,
    383, 4097, 189, 4096, 21, 378, 0, 4096, 21, 378, 18, 4097, 383, 4099, 189,
    4097, 383, 4100, 189, 4096, 383, 4100, 189, 4096, 383, 4100, 189, 20481,
    189, 1
},
// jungleShrine9
{
    2571, 4104, 189, 20481, 189, 1, 4097, 189, 4099, 226, 4096, 10, 36, 756,
    4096, 10, 0, 774, 4096, 10, 36, 792, 4096, 226, 4098, 189, 4096, 226, 8197,
    112, 4096, 226, 4097, 189, 4097, 226, 12288, 42, 0, 684, 112, 12288, 42, 0,
    702, 112, 8195, 112, 4096, 226, 4097, 189, 4096, 226, 8196, 112, 12288, 21,
    360, 0, 112, 12288, 21, 360, 18, 112, 4096, 226, 4097, 189, 4096, 226,
    8196, 112, 12288, 21, 378, 0, 112, 12288, 21, 378, 18, 112, 4096, 226,
    4097, 189, 4097, 226, 12288, 42, 0, 684, 112, 12288, 42, 0, 702, 112, 8195,
    112, 4096, 226, 4098, 189, 4096, 226, 8197, 112, 4096, 226, 4098, 189,
    4099, 226, 4096, 10, 0, 756, 4096, 10, 0, 774, 4096, 10, 0, 792, 4096, 226,
    4105, 189, 20481, 189, 1
},
// jungleShrine10
{
    3592, 4097, 189, 20485, 189, 1, 4096, 189, 4100, 158, 4096, 59, 4097, 189,
    4096, 158, 12288, 4, 22, 66, 78, 8192, 78, 12288, 21, 288, 0, 78, 12288,
    21, 288, 18, 78, 4096, 59, 4097, 189, 4096, 158, 8193, 78, 12288, 21, 306,
    0, 78, 12288, 21, 306, 18, 78, 4096, 59, 4097, 189, 4096, 158, 8195, 78,
    4096, 59, 4097, 189, 4096, 158, 8195, 78, 4096, 59, 4097, 189, 4097, 158,
    2, 4096, 59, 4099, 189, 2, 4096, 59, 4098, 189, 3, 4096, 59, 4098, 189, 3,
    4096, 59, 4097, 189, 4, 4098, 189, 3, 4099, 189, 0, 4101, 189, 20486, 189,
    1, 4096, 189
},
// jungleShrine11
{
    3849, 20487, 189, 1, 4106, 189, 1, 4102, 189, 4, 4099, 189, 4, 4100, 189,
    4, 4099, 189, 4, 4096, 59, 4099, 189, 3, 4096, 59, 4098, 189, 4097, 120, 2,
    4096, 59, 4098, 189, 4096, 120, 12288, 59, 24, 8194, 24, 4096, 59, 4098,
    189, 4096, 120, 12288, 59, 24, 8194, 24, 4096, 59, 4098, 189, 4096, 120,
    12288, 59, 24, 8192, 24, 12288, 21, 288, 0, 24, 12288, 21, 288, 18, 24,
    4096, 59, 4098, 189, 4096, 120, 4096, 59, 12288, 59, 24, 12288, 21, 306, 0,
    24, 12288, 21, 306, 18, 24, 4096, 59, 4098, 189, 4100, 120, 4096, 59, 4099,
    189, 20485, 189, 1
},
// jungleShrine12
{
    4880, 4106, 189, 20483, 189, 1, 4097, 189, 0, 4096, 189, 0, 4105, 189,
    4096, 59, 4097, 189, 11, 4096, 189, 4096, 59, 4097, 189, 11, 4096, 189,
    4096, 59, 4097, 189, 12, 4096, 59, 4097, 189, 12, 4096, 59, 4097, 189, 3,
    4104, 120, 4096, 59, 4097, 189, 3, 4104, 120, 4096, 59, 4097, 189, 3, 4096,
    120, 12295, 120, 24, 4096, 59, 4097, 189, 2, 36864, 135, 0, 54, 64, 36864,
    120, 1088, 45061, 120, 24, 1088, 45056, 21, 360, 0, 24, 1088, 12288, 21,
    360, 18, 24, 4096, 59, 4097, 189, 2, 36864, 135, 0, 54, 64, 36864, 120,
    1088, 45061, 120, 24, 1088, 45056, 21, 378, 0, 24, 1088, 12288, 21, 378,
    18, 24, 4096, 59, 4097, 189, 3, 4096, 120, 12295, 120, 24, 4096, 59, 4097,
    189, 3, 4104, 120, 4096, 59, 4097, 189, 3, 4104, 120, 4096, 59, 4097, 189,
    12, 4096, 59, 4097, 189, 12, 4096, 59, 4097, 189, 10, 4097, 189, 4096, 59,
    4099, 189, 5, 4100, 189, 4096, 59, 4104, 189, 20486, 189, 1, 4096, 189
},
// jungleShrine13
{
    4621, 4104, 189, 20482, 189, 1, 4097, 189, 9, 4096, 59, 4097, 189, 8, 4096,
    120, 4096, 59, 4097, 189, 7, 4097, 120, 4096, 59, 4097, 189, 6, 4098, 120,
    4096, 59, 4097, 189, 5, 4099, 120, 4096, 59, 4097, 189, 4, 4100, 120, 4096,
    59, 4097, 189, 2, 4096, 4, 0, 44, 4101, 120, 4096, 59, 4097, 189, 1, 36864,
    135, 0, 54, 64, 45060, 120, 24, 1088, 12288, 21, 360, 0, 24, 12288, 21,
    360, 18, 24, 4096, 59, 4097, 189, 1, 36864, 135, 0, 54, 64, 45060, 120, 24,
    1088, 12288, 21, 378, 0, 24, 12288, 21, 378, 18, 24, 4096, 59, 4097, 189,
    2, 4096, 4, 0, 44, 4101, 120, 4096, 59, 4097, 189, 4, 4100, 120, 4096, 59,
    4097, 189, 5, 4099, 120, 4096, 59, 4097, 189, 6, 4098, 120, 4096, 59, 4097,
    189, 7, 4097, 120, 4096, 59, 4097, 189, 8, 4096, 120, 4096, 59, 4097, 189,
    9, 4096, 59, 4105, 189, 20482, 189, 1, 4096, 189
},
// jungleShrine14
{
    2571, 4102, 189, 20481, 189, 1, 4098, 189, 4098, 158, 36866, 158, 2048,
    4098, 59, 4097, 189, 4097, 158, 36867, 158, 2048, 4098, 59, 4097, 189,
    4096, 158, 36868, 158, 2048, 4096, 59, 4097, 158, 4097, 189, 4096, 158,
    36868, 158, 2048, 12288, 21, 288, 0, 42, 12288, 21, 288, 18, 42, 4096, 158,
    4097, 189, 4096, 158, 36868, 158, 2048, 12288, 21, 306, 0, 42, 12288, 21,
    306, 18, 42, 4096, 158, 4097, 189, 4096, 158, 36868, 158, 2048, 4096, 59,
    4097, 158, 4097, 189, 4097, 158, 36867, 158, 2048, 4098, 59, 4097, 189,
    4098, 158, 36866, 158, 2048, 4098, 59, 4103, 189, 20481, 189, 1, 4097, 189
},
// jungleShrine15
{
    1798, 20483, 189, 1, 4098, 189, 36864, 383, 8, 4097, 383, 4096, 59, 4097,
    189, 4096, 383, 12288, 21, 360, 0, 42, 12288, 21, 360, 18, 42, 4096, 59,
    4097, 189, 4096, 383, 12288, 21, 378, 0, 42, 12288, 21, 378, 18, 42, 4096,
    59, 4097, 189, 4096, 383, 12288, 4, 44, 66, 42, 8192, 42, 4096, 59, 4097,
    189, 36864, 383, 16, 4097, 383, 4096, 59, 4096, 189, 20483, 189, 1, 4097,
    189
},
// jungleShrine16
{
    1798, 20483, 189, 1, 4098, 189, 36864, 120, 24, 4097, 120, 4096, 59, 4097,
    189, 4096, 120, 12288, 4, 22, 66, 78, 8192, 78, 4096, 59, 4097, 189, 4096,
    120, 12288, 21, 288, 0, 78, 12288, 21, 288, 18, 78, 4096, 59, 4097, 189,
    4096, 120, 12288, 21, 306, 0, 78, 12288, 21, 306, 18, 78, 4096, 59, 4097,
    189, 36864, 120, 8, 4097, 120, 4096, 59, 4096, 189, 20483, 189, 1, 4097,
    189
},
// jungleShrine17
{
    2567, 4098, 189, 20482, 189, 1, 4097, 189, 0, 4096, 119, 4098, 59, 4097,
    189, 4096, 215, 702, 0, 12288, 215, 702, 18, 23, 4098, 59, 4097, 189, 4096,
    215, 720, 0, 12288, 215, 720, 18, 23, 4098, 59, 4097, 189, 4096, 215, 738,
    0, 12288, 215, 738, 18, 23, 4098, 59, 4097, 189, 0, 4097, 119, 4097, 59,
    4097, 189, 4096, 21, 288, 0, 4096, 21, 288, 18, 4096, 119, 4097, 59, 4097,
    189, 4096, 21, 306, 0, 4096, 21, 306, 18, 4096, 119, 4097, 59, 4097, 189,
    1, 4096, 119, 4097, 59, 4099, 189, 20482, 189, 1, 4096, 189
},
// jungleShrine18
{
    2311, 4098, 189, 20482, 189, 1, 4097, 189, 1, 4097, 120, 4096, 59, 4097,
    189, 4096, 21, 360, 0, 4096, 21, 360, 18, 4097, 120, 4096, 59, 4097, 189,
    4096, 21, 378, 0, 4096, 21, 378, 18, 4097, 120, 4096, 59, 4097, 189, 1,
    4097, 120, 4096, 59, 4097, 189, 4096, 215, 702, 0, 4096, 215, 702, 18,
    4097, 120, 4096, 59, 4097, 189, 4096, 215, 720, 0, 4096, 215, 720, 18,
    4097, 120, 4096, 59, 4097, 189, 4096, 215, 738, 0, 4096, 215, 738, 18,
    4097, 120, 4096, 59, 4099, 189, 20482, 189, 1, 4096, 189
},
// jungleShrine19
{
    3849, 4097, 189, 20484, 189, 1, 4098, 189, 2, 4101, 189, 4, 4099, 189, 5,
    4098, 189, 5, 4096, 59, 4097, 189, 5, 4096, 59, 4097, 189, 4098, 383, 4096,
    10, 36, 378, 4096, 10, 0, 396, 4096, 10, 36, 414, 4096, 59, 4097, 189,
    4096, 383, 8196, 42, 4096, 59, 4097, 189, 4096, 383, 8196, 42, 4096, 59,
    4097, 189, 4096, 383, 8196, 42, 4096, 59, 4097, 189, 4096, 383, 12288, 21,
    288, 0, 42, 12288, 21, 288, 18, 42, 12288, 19, 36, 36, 42, 8193, 42, 4096,
    59, 4097, 189, 4096, 383, 12288, 21, 306, 0, 42, 12288, 21, 306, 18, 42,
    12288, 19, 72, 36, 42, 8193, 42, 4096, 59, 4097, 189, 4099, 383, 4098, 59,
    4102, 189, 4097, 59, 4096, 189, 20486, 189, 1, 4097, 189
},
// jungleShrine20
{
    5646, 4106, 189, 20482, 189, 1, 4096, 189, 10, 4096, 59, 4097, 189, 9,
    4096, 120, 4096, 59, 4097, 189, 8, 36864, 120, 2056, 4096, 120, 4096, 59,
    4097, 189, 7, 4096, 120, 36864, 120, 2048, 4096, 120, 4096, 59, 4097, 189,
    6, 36864, 120, 2056, 4096, 120, 36864, 120, 2048, 4096, 120, 4096, 59,
    4097, 189, 5, 4096, 120, 36864, 120, 2048, 4096, 120, 36864, 120, 2048,
    4096, 120, 4096, 59, 4097, 189, 4, 36864, 120, 2056, 4096, 120, 36864, 120,
    2048, 4096, 120, 36864, 120, 2048, 4096, 120, 4096, 59, 4097, 189, 3, 4096,
    120, 36864, 120, 2048, 4096, 120, 36864, 120, 2048, 4096, 120, 36864, 120,
    2048, 4096, 120, 4096, 59, 4097, 189, 2, 36864, 120, 2056, 4096, 120,
    36864, 120, 2048, 4096, 120, 36864, 120, 2048, 4096, 120, 36864, 120, 2048,
    4096, 120, 4096, 59, 4097, 189, 0, 4096, 21, 288, 0, 4096, 21, 288, 18,
    4097, 120, 36864, 120, 2048, 4096, 120, 36864, 120, 2048, 4096, 120, 36864,
    120, 2048, 4096, 120, 4096, 59, 4097, 189, 0, 4096, 21, 306, 0, 4096, 21,
    306, 18, 4097, 120, 36864, 120, 2048, 4096, 120, 36864, 120, 2048, 4096,
    120, 36864, 120, 2048, 4096, 120, 4096, 59, 4097, 189, 2, 36864, 120, 2056,
    4096, 120, 36864, 120, 2048, 4096, 120, 36864, 120, 2048, 4096, 120, 36864,
    120, 2048, 4096, 120, 4096, 59, 4097, 189, 3, 4096, 120, 36864, 120, 2048,
    4096, 120, 36864, 120, 2048, 4096, 120, 36864, 120, 2048, 4096, 120, 4096,
    59, 4097, 189, 4, 36864, 120, 2056, 4096, 120, 36864, 120, 2048, 4096, 120,
    36864, 120, 2048, 4096, 120, 4096, 59, 4097, 189, 5, 4096, 120, 36864, 120,
    2048, 4096, 120, 36864, 120, 2048, 4096, 120, 4096, 59, 4097, 189, 6,
    36864, 120, 2056, 4096, 120, 36864, 120, 2048, 4096, 120, 4096, 59, 4097,
    189, 7, 4096, 120, 36864, 120, 2048, 4096, 120, 4096, 59, 4097, 189, 8,
    36864, 120, 2056, 4096, 120, 4096, 59, 4097, 189, 9, 4096, 120, 4096, 59,
    4097, 189, 10, 4096, 59, 4107, 189, 20482, 189, 1
},
// jungleShrine21
{
    3592, 4097, 189, 20482, 189, 1, 4101, 189, 12290, 59, 24, 4096, 59, 4099,
    189, 12290, 59, 24, 4096, 59, 4098, 189, 12291, 59, 24, 4096, 59, 4098,
    189, 12291, 59, 24, 4096, 59, 4097, 189, 12292, 59, 24, 4096, 59, 4097,
    189, 12290, 59, 24, 12288, 21, 288, 0, 24, 12288, 21, 288, 18, 24, 4096,
    59, 4097, 189, 12290, 59, 24, 12288, 21, 306, 0, 24, 12288, 21, 306, 18,
    24, 4096, 59, 4097, 189, 12292, 59, 24, 4096, 59, 4098, 189, 12291, 59, 24,
    4096, 59, 4098, 189, 12291, 59, 24, 4096, 59, 4099, 189, 12290, 59, 24,
    4096, 59, 4099, 189, 12290, 59, 24, 4096, 59, 4098, 189, 20482, 189, 1,
    4098, 189
},
// jungleShrine22
{
    5388, 4097, 189, 20488, 189, 1, 4102, 189, 3, 4096, 59, 4102, 189, 3, 4096,
    59, 4097, 189, 4100, 383, 4096, 10, 36, 108, 4096, 10, 0, 126, 4096, 10, 0,
    144, 4096, 383, 4096, 59, 4097, 189, 4096, 383, 8192, 42, 12288, 4, 22,
    462, 42, 8196, 42, 12288, 383, 42, 4096, 59, 4097, 189, 4096, 383, 8197,
    42, 45056, 158, 42, 24, 12288, 383, 42, 4096, 59, 4097, 189, 4096, 383,
    8197, 42, 12288, 158, 42, 12288, 383, 42, 4096, 59, 4097, 189, 4096, 383,
    8195, 42, 12288, 21, 360, 0, 42, 12288, 21, 360, 18, 42, 12288, 158, 42,
    12288, 383, 42, 4096, 59, 4097, 189, 4096, 383, 8195, 42, 12288, 21, 378,
    0, 42, 12288, 21, 378, 18, 42, 12288, 158, 42, 12288, 383, 42, 4096, 59,
    4097, 189, 4096, 383, 8197, 42, 12288, 158, 42, 12288, 383, 42, 4096, 59,
    4097, 189, 4096, 383, 8197, 42, 45056, 158, 42, 16, 12288, 383, 42, 4096,
    59, 4097, 189, 4096, 383, 8192, 42, 12288, 4, 44, 462, 42, 8196, 42, 12288,
    383, 42, 4096, 59, 4097, 189, 4100, 383, 4096, 10, 18, 108, 4096, 10, 18,
    126, 4096, 10, 36, 144, 4096, 383, 4096, 59, 4097, 189, 8, 4096, 59, 4097,
    189, 8, 4096, 59, 4097, 189, 7, 4096, 189, 4096, 59, 4097, 189, 6, 4097,
    189, 4096, 59, 4097, 189, 5, 4098, 189, 4096, 59, 4097, 189, 1, 4102, 189,
    4096, 59, 4106, 189, 4096, 59, 4098, 189, 20488, 189, 1, 4096, 189
},
// jungleShrine23
{
    6677, 4109, 189, 20486, 189, 1, 4108, 189, 1, 4114, 189, 2, 4112, 189, 4,
    4097, 189, 4096, 59, 4108, 189, 6, 4096, 59, 4107, 189, 7, 4096, 59, 4097,
    189, 4110, 158, 36866, 158, 3136, 4096, 59, 4097, 189, 4110, 158, 36866,
    158, 3136, 4096, 59, 4097, 189, 4096, 158, 8193, 42, 12288, 21, 288, 0, 42,
    12288, 21, 288, 18, 42, 12288, 19, 54, 36, 42, 8202, 42, 45056, 135, 0, 54,
    42, 64, 4096, 59, 4097, 189, 4096, 158, 8193, 42, 12288, 21, 306, 0, 42,
    12288, 21, 306, 18, 42, 12288, 19, 18, 36, 42, 8202, 42, 40960, 42, 64,
    4096, 59, 4097, 189, 4096, 158, 8200, 42, 12288, 19, 36, 36, 42, 8197, 42,
    40960, 42, 64, 4096, 59, 4097, 189, 4096, 158, 8200, 42, 12288, 19, 0, 36,
    42, 8197, 42, 40960, 42, 64, 4096, 59, 4097, 189, 4096, 158, 8200, 42,
    12288, 19, 0, 36, 42, 45056, 42, 18, 576, 42, 64, 45056, 42, 18, 594, 42,
    64, 40964, 42, 64, 4096, 59, 4097, 189, 4096, 158, 8200, 42, 12288, 19, 0,
    36, 42, 8197, 42, 40960, 42, 64, 4096, 59, 4097, 189, 4096, 158, 8200, 42,
    12288, 19, 18, 36, 42, 8197, 42, 40960, 42, 64, 4096, 59, 4097, 189, 4096,
    158, 8194, 42, 12288, 649, 1152, 0, 42, 12288, 19, 36, 36, 42, 8202, 42,
    40960, 42, 64, 4096, 59, 4097, 189, 4096, 158, 8194, 42, 12288, 649, 1170,
    0, 42, 12288, 19, 72, 36, 42, 8202, 42, 45056, 135, 0, 54, 42, 64, 4096,
    59, 4097, 189, 4110, 158, 36866, 158, 3136, 4096, 59, 4097, 189, 4110, 158,
    36866, 158, 3136, 4096, 59, 4107, 189, 7, 4096, 59, 4108, 189, 6, 4096, 59,
    4109, 189, 4, 4096, 189, 4096, 59, 4110, 189, 1, 4114, 189, 1, 4114, 189,
    0, 4115, 189, 20486, 189, 1
},
// jungleShrine24
{
    3081, 4102, 189, 20481, 189, 1, 4096, 189, 4098, 119, 2, 4096, 119, 4097,
    189, 4096, 119, 8192, 23, 12288, 4, 22, 462, 23, 8194, 23, 4096, 119, 4097,
    189, 4096, 119, 8196, 23, 4096, 119, 4097, 189, 4096, 119, 8196, 23, 4096,
    119, 4097, 189, 4096, 119, 8192, 23, 12288, 21, 360, 0, 23, 12288, 21, 360,
    18, 23, 12288, 19, 36, 36, 23, 8192, 23, 4096, 119, 4097, 189, 4096, 119,
    8192, 23, 12288, 21, 378, 0, 23, 12288, 21, 378, 18, 23, 12288, 19, 18, 36,
    23, 8192, 23, 4096, 119, 4097, 189, 4096, 119, 8196, 23, 4096, 119, 4097,
    189, 4096, 119, 8196, 23, 4096, 119, 4097, 189, 4096, 119, 8192, 23, 12288,
    4, 44, 462, 23, 8194, 23, 4096, 119, 4097, 189, 4098, 119, 2, 4096, 119,
    4103, 189, 20481, 189, 1
},
// jungleShrine25
{
    2567, 4099, 189, 20482, 189, 1, 4100, 189, 4096, 119, 4100, 189, 4097, 119,
    4099, 189, 4098, 119, 4097, 189, 4096, 21, 360, 0, 4096, 21, 360, 18, 4098,
    119, 4097, 189, 4096, 21, 378, 0, 4096, 21, 378, 18, 4098, 119, 4099, 189,
    4098, 119, 4100, 189, 4097, 119, 4101, 189, 4096, 119, 4100, 189, 20482,
    189, 1
},
// jungleShrine26
{
    3080, 4100, 189, 20482, 189, 1, 4096, 189, 4, 4096, 120, 4097, 189, 3,
    8192, 23, 4096, 120, 4097, 189, 1, 12288, 4, 0, 462, 23, 8192, 23, 12288,
    120, 23, 4096, 120, 4097, 189, 0, 8193, 23, 12288, 119, 23, 4097, 120,
    4097, 189, 0, 12288, 21, 288, 0, 23, 12288, 21, 288, 18, 23, 4096, 119,
    4097, 120, 4097, 189, 0, 12288, 21, 306, 0, 23, 12288, 21, 306, 18, 23,
    4096, 119, 4097, 120, 4097, 189, 0, 8193, 23, 4096, 119, 4097, 120, 4097,
    189, 1, 12288, 4, 0, 462, 23, 8192, 23, 12288, 120, 23, 4096, 120, 4097,
    189, 3, 8192, 23, 4096, 120, 4097, 189, 4, 4096, 120, 4101, 189, 20482,
    189, 1
},
// jungleShrine27
{
    2571, 4102, 189, 20482, 189, 1, 4098, 189, 36864, 563, 24, 4102, 563, 4098,
    189, 4103, 563, 4098, 189, 4096, 563, 0, 8196, 313, 4096, 563, 4098, 189,
    4096, 563, 0, 8194, 313, 12288, 21, 288, 0, 313, 12288, 21, 288, 18, 313,
    4096, 563, 4098, 189, 4096, 563, 0, 8194, 313, 12288, 21, 306, 0, 313,
    12288, 21, 306, 18, 313, 4096, 563, 4098, 189, 4096, 563, 0, 8196, 313,
    4096, 563, 4098, 189, 4103, 563, 4098, 189, 36864, 563, 16, 4102, 563,
    4103, 189, 20482, 189, 1, 4096, 189
},
// jungleShrine28
{
    3850, 4101, 189, 20482, 189, 1, 4097, 189, 4096, 562, 36869, 562, 2048,
    4096, 563, 4097, 189, 4096, 562, 36869, 562, 2048, 4096, 563, 4097, 189,
    4096, 562, 36869, 562, 2048, 4096, 563, 4097, 189, 4096, 562, 36869, 562,
    2048, 4096, 563, 4097, 189, 4096, 562, 8195, 312, 12288, 15, 18, 1760, 312,
    12288, 15, 18, 1778, 312, 4096, 563, 4097, 189, 4096, 562, 8197, 312, 4096,
    563, 4097, 189, 4096, 562, 8197, 312, 4096, 563, 4097, 189, 4096, 562,
    8195, 312, 12288, 21, 360, 0, 312, 12288, 21, 360, 18, 312, 4096, 563,
    4097, 189, 4096, 562, 8195, 312, 12288, 21, 378, 0, 312, 12288, 21, 378,
    18, 312, 4096, 563, 4097, 189, 4096, 562, 36869, 562, 2048, 4096, 563,
    4097, 189, 4096, 562, 36869, 562, 2048, 4096, 563, 4097, 189, 4096, 562,
    36869, 562, 2048, 4096, 563, 4097, 189, 4096, 562, 36869, 562, 2048, 4096,
    563, 4102, 189, 20482, 189, 1, 4096, 189
},
// jungleShrine29
{
    2315, 4097, 189, 20488, 189, 1, 4096, 189, 4101, 158, 36866, 158, 2048,
    4097, 189, 4097, 158, 12288, 158, 42, 12288, 21, 288, 0, 42, 12288, 21,
    288, 18, 42, 4096, 158, 2, 4097, 189, 4097, 158, 12288, 158, 42, 12288, 21,
    306, 0, 42, 12288, 21, 306, 18, 42, 4096, 158, 2, 4097, 189, 4097, 158,
    12290, 158, 42, 4096, 158, 2, 4097, 189, 4101, 158, 2, 4097, 189, 4101,
    158, 2, 4097, 189, 4101, 158, 36866, 158, 2048, 4106, 189, 20480, 189, 1
},
// jungleShrine30
{
    3082, 4103, 189, 20480, 189, 1, 4099, 189, 4, 4096, 59, 4098, 189, 1,
    36864, 383, 8, 4098, 383, 4096, 59, 4097, 189, 1, 36864, 383, 24, 4099,
    383, 4096, 59, 4097, 189, 0, 4096, 383, 12292, 383, 78, 4096, 59, 4097,
    189, 0, 8192, 78, 8193, 42, 8192, 78, 12288, 21, 360, 0, 78, 12288, 21,
    360, 18, 42, 4096, 59, 4097, 189, 0, 8192, 78, 8193, 42, 8192, 78, 12288,
    21, 378, 0, 42, 12288, 21, 378, 18, 78, 4096, 59, 4097, 189, 0, 36864, 383,
    8, 12292, 383, 78, 4096, 59, 4097, 189, 1, 36864, 383, 8, 4099, 383, 4096,
    59, 4098, 189, 1, 36864, 383, 16, 4098, 383, 4096, 59, 4100, 189, 3, 4096,
    59, 4104, 189, 20480, 189, 1, 4096, 189
},
// jungleShrine31
{
    2569, 4102, 189, 20480, 189, 1, 4097, 189, 4098, 158, 2, 4096, 59, 4097,
    189, 4096, 158, 8192, 78, 12288, 4, 22, 66, 78, 8194, 78, 4096, 59, 4097,
    189, 4096, 158, 8196, 78, 4096, 59, 4097, 189, 4096, 158, 8196, 78, 4096,
    59, 4097, 189, 4096, 158, 8196, 78, 4096, 59, 4097, 189, 4096, 158, 8192,
    78, 12288, 21, 360, 0, 78, 12288, 21, 360, 18, 78, 12288, 19, 36, 36, 78,
    8192, 78, 4096, 59, 4097, 189, 4096, 158, 8192, 78, 12288, 21, 378, 0, 78,
    12288, 21, 378, 18, 78, 12288, 19, 72, 36, 78, 8192, 78, 4096, 59, 4097,
    189, 4101, 158, 4096, 59, 4098, 189, 20485, 189, 1, 4096, 189
},
// jungleShrine32
{
    2566, 4099, 189, 20481, 189, 1, 4096, 189, 8193, 73, 8192, 139, 4096, 120,
    4097, 189, 8193, 73, 8192, 139, 4096, 120, 4097, 189, 8192, 73, 8193, 139,
    4096, 120, 4097, 189, 8192, 73, 12288, 21, 288, 0, 73, 12288, 21, 288, 18,
    42, 4096, 120, 4097, 189, 8192, 73, 12288, 21, 306, 0, 73, 12288, 21, 306,
    18, 42, 4096, 120, 4097, 189, 8192, 73, 8193, 139, 4096, 120, 4097, 189,
    8193, 73, 8192, 139, 4096, 120, 4097, 189, 8193, 73, 8192, 139, 4096, 120,
    4100, 189, 20481, 189, 1
},
// jungleShrine33
{
    3080, 20482, 189, 1, 4101, 189, 4096, 226, 4100, 59, 4097, 189, 4097, 226,
    4099, 59, 4097, 189, 4098, 226, 4098, 59, 4097, 189, 4100, 226, 4096, 59,
    4097, 189, 4096, 226, 12288, 226, 112, 12288, 21, 360, 0, 112, 12288, 21,
    360, 18, 112, 4096, 226, 4096, 59, 4097, 189, 4097, 226, 12288, 21, 378, 0,
    112, 12288, 21, 378, 18, 112, 4096, 226, 4096, 59, 4097, 189, 4100, 226,
    4096, 59, 4097, 189, 4098, 226, 4098, 59, 4097, 189, 4097, 226, 4099, 59,
    4097, 189, 4096, 226, 4100, 59, 4096, 189, 20482, 189, 1, 4100, 189
},
// jungleShrine34
{
    1542, 4102, 189, 2, 4096, 19, 54, 594, 4097, 189, 0, 12288, 21, 360, 0,
    112, 12288, 21, 360, 18, 112, 12288, 19, 0, 594, 112, 4097, 189, 0, 12288,
    21, 378, 0, 112, 12288, 21, 378, 18, 112, 12288, 19, 0, 594, 112, 4097,
    189, 2, 4096, 19, 72, 594, 4102, 189
},
// jungleShrine35
{
    2315, 20490, 189, 1, 4096, 189, 12296, 226, 112, 4097, 189, 12296, 226,
    112, 4097, 189, 12289, 226, 112, 12288, 34, 0, 756, 112, 12288, 34, 0, 774,
    112, 12288, 34, 0, 792, 112, 8193, 112, 12289, 226, 112, 4097, 189, 12289,
    226, 112, 12288, 34, 18, 756, 112, 12288, 34, 18, 774, 112, 12288, 34, 18,
    792, 112, 12288, 21, 360, 0, 112, 12288, 21, 360, 18, 112, 12289, 226, 112,
    4097, 189, 12289, 226, 112, 12288, 34, 36, 756, 112, 12288, 34, 36, 774,
    112, 12288, 34, 36, 792, 112, 12288, 21, 378, 0, 112, 12288, 21, 378, 18,
    112, 12289, 226, 112, 4097, 189, 12296, 226, 112, 4097, 189, 12296, 226,
    112, 4096, 189, 20490, 189, 1
},
// jungleShrine36
{
    3083, 4104, 189, 20481, 189, 1, 4096, 189, 4100, 158, 4096, 10, 36, 648,
    4096, 10, 0, 666, 4096, 10, 36, 684, 4096, 158, 4097, 189, 4096, 158,
    12288, 42, 18, 684, 42, 45056, 42, 18, 702, 42, 256, 40963, 42, 256, 45056,
    135, 0, 108, 42, 256, 4096, 158, 4097, 189, 4096, 158, 8192, 42, 8195, 67,
    8192, 42, 45056, 135, 0, 108, 42, 256, 4096, 158, 4097, 189, 4096, 158,
    8192, 42, 8192, 67, 45057, 226, 112, 2048, 8192, 67, 8192, 42, 45056, 135,
    0, 108, 42, 256, 4096, 158, 4097, 189, 4096, 158, 8192, 42, 8192, 67, 8193,
    112, 8192, 67, 12288, 21, 360, 0, 42, 12288, 21, 360, 18, 42, 4096, 158,
    4097, 189, 4096, 158, 8192, 42, 8192, 67, 8193, 112, 8192, 67, 12288, 21,
    378, 0, 42, 12288, 21, 378, 18, 42, 4096, 158, 4097, 189, 4096, 158, 8192,
    42, 8192, 67, 45057, 226, 112, 2048, 8192, 67, 8192, 42, 45056, 135, 0,
    108, 42, 256, 4096, 158, 4097, 189, 4096, 158, 8192, 42, 8195, 67, 8192,
    42, 45056, 135, 0, 108, 42, 256, 4096, 158, 4097, 189, 4096, 158, 12288,
    42, 18, 684, 42, 45056, 42, 18, 702, 42, 256, 40963, 42, 256, 45056, 135,
    0, 108, 42, 256, 4096, 158, 4097, 189, 4100, 158, 4096, 10, 18, 648, 4096,
    10, 36, 666, 4096, 10, 18, 684, 4096, 158, 4105, 189, 20481, 189, 1
},
// jungleShrine37
{
    2570, 4102, 189, 20482, 189, 1, 4096, 189, 5, 4097, 226, 4097, 189, 5,
    4097, 226, 4097, 189, 2, 4096, 4, 0, 220, 4099, 226, 4097, 189, 4096, 21,
    360, 0, 4096, 21, 360, 18, 4101, 226, 4097, 189, 4096, 21, 378, 0, 4096,
    21, 378, 18, 4101, 226, 4097, 189, 2, 4096, 4, 0, 220, 4099, 226, 4097,
    189, 5, 4097, 226, 4097, 189, 5, 4097, 226, 4103, 189, 20482, 189, 1
},
// jungleShrine38
{
    3337, 4101, 189, 20482, 189, 1, 4096, 189, 5, 4096, 226, 4097, 189, 4097,
    226, 4096, 120, 36866, 226, 2048, 4096, 120, 4097, 189, 4096, 226, 8192,
    112, 12288, 4, 22, 462, 112, 8192, 24, 8193, 112, 4096, 226, 4097, 189,
    4096, 226, 8196, 112, 4096, 226, 4097, 189, 4096, 120, 8192, 24, 8194, 112,
    8192, 24, 4096, 226, 4097, 189, 4096, 226, 8196, 112, 4096, 120, 4097, 189,
    4096, 226, 8194, 112, 12288, 21, 360, 0, 112, 12288, 21, 360, 18, 112,
    4096, 226, 4097, 189, 4096, 226, 8192, 112, 8192, 24, 8192, 112, 12288, 21,
    378, 0, 112, 12288, 21, 378, 18, 112, 4096, 226, 4097, 189, 4096, 120,
    8192, 112, 12288, 4, 44, 462, 112, 8192, 112, 8192, 24, 8192, 112, 4096,
    120, 4097, 189, 4098, 226, 36864, 120, 2048, 36865, 226, 2048, 4096, 226,
    4097, 189, 5, 4096, 226, 4102, 189, 20482, 189, 1
},
// jungleShrine39
{
    3335, 4100, 189, 20481, 189, 1, 4096, 189, 4096, 120, 36866, 120, 2048,
    4096, 120, 4097, 189, 4096, 59, 8194, 24, 4096, 120, 4097, 189, 4096, 59,
    8192, 24, 12288, 186, 1296, 0, 24, 12288, 186, 1296, 18, 24, 4096, 59,
    4097, 189, 4096, 120, 12288, 4, 0, 44, 24, 12288, 186, 1314, 0, 24, 12288,
    186, 1314, 18, 24, 4096, 120, 4097, 189, 4096, 120, 8192, 24, 12288, 186,
    1332, 0, 24, 12288, 186, 1332, 18, 24, 4096, 59, 4097, 189, 4096, 59, 8194,
    24, 4096, 59, 4097, 189, 4096, 120, 8192, 24, 12288, 21, 360, 0, 24, 12288,
    21, 360, 18, 24, 4096, 120, 4097, 189, 4096, 120, 12288, 4, 0, 44, 24,
    12288, 21, 378, 0, 24, 12288, 21, 378, 18, 24, 4096, 59, 4097, 189, 4096,
    59, 8194, 24, 4096, 120, 4097, 189, 4096, 120, 8194, 24, 4096, 120, 4097,
    189, 4096, 120, 36866, 120, 2048, 4096, 120, 4101, 189, 20481, 189, 1
},
// jungleShrine40
{
    2058, 4103, 189, 20481, 189, 1, 4096, 189, 4096, 120, 4097, 119, 4096, 120,
    36866, 119, 2048, 4096, 120, 4097, 189, 4096, 119, 8192, 24, 12288, 33, 0,
    242, 23, 12288, 19, 108, 594, 24, 8193, 23, 8192, 24, 4096, 119, 4097, 189,
    4096, 119, 8192, 24, 8194, 23, 12288, 21, 360, 0, 23, 12288, 21, 360, 18,
    23, 4096, 119, 4097, 189, 4096, 119, 8195, 23, 12288, 21, 378, 0, 23,
    12288, 21, 378, 18, 23, 4096, 119, 4097, 189, 4096, 120, 8192, 23, 12288,
    33, 0, 242, 24, 12288, 19, 126, 594, 24, 8192, 24, 8192, 23, 8192, 24,
    4096, 120, 4097, 189, 4097, 119, 4097, 120, 36864, 120, 2048, 36865, 119,
    2048, 4096, 119, 4104, 189, 20481, 189, 1
},
// jungleShrine41
{
    2058, 4096, 189, 20487, 189, 1, 4097, 189, 36864, 120, 2048, 4098, 120,
    36865, 120, 2048, 4097, 120, 4097, 189, 0, 8192, 24, 8192, 247, 8194, 24,
    8192, 247, 4096, 59, 4097, 189, 0, 8196, 24, 8192, 247, 4096, 59, 4097,
    189, 4096, 59, 8192, 247, 8194, 24, 12288, 21, 360, 0, 24, 12288, 21, 360,
    18, 24, 4096, 120, 4097, 189, 4096, 120, 8192, 24, 12288, 4, 44, 462, 24,
    8192, 24, 8192, 247, 12288, 21, 378, 0, 24, 12288, 21, 378, 18, 24, 4096,
    120, 4097, 189, 4096, 120, 36864, 120, 2048, 4097, 120, 4096, 59, 4098,
    120, 4097, 189, 20487, 189, 1, 4096, 189
},
// jungleShrine42
{
    2059, 4096, 189, 20489, 189, 1, 4096, 189, 4098, 226, 0, 4098, 226, 0,
    4096, 226, 4097, 189, 4096, 226, 12288, 4, 0, 462, 23, 4098, 226, 12288, 4,
    0, 462, 23, 4098, 226, 4097, 189, 4096, 226, 8192, 23, 12288, 21, 360, 0,
    23, 12288, 21, 360, 18, 23, 12288, 19, 54, 594, 23, 8193, 23, 12288, 18,
    360, 0, 23, 4096, 226, 4097, 189, 4096, 226, 8192, 23, 12288, 21, 378, 0,
    23, 12288, 21, 378, 18, 23, 12288, 19, 72, 594, 23, 8193, 23, 12288, 18,
    378, 0, 23, 4096, 226, 4097, 189, 4096, 226, 12288, 4, 0, 462, 23, 4098,
    226, 12288, 4, 0, 462, 23, 4098, 226, 4097, 189, 4098, 226, 0, 4098, 226,
    0, 4096, 226, 4097, 189, 20489, 189, 1
},
// jungleShrine43
{
    1542, 20484, 189, 1, 4097, 189, 4096, 120, 4098, 119, 4097, 189, 4096, 120,
    12288, 21, 360, 0, 112, 12288, 21, 360, 18, 112, 4096, 119, 4097, 189,
    4096, 120, 12288, 21, 378, 0, 112, 12288, 21, 378, 18, 112, 4096, 119,
    4097, 189, 4096, 120, 4098, 119, 4096, 189, 20484, 189, 1, 4096, 189
},
// jungleShrine44
{
    2314, 4102, 189, 20482, 189, 1, 4096, 189, 36864, 226, 8, 4096, 226, 36868,
    119, 2048, 4096, 120, 4097, 189, 4096, 226, 8192, 112, 8195, 23, 8192, 24,
    4096, 120, 4097, 189, 4096, 226, 8192, 112, 12288, 33, 0, 242, 23, 12288,
    19, 36, 594, 23, 8193, 23, 8192, 24, 4096, 120, 4097, 189, 4096, 226, 8192,
    112, 12288, 33, 0, 242, 23, 12288, 19, 18, 594, 23, 8193, 23, 8192, 24,
    4096, 120, 4097, 189, 4096, 226, 8192, 112, 8194, 23, 12288, 21, 360, 0,
    23, 12288, 21, 360, 18, 24, 4096, 120, 4097, 189, 4096, 226, 8192, 112,
    8194, 23, 12288, 21, 378, 0, 23, 12288, 21, 378, 18, 24, 4096, 120, 4097,
    189, 36864, 226, 16, 4096, 226, 4100, 119, 4096, 120, 4098, 189, 20487,
    189, 1
},
// jungleShrine45
{
    2054, 4102, 189, 4096, 19, 288, 594, 4097, 19, 108, 594, 4096, 19, 288,
    594, 4097, 189, 36864, 19, 468, 594, 16, 36865, 19, 90, 594, 8, 36864, 19,
    468, 594, 16, 4097, 189, 4096, 19, 0, 594, 4096, 21, 360, 0, 4096, 21, 360,
    18, 4096, 19, 0, 594, 4097, 189, 4096, 19, 0, 594, 4096, 21, 378, 0, 4096,
    21, 378, 18, 4096, 19, 0, 594, 4097, 189, 36864, 19, 450, 594, 24, 36865,
    19, 90, 594, 8, 36864, 19, 450, 594, 24, 4097, 189, 4096, 19, 270, 594,
    4097, 19, 126, 594, 4096, 19, 270, 594, 4102, 189
},
// jungleShrine46
{
    1544, 4104, 189, 12289, 19, 54, 594, 67, 12288, 4, 0, 44, 67, 12288, 19,
    108, 594, 67, 12289, 19, 54, 594, 67, 4097, 189, 45056, 19, 450, 594, 67,
    24, 12288, 19, 0, 594, 67, 12288, 21, 360, 0, 67, 12288, 21, 360, 18, 67,
    45056, 19, 450, 594, 67, 24, 12288, 19, 0, 594, 67, 4097, 189, 45056, 19,
    468, 594, 67, 16, 12288, 19, 0, 594, 67, 12288, 21, 378, 0, 67, 12288, 21,
    378, 18, 67, 45056, 19, 468, 594, 67, 16, 12288, 19, 0, 594, 67, 4097, 189,
    12289, 19, 72, 594, 67, 12288, 4, 0, 44, 67, 12288, 19, 126, 594, 67,
    12289, 19, 72, 594, 67, 4104, 189
},
// jungleShrine47
{
    2053, 4099, 189, 20480, 189, 1, 4096, 189, 0, 4096, 15, 18, 480, 4096, 15,
    18, 498, 4097, 189, 4096, 33, 0, 242, 4096, 14, 486, 0, 4096, 14, 486, 18,
    4097, 189, 0, 4096, 14, 504, 0, 4096, 14, 504, 18, 4097, 189, 0, 4096, 14,
    522, 0, 4096, 14, 522, 18, 4097, 189, 0, 4096, 21, 360, 0, 4096, 21, 360,
    18, 4097, 189, 0, 4096, 21, 378, 0, 4096, 21, 378, 18, 4100, 189, 20480,
    189, 1
},
// jungleShrine48
{
    2569, 4101, 189, 20482, 189, 1, 4096, 189, 36864, 119, 24, 36868, 119,
    2048, 4096, 120, 4097, 189, 4096, 119, 8192, 23, 12288, 33, 0, 242, 23,
    12288, 19, 108, 594, 23, 0, 8192, 23, 4096, 120, 4097, 189, 4096, 119,
    8195, 23, 45056, 226, 23, 8, 4096, 120, 4097, 189, 4096, 119, 8193, 23,
    12288, 21, 360, 0, 23, 12288, 21, 360, 18, 23, 12288, 226, 23, 4096, 120,
    4097, 189, 4096, 119, 8193, 23, 12288, 21, 378, 0, 23, 12288, 21, 378, 18,
    23, 12288, 226, 23, 4096, 120, 4097, 189, 4096, 119, 8195, 23, 45056, 226,
    23, 8, 4096, 120, 4097, 189, 4096, 119, 8192, 23, 12288, 33, 0, 242, 23,
    12288, 19, 126, 594, 23, 8193, 23, 4096, 120, 4097, 189, 36864, 119, 16,
    36868, 119, 2048, 4096, 120, 4102, 189, 20482, 189, 1
},
// jungleShrine49
{
    2316, 4105, 189, 20481, 189, 1, 4096, 189, 4101, 120, 4096, 10, 0, 810,
    4096, 10, 0, 828, 4096, 10, 0, 846, 4096, 120, 4097, 189, 4096, 120, 8199,
    247, 4096, 120, 4097, 189, 4096, 120, 8193, 247, 12288, 21, 360, 0, 247,
    12288, 21, 360, 18, 247, 12288, 19, 36, 792, 247, 8194, 247, 4096, 120,
    4097, 189, 4096, 120, 8193, 247, 12288, 21, 378, 0, 247, 12288, 21, 378,
    18, 247, 12288, 19, 18, 792, 247, 8194, 247, 4096, 120, 4097, 189, 4096,
    120, 8192, 247, 12288, 33, 0, 242, 247, 12288, 19, 90, 792, 247, 8196, 247,
    4096, 120, 4097, 189, 4096, 120, 8199, 247, 4096, 120, 4097, 189, 4101,
    120, 4096, 10, 0, 810, 4096, 10, 0, 828, 4096, 10, 0, 846, 4096, 120, 4106,
    189, 20481, 189, 1
},
// jungleShrine50
{
    2062, 4100, 189, 20483, 189, 1, 4101, 189, 4096, 562, 4096, 10, 0, 108,
    4096, 10, 0, 126, 4096, 10, 18, 144, 4103, 562, 4097, 189, 4096, 562, 8194,
    67, 12288, 19, 54, 792, 67, 8192, 67, 12288, 33, 18, 198, 67, 12288, 19,
    108, 792, 67, 8194, 67, 4096, 562, 4097, 189, 4096, 562, 8194, 67, 12288,
    19, 0, 792, 67, 8195, 67, 12288, 21, 360, 0, 67, 12288, 21, 360, 18, 67,
    4096, 562, 4097, 189, 4096, 562, 8194, 67, 12288, 19, 0, 792, 67, 8195, 67,
    12288, 21, 378, 0, 67, 12288, 21, 378, 18, 67, 4096, 562, 4097, 189, 4096,
    562, 8194, 67, 12288, 19, 72, 792, 67, 8192, 67, 12288, 33, 18, 198, 67,
    12288, 19, 126, 792, 67, 8194, 67, 4096, 562, 4097, 189, 4096, 562, 4096,
    10, 18, 108, 4096, 10, 18, 126, 4096, 10, 18, 144, 4103, 562, 4101, 189,
    20483, 189, 1, 4100, 189
},
// jungleShrine51
{
    2572, 4108, 189, 9, 4097, 189, 12288, 4, 0, 462, 313, 45056, 19, 396, 792,
    313, 16, 45057, 19, 342, 792, 313, 24, 45058, 19, 396, 792, 313, 16, 45056,
    19, 342, 792, 313, 24, 12288, 19, 36, 792, 313, 12288, 4, 0, 462, 313,
    4097, 189, 8192, 313, 45056, 19, 180, 792, 313, 16, 45056, 19, 144, 792,
    313, 24, 12288, 19, 216, 792, 313, 45058, 19, 144, 792, 313, 24, 12288, 19,
    252, 792, 313, 12288, 19, 234, 792, 313, 8192, 313, 4097, 189, 8192, 313,
    45056, 19, 144, 792, 313, 24, 12288, 19, 216, 792, 313, 45056, 19, 450,
    792, 313, 24, 12288, 21, 360, 0, 313, 12288, 21, 360, 18, 313, 12288, 19,
    216, 792, 313, 45056, 19, 180, 792, 313, 16, 45056, 19, 360, 792, 313, 16,
    8192, 313, 4097, 189, 8192, 313, 45056, 19, 180, 792, 313, 16, 12288, 19,
    234, 792, 313, 45056, 19, 468, 792, 313, 16, 12288, 21, 378, 0, 313, 12288,
    21, 378, 18, 313, 12288, 19, 234, 792, 313, 45056, 19, 144, 792, 313, 24,
    45056, 19, 342, 792, 313, 24, 8192, 313, 4097, 189, 8192, 313, 45056, 19,
    144, 792, 313, 24, 45056, 19, 180, 792, 313, 16, 12288, 19, 234, 792, 313,
    45058, 19, 180, 792, 313, 16, 12288, 19, 252, 792, 313, 12288, 19, 216,
    792, 313, 8192, 313, 4097, 189, 12288, 4, 0, 462, 313, 45056, 19, 378, 792,
    313, 24, 45057, 19, 360, 792, 313, 16, 45058, 19, 378, 792, 313, 24, 45056,
    19, 360, 792, 313, 16, 12288, 19, 18, 792, 313, 12288, 4, 0, 462, 313,
    4097, 189, 9, 4108, 189
},
// jungleShrine52
{
    2055, 4103, 189, 4100, 562, 4097, 189, 4096, 562, 1, 4096, 19, 54, 414, 0,
    4097, 189, 4096, 562, 4096, 21, 360, 0, 4096, 21, 360, 18, 4096, 19, 0,
    414, 0, 4097, 189, 4096, 562, 4096, 21, 378, 0, 4096, 21, 378, 18, 4096,
    19, 0, 414, 0, 4097, 189, 4096, 562, 1, 4096, 19, 72, 414, 0, 4097, 189,
    4100, 562, 4103, 189
},
// jungleShrine53
{
    2568, 4099, 189, 20483, 189, 1, 4096, 189, 4, 4096, 563, 4097, 189, 0,
    12288, 4, 0, 220, 67, 8194, 313, 4096, 563, 4097, 189, 0, 8192, 313, 8192,
    67, 8193, 313, 4096, 563, 4097, 189, 0, 8192, 313, 8192, 67, 12288, 21,
    360, 0, 67, 12288, 21, 360, 18, 313, 4096, 563, 4097, 189, 0, 8193, 313,
    12288, 21, 378, 0, 313, 12288, 21, 378, 18, 313, 4096, 563, 4097, 189, 0,
    8194, 313, 8192, 67, 4096, 563, 4097, 189, 0, 12288, 4, 0, 220, 67, 8193,
    313, 8192, 67, 4096, 563, 4097, 189, 4, 4096, 563, 4100, 189, 20483, 189, 1
},
// jungleShrine54
{
    2062, 4096, 189, 20484, 189, 1, 4104, 189, 4098, 119, 4098, 120, 4099, 119,
    4097, 120, 4097, 189, 4096, 119, 8192, 23, 8193, 24, 8194, 23, 12288, 4, 0,
    462, 23, 12288, 19, 108, 414, 23, 8193, 24, 4096, 120, 4097, 189, 4096,
    387, 0, 0, 8195, 24, 12288, 21, 360, 0, 24, 12288, 21, 360, 18, 24, 12288,
    19, 36, 414, 24, 8194, 24, 4096, 120, 4097, 189, 4096, 387, 18, 0, 8193,
    24, 8193, 23, 12288, 21, 378, 0, 23, 12288, 21, 378, 18, 24, 12288, 19, 18,
    414, 24, 8192, 24, 8193, 23, 4096, 119, 4097, 189, 4096, 119, 8192, 24,
    8194, 23, 8193, 24, 12288, 4, 0, 462, 23, 12288, 19, 126, 414, 23, 8192,
    23, 8192, 24, 4096, 119, 4097, 189, 4096, 119, 4097, 120, 4100, 119, 4098,
    120, 4096, 119, 4097, 189, 20484, 189, 1, 4103, 189
},
// jungleShrine55
{
    3337, 20488, 189, 1, 4096, 189, 4096, 226, 4, 4096, 59, 4097, 189, 4096,
    226, 4100, 158, 4096, 120, 4097, 189, 4096, 226, 8196, 139, 4096, 120,
    4097, 189, 4096, 226, 8192, 139, 8192, 42, 8192, 139, 12288, 21, 360, 0,
    42, 12288, 21, 360, 18, 139, 4096, 120, 4097, 189, 4096, 226, 8194, 139,
    12288, 21, 378, 0, 139, 12288, 21, 378, 18, 139, 4096, 120, 4097, 189,
    4096, 226, 8192, 139, 8192, 42, 8192, 139, 8192, 42, 8192, 139, 4096, 120,
    4097, 189, 4096, 226, 8196, 139, 4096, 120, 4097, 189, 4096, 226, 8192,
    139, 8192, 42, 8192, 139, 8192, 42, 8192, 139, 4096, 120, 4097, 189, 4096,
    226, 8196, 139, 4096, 120, 4097, 189, 4096, 226, 36868, 158, 2048, 4096,
    120, 4097, 189, 4096, 226, 4, 4096, 59, 4102, 189, 20482, 189, 1
},
// jungleShrine56
{
    2569, 4105, 189, 0, 8192, 42, 0, 8192, 42, 0, 8192, 42, 0, 4097, 189, 8192,
    139, 8192, 42, 8192, 139, 8192, 42, 8192, 139, 8192, 42, 8192, 139, 4097,
    189, 8192, 139, 12288, 4, 0, 220, 42, 8192, 139, 8192, 42, 8192, 139,
    12288, 4, 0, 220, 42, 8192, 139, 4097, 189, 8192, 139, 8192, 42, 12288, 21,
    360, 0, 139, 12288, 21, 360, 18, 42, 12288, 19, 36, 414, 139, 8192, 42,
    8192, 139, 4097, 189, 8192, 139, 8192, 42, 12288, 21, 378, 0, 139, 12288,
    21, 378, 18, 42, 12288, 19, 18, 414, 139, 8192, 42, 8192, 139, 4097, 189,
    8192, 139, 12288, 4, 0, 220, 42, 8192, 139, 8192, 42, 8192, 139, 12288, 4,
    0, 220, 42, 8192, 139, 4097, 189, 8192, 139, 8192, 42, 8192, 139, 8192, 42,
    8192, 139, 8192, 42, 8192, 139, 4097, 189, 0, 8192, 42, 0, 8192, 42, 0,
    8192, 42, 0, 4105, 189
},
// jungleShrine57
{
    4363, 4104, 189, 20481, 189, 1, 4096, 189, 0, 4099, 120, 4096, 10, 36, 108,
    4096, 10, 18, 126, 4096, 10, 36, 144, 4096, 158, 4097, 189, 0, 4096, 120,
    8192, 42, 12288, 33, 0, 242, 42, 12288, 19, 108, 414, 42, 8194, 42, 4096,
    158, 4097, 189, 0, 4096, 120, 8197, 139, 4096, 158, 4097, 189, 0, 4096,
    383, 8197, 139, 4096, 158, 4097, 189, 36864, 384, 8, 4096, 384, 8195, 42,
    12288, 21, 360, 0, 42, 12288, 21, 360, 18, 42, 4096, 158, 4097, 189, 1,
    8195, 139, 12288, 21, 378, 0, 139, 12288, 21, 378, 18, 139, 4096, 158,
    4097, 189, 36864, 384, 8, 4096, 384, 8197, 139, 4096, 158, 4097, 189,
    36864, 384, 8, 4096, 120, 8195, 42, 28672, 14, 108, 0, 42, 28, 28672, 14,
    108, 18, 42, 28, 4096, 158, 4097, 189, 0, 4096, 120, 8195, 139, 28672, 14,
    126, 0, 139, 28, 28672, 14, 126, 18, 139, 28, 4096, 158, 4097, 189, 0,
    4096, 120, 8195, 139, 28672, 14, 144, 0, 139, 28, 28672, 14, 144, 18, 139,
    28, 4096, 158, 4097, 189, 0, 4096, 120, 8195, 42, 12288, 15, 0, 200, 42,
    12288, 15, 0, 218, 42, 4096, 158, 4097, 189, 0, 4096, 120, 8197, 139, 4096,
    158, 4097, 189, 0, 4096, 120, 8197, 139, 4096, 158, 4097, 189, 0, 4096,
    384, 12288, 384, 42, 8196, 42, 4096, 158, 4097, 189, 0, 36864, 384, 8,
    4098, 120, 4096, 10, 0, 108, 4096, 10, 0, 126, 4096, 10, 0, 144, 4096, 158,
    4105, 189, 20481, 189, 1
},
// jungleShrine58
{
    2312, 20487, 189, 1, 4096, 189, 36864, 120, 2048, 4097, 120, 4098, 119,
    4097, 189, 36864, 120, 2048, 0, 8192, 42, 12288, 21, 360, 0, 42, 12288, 21,
    360, 18, 42, 4096, 119, 4097, 189, 4096, 120, 0, 8192, 42, 12288, 21, 378,
    0, 42, 4096, 21, 378, 18, 4096, 119, 4097, 189, 4096, 120, 8194, 42, 0,
    4096, 119, 4097, 189, 4096, 120, 8194, 42, 0, 4096, 120, 4097, 189, 4096,
    119, 8192, 42, 12288, 4, 0, 462, 42, 12288, 19, 126, 414, 42, 8192, 42,
    4096, 119, 4097, 189, 4097, 119, 36866, 120, 2048, 4096, 119, 4102, 189,
    20481, 189, 1
},
// jungleShrine59
{
    3599, 4105, 189, 20483, 189, 1, 4097, 189, 10, 4099, 189, 3, 36864, 383,
    16, 36864, 383, 40, 5, 4098, 189, 2, 8192, 60, 8192, 78, 12288, 383, 78, 3,
    8193, 60, 4098, 189, 1, 12289, 384, 60, 4096, 383, 12290, 383, 78, 4096,
    383, 12288, 383, 60, 12289, 384, 60, 4098, 189, 0, 4096, 384, 12288, 384,
    60, 28672, 353, 60, 4, 28675, 353, 78, 4, 12288, 383, 78, 8192, 60, 12289,
    384, 60, 4098, 189, 0, 4097, 383, 8192, 60, 8195, 78, 12288, 383, 78, 8193,
    78, 12288, 383, 78, 4098, 189, 1, 12288, 383, 78, 8192, 78, 12288, 383, 78,
    8197, 78, 12288, 383, 78, 4098, 189, 4096, 383, 0, 12288, 383, 78, 45056,
    383, 78, 8, 45056, 383, 78, 32, 8192, 78, 12288, 384, 78, 8193, 60, 12288,
    21, 360, 0, 60, 12288, 21, 360, 18, 78, 12288, 383, 78, 12288, 59, 78,
    4097, 189, 36864, 383, 16, 4096, 383, 12289, 383, 78, 8192, 78, 8192, 60,
    12290, 384, 60, 12288, 21, 378, 0, 60, 12288, 21, 378, 18, 78, 12288, 383,
    78, 12288, 59, 78, 4097, 189, 1, 36864, 383, 16, 12288, 383, 78, 4096, 383,
    12288, 383, 60, 12291, 384, 60, 4096, 383, 12288, 383, 78, 4098, 189, 3,
    8192, 78, 12288, 383, 60, 8193, 60, 0, 4096, 384, 12288, 384, 78, 8192, 78,
    4098, 189, 11, 4108, 189, 20482, 189, 1, 4096, 189
},
// jungleShrine60
{
    3340, 4101, 189, 20485, 189, 1, 4096, 189, 2, 8192, 247, 4097, 59, 4096,
    120, 12289, 120, 292, 4096, 120, 4097, 189, 1, 12288, 384, 292, 28672, 353,
    292, 4, 20480, 353, 4, 4096, 101, 648, 0, 4096, 101, 648, 18, 12288, 101,
    648, 36, 292, 12288, 101, 648, 54, 292, 4096, 158, 4097, 189, 1, 4096, 384,
    12288, 384, 292, 0, 4096, 101, 666, 0, 4096, 101, 666, 18, 4096, 101, 666,
    36, 12288, 101, 666, 54, 292, 4096, 158, 4097, 189, 1, 4096, 384, 12288,
    59, 247, 4096, 13, 18, 0, 4096, 101, 684, 0, 4096, 101, 684, 18, 12288,
    101, 684, 36, 247, 12288, 101, 684, 54, 247, 4096, 158, 4097, 189, 1, 8192,
    247, 4096, 59, 2, 12288, 21, 360, 0, 247, 4096, 21, 360, 18, 4096, 158,
    4097, 189, 2, 12288, 384, 247, 4096, 384, 0, 8192, 247, 12288, 21, 378, 0,
    247, 4096, 21, 378, 18, 4096, 158, 4097, 189, 2, 12288, 384, 292, 20480,
    353, 4, 3, 4096, 158, 4097, 189, 2, 4096, 120, 8192, 247, 3, 4096, 158,
    4097, 189, 1, 4096, 384, 12288, 120, 292, 4, 4096, 158, 4097, 189, 0, 4097,
    384, 12288, 120, 292, 4097, 120, 8194, 292, 4096, 158, 4097, 189, 0, 36864,
    384, 8, 4096, 384, 20484, 353, 4, 8192, 292, 4106, 189, 20482, 189, 1
},
// jungleShrine61
{
    3338, 4101, 189, 20483, 189, 1, 4096, 189, 1, 4097, 119, 4097, 120, 4097,
    119, 4097, 189, 0, 4097, 119, 8194, 24, 8192, 23, 4096, 119, 4097, 189, 0,
    4096, 119, 8192, 23, 8192, 73, 8194, 23, 4096, 119, 4097, 189, 0, 8195, 23,
    12288, 21, 360, 0, 23, 12288, 21, 360, 18, 23, 4096, 119, 4097, 189, 0,
    8192, 73, 8194, 23, 12288, 21, 378, 0, 23, 12288, 21, 378, 18, 23, 4096,
    119, 4097, 189, 4096, 119, 8192, 24, 8195, 23, 8192, 73, 4096, 119, 4097,
    189, 4096, 119, 8193, 24, 8192, 23, 8193, 24, 12288, 16, 0, 0, 24, 4096,
    119, 4097, 189, 4096, 120, 8194, 24, 8192, 23, 8192, 24, 12288, 16, 18, 0,
    24, 4096, 120, 4097, 189, 4097, 120, 8192, 24, 8193, 73, 8192, 23, 8192,
    24, 4096, 120, 4097, 189, 0, 4096, 120, 12288, 120, 24, 8192, 24, 8193, 23,
    8192, 24, 4096, 120, 4097, 189, 1, 4100, 119, 4096, 120, 4102, 189, 20483,
    189, 1
},
// jungleShrine62
{
    3596, 4103, 189, 20483, 189, 1, 4096, 189, 0, 36864, 384, 8, 4096, 384,
    4099, 383, 4098, 158, 4097, 189, 0, 4098, 384, 4098, 383, 4098, 158, 4097,
    189, 0, 4097, 384, 0, 36864, 383, 32, 4096, 377, 0, 0, 4096, 377, 0, 18,
    4097, 158, 36864, 158, 32, 4097, 189, 0, 4096, 384, 4096, 383, 1, 4096,
    377, 18, 0, 4096, 377, 18, 18, 4097, 158, 0, 4097, 189, 0, 4097, 383, 1,
    4096, 377, 36, 0, 4096, 377, 36, 18, 4097, 158, 0, 4097, 189, 4098, 383, 3,
    4097, 158, 0, 4097, 189, 0, 4097, 383, 0, 4096, 93, 0, 324, 4096, 93, 0,
    342, 4096, 93, 0, 360, 4097, 158, 0, 4097, 189, 0, 4097, 383, 36864, 383,
    40, 0, 4096, 21, 360, 0, 4096, 21, 360, 18, 4097, 158, 0, 4097, 189, 0,
    36864, 383, 8, 4096, 383, 1, 4096, 21, 378, 0, 4096, 21, 378, 18, 4097,
    158, 36864, 158, 40, 4097, 189, 0, 4098, 383, 36864, 383, 40, 4097, 383,
    4098, 158, 4097, 189, 0, 36864, 383, 16, 4100, 383, 4098, 158, 4097, 189,
    2, 4096, 383, 1, 4108, 189, 20483, 189, 1
},
// jungleShrine63
{
    2570, 4100, 189, 20483, 189, 1, 4097, 189, 4103, 119, 4097, 189, 4096, 119,
    36864, 120, 32, 36864, 120, 16, 4097, 120, 36864, 120, 32, 36864, 120, 16,
    4096, 119, 4097, 189, 4096, 119, 36864, 120, 40, 0, 36864, 120, 16, 36864,
    120, 32, 0, 36864, 120, 24, 4096, 119, 4097, 189, 4096, 119, 4096, 120,
    36864, 120, 40, 4096, 21, 360, 0, 4096, 21, 360, 18, 12288, 19, 36, 36,
    107, 4096, 120, 4096, 119, 4097, 189, 4096, 119, 4096, 120, 36864, 120, 32,
    4096, 21, 378, 0, 4096, 21, 378, 18, 12288, 19, 18, 36, 107, 4096, 120,
    4096, 119, 4097, 189, 4096, 119, 36864, 120, 32, 0, 36864, 120, 24, 36864,
    120, 40, 0, 36864, 120, 16, 4096, 119, 4097, 189, 4096, 119, 36864, 120,
    40, 36864, 120, 24, 4097, 120, 36864, 120, 40, 36864, 120, 24, 4096, 119,
    4097, 189, 4103, 119, 4101, 189, 20483, 189, 1, 4096, 189
},
// jungleShrine64
{
    3085, 4105, 189, 20482, 189, 1, 4096, 189, 1, 20480, 158, 28, 53248, 158,
    28, 40, 5, 4096, 45, 4097, 189, 0, 36864, 45, 8, 20480, 158, 28, 61440,
    158, 10, 28, 16, 61440, 158, 10, 28, 40, 8196, 10, 4096, 45, 4097, 189, 0,
    36864, 45, 8, 20480, 158, 28, 24582, 313, 7168, 4096, 45, 4097, 189, 0,
    4096, 45, 20480, 158, 28, 8198, 10, 4096, 45, 4097, 189, 0, 4097, 45,
    12288, 592, 0, 0, 10, 12288, 592, 0, 18, 10, 12288, 592, 0, 36, 10, 8193,
    10, 12288, 21, 360, 0, 60, 12288, 21, 360, 18, 10, 4096, 45, 4097, 189, 0,
    4097, 45, 12288, 592, 18, 0, 10, 12288, 592, 18, 18, 10, 12288, 592, 18,
    36, 10, 8193, 60, 12288, 21, 378, 0, 10, 12288, 21, 378, 18, 10, 4096, 45,
    4097, 189, 0, 4096, 45, 20480, 158, 28, 8194, 10, 8192, 60, 8194, 10, 4096,
    45, 4097, 189, 0, 36864, 45, 8, 20480, 158, 28, 24582, 313, 7168, 4096, 45,
    4097, 189, 0, 36864, 45, 8, 20480, 158, 28, 61440, 158, 10, 28, 24, 61440,
    158, 60, 28, 32, 8193, 60, 8194, 10, 4096, 45, 4097, 189, 1, 20480, 158,
    28, 53248, 158, 28, 32, 5, 4096, 45, 4106, 189, 20482, 189, 1
},
// jungleShrine65
{
    3081, 4101, 189, 20482, 189, 1, 4096, 189, 3, 4096, 45, 8192, 10, 4096, 45,
    4097, 189, 2, 4096, 45, 8193, 10, 4096, 45, 4097, 189, 1, 4096, 45, 8194,
    10, 4096, 45, 4097, 189, 0, 4096, 45, 8193, 10, 12288, 19, 36, 36, 139,
    8192, 139, 4096, 45, 4097, 189, 0, 8192, 10, 12288, 21, 360, 0, 10, 12288,
    21, 360, 18, 10, 12288, 19, 0, 36, 10, 8192, 10, 4096, 45, 4097, 189, 0,
    8192, 10, 12288, 21, 378, 0, 10, 12288, 21, 378, 18, 10, 12288, 19, 0, 36,
    10, 8192, 10, 4096, 45, 4097, 189, 0, 4096, 45, 8193, 10, 12288, 19, 18,
    36, 139, 8192, 139, 4096, 45, 4097, 189, 1, 4096, 45, 8193, 10, 24576, 10,
    3840, 4096, 45, 4097, 189, 2, 4096, 45, 8193, 10, 4096, 45, 4097, 189, 3,
    4096, 45, 8192, 10, 4096, 45, 4102, 189, 20482, 189, 1
},
// jungleShrine66
{
    6927, 4105, 189, 20483, 189, 1, 4097, 189, 7, 4096, 383, 0, 4096, 384,
    4099, 189, 5, 4097, 384, 4097, 383, 4097, 384, 4098, 189, 4, 4097, 384,
    4098, 383, 4097, 384, 4098, 189, 5, 4096, 384, 4097, 383, 4098, 384, 4098,
    189, 3, 4101, 383, 4097, 384, 4098, 189, 0, 36864, 384, 8, 4098, 384, 4098,
    383, 4098, 384, 4099, 189, 1, 4096, 384, 4099, 383, 4096, 384, 36864, 384,
    32, 4097, 384, 4099, 189, 0, 4097, 384, 4100, 383, 4099, 384, 4096, 383,
    4097, 189, 0, 4097, 384, 4097, 383, 4097, 384, 4098, 383, 4096, 384, 4097,
    383, 4097, 189, 1, 4096, 384, 4097, 383, 4098, 384, 4100, 383, 4097, 189,
    2, 4098, 383, 4100, 384, 4096, 383, 4098, 189, 0, 4099, 383, 4099, 384,
    4098, 383, 4098, 189, 1, 4097, 383, 4096, 384, 36864, 384, 8, 4097, 384,
    4099, 383, 4098, 189, 0, 36864, 384, 8, 4098, 383, 4097, 384, 4097, 383,
    4096, 384, 4097, 383, 4098, 189, 0, 4096, 384, 4101, 383, 4097, 384, 4096,
    383, 4099, 189, 0, 4097, 384, 4099, 383, 4098, 384, 4097, 383, 4098, 189,
    1, 4096, 384, 4099, 383, 4096, 384, 12289, 384, 60, 4097, 383, 4098, 189,
    2, 4096, 384, 4099, 383, 12288, 21, 360, 0, 60, 12288, 21, 360, 18, 60,
    12288, 383, 60, 4097, 384, 4097, 189, 2, 4097, 384, 4098, 383, 12288, 21,
    378, 0, 60, 12288, 21, 378, 18, 60, 12288, 383, 60, 12288, 384, 60, 4096,
    384, 4097, 189, 3, 4098, 384, 4097, 383, 12288, 383, 60, 4098, 384, 4097,
    189, 5, 4099, 383, 4097, 384, 4098, 189, 4, 4100, 383, 4096, 384, 4099,
    189, 5, 4097, 384, 4097, 383, 4096, 384, 4099, 189, 5, 36864, 384, 8, 4099,
    384, 4099, 189, 7, 4097, 384, 4107, 189, 20484, 189, 1, 4097, 189
},
// jungleShrine67
{
    2570, 4100, 189, 20483, 189, 1, 4097, 189, 2, 4099, 189, 4096, 45, 4097,
    189, 1, 36864, 45, 24, 4100, 45, 4097, 189, 0, 4096, 45, 36864, 45, 32,
    8195, 23, 4096, 45, 4097, 189, 0, 20480, 387, 0, 0, 28, 8194, 23, 12288,
    21, 360, 0, 23, 12288, 21, 360, 18, 23, 4096, 45, 4097, 189, 0, 20480, 387,
    18, 0, 28, 8194, 23, 12288, 21, 378, 0, 23, 12288, 21, 378, 18, 23, 4096,
    45, 4097, 189, 0, 4096, 45, 36864, 45, 40, 8195, 23, 4096, 45, 4097, 189,
    1, 36864, 45, 16, 4100, 45, 4097, 189, 2, 4099, 189, 4096, 45, 4101, 189,
    20483, 189, 1, 4096, 189
},
// jungleShrine68
{
    3593, 4100, 189, 20483, 189, 1, 4096, 189, 4, 4096, 189, 4096, 120, 4097,
    189, 4, 4096, 119, 4096, 120, 4097, 189, 3, 4096, 45, 4096, 119, 4096, 120,
    4097, 189, 1, 20480, 33, 0, 242, 28, 12288, 19, 90, 414, 10, 4096, 45,
    4096, 119, 4096, 120, 4097, 189, 1, 8192, 23, 8192, 10, 4096, 45, 4096,
    119, 4096, 120, 4097, 189, 0, 8192, 24, 12288, 21, 360, 0, 23, 12288, 21,
    360, 18, 10, 4096, 45, 4096, 119, 4096, 120, 4097, 189, 0, 8192, 24, 12288,
    21, 378, 0, 23, 12288, 21, 378, 18, 10, 4096, 45, 4096, 119, 4096, 120,
    4097, 189, 1, 8192, 23, 8192, 10, 4096, 45, 4096, 119, 4096, 120, 4097,
    189, 1, 20480, 33, 0, 242, 28, 12288, 19, 90, 414, 10, 4096, 45, 4096, 119,
    4096, 120, 4097, 189, 3, 4096, 45, 4096, 119, 4096, 120, 4097, 189, 4,
    4096, 119, 4096, 120, 4097, 189, 4, 4096, 189, 4096, 120, 4101, 189, 20483,
    189, 1
},
// jungleShrine69
{
    3085, 4104, 189, 20483, 189, 1, 4096, 189, 4096, 59, 4097, 120, 0, 4098,
    119, 0, 4096, 59, 4097, 120, 4097, 189, 4096, 119, 8192, 24, 4096, 120,
    4096, 59, 0, 8192, 23, 4098, 119, 8192, 24, 4096, 120, 4097, 189, 4096,
    119, 8193, 24, 8192, 247, 8195, 23, 12288, 377, 0, 0, 24, 12288, 377, 0,
    18, 24, 4096, 120, 4097, 189, 4096, 119, 8198, 23, 12288, 377, 18, 0, 24,
    12288, 377, 18, 18, 24, 4096, 120, 4097, 189, 4096, 119, 8194, 23, 12288,
    21, 360, 0, 23, 12288, 21, 360, 18, 23, 28672, 19, 36, 594, 24, 28, 8192,
    23, 12288, 377, 36, 0, 24, 12288, 377, 36, 18, 24, 4096, 59, 4097, 189, 0,
    8194, 23, 12288, 21, 378, 0, 23, 12288, 21, 378, 18, 24, 28672, 19, 18,
    594, 24, 28, 8193, 23, 8192, 247, 4096, 59, 4097, 189, 0, 8195, 23, 8194,
    24, 8193, 23, 4096, 119, 4097, 189, 4096, 59, 8194, 24, 8192, 247, 8192,
    23, 8193, 24, 8193, 247, 4096, 119, 4097, 189, 4096, 120, 8192, 24, 4097,
    120, 4096, 119, 8192, 23, 36866, 59, 2048, 8192, 247, 4096, 119, 4097, 189,
    4098, 120, 0, 4097, 119, 2, 4097, 119, 4105, 189, 20483, 189, 1
},
// jungleShrine70
{
    3084, 4111, 189, 36864, 59, 24, 4097, 59, 36864, 59, 40, 4102, 189, 36864,
    120, 24, 4099, 120, 36864, 120, 40, 4100, 189, 36864, 120, 24, 4101, 119,
    36864, 120, 40, 4098, 189, 36864, 59, 24, 4096, 120, 4096, 119, 4099, 45,
    4096, 119, 4096, 120, 36864, 59, 40, 4097, 189, 4096, 59, 4096, 120, 4096,
    119, 4096, 45, 4096, 21, 360, 0, 4096, 21, 360, 18, 4096, 45, 4096, 119,
    4096, 120, 4096, 59, 4097, 189, 4096, 59, 4096, 120, 4096, 119, 4096, 45,
    4096, 21, 378, 0, 4096, 21, 378, 18, 4096, 45, 4096, 119, 4096, 120, 4096,
    59, 4097, 189, 36864, 59, 16, 4096, 120, 4096, 119, 4099, 45, 4096, 119,
    4096, 120, 36864, 59, 32, 4098, 189, 36864, 120, 16, 4101, 119, 36864, 120,
    32, 4100, 189, 36864, 120, 16, 4099, 120, 36864, 120, 32, 4102, 189, 36864,
    59, 16, 4097, 59, 36864, 59, 32, 4111, 189
},
// jungleShrine71
{
    4619, 4102, 189, 20483, 189, 1, 4096, 189, 7, 4098, 189, 7, 4096, 120,
    4097, 189, 6, 4097, 120, 4097, 189, 0, 36864, 59, 24, 4097, 120, 20480, 10,
    0, 648, 28, 20480, 10, 36, 666, 28, 20480, 10, 18, 684, 28, 4097, 120,
    4097, 189, 0, 4096, 59, 8192, 247, 12289, 51, 247, 8193, 247, 12288, 120,
    247, 4096, 120, 4097, 189, 0, 4096, 59, 12288, 51, 24, 8193, 247, 12288,
    51, 247, 12288, 51, 24, 12288, 59, 247, 4096, 120, 4097, 189, 0, 4096, 120,
    12289, 51, 24, 12289, 51, 247, 8192, 24, 12288, 120, 247, 4096, 120, 4097,
    189, 0, 4096, 120, 8192, 247, 8192, 24, 12288, 51, 247, 12288, 21, 360, 0,
    247, 12288, 21, 360, 18, 24, 4097, 120, 4097, 189, 0, 4096, 120, 8194, 24,
    12288, 21, 378, 0, 247, 12288, 21, 378, 18, 247, 4097, 120, 4097, 189, 0,
    4096, 120, 8192, 24, 8193, 247, 8192, 24, 8192, 247, 12288, 120, 247, 4096,
    120, 4097, 189, 0, 4096, 120, 12288, 51, 24, 12288, 51, 247, 8192, 247,
    12289, 51, 24, 12288, 120, 247, 4096, 59, 4097, 189, 0, 4096, 120, 8192,
    24, 12288, 51, 247, 8192, 247, 12288, 51, 247, 8192, 24, 12288, 120, 247,
    4096, 59, 4097, 189, 0, 36864, 120, 16, 4097, 120, 20480, 10, 0, 648, 28,
    20480, 10, 0, 666, 28, 20480, 10, 0, 684, 28, 4097, 120, 4097, 189, 6,
    4097, 120, 4097, 189, 7, 4096, 120, 4097, 189, 7, 4105, 189, 20482, 189, 1
},
// jungleShrine72
{
    4878, 4103, 189, 20483, 189, 1, 4098, 189, 5, 36864, 383, 24, 1, 4100, 189,
    2, 4100, 383, 0, 4100, 189, 1, 36864, 383, 8, 4096, 383, 8194, 60, 45056,
    383, 60, 32, 36864, 383, 24, 4100, 189, 0, 36864, 383, 8, 4096, 383, 12290,
    51, 60, 8192, 60, 8192, 67, 12288, 383, 60, 4097, 383, 36864, 383, 32,
    4097, 189, 0, 4097, 383, 8192, 60, 8194, 67, 12288, 21, 360, 0, 60, 12288,
    21, 360, 18, 60, 4096, 383, 36864, 383, 32, 4098, 189, 0, 36864, 383, 8,
    4096, 383, 12290, 51, 67, 8192, 67, 12288, 21, 378, 0, 60, 12288, 21, 378,
    18, 60, 4096, 158, 4099, 189, 4097, 383, 36864, 383, 32, 8194, 67, 8194,
    60, 4096, 383, 4099, 189, 0, 4096, 383, 12290, 51, 67, 12289, 51, 60, 8192,
    60, 45056, 383, 60, 24, 4096, 383, 4099, 189, 0, 4096, 383, 8194, 67, 8193,
    60, 45056, 383, 67, 24, 45056, 383, 67, 32, 4096, 383, 4099, 189, 0, 4096,
    383, 28676, 353, 60, 4, 28672, 353, 67, 4, 8192, 67, 4096, 383, 4099, 189,
    0, 36864, 383, 8, 4096, 383, 12288, 51, 67, 12288, 51, 60, 8192, 60, 8192,
    67, 12288, 86, 0, 0, 67, 12288, 86, 0, 18, 60, 4097, 383, 4098, 189, 1,
    4096, 383, 8192, 60, 8194, 67, 12288, 86, 18, 0, 67, 12288, 86, 18, 18, 60,
    4096, 383, 36864, 383, 32, 4098, 189, 0, 36864, 383, 8, 4096, 383, 12290,
    51, 60, 8192, 60, 12288, 86, 36, 0, 60, 12288, 86, 36, 18, 60, 4097, 383,
    4098, 189, 0, 4097, 383, 8194, 67, 8193, 60, 45056, 383, 60, 24, 4097, 383,
    4098, 189, 1, 36864, 383, 16, 4096, 383, 28672, 353, 60, 4, 28672, 353, 67,
    4, 28672, 353, 60, 4, 45056, 383, 60, 8, 4097, 383, 36864, 383, 32, 4098,
    189, 2, 36864, 383, 16, 4098, 383, 36864, 383, 32, 0, 4100, 189, 4, 4096,
    383, 1, 4107, 189, 20483, 189, 1, 4098, 189
},
// jungleShrine73
{
    2569, 4101, 189, 20482, 189, 1, 4096, 189, 4098, 158, 2, 4096, 158, 4097,
    189, 4096, 158, 12288, 21, 360, 0, 247, 12288, 21, 360, 18, 67, 12288, 19,
    36, 36, 67, 8192, 73, 8192, 247, 4096, 158, 4097, 189, 4096, 158, 12288,
    21, 378, 0, 67, 12288, 21, 378, 18, 247, 12288, 19, 18, 36, 247, 8193, 67,
    4096, 158, 4097, 189, 4096, 158, 8192, 67, 8192, 73, 8193, 247, 8192, 73,
    4096, 158, 4097, 189, 4096, 158, 8193, 67, 8192, 73, 12288, 86, 0, 0, 247,
    12288, 86, 0, 18, 247, 4096, 158, 4097, 189, 4096, 158, 8192, 247, 12288,
    4, 0, 66, 247, 8192, 67, 12288, 86, 18, 0, 247, 12288, 86, 18, 18, 247,
    4096, 158, 4097, 189, 4096, 158, 8193, 247, 8192, 67, 12288, 86, 36, 0,
    247, 12288, 86, 36, 18, 247, 4096, 158, 4097, 189, 4102, 158, 4099, 189,
    20484, 189, 1, 4096, 189
},
// jungleShrine74
{
    3595, 4102, 189, 20482, 189, 1, 4097, 189, 2, 8195, 67, 12288, 59, 247,
    4096, 59, 4097, 189, 2, 8193, 67, 8192, 247, 12289, 59, 247, 4096, 120,
    4097, 189, 1, 8193, 67, 8192, 247, 12288, 59, 247, 4096, 59, 12288, 59,
    247, 4096, 120, 4097, 189, 0, 8193, 67, 8193, 247, 8192, 24, 12288, 59, 24,
    12288, 59, 247, 4096, 120, 4097, 189, 0, 8192, 67, 8193, 247, 8192, 24,
    12289, 59, 24, 12288, 59, 247, 4096, 120, 4097, 189, 8192, 67, 12288, 59,
    67, 12288, 51, 247, 8193, 24, 4096, 59, 12288, 59, 24, 12288, 59, 247,
    4096, 120, 4097, 189, 8192, 67, 4096, 120, 8192, 247, 8192, 24, 12288, 51,
    24, 8193, 24, 12288, 59, 247, 4096, 120, 4097, 189, 0, 4096, 120, 8192, 24,
    12288, 51, 24, 8192, 247, 8192, 24, 12288, 51, 247, 12288, 59, 247, 4096,
    120, 4097, 189, 4096, 59, 4096, 120, 12288, 51, 24, 8193, 247, 12288, 51,
    24, 12288, 21, 360, 0, 67, 12288, 21, 360, 18, 24, 4096, 120, 4097, 189, 0,
    4096, 120, 8192, 24, 12288, 51, 24, 8192, 24, 12288, 51, 24, 12288, 21,
    378, 0, 67, 12288, 21, 378, 18, 24, 4096, 120, 4097, 189, 0, 36864, 120,
    16, 4099, 120, 12290, 120, 67, 4097, 189, 3, 4097, 189, 12288, 189, 67,
    4097, 59, 4102, 189, 20483, 189, 1, 4096, 189
},
// jungleShrine75
{
    2566, 4098, 189, 20481, 189, 1, 4097, 189, 4099, 120, 4097, 189, 4096, 120,
    12288, 21, 360, 0, 42, 12288, 21, 360, 18, 42, 4096, 120, 4097, 189, 4096,
    120, 12288, 21, 378, 0, 42, 12288, 21, 378, 18, 42, 4096, 120, 4097, 189,
    4096, 120, 12288, 21, 180, 0, 42, 12288, 21, 180, 18, 42, 4096, 120, 4097,
    189, 4096, 120, 12288, 21, 198, 0, 42, 12288, 21, 198, 18, 42, 4096, 120,
    4097, 189, 4096, 120, 12288, 287, 0, 0, 42, 12288, 287, 0, 18, 42, 4096,
    120, 4097, 189, 4096, 120, 12288, 287, 18, 0, 42, 12288, 287, 18, 18, 42,
    4096, 120, 4097, 189, 4099, 120, 4098, 189, 20482, 189, 1, 4096, 189
},
// jungleShrine76
{
    4103, 4099, 189, 20482, 189, 1, 4096, 189, 3, 4096, 59, 4097, 189, 0,
    45056, 19, 342, 36, 139, 24, 8193, 139, 4096, 59, 4097, 189, 0, 4096, 19,
    216, 36, 4096, 215, 702, 0, 4096, 215, 702, 18, 4096, 59, 4097, 189, 0,
    4096, 19, 0, 36, 4096, 215, 720, 0, 4096, 215, 720, 18, 4096, 59, 4097,
    189, 0, 4096, 19, 234, 36, 4096, 215, 738, 0, 4096, 215, 738, 18, 4096, 59,
    4097, 189, 0, 45056, 19, 180, 36, 139, 16, 12288, 96, 0, 0, 139, 12288, 96,
    0, 18, 139, 4096, 59, 4097, 189, 1, 4096, 96, 18, 0, 4096, 96, 18, 18,
    4096, 59, 4097, 189, 3, 4096, 59, 4097, 189, 1, 4096, 21, 360, 0, 4096, 21,
    360, 18, 4096, 59, 4097, 189, 1, 4096, 21, 378, 0, 4096, 21, 378, 18, 4096,
    59, 4097, 189, 3, 4096, 59, 4097, 189, 1, 4096, 648, 1404, 0, 4096, 648,
    1404, 18, 4096, 59, 4097, 189, 1, 4096, 648, 1422, 0, 4096, 648, 1422, 18,
    4096, 59, 4097, 189, 1, 4096, 648, 1440, 0, 4096, 648, 1440, 18, 4096, 59,
    4100, 189, 20482, 189, 1
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getShrine(int shrineId, const std::vector<bool> &framedTiles)
{
    return {shrineData[shrineId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/JungleShrines.h`
```
#ifndef JUNGLESHRINES_H
#define JUNGLESHRINES_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto shrines = std::views::iota(0, 76);

TileBuffer getShrine(int shrineId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // JUNGLESHRINES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Mushrooms.cpp`
```
#include "structures/data/Mushrooms.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> mushroomData{
// mushroom1
{
    6427, 4, 4099, 59, 20, 4102, 59, 18, 4103, 59, 18, 4103, 59, 17, 4104, 59,
    17, 4104, 59, 11, 4099, 59, 0, 4105, 59, 7, 4103, 59, 0, 4105, 59, 5, 4105,
    59, 0, 4106, 59, 2, 4107, 59, 0, 4121, 59, 0, 4141, 59, 7, 4112, 59, 9,
    4108, 59, 13, 4107, 59, 14, 4107, 59, 15, 4106, 59, 15, 4106, 59, 16, 4105,
    59, 16, 4106, 59, 16, 4105, 59, 17, 4104, 59, 18, 4104, 59, 18, 4103, 59,
    19, 4101, 59, 13
},
// mushroom2
{
    6169, 5, 4097, 59, 21, 4098, 59, 20, 4099, 59, 19, 4101, 59, 17, 4102, 59,
    17, 4102, 59, 16, 4103, 59, 16, 4103, 59, 16, 4103, 59, 16, 4103, 59, 14,
    4096, 59, 0, 4194, 59, 0, 4103, 59, 4, 4096, 59, 7, 4097, 59, 0, 4102, 59,
    17, 4102, 59, 18, 4101, 59, 18, 4101, 59, 18, 4101, 59, 18, 4101, 59, 19,
    4099, 59, 21, 4098, 59, 22, 4097, 59, 17
},
// mushroom3
{
    4127, 7, 4098, 59, 25, 4100, 59, 24, 4101, 59, 22, 4104, 59, 20, 4105, 59,
    20, 4105, 59, 19, 4106, 59, 19, 4124, 59, 0, 4125, 59, 0, 4126, 59, 0,
    4125, 59, 1, 4104, 59, 13, 4100, 59, 3, 4103, 59, 23, 4102, 59, 24, 4100,
    59, 27, 4097, 59, 21
},
// mushroom4
{
    3609, 7, 4099, 59, 17, 4102, 59, 15, 4104, 59, 13, 4106, 59, 13, 4106, 59,
    12, 4107, 59, 13, 4115, 59, 4, 4117, 59, 3, 4104, 59, 6, 4102, 59, 2, 4103,
    59, 9, 4099, 59, 3, 4102, 59, 11, 4097, 59, 4, 4100, 59, 13, 4096, 59, 5,
    4099, 59, 21, 4097, 59, 15
},
// mushroom5
{
    7195, 6, 4097, 59, 23, 4098, 59, 23, 4099, 59, 21, 4100, 59, 20, 4101, 59,
    20, 4102, 59, 18, 4103, 59, 18, 4103, 59, 17, 4104, 59, 17, 4104, 59, 16,
    4105, 59, 11, 4099, 59, 0, 4105, 59, 0, 4110, 59, 0, 4175, 59, 0, 4121, 59,
    0, 4105, 59, 4, 4105, 59, 1, 4105, 59, 12, 4097, 59, 2, 4104, 59, 17, 4104,
    59, 18, 4103, 59, 18, 4103, 59, 19, 4102, 59, 20, 4100, 59, 21, 4100, 59,
    22, 4099, 59, 23, 4098, 59, 24, 4096, 59, 17
},
// mushroom6
{
    3856, 14, 4096, 59, 13, 4097, 59, 12, 4098, 59, 11, 4099, 59, 9, 4099, 59,
    3, 4098, 59, 3, 4099, 59, 3, 4100, 59, 1, 4099, 59, 4, 4105, 59, 5, 4104,
    59, 5, 4103, 59, 7, 4103, 59, 7, 4103, 59, 8, 4103, 59, 8, 4102, 59, 9,
    4101, 59, 6
},
// mushroom7
{
    3089, 4, 4096, 59, 9, 4096, 59, 2, 4099, 59, 6, 4098, 59, 2, 4099, 59, 6,
    4098, 59, 1, 4101, 59, 3, 4099, 59, 2, 4107, 59, 3, 4106, 59, 4, 4104, 59,
    7, 4104, 59, 7, 4104, 59, 7, 4104, 59, 10, 4102, 59, 12, 4098, 59, 7
},
// mushroom8
{
    5141, 3, 4097, 59, 17, 4100, 59, 14, 4101, 59, 13, 4102, 59, 13, 4102, 59,
    9, 4106, 59, 5, 4101, 59, 0, 4103, 59, 3, 4103, 59, 0, 4152, 59, 5, 4107,
    59, 8, 4104, 59, 12, 4103, 59, 12, 4104, 59, 11, 4104, 59, 12, 4103, 59,
    12, 4103, 59, 13, 4103, 59, 14, 4101, 59, 15, 4099, 59, 10
},
// mushroom9
{
    4628, 3, 4098, 59, 15, 4099, 59, 14, 4100, 59, 14, 4100, 59, 13, 4101, 59,
    13, 4101, 59, 13, 4101, 59, 13, 4101, 59, 0, 4107, 59, 0, 4134, 59, 0,
    4101, 59, 0, 4099, 59, 3, 4099, 59, 0, 4101, 59, 13, 4101, 59, 14, 4099,
    59, 15, 4099, 59, 15, 4099, 59, 16, 4098, 59, 17, 4097, 59, 13
},
// mushroom10
{
    3352, 6, 4097, 59, 20, 4098, 59, 18, 4100, 59, 16, 4102, 59, 16, 4102, 59,
    15, 4103, 59, 15, 4117, 59, 0, 4119, 59, 0, 4118, 59, 0, 4103, 59, 8, 4101,
    59, 1, 4102, 59, 17, 4100, 59, 20, 4098, 59, 15
},
// mushroom11
{
    3091, 6, 4096, 59, 15, 4099, 59, 11, 4102, 59, 10, 4103, 59, 9, 4104, 59,
    9, 4109, 59, 4, 4113, 59, 1, 4103, 59, 4, 4100, 59, 2, 4100, 59, 8, 4097,
    59, 2, 4100, 59, 9, 4096, 59, 3, 4098, 59, 16, 4096, 59, 12
},
// mushroom12
{
    5397, 4, 4097, 59, 17, 4099, 59, 16, 4099, 59, 15, 4100, 59, 14, 4101, 59,
    14, 4101, 59, 13, 4102, 59, 13, 4102, 59, 9, 4098, 59, 0, 4178, 59, 0,
    4103, 59, 6, 4099, 59, 1, 4103, 59, 13, 4102, 59, 13, 4101, 59, 15, 4100,
    59, 15, 4100, 59, 16, 4099, 59, 17, 4098, 59, 18, 4096, 59, 13
},
// mushroom13
{
    2828, 10, 4096, 59, 8, 4098, 59, 7, 4098, 59, 1, 4097, 59, 3, 4098, 59, 2,
    4098, 59, 1, 4098, 59, 2, 4103, 59, 3, 4101, 59, 5, 4101, 59, 5, 4101, 59,
    6, 4101, 59, 6, 4100, 59, 4
},
// mushroom14
{
    2574, 12, 4096, 59, 2, 4097, 59, 6, 4097, 59, 1, 4099, 59, 4, 4097, 59, 2,
    4099, 59, 1, 4099, 59, 2, 4104, 59, 3, 4103, 59, 5, 4102, 59, 6, 4102, 59,
    8, 4101, 59, 9, 4098, 59, 6
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getMushroom(int mushroomId, const std::vector<bool> &framedTiles)
{
    return {mushroomData[mushroomId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Mushrooms.h`
```
#ifndef MUSHROOMS_H
#define MUSHROOMS_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto mushrooms = std::views::iota(0, 14);

TileBuffer getMushroom(int mushroomId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // MUSHROOMS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/RoomWindows.cpp`
```
#include "structures/data/RoomWindows.h"

#include "ids/WallID.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> windowData{
// window1
{
    1285, 36869, 189, 2048, 8194, 73, 36865, 189, 2048, 8194, 73, 36865, 189,
    2048, 8194, 73, 36869, 189, 2048
},
// window2
{
    1286, 0, 36864, 189, 2072, 36867, 189, 2048, 36864, 189, 2072, 45056, 189,
    73, 2080, 8194, 73, 36865, 189, 2048, 8195, 73, 36864, 189, 2048, 36864,
    189, 2064, 45056, 189, 73, 2088, 8194, 73, 36864, 189, 2048, 0, 36864, 189,
    2064, 36867, 189, 2048
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getWindow(
    Window windowId,
    int frameBlockId,
    int paneWallId,
    const std::vector<bool> &framedTiles)
{
    TileBuffer data{windowData[static_cast<int>(windowId)].data(), framedTiles};
    for (int i = 0; i < data.getWidth(); ++i) {
        for (int j = 0; j < data.getHeight(); ++j) {
            Tile &tile = data.getTile(i, j);
            if (tile.blockID == TileID::cloud) {
                tile.blockID = frameBlockId;
            }
            if (tile.wallID == WallID::Safe::cloud) {
                tile.wallID = paneWallId;
            }
        }
    }
    return data;
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/RoomWindows.h`
```
#ifndef ROOMWINDOWS_H
#define ROOMWINDOWS_H

#include "TileBuffer.h"

namespace Data
{

enum class Window { square = 0, tall };

TileBuffer getWindow(
    Window windowId,
    int frameBlockId,
    int paneWallId,
    const std::vector<bool> &framedTiles);

} // namespace Data

#endif // ROOMWINDOWS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Rooms.cpp`
```
#include "structures/data/Rooms.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> roomData{
// pyramidRoom1
{
    9246, 12297, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12310, 151, 34, 8192,
    235, 8192, 10, 8196, 34, 12310, 151, 34, 12288, 577, 235, 12288, 577, 10,
    12292, 577, 34, 12303, 151, 34, 12291, 53, 34, 45058, 151, 34, 1088, 8192,
    235, 8192, 10, 8196, 34, 12303, 151, 34, 12290, 53, 34, 45056, 53, 34, 64,
    45058, 151, 34, 1088, 40960, 235, 64, 40960, 10, 64, 40964, 34, 64, 45065,
    151, 34, 64, 12293, 151, 34, 12290, 53, 34, 45056, 53, 34, 64, 45058, 151,
    34, 1152, 8192, 235, 8192, 10, 8196, 34, 12296, 151, 34, 45056, 151, 34,
    64, 12293, 151, 34, 12290, 53, 34, 45056, 53, 34, 64, 45058, 151, 34, 1152,
    8192, 235, 8192, 10, 8196, 34, 12296, 151, 34, 45056, 151, 34, 64, 12293,
    151, 34, 12290, 53, 34, 45056, 53, 34, 192, 45058, 151, 34, 1152, 8192,
    235, 8192, 10, 8196, 34, 12296, 151, 34, 45056, 151, 34, 64, 12293, 151,
    34, 12290, 53, 34, 45056, 53, 34, 192, 45058, 151, 34, 1280, 8192, 235,
    8192, 10, 8196, 34, 12296, 151, 34, 45056, 151, 34, 64, 12293, 151, 34,
    12290, 53, 34, 45056, 53, 34, 192, 45058, 151, 34, 1280, 8192, 235, 8192,
    10, 8196, 34, 12296, 151, 34, 45056, 151, 34, 64, 12293, 151, 34, 12290,
    53, 34, 45056, 53, 34, 448, 45058, 151, 34, 1280, 8192, 235, 8192, 10,
    8196, 34, 12296, 151, 34, 45056, 151, 34, 64, 12293, 151, 34, 12290, 53,
    34, 45056, 53, 34, 448, 45058, 151, 34, 1536, 12288, 577, 235, 12288, 577,
    10, 12292, 577, 34, 12296, 151, 34, 45056, 151, 34, 64, 12293, 151, 34,
    12289, 53, 34, 45056, 53, 34, 64, 45056, 53, 34, 448, 45058, 151, 34, 1536,
    8192, 235, 8192, 10, 8196, 34, 12296, 151, 34, 45056, 151, 34, 64, 12293,
    151, 34, 12289, 53, 34, 45056, 53, 34, 64, 45056, 53, 34, 896, 45058, 151,
    34, 1536, 8192, 235, 8192, 10, 8196, 34, 12296, 151, 34, 45056, 151, 34,
    64, 12293, 151, 34, 12289, 53, 34, 45056, 53, 34, 64, 45056, 53, 34, 896,
    45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12296, 151, 34, 45056,
    151, 34, 64, 12293, 151, 34, 12289, 53, 34, 45056, 53, 34, 64, 45056, 53,
    34, 896, 45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12291, 151,
    34, 12288, 138, 0, 0, 34, 12288, 138, 0, 18, 34, 45056, 151, 34, 1088,
    8193, 34, 40960, 34, 64, 12293, 151, 34, 12289, 53, 34, 45056, 53, 34, 64,
    45056, 53, 34, 896, 45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34,
    12291, 151, 34, 12288, 138, 18, 0, 34, 12288, 138, 18, 18, 34, 45056, 151,
    34, 1088, 8193, 34, 40960, 34, 64, 12293, 151, 34, 12289, 53, 34, 45056,
    53, 34, 64, 45056, 53, 34, 896, 45058, 151, 34, 1088, 8192, 235, 8192, 10,
    8194, 34, 12288, 21, 36, 0, 34, 12288, 21, 36, 18, 34, 12292, 151, 34,
    45056, 423, 0, 36, 34, 4160, 45056, 151, 34, 64, 8193, 34, 45056, 135, 0,
    90, 34, 64, 12293, 151, 34, 12289, 53, 34, 45056, 53, 34, 64, 45056, 53,
    34, 896, 45058, 151, 34, 1088, 8192, 235, 8192, 10, 8194, 34, 12288, 21,
    54, 0, 34, 12288, 21, 54, 18, 34, 12295, 151, 34, 8193, 34, 12293, 151, 34,
    12289, 53, 34, 45056, 53, 34, 64, 45056, 53, 34, 896, 45058, 151, 34, 1088,
    8192, 235, 8192, 10, 8196, 34, 12295, 151, 34, 8193, 34, 12293, 151, 34,
    12289, 53, 34, 45056, 53, 34, 64, 45056, 53, 34, 896, 45058, 151, 34, 1088,
    8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 45057, 151, 34, 128, 40960,
    34, 128, 45056, 135, 0, 90, 34, 128, 12293, 151, 34, 12289, 53, 34, 45056,
    53, 34, 64, 45056, 53, 34, 896, 45058, 151, 34, 1088, 40960, 235, 64,
    40960, 10, 64, 40964, 34, 64, 45061, 151, 34, 64, 45056, 151, 34, 192,
    12288, 151, 34, 8193, 34, 12293, 151, 34, 12289, 53, 34, 45056, 53, 34, 64,
    45056, 53, 34, 896, 45058, 151, 34, 1536, 40960, 235, 512, 40960, 10, 512,
    40964, 34, 512, 45061, 151, 34, 512, 45056, 151, 34, 704, 12288, 151, 34,
    8193, 34, 12293, 151, 34, 12289, 53, 34, 45056, 53, 34, 64, 45056, 53, 34,
    448, 45058, 151, 34, 1536, 8192, 235, 8192, 10, 8196, 34, 12293, 151, 34,
    45056, 151, 34, 960, 45056, 151, 34, 256, 40960, 34, 256, 45056, 135, 0,
    90, 34, 256, 12293, 151, 34, 12290, 53, 34, 45056, 53, 34, 448, 45058, 151,
    34, 1536, 12288, 577, 235, 12288, 577, 10, 12292, 577, 34, 12293, 151, 34,
    45056, 151, 34, 960, 12288, 151, 34, 8193, 34, 12293, 151, 34, 12290, 53,
    34, 45056, 53, 34, 448, 45058, 151, 34, 1280, 40960, 235, 256, 40960, 10,
    256, 40964, 34, 256, 45061, 151, 34, 256, 45056, 151, 34, 960, 12288, 151,
    34, 8193, 34, 12293, 151, 34, 12290, 53, 34, 45056, 53, 34, 192, 45058,
    151, 34, 1280, 8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 45056, 151,
    34, 704, 12288, 151, 34, 8193, 34, 12293, 151, 34, 12290, 53, 34, 45056,
    53, 34, 192, 45058, 151, 34, 1280, 8192, 235, 8192, 10, 8196, 34, 12293,
    151, 34, 45056, 151, 34, 704, 45056, 151, 34, 512, 40960, 34, 512, 45056,
    135, 0, 90, 34, 512, 12293, 151, 34, 12290, 53, 34, 45056, 53, 34, 192,
    45058, 151, 34, 1152, 40960, 235, 128, 40960, 10, 128, 40964, 34, 128,
    45061, 151, 34, 128, 45056, 151, 34, 192, 12288, 151, 34, 8193, 34, 12293,
    151, 34, 12290, 53, 34, 45056, 53, 34, 64, 45058, 151, 34, 1152, 8192, 235,
    8192, 10, 8196, 34, 12293, 151, 34, 45056, 151, 34, 64, 12288, 151, 34,
    8193, 34, 12293, 151, 34, 12290, 53, 34, 45056, 53, 34, 64, 45058, 151, 34,
    1152, 8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 45056, 151, 34, 64,
    12288, 151, 34, 8193, 34, 12293, 151, 34, 12290, 53, 34, 45056, 53, 34, 64,
    45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 45057,
    151, 34, 64, 40960, 34, 64, 45056, 135, 0, 90, 34, 64, 12293, 151, 34,
    12291, 53, 34, 45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12310,
    151, 34, 12288, 577, 235, 12288, 577, 10, 12292, 577, 34, 12310, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 12310, 151, 34, 8192, 235, 8192, 10, 8196,
    34, 12300, 151, 34
},
// pyramidRoom2
{
    9239, 12290, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12303, 151, 34, 8192,
    235, 8192, 10, 8196, 34, 12303, 151, 34, 12288, 577, 235, 12288, 577, 10,
    12292, 577, 34, 12303, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12290, 151,
    34, 8196, 34, 12288, 484, 0, 0, 34, 12288, 484, 0, 18, 34, 12293, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 12290, 151, 34, 8196, 34, 12288, 484, 18, 0,
    34, 12288, 484, 18, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    12290, 151, 34, 8196, 34, 12288, 484, 0, 0, 34, 12288, 484, 0, 18, 34,
    12293, 151, 34, 8192, 235, 8192, 10, 8196, 34, 45058, 151, 34, 1088, 8196,
    34, 12288, 484, 18, 0, 34, 12288, 484, 18, 18, 34, 12293, 151, 34, 8192,
    235, 8192, 10, 8196, 34, 45058, 151, 34, 1088, 8196, 34, 12288, 484, 0, 0,
    34, 12288, 484, 0, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    45058, 151, 34, 1088, 8196, 34, 12288, 484, 18, 0, 34, 12288, 484, 18, 18,
    34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34, 45058, 151, 34, 1088,
    8196, 34, 12288, 484, 0, 0, 34, 12288, 484, 0, 18, 34, 12293, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 45058, 151, 34, 1088, 8196, 34, 12288, 484,
    18, 0, 34, 12288, 484, 18, 18, 34, 12293, 151, 34, 12288, 577, 235, 12288,
    577, 10, 12292, 577, 34, 45058, 151, 34, 1088, 8196, 34, 12288, 484, 0, 0,
    34, 12288, 484, 0, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8195, 34,
    61440, 135, 0, 126, 34, 3, 64, 45058, 151, 34, 1088, 8196, 34, 12288, 484,
    18, 0, 34, 12288, 484, 18, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 45058, 151, 34, 1088, 8196, 34, 12288, 484, 0, 0, 34, 12288, 484,
    0, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34, 45058, 151, 34,
    1088, 8196, 34, 12288, 484, 18, 0, 34, 12288, 484, 18, 18, 34, 12293, 151,
    34, 8192, 235, 8192, 10, 8196, 34, 45058, 151, 34, 1088, 8196, 34, 12288,
    484, 0, 0, 34, 12288, 484, 0, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 45058, 151, 34, 1088, 8196, 34, 12288, 484, 18, 0, 34, 12288,
    484, 18, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8194, 34, 12288, 21,
    36, 0, 34, 12288, 21, 36, 18, 34, 12288, 151, 34, 45057, 151, 34, 1088,
    8196, 34, 12288, 484, 0, 0, 34, 12288, 484, 0, 18, 34, 12293, 151, 34,
    8192, 235, 8192, 10, 8194, 34, 12288, 21, 54, 0, 34, 12288, 21, 54, 18, 34,
    12288, 151, 34, 45057, 151, 34, 1088, 8196, 34, 12288, 484, 18, 0, 34,
    12288, 484, 18, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    45058, 151, 34, 1088, 8196, 34, 12288, 484, 0, 0, 34, 12288, 484, 0, 18,
    34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34, 45058, 151, 34, 1088,
    8196, 34, 12288, 484, 18, 0, 34, 12288, 484, 18, 18, 34, 12293, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 45058, 151, 34, 1088, 8196, 34, 12288, 484,
    0, 0, 34, 12288, 484, 0, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8196,
    34, 45058, 151, 34, 1088, 8196, 34, 12288, 484, 18, 0, 34, 12288, 484, 18,
    18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8195, 34, 61440, 135, 0, 126,
    34, 3, 64, 45058, 151, 34, 1088, 8196, 34, 12288, 484, 0, 0, 34, 12288,
    484, 0, 18, 34, 12293, 151, 34, 12288, 577, 235, 12288, 577, 10, 12292,
    577, 34, 45058, 151, 34, 1088, 8196, 34, 12288, 484, 18, 0, 34, 12288, 484,
    18, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34, 45058, 151, 34,
    1088, 8196, 34, 12288, 484, 0, 0, 34, 12288, 484, 0, 18, 34, 12293, 151,
    34, 8192, 235, 8192, 10, 8196, 34, 45058, 151, 34, 1088, 8196, 34, 12288,
    484, 18, 0, 34, 12288, 484, 18, 18, 34, 12293, 151, 34, 8192, 235, 8192,
    10, 8196, 34, 45058, 151, 34, 1088, 8196, 34, 12288, 484, 0, 0, 34, 12288,
    484, 0, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34, 45058, 151,
    34, 1088, 8196, 34, 12288, 484, 18, 0, 34, 12288, 484, 18, 18, 34, 12293,
    151, 34, 8192, 235, 8192, 10, 8196, 34, 45058, 151, 34, 1088, 8196, 34,
    12288, 484, 0, 0, 34, 12288, 484, 0, 18, 34, 12293, 151, 34, 8192, 235,
    8192, 10, 8196, 34, 12290, 151, 34, 8196, 34, 12288, 484, 18, 0, 34, 12288,
    484, 18, 18, 34, 12293, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12290, 151,
    34, 8196, 34, 12288, 484, 0, 0, 34, 12288, 484, 0, 18, 34, 12293, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 12290, 151, 34, 8196, 34, 12288, 484, 18, 0,
    34, 12288, 484, 18, 18, 34, 12293, 151, 34, 12288, 577, 235, 12288, 577,
    10, 12292, 577, 34, 12303, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12303,
    151, 34, 8192, 235, 8192, 10, 8196, 34, 12300, 151, 34
},
// pyramidRoom3
{
    9238, 12299, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12302, 151, 34, 8192,
    235, 8192, 10, 8196, 34, 12302, 151, 34, 12288, 577, 235, 12288, 577, 10,
    12292, 577, 34, 12293, 151, 34, 12293, 53, 34, 45058, 151, 34, 1088, 8192,
    235, 8192, 10, 8196, 34, 12293, 151, 34, 12293, 53, 34, 45058, 151, 34,
    1088, 8192, 235, 8192, 10, 8196, 34, 12299, 151, 34, 45056, 151, 34, 64,
    12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299, 151, 34, 45056, 151,
    34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299, 151, 34,
    45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299,
    151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    12299, 151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 12299, 151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235,
    8192, 10, 8196, 34, 12299, 151, 34, 45056, 151, 34, 64, 12289, 151, 34,
    12288, 577, 235, 12288, 577, 10, 12292, 577, 34, 12299, 151, 34, 45056,
    151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299, 151, 34,
    45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299,
    151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    12299, 151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 12299, 151, 34, 45056, 151, 34, 64, 12288, 151, 34, 45056, 151,
    34, 64, 40960, 235, 64, 40960, 10, 64, 40963, 34, 64, 61440, 135, 0, 126,
    34, 3, 64, 12293, 151, 34, 12288, 664, 0, 0, 34, 12288, 664, 0, 18, 34,
    45062, 151, 34, 1088, 8192, 235, 8192, 10, 8194, 34, 12288, 21, 36, 0, 34,
    12288, 21, 36, 18, 34, 12293, 151, 34, 12288, 664, 18, 0, 34, 12288, 664,
    18, 18, 34, 45062, 151, 34, 1088, 8192, 235, 8192, 10, 8194, 34, 12288, 21,
    54, 0, 34, 12288, 21, 54, 18, 34, 12299, 151, 34, 45056, 151, 34, 64,
    12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299, 151, 34, 45056, 151,
    34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299, 151, 34,
    45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299,
    151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    12299, 151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 12299, 151, 34, 45056, 151, 34, 64, 12289, 151, 34, 12288, 577,
    235, 12288, 577, 10, 12292, 577, 34, 12299, 151, 34, 45056, 151, 34, 64,
    12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299, 151, 34, 45056, 151,
    34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299, 151, 34,
    45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12299,
    151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    12299, 151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 12299, 151, 34, 45056, 151, 34, 64, 12289, 151, 34, 8192, 235,
    8192, 10, 8196, 34, 12293, 151, 34, 12293, 53, 34, 45058, 151, 34, 1088,
    8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 12293, 53, 34, 45058, 151,
    34, 1088, 8192, 235, 8192, 10, 8196, 34, 12302, 151, 34, 12288, 577, 235,
    12288, 577, 10, 12292, 577, 34, 12302, 151, 34, 8192, 235, 8192, 10, 8196,
    34, 12302, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12290, 151, 34
},
// pyramidRoom4
{
    9233, 12294, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192,
    235, 8192, 10, 8196, 34, 12297, 151, 34, 12288, 577, 235, 12288, 577, 10,
    12292, 577, 34, 12297, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151,
    34, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 12297, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192, 235, 8192, 10, 8196,
    34, 12297, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192,
    235, 8192, 10, 8196, 34, 12297, 151, 34, 12288, 577, 235, 12288, 577, 10,
    12292, 577, 34, 12297, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151,
    34, 8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 61440, 137, 0, 54, 34,
    3, 64, 45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12296, 151, 34,
    45056, 151, 34, 64, 8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 61440,
    137, 0, 54, 34, 3, 64, 45058, 151, 34, 1088, 8192, 235, 8192, 10, 8195, 34,
    61440, 135, 0, 126, 34, 3, 64, 12296, 151, 34, 45056, 151, 34, 64, 8192,
    235, 8192, 10, 8194, 34, 12288, 21, 36, 0, 34, 45056, 21, 36, 18, 34, 64,
    12296, 151, 34, 45056, 151, 34, 64, 8192, 235, 8192, 10, 8194, 34, 12288,
    21, 54, 0, 34, 45056, 21, 54, 18, 34, 64, 12293, 151, 34, 61440, 137, 0,
    54, 34, 3, 64, 45058, 151, 34, 1088, 40960, 235, 64, 40960, 10, 64, 40963,
    34, 64, 61440, 135, 0, 126, 34, 3, 64, 12296, 151, 34, 45056, 151, 34, 64,
    8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 61440, 137, 18, 54, 34, 3,
    64, 45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192, 235, 8192, 10, 8196,
    34, 12297, 151, 34, 12288, 577, 235, 12288, 577, 10, 12292, 577, 34, 12297,
    151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192, 235, 8192,
    10, 8196, 34, 12297, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151,
    34, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 12297, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192, 235, 8192, 10, 8196,
    34, 12297, 151, 34, 12288, 577, 235, 12288, 577, 10, 12292, 577, 34, 12297,
    151, 34, 8192, 235, 8192, 10, 8196, 34, 12297, 151, 34, 8192, 235, 8192,
    10, 8196, 34, 12290, 151, 34
},
// pyramidRoom5
{
    9237, 12298, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12301, 151, 34, 8192,
    235, 8192, 10, 8196, 34, 12301, 151, 34, 12288, 577, 235, 12288, 577, 10,
    12292, 577, 34, 12301, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12301, 151,
    34, 8192, 235, 8192, 10, 8196, 34, 12301, 151, 34, 8192, 235, 8192, 10,
    8196, 34, 12301, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12301, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 12292, 53, 34, 45058, 151,
    34, 1088, 8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 12292, 53, 34,
    45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12296, 151, 34, 12288,
    138, 0, 0, 34, 12288, 138, 0, 18, 34, 45058, 151, 34, 1088, 40960, 235, 64,
    40960, 10, 64, 40963, 34, 64, 61440, 135, 0, 126, 34, 3, 64, 12296, 151,
    34, 12288, 138, 18, 0, 34, 12288, 138, 18, 18, 34, 45058, 151, 34, 1088,
    12288, 577, 235, 12288, 577, 10, 12292, 577, 34, 12301, 151, 34, 8192, 235,
    8192, 10, 8196, 34, 12301, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12301,
    151, 34, 8192, 235, 8192, 10, 8196, 34, 12301, 151, 34, 8192, 235, 8192,
    10, 8196, 34, 12301, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12301, 151,
    34, 8192, 235, 8192, 10, 8194, 34, 12288, 21, 36, 0, 34, 12288, 21, 36, 18,
    34, 12301, 151, 34, 8192, 235, 8192, 10, 8194, 34, 12288, 21, 54, 0, 34,
    12288, 21, 54, 18, 34, 12301, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    12301, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12301, 151, 34, 8192, 235,
    8192, 10, 8196, 34, 12301, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12301,
    151, 34, 8192, 235, 8192, 10, 8196, 34, 12296, 151, 34, 12288, 138, 0, 0,
    34, 12288, 138, 0, 18, 34, 45058, 151, 34, 1088, 12288, 577, 235, 12288,
    577, 10, 12292, 577, 34, 12296, 151, 34, 12288, 138, 18, 0, 34, 12288, 138,
    18, 18, 34, 45058, 151, 34, 1088, 40960, 235, 64, 40960, 10, 64, 40963, 34,
    64, 61440, 135, 0, 126, 34, 3, 64, 12293, 151, 34, 12292, 53, 34, 45058,
    151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12293, 151, 34, 12292, 53,
    34, 45058, 151, 34, 1088, 8192, 235, 8192, 10, 8196, 34, 12301, 151, 34,
    8192, 235, 8192, 10, 8196, 34, 12301, 151, 34, 8192, 235, 8192, 10, 8196,
    34, 12301, 151, 34, 8192, 235, 8192, 10, 8196, 34, 12301, 151, 34, 8192,
    235, 8192, 10, 8196, 34, 12301, 151, 34, 8192, 235, 8192, 10, 8196, 34,
    12301, 151, 34, 12288, 577, 235, 12288, 577, 10, 12292, 577, 34, 12301,
    151, 34, 8192, 235, 8192, 10, 8196, 34, 12301, 151, 34, 8192, 235, 8192,
    10, 8196, 34, 12290, 151, 34
},
// treeRoom1
{
    4622, 12289, 189, 244, 12289, 191, 244, 12288, 189, 244, 12291, 191, 244,
    12288, 189, 244, 12288, 191, 244, 12291, 189, 244, 12293, 191, 244, 45056,
    192, 244, 32, 12290, 191, 244, 12291, 189, 244, 12289, 191, 244, 45056,
    191, 244, 32, 8196, 244, 12290, 191, 244, 12290, 189, 244, 12290, 191, 244,
    8195, 244, 45056, 191, 244, 24, 12289, 191, 244, 12290, 189, 244, 12291,
    191, 244, 45056, 191, 244, 40, 8193, 244, 12288, 51, 244, 12289, 191, 244,
    12291, 189, 244, 12290, 191, 244, 8192, 244, 12288, 191, 244, 8192, 244,
    12288, 304, 0, 0, 244, 12288, 304, 0, 18, 244, 12288, 304, 0, 36, 244,
    12289, 191, 244, 12291, 189, 244, 12288, 191, 244, 45056, 191, 244, 32,
    8192, 244, 12288, 191, 244, 8192, 244, 12288, 304, 18, 0, 244, 12288, 304,
    18, 18, 244, 12288, 304, 18, 36, 244, 12289, 191, 244, 12291, 189, 244,
    12288, 191, 244, 12288, 192, 244, 12288, 21, 432, 0, 244, 12288, 21, 432,
    18, 244, 12288, 19, 36, 414, 244, 12288, 304, 36, 0, 244, 12288, 304, 36,
    18, 244, 12288, 304, 36, 36, 244, 12289, 191, 244, 12291, 189, 244, 12289,
    191, 244, 12288, 21, 450, 0, 244, 12288, 21, 450, 18, 244, 12288, 19, 0,
    414, 244, 8193, 244, 45056, 192, 244, 8, 12291, 191, 244, 12289, 189, 244,
    12289, 191, 244, 8192, 244, 45056, 19, 144, 414, 244, 24, 8196, 244, 12288,
    191, 244, 12288, 189, 244, 12289, 191, 244, 12288, 189, 244, 12288, 191,
    244, 8192, 244, 45056, 191, 244, 24, 12288, 191, 244, 8195, 244, 45056,
    191, 244, 8, 12288, 191, 244, 12288, 189, 244, 12288, 191, 244, 12289, 189,
    244, 12290, 191, 244, 45056, 191, 244, 32, 8195, 244, 45056, 191, 244, 8,
    12288, 191, 244, 12291, 189, 244, 12290, 191, 244, 8196, 244, 12288, 51,
    244, 12288, 191, 244, 12292, 189, 244, 12288, 191, 244, 12288, 51, 244,
    8194, 244, 12288, 89, 1512, 0, 244, 12288, 89, 1512, 18, 244, 12289, 191,
    244, 12291, 189, 244, 12289, 191, 244, 8195, 244, 12288, 89, 1530, 0, 244,
    12288, 89, 1530, 18, 244, 12292, 191, 244, 12288, 189, 244, 12290, 191,
    244, 45056, 192, 244, 40, 12288, 191, 244, 8192, 244, 12288, 89, 1548, 0,
    244, 12288, 89, 1548, 18, 244, 12290, 191, 244, 12290, 189, 244, 12292,
    191, 244, 12288, 10, 18, 378, 244, 12288, 10, 36, 396, 244, 12288, 10, 0,
    414, 244, 12289, 191, 244, 12293, 189, 244, 12290, 191, 244, 12288, 51,
    244, 8193, 244, 12288, 191, 244, 12291, 189, 244
},
// treeRoom2
{
    4109, 12288, 189, 244, 12288, 191, 244, 12288, 189, 244, 12290, 191, 244,
    12288, 10, 36, 378, 244, 12288, 10, 36, 396, 244, 12288, 10, 0, 414, 244,
    12288, 191, 244, 12291, 189, 244, 12291, 191, 244, 12288, 51, 244, 8193,
    244, 12288, 51, 244, 12290, 191, 244, 12288, 189, 244, 12290, 191, 244,
    12288, 192, 244, 8196, 244, 12288, 191, 244, 12288, 192, 244, 12291, 191,
    244, 12288, 192, 244, 8195, 244, 12288, 21, 432, 0, 244, 12288, 21, 432,
    18, 244, 12293, 191, 244, 8196, 244, 12288, 21, 450, 0, 244, 12288, 21,
    450, 18, 244, 12288, 191, 244, 12288, 192, 244, 12288, 191, 244, 12288,
    189, 244, 12289, 191, 244, 45056, 191, 244, 40, 12288, 34, 54, 972, 244,
    12288, 34, 54, 990, 244, 12288, 34, 54, 1008, 244, 8194, 244, 45056, 191,
    244, 8, 12289, 191, 244, 12288, 189, 244, 12290, 191, 244, 12288, 34, 72,
    972, 244, 12288, 34, 72, 990, 244, 12288, 34, 72, 1008, 244, 8194, 244,
    45056, 191, 244, 8, 12289, 191, 244, 12288, 189, 244, 12289, 191, 244,
    12288, 51, 244, 12288, 34, 90, 972, 244, 12288, 34, 90, 990, 244, 12288,
    34, 90, 1008, 244, 8194, 244, 12289, 191, 244, 12288, 192, 244, 12288, 189,
    244, 12289, 191, 244, 45056, 192, 244, 40, 8197, 244, 12288, 191, 244,
    12288, 192, 244, 12288, 191, 244, 12288, 189, 244, 12290, 191, 244, 8195,
    244, 12288, 87, 270, 0, 244, 12288, 87, 270, 18, 244, 12290, 191, 244,
    12289, 189, 244, 12290, 191, 244, 8194, 244, 12288, 87, 288, 0, 244, 12288,
    87, 288, 18, 244, 12290, 191, 244, 12288, 189, 244, 12290, 191, 244, 45056,
    192, 244, 32, 8194, 244, 12288, 87, 306, 0, 244, 12288, 87, 306, 18, 244,
    12288, 191, 244, 12288, 192, 244, 12288, 191, 244, 12288, 189, 244, 12292,
    191, 244, 8195, 244, 45056, 191, 244, 16, 12288, 191, 244, 12290, 189, 244,
    12291, 191, 244, 12288, 51, 244, 8194, 244, 45056, 191, 244, 24, 12288,
    191, 244, 12291, 189, 244, 12292, 191, 244, 12288, 192, 244, 12289, 191,
    244, 12292, 189, 244, 12290, 191, 244, 12288, 192, 244, 12291, 191, 244,
    12290, 189, 244
},
// treeRoom3
{
    2569, 12289, 189, 244, 12289, 191, 244, 12288, 189, 244, 8194, 244, 12293,
    191, 244, 12288, 10, 36, 378, 244, 12288, 10, 36, 396, 244, 12288, 10, 18,
    414, 244, 12288, 191, 244, 12288, 189, 244, 12288, 191, 244, 45056, 192,
    244, 32, 8192, 244, 12289, 51, 244, 45056, 191, 244, 8, 12288, 191, 244,
    12289, 189, 244, 12288, 191, 244, 45056, 191, 244, 40, 8193, 244, 12289,
    51, 244, 12290, 189, 244, 12289, 191, 244, 45056, 191, 244, 32, 12288, 21,
    432, 0, 244, 12288, 21, 432, 18, 244, 12288, 191, 244, 12289, 189, 244,
    12290, 191, 244, 8192, 244, 12288, 21, 450, 0, 244, 12288, 21, 450, 18,
    244, 12289, 191, 244, 12289, 189, 244, 8192, 244, 12290, 191, 244, 45056,
    191, 244, 40, 8192, 244, 12289, 191, 244, 12289, 189, 244, 12288, 191, 244,
    12288, 189, 244, 8192, 244, 12289, 191, 244, 12288, 189, 244, 12291, 191,
    244, 12289, 189, 244, 12288, 191, 244, 12290, 189, 244, 12288, 191, 244,
    12291, 189, 244, 12288, 191, 244, 12290, 189, 244
},
// treeRoom4
{
    3848, 12293, 191, 244, 12289, 189, 244, 12297, 191, 244, 12288, 51, 244,
    12288, 191, 244, 45056, 191, 244, 32, 12291, 191, 244, 8195, 244, 12289,
    191, 244, 12288, 189, 244, 12288, 191, 244, 8196, 244, 12290, 191, 244,
    12288, 51, 244, 8195, 244, 45056, 192, 244, 8, 12290, 191, 244, 45056, 191,
    244, 40, 8194, 244, 45056, 192, 244, 8, 12290, 191, 244, 8192, 244, 12288,
    93, 18, 702, 244, 12288, 93, 18, 720, 244, 12288, 93, 18, 738, 244, 12290,
    191, 244, 8196, 244, 45056, 192, 244, 24, 12291, 191, 244, 8194, 244,
    12291, 191, 244, 8193, 244, 12288, 21, 432, 0, 244, 12288, 21, 432, 18,
    244, 12288, 191, 244, 12288, 189, 244, 12288, 191, 244, 12288, 192, 244,
    8193, 244, 12288, 21, 450, 0, 244, 12288, 21, 450, 18, 244, 12291, 191,
    244, 8195, 244, 12288, 19, 54, 414, 244, 12289, 191, 244, 12288, 192, 244,
    8195, 244, 12288, 19, 72, 414, 244, 12291, 191, 244, 12288, 10, 0, 378,
    244, 12288, 10, 36, 396, 244, 12288, 10, 36, 414, 244, 12289, 191, 244
},
// treeRoom5
{
    4874, 12288, 189, 244, 12290, 191, 244, 12288, 10, 0, 378, 244, 12288, 10,
    0, 396, 244, 12288, 10, 18, 414, 244, 12289, 191, 244, 12289, 189, 244,
    12289, 191, 244, 45056, 191, 244, 32, 8194, 244, 12290, 191, 244, 12288,
    189, 244, 12288, 191, 244, 12288, 51, 244, 8196, 244, 12289, 191, 244,
    12288, 189, 244, 12288, 191, 244, 8197, 244, 45056, 192, 244, 8, 12288,
    191, 244, 12288, 189, 244, 12288, 191, 244, 45056, 192, 244, 40, 8193, 244,
    12288, 304, 0, 0, 244, 12288, 304, 0, 18, 244, 12288, 304, 0, 36, 244,
    12289, 191, 244, 12288, 189, 244, 12288, 191, 244, 12288, 192, 244, 8193,
    244, 12288, 304, 18, 0, 244, 12288, 304, 18, 18, 244, 12288, 304, 18, 36,
    244, 12291, 191, 244, 8194, 244, 12288, 304, 36, 0, 244, 12288, 304, 36,
    18, 244, 12288, 304, 36, 36, 244, 12291, 191, 244, 12288, 51, 244, 8194,
    244, 12288, 21, 432, 0, 244, 12288, 21, 432, 18, 244, 12289, 191, 244,
    12288, 189, 244, 12290, 191, 244, 8193, 244, 12288, 21, 450, 0, 244, 12288,
    21, 450, 18, 244, 12288, 191, 244, 12289, 189, 244, 12288, 191, 244, 8192,
    244, 12289, 191, 244, 8194, 244, 12289, 191, 244, 12288, 189, 244, 12288,
    191, 244, 8192, 244, 45056, 192, 244, 8, 12288, 191, 244, 8194, 244, 45056,
    19, 180, 414, 244, 16, 12288, 191, 244, 12288, 189, 244, 12288, 191, 244,
    8193, 244, 12288, 191, 244, 8195, 244, 12288, 191, 244, 12288, 189, 244,
    12290, 191, 244, 45056, 191, 244, 32, 8193, 244, 12288, 79, 0, 684, 244,
    12288, 79, 0, 702, 244, 12288, 191, 244, 12288, 189, 244, 12289, 191, 244,
    45056, 191, 244, 40, 8194, 244, 12288, 79, 18, 684, 244, 12288, 79, 18,
    702, 244, 12288, 191, 244, 12288, 189, 244, 12288, 191, 244, 12288, 51,
    244, 12288, 191, 244, 8194, 244, 12288, 79, 36, 684, 244, 12288, 79, 36,
    702, 244, 12288, 191, 244, 12288, 189, 244, 12288, 191, 244, 8193, 244,
    12289, 51, 244, 8192, 244, 12288, 79, 54, 684, 244, 12288, 79, 54, 702,
    244, 12288, 191, 244, 12288, 189, 244, 12291, 191, 244, 12288, 192, 244,
    8192, 244, 12290, 191, 244, 12288, 189, 244, 12294, 191, 244, 12294, 189,
    244, 12288, 191, 244, 12291, 189, 244
},
// treeRoom6
{
    3596, 12290, 189, 244, 12294, 191, 244, 12291, 189, 244, 12288, 192, 244,
    12289, 191, 244, 12288, 21, 432, 0, 244, 12288, 21, 432, 18, 244, 12291,
    191, 244, 12289, 189, 244, 12289, 192, 244, 12288, 191, 244, 12288, 192,
    244, 12288, 21, 450, 0, 244, 12288, 21, 450, 18, 244, 12288, 19, 108, 414,
    244, 45056, 192, 244, 8, 12289, 191, 244, 12289, 189, 244, 12290, 191, 244,
    8196, 244, 12293, 191, 244, 12288, 42, 18, 792, 244, 12288, 42, 18, 810,
    244, 8194, 244, 12288, 15, 18, 200, 244, 12288, 15, 18, 218, 244, 12288,
    191, 244, 12288, 192, 244, 12288, 191, 244, 12288, 192, 244, 8196, 244,
    12288, 304, 0, 0, 244, 12288, 304, 0, 18, 244, 12288, 304, 0, 36, 244,
    12288, 191, 244, 12288, 192, 244, 12288, 191, 244, 12288, 192, 244, 8196,
    244, 12288, 304, 18, 0, 244, 12288, 304, 18, 18, 244, 12288, 304, 18, 36,
    244, 12291, 191, 244, 8196, 244, 12288, 304, 36, 0, 244, 12288, 304, 36,
    18, 244, 12288, 304, 36, 36, 244, 12290, 191, 244, 45056, 191, 244, 32,
    8198, 244, 12288, 51, 244, 12289, 191, 244, 12288, 189, 244, 12289, 191,
    244, 12288, 42, 18, 792, 244, 12288, 42, 18, 810, 244, 8195, 244, 45056,
    19, 144, 414, 244, 24, 12289, 191, 244, 12288, 189, 244, 12290, 191, 244,
    8195, 244, 45056, 19, 144, 414, 244, 24, 12288, 192, 244, 12289, 191, 244,
    12289, 189, 244, 12289, 191, 244, 45056, 191, 244, 40, 8194, 244, 12290,
    191, 244, 12290, 189, 244, 12289, 192, 244, 12288, 191, 244, 8194, 244,
    12289, 191, 244, 12292, 189, 244, 12288, 192, 244, 12288, 191, 244, 12288,
    10, 0, 378, 244, 12288, 10, 36, 396, 244, 12288, 10, 18, 414, 244, 12288,
    191, 244, 12290, 189, 244
},
// treeRoom7
{
    3852, 12291, 189, 244, 12288, 191, 244, 8194, 244, 12288, 191, 244, 12292,
    189, 244, 12290, 191, 244, 12288, 10, 36, 378, 244, 12288, 10, 18, 396,
    244, 12288, 10, 0, 414, 244, 12289, 191, 244, 12290, 189, 244, 12289, 191,
    244, 12288, 192, 244, 8196, 244, 12289, 191, 244, 12289, 189, 244, 12290,
    191, 244, 12288, 51, 244, 8194, 244, 45056, 192, 244, 8, 12289, 191, 244,
    12289, 189, 244, 12288, 191, 244, 12288, 192, 244, 12289, 191, 244, 8194,
    244, 12290, 191, 244, 12289, 189, 244, 12288, 191, 244, 8197, 244, 12292,
    191, 244, 8197, 244, 12288, 101, 972, 0, 244, 12288, 101, 972, 18, 244,
    12288, 101, 972, 36, 244, 12288, 101, 972, 54, 244, 12289, 191, 244, 45056,
    191, 244, 40, 8196, 244, 12288, 101, 990, 0, 244, 12288, 101, 990, 18, 244,
    12288, 101, 990, 36, 244, 12288, 101, 990, 54, 244, 12290, 191, 244, 8196,
    244, 12288, 101, 1008, 0, 244, 12288, 101, 1008, 18, 244, 12288, 101, 1008,
    36, 244, 12288, 101, 1008, 54, 244, 12289, 191, 244, 12288, 192, 244, 8196,
    244, 12288, 21, 432, 0, 244, 12288, 21, 432, 18, 244, 12288, 191, 244,
    8192, 244, 12293, 191, 244, 8193, 244, 12288, 21, 450, 0, 244, 12288, 21,
    450, 18, 244, 12288, 191, 244, 12288, 192, 244, 12290, 191, 244, 12288, 51,
    244, 8192, 244, 45056, 191, 244, 16, 12288, 191, 244, 45056, 191, 244, 40,
    8193, 244, 45056, 191, 244, 16, 12289, 191, 244, 12288, 189, 244, 12288,
    191, 244, 12288, 192, 244, 8194, 244, 12288, 191, 244, 8194, 244, 12289,
    191, 244, 12288, 189, 244, 12290, 191, 244, 12288, 51, 244, 12289, 191,
    244, 8192, 244, 12290, 191, 244, 12291, 189, 244, 12293, 191, 244, 12290,
    189, 244
},
// treeRoom8
{
    4360, 12294, 191, 244, 12288, 189, 244, 12288, 191, 244, 12288, 192, 244,
    12288, 191, 244, 8192, 244, 12288, 51, 244, 12291, 191, 244, 12288, 192,
    244, 8194, 244, 12288, 191, 244, 12288, 192, 244, 12291, 191, 244, 8193,
    244, 45056, 191, 244, 8, 12288, 192, 244, 12290, 191, 244, 12288, 51, 244,
    8194, 244, 12288, 192, 244, 12289, 191, 244, 12288, 192, 244, 8196, 244,
    12290, 191, 244, 12288, 192, 244, 8195, 244, 12290, 191, 244, 45056, 191,
    244, 32, 8194, 244, 45056, 191, 244, 8, 12289, 191, 244, 12288, 192, 244,
    8195, 244, 45056, 191, 244, 8, 12289, 191, 244, 12288, 192, 244, 8194, 244,
    12288, 21, 432, 0, 244, 12288, 21, 432, 18, 244, 12290, 191, 244, 8194,
    244, 12288, 21, 450, 0, 244, 12288, 21, 450, 18, 244, 12288, 191, 244,
    12288, 189, 244, 12288, 191, 244, 12288, 192, 244, 8194, 244, 12289, 191,
    244, 12288, 189, 244, 12288, 191, 244, 12288, 192, 244, 8194, 244, 12291,
    191, 244, 12288, 51, 244, 8194, 244, 12288, 51, 244, 12289, 191, 244,
    12288, 192, 244, 12288, 191, 244, 8194, 244, 45056, 191, 244, 8, 12291,
    191, 244, 12288, 51, 244, 8193, 244, 12292, 191, 244, 12288, 10, 18, 378,
    244, 12288, 10, 0, 396, 244, 12288, 10, 0, 414, 244, 12289, 191, 244
},
// treeRoom9
{
    4108, 12289, 189, 244, 12288, 192, 244, 12288, 191, 244, 8195, 244, 12288,
    192, 244, 12288, 191, 244, 12291, 189, 244, 12289, 191, 244, 8194, 244,
    12288, 51, 244, 12288, 191, 244, 12291, 189, 244, 12290, 191, 244, 12288,
    10, 36, 378, 244, 12288, 10, 18, 396, 244, 12288, 10, 0, 414, 244, 12289,
    191, 244, 12288, 189, 244, 12288, 192, 244, 12289, 189, 244, 12289, 191,
    244, 45056, 191, 244, 32, 8194, 244, 12291, 191, 244, 12288, 189, 244,
    12290, 191, 244, 8195, 244, 45056, 19, 180, 414, 244, 16, 12288, 51, 244,
    45056, 191, 244, 8, 12289, 189, 244, 12288, 191, 244, 12288, 192, 244,
    12288, 191, 244, 12288, 51, 244, 8195, 244, 45056, 19, 180, 414, 244, 16,
    12289, 191, 244, 12288, 189, 244, 12290, 191, 244, 12288, 192, 244, 8196,
    244, 12288, 192, 244, 12288, 191, 244, 12288, 189, 244, 12289, 191, 244,
    45056, 191, 244, 32, 8196, 244, 45056, 191, 244, 8, 12291, 191, 244, 12288,
    192, 244, 45056, 191, 244, 40, 8195, 244, 12288, 21, 432, 0, 244, 12288,
    21, 432, 18, 244, 12289, 191, 244, 12288, 189, 244, 12290, 191, 244, 12288,
    192, 244, 8194, 244, 12288, 21, 450, 0, 244, 12288, 21, 450, 18, 244,
    12288, 191, 244, 12288, 51, 244, 12288, 191, 244, 12288, 189, 244, 12289,
    191, 244, 12288, 192, 244, 12288, 104, 468, 0, 244, 12288, 104, 468, 18,
    244, 12288, 104, 468, 36, 244, 12288, 104, 468, 54, 244, 12288, 104, 468,
    72, 244, 12291, 191, 244, 12288, 192, 244, 8193, 244, 12288, 104, 486, 0,
    244, 12288, 104, 486, 18, 244, 12288, 104, 486, 36, 244, 12288, 104, 486,
    54, 244, 12288, 104, 486, 72, 244, 12288, 192, 244, 12288, 191, 244, 12288,
    189, 244, 12290, 191, 244, 45056, 191, 244, 40, 8195, 244, 45056, 192, 244,
    8, 12288, 192, 244, 12288, 191, 244, 12290, 189, 244, 12290, 191, 244,
    12288, 51, 244, 8192, 244, 12291, 191, 244, 12289, 189, 244, 12290, 191,
    244, 8192, 244, 12293, 191, 244, 12291, 189, 244, 12289, 191, 244, 12288,
    189, 244, 12289, 191, 244, 12288, 192, 244, 12288, 191, 244, 12289, 189,
    244
},
// treeRoom10
{
    2569, 12289, 189, 244, 12288, 191, 244, 12289, 189, 244, 12288, 191, 244,
    12291, 189, 244, 12289, 191, 244, 12288, 192, 244, 12288, 189, 244, 12288,
    192, 244, 12288, 191, 244, 12290, 189, 244, 12290, 191, 244, 12288, 192,
    244, 12294, 191, 244, 45056, 191, 244, 16, 12288, 191, 244, 45056, 191,
    244, 8, 12288, 51, 244, 12289, 191, 244, 12288, 189, 244, 12288, 191, 244,
    45056, 191, 244, 32, 12288, 21, 432, 0, 244, 12288, 21, 432, 18, 244,
    12289, 191, 244, 12290, 189, 244, 12288, 192, 244, 12288, 191, 244, 12288,
    21, 450, 0, 244, 12288, 21, 450, 18, 244, 12289, 191, 244, 12288, 192, 244,
    12289, 189, 244, 12289, 191, 244, 8192, 244, 12288, 191, 244, 45056, 192,
    244, 32, 12289, 191, 244, 45056, 191, 244, 32, 12289, 191, 244, 45056, 191,
    244, 32, 8192, 244, 12288, 51, 244, 12288, 191, 244, 12288, 51, 244, 12291,
    191, 244, 12288, 10, 18, 378, 244, 12288, 10, 36, 396, 244, 12288, 10, 36,
    414, 244, 12290, 191, 244, 12288, 189, 244, 12289, 192, 244, 12288, 51,
    244, 8193, 244, 12289, 192, 244, 12288, 191, 244, 12288, 189, 244
},
// treeRoom11
{
    4876, 12290, 189, 244, 12289, 191, 244, 12290, 189, 244, 12288, 191, 244,
    12292, 189, 244, 12289, 191, 244, 12288, 51, 244, 12291, 191, 244, 12288,
    189, 244, 12289, 192, 244, 12288, 189, 244, 12290, 191, 244, 12288, 51,
    244, 8192, 244, 12288, 191, 244, 8192, 244, 12290, 191, 244, 12289, 189,
    244, 12289, 191, 244, 12289, 192, 244, 8196, 244, 45056, 191, 244, 8,
    12289, 189, 244, 12290, 191, 244, 12288, 192, 244, 8194, 244, 12288, 172,
    0, 228, 244, 12288, 172, 0, 246, 244, 12288, 191, 244, 12288, 189, 244,
    12290, 191, 244, 45056, 191, 244, 40, 8195, 244, 12288, 172, 18, 228, 244,
    12288, 172, 18, 246, 244, 12292, 191, 244, 12290, 192, 244, 8195, 244,
    45056, 19, 180, 414, 244, 16, 12288, 191, 244, 12288, 189, 244, 12288, 191,
    244, 12292, 192, 244, 8194, 244, 12288, 51, 244, 12289, 191, 244, 8200,
    244, 12288, 51, 244, 12290, 191, 244, 8194, 244, 12288, 51, 244, 12288,
    191, 244, 8194, 244, 45056, 192, 244, 8, 12288, 191, 244, 12288, 192, 244,
    8194, 244, 45056, 191, 244, 8, 12289, 191, 244, 8194, 244, 45056, 191, 244,
    8, 12289, 191, 244, 12288, 192, 244, 8193, 244, 12290, 191, 244, 8194, 244,
    45056, 192, 244, 8, 12293, 191, 244, 45056, 191, 244, 32, 8195, 244, 12288,
    191, 244, 12288, 189, 244, 12289, 191, 244, 12289, 51, 244, 8194, 244,
    12288, 105, 1836, 0, 244, 12288, 105, 1836, 18, 244, 12288, 105, 1836, 36,
    244, 12288, 191, 244, 12288, 189, 244, 12288, 191, 244, 12288, 192, 244,
    8196, 244, 12288, 105, 1854, 0, 244, 12288, 105, 1854, 18, 244, 12288, 105,
    1854, 36, 244, 12288, 191, 244, 12288, 189, 244, 12288, 191, 244, 8193,
    244, 12288, 33, 18, 308, 244, 12288, 19, 36, 414, 244, 8196, 244, 12288,
    191, 244, 12288, 189, 244, 12288, 191, 244, 12288, 51, 244, 12288, 21, 432,
    0, 244, 12288, 21, 432, 18, 244, 12288, 19, 0, 414, 244, 8195, 244, 45056,
    19, 144, 414, 244, 24, 12288, 191, 244, 12288, 192, 244, 12288, 189, 244,
    12288, 191, 244, 12288, 21, 450, 0, 244, 12288, 21, 450, 18, 244, 12288,
    19, 72, 414, 244, 8194, 244, 45056, 19, 144, 414, 244, 24, 12289, 191, 244,
    12289, 189, 244, 12291, 191, 244, 12288, 10, 18, 378, 244, 12288, 10, 18,
    396, 244, 12288, 10, 0, 414, 244, 12289, 191, 244, 12289, 189, 244
},
// treeRoom12
{
    4363, 12288, 189, 244, 12288, 191, 244, 12291, 189, 244, 8194, 244, 12290,
    189, 244, 12290, 191, 244, 12288, 189, 244, 12288, 191, 244, 8194, 244,
    12289, 192, 244, 12288, 189, 244, 12288, 192, 244, 12288, 191, 244, 45056,
    191, 244, 16, 12289, 191, 244, 12288, 10, 36, 378, 244, 12288, 10, 0, 396,
    244, 12288, 10, 18, 414, 244, 12292, 191, 244, 8197, 244, 12288, 191, 244,
    12288, 189, 244, 12289, 191, 244, 45056, 191, 244, 32, 8197, 244, 12291,
    191, 244, 8198, 244, 12288, 51, 244, 12288, 191, 244, 12288, 189, 244,
    12288, 191, 244, 12288, 34, 54, 972, 244, 12288, 34, 54, 990, 244, 12288,
    34, 54, 1008, 244, 8193, 244, 12288, 304, 0, 0, 244, 12288, 304, 0, 18,
    244, 12288, 304, 0, 36, 244, 12288, 191, 244, 12288, 189, 244, 12288, 191,
    244, 12288, 34, 72, 972, 244, 12288, 34, 72, 990, 244, 12288, 34, 72, 1008,
    244, 8193, 244, 12288, 304, 18, 0, 244, 12288, 304, 18, 18, 244, 12288,
    304, 18, 36, 244, 12289, 191, 244, 8192, 244, 12288, 34, 90, 972, 244,
    12288, 34, 90, 990, 244, 12288, 34, 90, 1008, 244, 8193, 244, 12288, 304,
    36, 0, 244, 12288, 304, 36, 18, 244, 12288, 304, 36, 36, 244, 12289, 191,
    244, 12288, 192, 244, 8197, 244, 12288, 18, 936, 0, 244, 12291, 191, 244,
    12288, 51, 244, 8196, 244, 12288, 18, 954, 0, 244, 12288, 191, 244, 12288,
    189, 244, 12289, 191, 244, 12289, 192, 244, 8195, 244, 12288, 51, 244,
    12289, 191, 244, 12288, 189, 244, 12288, 191, 244, 12288, 192, 244, 8195,
    244, 12288, 21, 432, 0, 244, 12288, 21, 432, 18, 244, 12288, 191, 244,
    12288, 189, 244, 12289, 191, 244, 12288, 192, 244, 8195, 244, 12288, 21,
    450, 0, 244, 12288, 21, 450, 18, 244, 12288, 191, 244, 12288, 189, 244,
    12289, 191, 244, 12288, 192, 244, 45056, 192, 244, 40, 8193, 244, 12288,
    51, 244, 12290, 191, 244, 12289, 189, 244, 12290, 191, 244, 8192, 244,
    45056, 191, 244, 24, 12288, 191, 244, 45056, 191, 244, 32, 8192, 244,
    45056, 191, 244, 16, 12288, 191, 244, 12289, 189, 244, 12291, 191, 244,
    12289, 189, 244, 12289, 191, 244, 12288, 189, 244
},
// treeRoom13
{
    4109, 12288, 189, 244, 12290, 191, 244, 12288, 189, 244, 12289, 191, 244,
    12288, 189, 244, 12289, 191, 244, 12291, 189, 244, 12290, 191, 244, 12288,
    189, 244, 12288, 191, 244, 12288, 192, 244, 12289, 189, 244, 12288, 192,
    244, 12288, 191, 244, 12289, 189, 244, 12288, 191, 244, 12288, 189, 244,
    12288, 191, 244, 12288, 192, 244, 45056, 192, 244, 8, 12288, 191, 244,
    12288, 51, 244, 12290, 191, 244, 12288, 189, 244, 12288, 191, 244, 12290,
    189, 244, 12288, 191, 244, 45056, 191, 244, 32, 8192, 244, 12288, 191, 244,
    8192, 244, 45056, 192, 244, 8, 12290, 191, 244, 12289, 189, 244, 12289,
    191, 244, 12288, 189, 244, 8195, 244, 45056, 191, 244, 8, 12288, 191, 244,
    12288, 192, 244, 12290, 189, 244, 12288, 191, 244, 12288, 189, 244, 12288,
    191, 244, 8194, 244, 12288, 89, 1512, 0, 244, 12288, 89, 1512, 18, 244,
    12291, 191, 244, 12289, 189, 244, 12289, 191, 244, 12288, 192, 244, 8193,
    244, 12288, 89, 1530, 0, 244, 12288, 89, 1530, 18, 244, 12290, 191, 244,
    12289, 189, 244, 12288, 191, 244, 12288, 192, 244, 12289, 191, 244, 12288,
    51, 244, 8192, 244, 12288, 89, 1548, 0, 244, 12288, 89, 1548, 18, 244,
    12290, 191, 244, 12288, 189, 244, 12288, 191, 244, 12289, 189, 244, 12289,
    191, 244, 12288, 51, 244, 8193, 244, 45056, 191, 244, 8, 12290, 191, 244,
    12288, 189, 244, 12291, 191, 244, 45056, 191, 244, 32, 8194, 244, 12288,
    21, 432, 0, 244, 12288, 21, 432, 18, 244, 12288, 191, 244, 12288, 192, 244,
    12288, 191, 244, 12289, 189, 244, 12288, 192, 244, 12289, 191, 244, 8194,
    244, 12288, 21, 450, 0, 244, 12288, 21, 450, 18, 244, 12288, 191, 244,
    12288, 189, 244, 12288, 191, 244, 12290, 189, 244, 12289, 191, 244, 8195,
    244, 12289, 191, 244, 12288, 189, 244, 12288, 191, 244, 12289, 189, 244,
    12290, 191, 244, 8195, 244, 45056, 191, 244, 16, 12288, 191, 244, 12288,
    192, 244, 12291, 189, 244, 12288, 191, 244, 12288, 192, 244, 12288, 191,
    244, 8195, 244, 12289, 191, 244, 12290, 189, 244, 12288, 191, 244, 12289,
    189, 244, 12288, 191, 244, 12288, 51, 244, 8193, 244, 45056, 192, 244, 8,
    12289, 191, 244, 12293, 189, 244, 12288, 191, 244, 12288, 10, 0, 378, 244,
    12288, 10, 0, 396, 244, 12288, 10, 36, 414, 244, 12288, 191, 244, 12289,
    192, 244, 12289, 189, 244
},
// treeRoom14
{
    3851, 12290, 189, 244, 12291, 191, 244, 12288, 10, 18, 378, 244, 12288, 10,
    18, 396, 244, 12288, 10, 18, 414, 244, 12288, 191, 244, 12289, 189, 244,
    12289, 191, 244, 12290, 51, 244, 8194, 244, 12288, 191, 244, 12288, 189,
    244, 12289, 191, 244, 12288, 192, 244, 8197, 244, 12288, 191, 244, 12288,
    189, 244, 12288, 191, 244, 45056, 19, 180, 414, 244, 16, 8197, 244, 12288,
    192, 244, 12290, 191, 244, 8192, 244, 45056, 19, 180, 414, 244, 16, 8195,
    244, 45056, 192, 244, 8, 12288, 192, 244, 12289, 191, 244, 12288, 192, 244,
    8193, 244, 45056, 19, 180, 414, 244, 16, 8195, 244, 12288, 51, 244, 12289,
    191, 244, 45056, 192, 244, 32, 12288, 304, 0, 0, 244, 12288, 304, 0, 18,
    244, 12288, 304, 0, 36, 244, 12288, 19, 0, 414, 244, 8194, 244, 45056, 191,
    244, 24, 12289, 191, 244, 8192, 244, 12288, 304, 18, 0, 244, 12288, 304,
    18, 18, 244, 12288, 304, 18, 36, 244, 12288, 19, 0, 414, 244, 8192, 244,
    45056, 191, 244, 8, 12291, 191, 244, 12288, 51, 244, 12288, 304, 36, 0,
    244, 12288, 304, 36, 18, 244, 12288, 304, 36, 36, 244, 12288, 19, 0, 414,
    244, 8193, 244, 12288, 191, 244, 45056, 191, 244, 8, 12289, 191, 244,
    12290, 51, 244, 45056, 19, 144, 414, 244, 24, 8196, 244, 12289, 191, 244,
    45056, 191, 244, 40, 8192, 244, 45056, 19, 144, 414, 244, 24, 8195, 244,
    12288, 15, 0, 200, 244, 12288, 15, 0, 218, 244, 12290, 191, 244, 45056, 19,
    144, 414, 244, 24, 8194, 244, 12288, 21, 432, 0, 244, 12288, 21, 432, 18,
    244, 12288, 192, 244, 45056, 192, 244, 16, 12288, 191, 244, 12288, 189,
    244, 12290, 191, 244, 12288, 192, 244, 8192, 244, 12288, 21, 450, 0, 244,
    12288, 21, 450, 18, 244, 12289, 192, 244, 12288, 191, 244, 12289, 189, 244,
    12295, 191, 244, 12294, 189, 244, 12289, 191, 244, 12290, 189, 244
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getRoom(int roomId, const std::vector<bool> &framedTiles)
{
    return {roomData[roomId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Rooms.h`
```
#ifndef ROOMS_H
#define ROOMS_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto pyramidRooms = std::views::iota(0, 5);
inline auto treeRooms = std::views::iota(5, 19);

TileBuffer getRoom(int roomId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // ROOMS_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/SkyBoxes.cpp`
```
#include "structures/data/SkyBoxes.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> skyBoxData{
// skyBox1
{
    4623, 4107, 189, 20482, 189, 1, 4096, 189, 11, 4096, 202, 4097, 189, 4108,
    202, 4097, 189, 4108, 202, 4097, 189, 4098, 202, 12288, 91, 144, 0, 90,
    12288, 91, 144, 18, 90, 12288, 91, 144, 36, 90, 8192, 21, 8193, 90, 12288,
    93, 18, 486, 90, 12288, 93, 18, 504, 90, 12288, 93, 18, 522, 90, 4096, 202,
    4097, 189, 4098, 202, 8194, 90, 8192, 21, 8196, 90, 4096, 202, 4097, 189,
    4098, 202, 8200, 21, 4096, 202, 4097, 189, 4096, 202, 20480, 202, 20, 4096,
    202, 12288, 91, 162, 0, 90, 12288, 91, 162, 18, 90, 12288, 91, 162, 36, 90,
    8192, 21, 8196, 90, 4096, 202, 4097, 189, 0, 20480, 387, 0, 0, 20, 8195,
    90, 8192, 21, 12288, 21, 468, 0, 90, 12288, 21, 468, 18, 90, 12288, 202,
    90, 8193, 90, 4096, 202, 4097, 189, 0, 20480, 387, 18, 0, 20, 8195, 90,
    8192, 21, 12288, 21, 486, 0, 90, 12288, 21, 486, 18, 90, 12288, 202, 90,
    8193, 90, 4096, 202, 4097, 189, 4096, 202, 20480, 202, 20, 4096, 202,
    12288, 91, 162, 0, 90, 12288, 91, 162, 18, 90, 12288, 91, 162, 36, 90,
    8192, 21, 8196, 90, 4096, 202, 4097, 189, 4098, 202, 8200, 21, 4096, 202,
    4097, 189, 4098, 202, 8194, 90, 8192, 21, 8196, 90, 4096, 202, 4097, 189,
    4098, 202, 12288, 91, 144, 0, 90, 12288, 91, 144, 18, 90, 12288, 91, 144,
    36, 90, 8192, 21, 8193, 90, 12288, 93, 18, 486, 90, 12288, 93, 18, 504, 90,
    12288, 93, 18, 522, 90, 4096, 202, 4097, 189, 4108, 202, 4097, 189, 4108,
    202, 4097, 189, 11, 4096, 202, 4108, 189, 20482, 189, 1
},
// skyBox2
{
    3085, 4105, 189, 20482, 189, 1, 4096, 189, 12288, 240, 1080, 108, 90,
    12288, 240, 1080, 126, 90, 12288, 240, 1080, 144, 90, 8197, 90, 12288, 357,
    90, 4096, 357, 4097, 189, 12288, 240, 1098, 108, 90, 12288, 240, 1098, 126,
    90, 12288, 240, 1098, 144, 90, 8196, 90, 12288, 350, 90, 12288, 357, 90,
    4096, 357, 4097, 189, 12288, 240, 1116, 108, 90, 12288, 240, 1116, 126, 90,
    12288, 240, 1116, 144, 90, 8195, 90, 12289, 350, 90, 12288, 357, 90, 4096,
    357, 4097, 189, 8197, 90, 12289, 370, 90, 12288, 350, 90, 12288, 357, 90,
    4096, 357, 4097, 189, 8195, 90, 12288, 21, 468, 0, 90, 12288, 21, 468, 18,
    90, 12289, 370, 90, 12288, 350, 90, 12288, 357, 90, 4096, 357, 4097, 189,
    8195, 90, 12288, 21, 486, 0, 90, 12288, 21, 486, 18, 90, 12289, 370, 90,
    12288, 350, 90, 12288, 357, 90, 4096, 357, 4097, 189, 8197, 90, 12289, 370,
    90, 12288, 350, 90, 12288, 357, 90, 4096, 357, 4097, 189, 12288, 240, 1080,
    108, 90, 12288, 240, 1080, 126, 90, 12288, 240, 1080, 144, 90, 8195, 90,
    12289, 350, 90, 12288, 357, 90, 4096, 357, 4097, 189, 12288, 240, 1098,
    108, 90, 12288, 240, 1098, 126, 90, 12288, 240, 1098, 144, 90, 8196, 90,
    12288, 350, 90, 12288, 357, 90, 4096, 357, 4097, 189, 12288, 240, 1116,
    108, 90, 12288, 240, 1116, 126, 90, 12288, 240, 1116, 144, 90, 8197, 90,
    12288, 357, 90, 4096, 357, 4106, 189, 20482, 189, 1
},
// skyBox3
{
    4365, 4105, 189, 20482, 189, 1, 4096, 189, 0, 36864, 370, 24, 4099, 370,
    4096, 10, 36, 1782, 4096, 10, 18, 1800, 4096, 10, 0, 1818, 4097, 370, 4097,
    189, 0, 4099, 370, 61440, 370, 82, 5632, 32, 24578, 82, 5632, 4097, 370,
    4097, 189, 0, 4097, 370, 24581, 82, 5632, 4097, 370, 4097, 189, 0, 4097,
    370, 24576, 82, 5632, 28672, 245, 900, 0, 82, 5632, 28672, 245, 900, 18,
    82, 5632, 28672, 245, 900, 36, 82, 5632, 24577, 82, 5632, 4097, 370, 4097,
    189, 0, 4097, 370, 24576, 82, 5632, 28672, 245, 918, 0, 82, 5632, 28672,
    245, 918, 18, 82, 5632, 28672, 245, 918, 36, 82, 5632, 24577, 82, 5632,
    4097, 370, 4097, 189, 0, 4097, 370, 24581, 82, 5632, 4097, 370, 4097, 189,
    0, 4097, 370, 24581, 82, 5632, 4097, 370, 4097, 189, 0, 4097, 370, 24579,
    82, 5632, 28672, 19, 36, 486, 82, 5632, 24576, 82, 5632, 4097, 370, 4097,
    189, 0, 4097, 370, 24577, 82, 5632, 28672, 21, 468, 0, 82, 5632, 28672, 21,
    468, 18, 82, 5632, 28672, 19, 0, 486, 82, 5632, 24576, 82, 5632, 4097, 370,
    4097, 189, 0, 4097, 370, 24577, 82, 5632, 28672, 21, 486, 0, 82, 5632,
    28672, 21, 486, 18, 82, 5632, 28672, 19, 0, 486, 82, 5632, 24576, 82, 5632,
    4097, 370, 4097, 189, 0, 4097, 370, 24579, 82, 5632, 28672, 19, 18, 486,
    82, 5632, 24576, 82, 5632, 4097, 370, 4097, 189, 0, 4097, 370, 28672, 42,
    18, 720, 82, 5632, 28672, 42, 18, 738, 82, 5632, 24579, 82, 5632, 4097,
    370, 4097, 189, 0, 4097, 370, 24581, 82, 5632, 4097, 370, 4097, 189, 0,
    4099, 370, 61440, 370, 82, 5632, 40, 24578, 82, 5632, 4097, 370, 4097, 189,
    0, 36864, 370, 16, 4099, 370, 4096, 10, 0, 1782, 4096, 10, 18, 1800, 4096,
    10, 0, 1818, 4097, 370, 4106, 189, 20482, 189, 1
},
// skyBox4
{
    4626, 4110, 189, 20482, 189, 1, 4096, 189, 4104, 140, 36869, 140, 2048,
    4096, 140, 4097, 189, 4096, 140, 4102, 347, 36869, 347, 2048, 4096, 347,
    4096, 140, 4097, 189, 4096, 140, 4096, 347, 28672, 91, 162, 0, 82, 5632,
    28672, 91, 162, 18, 82, 5632, 28672, 91, 162, 36, 82, 5632, 24582, 82,
    5632, 28672, 14, 378, 0, 82, 5632, 28672, 14, 378, 18, 82, 5632, 4096, 347,
    4096, 140, 4097, 189, 4096, 140, 4096, 347, 28672, 91, 0, 0, 82, 5632,
    28672, 91, 0, 18, 82, 256, 28672, 91, 0, 36, 82, 256, 24581, 82, 256,
    28672, 33, 18, 264, 82, 256, 28672, 14, 396, 0, 82, 256, 28672, 14, 396,
    18, 82, 5632, 4096, 347, 4096, 140, 4097, 189, 4096, 140, 4096, 347, 28672,
    91, 162, 0, 82, 5632, 28672, 91, 162, 18, 82, 256, 28672, 91, 162, 36, 82,
    5632, 24582, 82, 5632, 28672, 14, 414, 0, 82, 256, 28672, 14, 414, 18, 82,
    5632, 4096, 347, 4096, 140, 4097, 189, 4096, 140, 4096, 347, 24576, 82,
    5632, 28672, 242, 216, 0, 82, 256, 28672, 242, 216, 18, 82, 5632, 28672,
    242, 216, 36, 82, 256, 28672, 242, 216, 54, 82, 256, 24579, 82, 256, 24576,
    82, 5632, 24576, 82, 256, 24576, 82, 5632, 4096, 347, 4096, 140, 4097, 189,
    4096, 140, 4096, 347, 24576, 82, 5632, 28672, 242, 234, 0, 82, 256, 28672,
    242, 234, 18, 82, 5632, 28672, 242, 234, 36, 82, 256, 28672, 242, 234, 54,
    82, 5632, 24578, 82, 5632, 24576, 82, 256, 24576, 82, 5632, 24576, 82, 256,
    24576, 82, 5632, 4096, 347, 4096, 140, 4097, 189, 4096, 140, 4096, 347,
    24576, 82, 5632, 28672, 242, 252, 0, 82, 256, 28672, 242, 252, 18, 82,
    5632, 28672, 242, 252, 36, 82, 256, 28672, 242, 252, 54, 82, 5632, 28672,
    21, 468, 0, 82, 5632, 4096, 21, 468, 18, 28672, 19, 36, 396, 82, 5632,
    24576, 82, 256, 24576, 82, 5632, 24576, 82, 256, 24576, 82, 5632, 4096,
    347, 4096, 140, 4097, 189, 4096, 140, 4096, 347, 24576, 82, 5632, 28672,
    242, 270, 0, 82, 256, 28672, 242, 270, 18, 82, 5632, 28672, 242, 270, 36,
    82, 256, 28672, 242, 270, 54, 82, 5632, 28672, 21, 486, 0, 82, 5632, 4096,
    21, 486, 18, 28672, 19, 18, 396, 82, 5632, 24576, 82, 256, 24576, 82, 5632,
    24576, 82, 256, 24576, 82, 5632, 4096, 347, 4096, 140, 4097, 189, 4096,
    140, 4096, 347, 24576, 82, 5632, 28672, 242, 288, 0, 82, 256, 28672, 242,
    288, 18, 82, 5632, 28672, 242, 288, 36, 82, 256, 28672, 242, 288, 54, 82,
    5632, 24578, 82, 5632, 24576, 82, 256, 24576, 82, 5632, 24576, 82, 256,
    24576, 82, 5632, 4096, 347, 4096, 140, 4097, 189, 4096, 140, 4096, 347,
    24576, 82, 5632, 28672, 242, 306, 0, 82, 256, 28672, 242, 306, 18, 82,
    5632, 28672, 242, 306, 36, 82, 256, 28672, 242, 306, 54, 82, 256, 24579,
    82, 256, 24576, 82, 5632, 24576, 82, 256, 24576, 82, 5632, 4096, 347, 4096,
    140, 4097, 189, 4096, 140, 4096, 347, 28672, 91, 162, 0, 82, 5632, 28672,
    91, 162, 18, 82, 256, 28672, 91, 162, 36, 82, 5632, 24582, 82, 5632, 28672,
    14, 378, 0, 82, 256, 28672, 14, 378, 18, 82, 5632, 4096, 347, 4096, 140,
    4097, 189, 4096, 140, 4096, 347, 28672, 91, 0, 0, 82, 5632, 28672, 91, 0,
    18, 82, 256, 28672, 91, 0, 36, 82, 256, 24581, 82, 256, 28672, 33, 18, 264,
    82, 256, 28672, 14, 396, 0, 82, 256, 28672, 14, 396, 18, 82, 5632, 4096,
    347, 4096, 140, 4097, 189, 4096, 140, 4096, 347, 28672, 91, 162, 0, 82,
    5632, 28672, 91, 162, 18, 82, 5632, 28672, 91, 162, 36, 82, 5632, 24582,
    82, 5632, 28672, 14, 414, 0, 82, 5632, 28672, 14, 414, 18, 82, 5632, 4096,
    347, 4096, 140, 4097, 189, 4096, 140, 4102, 347, 36869, 347, 2048, 4096,
    347, 4096, 140, 4097, 189, 4104, 140, 36869, 140, 2048, 4096, 140, 4111,
    189, 20482, 189, 1
},
// skyBox5
{
    2573, 4104, 189, 20481, 189, 1, 4098, 189, 0, 36864, 347, 2072, 36870, 347,
    2048, 4096, 347, 4096, 124, 4097, 189, 0, 36871, 347, 2048, 4096, 347,
    4096, 124, 4097, 189, 0, 36871, 347, 2048, 4096, 347, 4096, 124, 4097, 189,
    0, 36866, 347, 2048, 12288, 21, 468, 0, 174, 12288, 21, 468, 18, 174,
    12288, 19, 54, 252, 174, 36865, 347, 2048, 4096, 347, 4096, 124, 4097, 189,
    0, 36866, 347, 2048, 12288, 21, 486, 0, 174, 12288, 21, 486, 18, 174,
    12288, 19, 72, 252, 174, 36865, 347, 2048, 4096, 347, 4096, 124, 4097, 189,
    0, 36866, 347, 2048, 45058, 347, 174, 2048, 36865, 347, 2048, 4096, 347,
    4096, 124, 4097, 189, 0, 36871, 347, 2048, 4096, 347, 4096, 124, 4097, 189,
    0, 36864, 347, 2064, 36870, 347, 2048, 4096, 347, 4096, 124, 4105, 189,
    20481, 189, 1, 4097, 189
},
// skyBox6
{
    4366, 4106, 189, 20482, 189, 1, 4096, 189, 0, 36864, 357, 24, 4100, 357, 2,
    36864, 202, 8, 4096, 202, 4097, 189, 0, 4096, 357, 8199, 82, 45056, 202,
    82, 8, 4096, 202, 4097, 189, 0, 4096, 357, 8192, 82, 8192, 91, 8192, 21,
    8192, 91, 8195, 82, 4097, 202, 4097, 189, 0, 4096, 357, 8192, 82, 8194, 21,
    8192, 82, 12288, 305, 0, 0, 82, 12288, 305, 0, 18, 82, 12288, 305, 0, 36,
    82, 4097, 202, 4097, 189, 0, 4096, 357, 8192, 82, 8192, 91, 8192, 21, 8192,
    91, 8192, 82, 12288, 305, 18, 0, 82, 12288, 305, 18, 18, 82, 12288, 305,
    18, 36, 82, 4097, 202, 4097, 189, 0, 4096, 357, 8196, 82, 12288, 305, 36,
    0, 82, 12288, 305, 36, 18, 82, 12288, 305, 36, 36, 82, 4097, 202, 4097,
    189, 0, 4096, 357, 8199, 82, 4097, 202, 4097, 189, 0, 4096, 357, 8198, 82,
    45056, 19, 144, 396, 82, 24, 4097, 202, 4097, 189, 0, 4096, 357, 8197, 82,
    45056, 19, 144, 396, 82, 24, 8192, 82, 4097, 202, 4097, 189, 0, 4096, 357,
    8195, 82, 12288, 21, 468, 0, 82, 12288, 21, 468, 18, 82, 12288, 19, 216,
    396, 82, 8192, 82, 4097, 202, 4097, 189, 0, 4096, 357, 8192, 82, 12288,
    240, 648, 108, 82, 12288, 240, 648, 126, 82, 12288, 240, 648, 144, 82,
    12288, 21, 486, 0, 82, 12288, 21, 486, 18, 82, 12288, 19, 234, 396, 82,
    8192, 82, 4097, 202, 4097, 189, 0, 4096, 357, 8192, 82, 12288, 240, 666,
    108, 82, 12288, 240, 666, 126, 82, 12288, 240, 666, 144, 82, 8193, 82,
    45056, 19, 180, 396, 82, 16, 8192, 82, 4097, 202, 4097, 189, 0, 4096, 357,
    8192, 82, 12288, 240, 684, 108, 82, 12288, 240, 684, 126, 82, 12288, 240,
    684, 144, 82, 8194, 82, 45056, 19, 180, 396, 82, 16, 4097, 202, 4097, 189,
    0, 4096, 357, 8199, 82, 45056, 202, 82, 8, 4096, 202, 4097, 189, 0, 36864,
    357, 16, 4100, 357, 2, 36864, 202, 8, 4096, 202, 4107, 189, 20482, 189, 1
},
// skyBox7
{
    4109, 4106, 189, 20481, 189, 1, 4096, 189, 20486, 54, 20, 20480, 10, 0,
    1080, 9, 20480, 10, 0, 1098, 9, 20480, 10, 0, 1116, 5, 20480, 54, 5, 4097,
    189, 20480, 54, 20, 8194, 90, 24576, 21, 6656, 12288, 547, 108, 0, 90,
    12288, 547, 108, 18, 90, 12288, 547, 108, 36, 90, 12288, 547, 108, 54, 90,
    45056, 547, 108, 72, 91, 4096, 20480, 54, 5, 4097, 189, 20480, 54, 20,
    8193, 90, 24577, 21, 6656, 12288, 547, 126, 0, 90, 12288, 547, 126, 18, 90,
    12288, 547, 126, 36, 90, 12288, 547, 126, 54, 90, 45056, 547, 126, 72, 91,
    4096, 20480, 54, 5, 4097, 189, 20480, 54, 20, 8193, 90, 24577, 21, 6656,
    8194, 90, 8193, 91, 20480, 54, 5, 4097, 189, 20480, 54, 20, 8194, 90,
    24576, 21, 6656, 8194, 90, 8193, 91, 20480, 54, 5, 4097, 189, 20480, 54,
    20, 8196, 90, 8195, 91, 20480, 54, 5, 4097, 189, 20480, 54, 20, 8196, 90,
    8195, 91, 20480, 54, 5, 4097, 189, 20480, 54, 20, 8196, 90, 8195, 91,
    20480, 54, 5, 4097, 189, 20480, 54, 20, 8195, 90, 12288, 21, 468, 0, 90,
    12288, 21, 468, 18, 90, 45056, 19, 36, 252, 91, 4096, 8193, 91, 20480, 54,
    5, 4097, 189, 20480, 54, 20, 8193, 90, 24576, 21, 6656, 8192, 90, 12288,
    21, 486, 0, 90, 12288, 21, 486, 18, 90, 45056, 19, 18, 252, 91, 4096, 8193,
    91, 20480, 54, 5, 4097, 189, 20480, 54, 20, 8192, 90, 24577, 21, 6656,
    8195, 90, 8193, 91, 20480, 54, 5, 4097, 189, 20480, 54, 20, 8193, 90,
    24576, 21, 6656, 8195, 90, 8193, 91, 20480, 54, 5, 4097, 189, 20480, 54,
    20, 8199, 90, 8192, 91, 20480, 54, 5, 4097, 189, 20486, 54, 20, 20480, 10,
    0, 1080, 9, 20480, 10, 18, 1098, 9, 20480, 10, 18, 1116, 5, 20480, 54, 5,
    4107, 189, 20481, 189, 1
},
// skyBox8
{
    4384, 4124, 189, 20482, 189, 1, 4096, 189, 6, 4096, 202, 36864, 202, 40,
    19, 4098, 189, 5, 4098, 202, 19, 4098, 189, 4, 4120, 202, 4097, 189, 3,
    4099, 202, 8192, 82, 12288, 88, 702, 0, 90, 12288, 88, 702, 18, 82, 45056,
    19, 468, 396, 182, 16, 45056, 19, 288, 396, 132, 4096, 12288, 91, 162, 0,
    82, 12288, 91, 162, 18, 82, 12288, 91, 162, 36, 132, 8192, 182, 8192, 82,
    8192, 90, 8192, 82, 12288, 305, 0, 0, 182, 12288, 305, 0, 18, 132, 12288,
    305, 0, 36, 82, 45056, 19, 468, 396, 82, 16, 8192, 132, 8192, 182, 8192,
    82, 12288, 89, 756, 0, 90, 12288, 89, 756, 18, 82, 4096, 202, 4097, 189, 2,
    4100, 202, 8192, 82, 12288, 88, 720, 0, 90, 12288, 88, 720, 18, 82, 12288,
    19, 0, 396, 182, 45056, 19, 180, 396, 132, 16, 45056, 19, 288, 396, 82,
    4096, 12288, 91, 144, 0, 82, 12288, 91, 144, 18, 132, 12288, 91, 144, 36,
    182, 8192, 82, 8192, 90, 8192, 82, 12288, 305, 18, 0, 182, 12288, 305, 18,
    18, 132, 12288, 305, 18, 36, 82, 12288, 19, 0, 396, 82, 45056, 19, 180,
    396, 132, 16, 8192, 182, 8192, 82, 12288, 89, 774, 0, 90, 12288, 89, 774,
    18, 82, 4096, 202, 4097, 189, 1, 4101, 202, 8192, 82, 12288, 88, 738, 0,
    90, 12288, 88, 738, 18, 82, 12288, 19, 0, 396, 182, 8192, 132, 45056, 19,
    180, 396, 82, 16, 45056, 19, 288, 396, 82, 4096, 12288, 91, 126, 0, 132,
    12288, 91, 126, 18, 182, 12288, 91, 126, 36, 82, 8192, 90, 8192, 82, 12288,
    305, 36, 0, 182, 12288, 305, 36, 18, 132, 12288, 305, 36, 36, 82, 12288,
    19, 0, 396, 82, 8192, 132, 45056, 19, 180, 396, 182, 16, 8192, 82, 12288,
    89, 792, 0, 90, 12288, 89, 792, 18, 82, 4096, 202, 4097, 189, 0, 4102, 202,
    8192, 82, 8192, 90, 8192, 82, 12288, 19, 0, 396, 182, 8192, 132, 8192, 82,
    45056, 19, 180, 396, 82, 16, 8192, 132, 8192, 182, 8192, 82, 8192, 90,
    8192, 82, 8192, 182, 8192, 132, 45056, 19, 144, 396, 82, 24, 8192, 82,
    8192, 132, 8192, 182, 45056, 19, 180, 396, 82, 16, 8192, 90, 12288, 18,
    864, 0, 82, 4096, 202, 4097, 189, 4103, 202, 8192, 82, 8192, 90, 8192, 82,
    12288, 19, 0, 396, 182, 8192, 132, 8193, 82, 45056, 19, 180, 396, 132, 16,
    8192, 182, 8192, 82, 8192, 90, 8192, 82, 8192, 182, 45056, 19, 144, 396,
    132, 24, 8193, 82, 8192, 132, 8192, 182, 8192, 82, 45056, 19, 180, 396, 90,
    16, 12288, 18, 882, 0, 82, 4096, 202, 4097, 189, 0, 4102, 202, 12288, 33,
    18, 264, 82, 12288, 14, 378, 0, 90, 12288, 14, 378, 18, 82, 12288, 19, 0,
    396, 182, 8192, 132, 8193, 82, 8192, 132, 45056, 19, 180, 396, 182, 16,
    8192, 82, 8192, 90, 8192, 82, 45056, 19, 144, 396, 182, 24, 8192, 132,
    8193, 82, 8192, 132, 8192, 182, 8192, 82, 8192, 90, 45056, 19, 180, 396,
    82, 16, 4096, 202, 4097, 189, 1, 4101, 202, 8192, 82, 12288, 14, 396, 0,
    90, 12288, 14, 396, 18, 82, 12288, 19, 0, 396, 182, 12288, 91, 126, 0, 132,
    12288, 91, 126, 18, 82, 12288, 91, 126, 36, 82, 8192, 132, 8192, 182,
    12288, 19, 0, 396, 82, 8192, 90, 45056, 19, 144, 396, 82, 24, 45056, 19,
    270, 396, 182, 4096, 12288, 91, 126, 0, 132, 12288, 91, 126, 18, 82, 12288,
    91, 126, 36, 82, 8192, 132, 8192, 182, 8192, 82, 8192, 90, 8192, 82, 4096,
    202, 4097, 189, 2, 4100, 202, 8192, 82, 12288, 14, 414, 0, 90, 12288, 14,
    414, 18, 82, 12288, 19, 0, 396, 182, 12288, 91, 144, 0, 132, 12288, 91,
    144, 18, 82, 12288, 91, 144, 36, 82, 12288, 21, 468, 0, 132, 12288, 21,
    468, 18, 182, 12288, 19, 0, 396, 82, 45056, 19, 144, 396, 90, 24, 45056,
    19, 270, 396, 82, 4096, 12288, 91, 144, 0, 182, 12288, 91, 144, 18, 132,
    12288, 91, 144, 36, 82, 8192, 82, 8192, 132, 8192, 182, 8192, 82, 8192, 90,
    8192, 82, 4096, 202, 4097, 189, 3, 4099, 202, 8192, 82, 12288, 15, 0, 400,
    90, 12288, 15, 0, 418, 82, 12288, 19, 72, 396, 182, 12288, 91, 162, 0, 132,
    12288, 91, 162, 18, 82, 12288, 91, 162, 36, 82, 12288, 21, 486, 0, 132,
    12288, 21, 486, 18, 182, 45056, 19, 450, 396, 82, 24, 45056, 19, 270, 396,
    90, 4096, 12288, 91, 162, 0, 82, 12288, 91, 162, 18, 182, 12288, 91, 162,
    36, 132, 8193, 82, 8192, 132, 8192, 182, 8192, 82, 8192, 90, 8192, 82,
    4096, 202, 4097, 189, 4, 4114, 202, 20480, 388, 0, 94, 20, 20480, 388, 0,
    114, 20, 20480, 388, 0, 132, 20, 20480, 388, 0, 150, 20, 20480, 388, 0,
    168, 20, 4096, 202, 4097, 189, 5, 4098, 202, 19, 4098, 189, 6, 4096, 202,
    36864, 202, 32, 19, 4126, 189, 20482, 189, 1
},
// skyBox9
{
    9232, 4107, 189, 20482, 189, 1, 4097, 189, 11, 4097, 202, 4097, 189, 0,
    36864, 202, 24, 36864, 202, 40, 7, 36864, 202, 2056, 4097, 202, 4097, 189,
    0, 4097, 202, 36864, 202, 2088, 6, 36864, 202, 2048, 4097, 202, 4097, 189,
    0, 4097, 202, 36872, 202, 2048, 4097, 202, 4097, 189, 0, 4097, 202, 36872,
    202, 2048, 4097, 202, 4097, 189, 0, 4097, 202, 36864, 202, 2080, 8198, 82,
    36864, 202, 2048, 4097, 202, 4097, 189, 0, 4097, 202, 8194, 82, 45056, 202,
    82, 2072, 45058, 202, 82, 2048, 8192, 82, 36864, 202, 2056, 4097, 202,
    4097, 189, 0, 4097, 202, 8193, 82, 45056, 202, 82, 2072, 45056, 202, 21,
    2080, 8193, 21, 45056, 202, 82, 2048, 8193, 82, 4097, 202, 4097, 189, 0,
    4097, 202, 8193, 82, 45056, 202, 82, 2064, 45056, 202, 21, 2088, 8193, 21,
    45056, 202, 82, 2048, 8193, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8194,
    82, 45056, 202, 82, 2064, 45058, 202, 82, 2048, 8192, 82, 36864, 202, 2056,
    4097, 202, 4097, 189, 0, 4097, 202, 36864, 202, 2088, 8198, 82, 36864, 202,
    2048, 4097, 202, 4097, 189, 0, 4097, 202, 36872, 202, 2048, 4097, 202,
    4097, 189, 0, 4097, 202, 36872, 202, 2048, 4097, 202, 4097, 189, 0, 4097,
    202, 36864, 202, 2080, 8198, 82, 36864, 202, 2048, 4097, 202, 4097, 189, 0,
    4097, 202, 8199, 82, 36864, 202, 2056, 4097, 202, 4097, 189, 0, 4097, 202,
    8195, 82, 12288, 19, 36, 252, 82, 8195, 82, 4097, 202, 4097, 189, 0, 4097,
    202, 8193, 82, 12288, 21, 468, 0, 82, 12288, 21, 468, 18, 82, 12288, 19, 0,
    252, 82, 45056, 19, 396, 252, 82, 2064, 45056, 19, 342, 252, 82, 2072,
    45056, 19, 396, 252, 82, 2064, 45056, 19, 144, 252, 82, 2072, 4097, 202,
    4097, 189, 0, 4097, 202, 8193, 82, 12288, 21, 486, 0, 82, 12288, 21, 486,
    18, 82, 12288, 19, 0, 252, 82, 45056, 19, 378, 252, 82, 2072, 45056, 19,
    360, 252, 82, 2064, 45056, 19, 378, 252, 82, 2072, 45056, 19, 180, 252, 82,
    2064, 4097, 202, 4097, 189, 0, 4097, 202, 8195, 82, 12288, 19, 18, 252, 82,
    8195, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8199, 82, 36864, 202, 2056,
    4097, 202, 4097, 189, 0, 4097, 202, 36864, 202, 2088, 8198, 82, 36864, 202,
    2048, 4097, 202, 4097, 189, 0, 4097, 202, 36872, 202, 2048, 4097, 202,
    4097, 189, 0, 4097, 202, 36872, 202, 2048, 4097, 202, 4097, 189, 0, 4097,
    202, 36864, 202, 2080, 8198, 82, 36864, 202, 2048, 4097, 202, 4097, 189, 0,
    4097, 202, 8194, 82, 45056, 202, 82, 2072, 45058, 202, 82, 2048, 8192, 82,
    36864, 202, 2056, 4097, 202, 4097, 189, 0, 4097, 202, 8193, 82, 45056, 202,
    82, 2072, 45056, 202, 21, 2080, 8193, 21, 45056, 202, 82, 2048, 8193, 82,
    4097, 202, 4097, 189, 0, 4097, 202, 8193, 82, 45056, 202, 82, 2064, 45056,
    202, 21, 2088, 8193, 21, 45056, 202, 82, 2048, 8193, 82, 4097, 202, 4097,
    189, 0, 4097, 202, 8194, 82, 45056, 202, 82, 2064, 45058, 202, 82, 2048,
    8192, 82, 36864, 202, 2056, 4097, 202, 4097, 189, 0, 4097, 202, 36864, 202,
    2088, 8198, 82, 36864, 202, 2048, 4097, 202, 4097, 189, 0, 4097, 202,
    36872, 202, 2048, 4097, 202, 4097, 189, 0, 4097, 202, 36872, 202, 2048,
    4097, 202, 4097, 189, 0, 4097, 202, 36864, 202, 2080, 6, 36864, 202, 2048,
    4097, 202, 4097, 189, 0, 36864, 202, 16, 36864, 202, 32, 7, 36864, 202,
    2056, 4097, 202, 4097, 189, 11, 4097, 202, 4108, 189, 20482, 189, 1, 4096,
    189
},
// skyBox10
{
    4365, 4104, 189, 20482, 189, 1, 4097, 189, 4, 4096, 93, 18, 486, 4096, 93,
    18, 504, 4096, 93, 18, 522, 4098, 202, 4097, 189, 6, 8192, 145, 40960, 145,
    1, 4097, 202, 4097, 189, 7, 40960, 145, 1, 4097, 202, 4097, 189, 6, 8192,
    145, 40960, 145, 1, 4097, 202, 4097, 189, 6, 36864, 202, 8, 4098, 202,
    4097, 189, 3, 36864, 202, 8, 4096, 202, 4096, 21, 468, 0, 45056, 21, 468,
    18, 145, 1, 4098, 202, 4097, 189, 0, 36864, 202, 8, 4096, 202, 0, 32768, 1,
    4096, 202, 4096, 21, 486, 0, 45056, 21, 486, 18, 145, 1, 4098, 202, 4097,
    189, 0, 32768, 1, 4104, 202, 4097, 189, 0, 36864, 202, 8, 4096, 202, 0,
    32768, 1, 4096, 202, 0, 40960, 145, 1, 4098, 202, 4097, 189, 3, 36864, 202,
    8, 4096, 202, 0, 40960, 145, 1, 4098, 202, 4097, 189, 6, 36864, 202, 8,
    4098, 202, 4097, 189, 6, 8192, 145, 40960, 145, 1, 4097, 202, 4097, 189, 7,
    40960, 145, 1, 4097, 202, 4097, 189, 6, 8192, 145, 40960, 145, 1, 4097,
    202, 4097, 189, 4, 4096, 93, 18, 486, 4096, 93, 18, 504, 4096, 93, 18, 522,
    4098, 202, 4105, 189, 20482, 189, 1, 4096, 189
},
// skyBox11
{
    9749, 4111, 189, 20482, 189, 1, 4098, 189, 10, 36864, 202, 24, 4096, 202,
    2, 4098, 202, 4097, 189, 7, 36864, 202, 24, 4099, 202, 4096, 10, 0, 486,
    4096, 10, 36, 504, 4096, 10, 0, 522, 4098, 202, 4097, 189, 7, 4100, 202,
    8194, 82, 4098, 202, 4097, 189, 5, 36864, 202, 24, 4099, 202, 12288, 202,
    82, 45056, 202, 82, 32, 8194, 82, 4098, 202, 4097, 189, 3, 36864, 202, 24,
    4100, 202, 12288, 202, 82, 8196, 82, 4098, 202, 4097, 189, 3, 4100, 202,
    12288, 202, 82, 45056, 202, 82, 32, 8196, 82, 4098, 202, 4097, 189, 1,
    36864, 202, 24, 4100, 202, 45056, 202, 82, 32, 8194, 82, 12288, 101, 810,
    0, 82, 12288, 101, 810, 18, 82, 12288, 101, 810, 36, 82, 12288, 101, 810,
    54, 82, 4098, 202, 4097, 189, 1, 4100, 202, 12288, 91, 144, 0, 82, 12288,
    91, 144, 18, 82, 12288, 91, 144, 36, 82, 8193, 82, 12288, 101, 828, 0, 82,
    12288, 101, 828, 18, 82, 12288, 101, 828, 36, 82, 12288, 101, 828, 54, 82,
    4098, 202, 4097, 189, 0, 36864, 202, 24, 4098, 202, 12288, 202, 82, 45056,
    202, 82, 32, 8196, 82, 12288, 101, 846, 0, 82, 12288, 101, 846, 18, 82,
    12288, 101, 846, 36, 82, 12288, 101, 846, 54, 82, 4098, 202, 4097, 189, 0,
    4098, 202, 12288, 202, 82, 12288, 91, 162, 0, 82, 12288, 91, 162, 18, 82,
    12288, 91, 162, 36, 82, 8196, 82, 12288, 33, 18, 264, 82, 12288, 14, 378,
    0, 82, 12288, 14, 378, 18, 82, 4098, 202, 4097, 189, 0, 4098, 202, 12288,
    202, 82, 12288, 91, 162, 0, 82, 12288, 91, 162, 18, 82, 12288, 91, 162, 36,
    82, 8197, 82, 12288, 14, 396, 0, 82, 12288, 14, 396, 18, 82, 4098, 202,
    4097, 189, 0, 4098, 202, 12288, 202, 82, 12288, 91, 126, 0, 82, 12288, 91,
    126, 18, 82, 12288, 91, 126, 36, 82, 45056, 202, 82, 2072, 45058, 202, 82,
    2048, 45056, 202, 82, 2088, 8192, 82, 12288, 14, 414, 0, 82, 12288, 14,
    414, 18, 82, 4098, 202, 4097, 189, 0, 4098, 202, 12288, 202, 82, 8194, 82,
    45056, 202, 82, 2048, 24578, 21, 6400, 45056, 202, 82, 2048, 8194, 82,
    4098, 202, 4097, 189, 0, 4098, 202, 12288, 202, 82, 8194, 82, 45056, 202,
    82, 2048, 24578, 21, 6400, 45056, 202, 82, 2048, 8194, 82, 4098, 202, 4097,
    189, 0, 4098, 202, 12288, 202, 82, 8194, 82, 45056, 202, 82, 2048, 24578,
    21, 6400, 45056, 202, 82, 2048, 8194, 82, 4098, 202, 4097, 189, 0, 4098,
    202, 12288, 202, 82, 8194, 82, 45056, 202, 82, 2048, 24578, 21, 6400,
    45056, 202, 82, 2048, 8192, 82, 12288, 21, 468, 0, 82, 12288, 21, 468, 18,
    82, 4098, 202, 4097, 189, 0, 4098, 202, 12288, 202, 82, 8194, 82, 45056,
    202, 82, 2064, 45058, 202, 82, 2048, 45056, 202, 82, 2080, 8192, 82, 12288,
    21, 486, 0, 82, 12288, 21, 486, 18, 82, 4098, 202, 4097, 189, 0, 4098, 202,
    12288, 202, 82, 8197, 82, 12288, 104, 828, 0, 82, 12288, 104, 828, 18, 82,
    12288, 104, 828, 36, 82, 12288, 104, 828, 54, 82, 12288, 104, 828, 72, 82,
    4098, 202, 4097, 189, 0, 4098, 202, 12288, 202, 82, 8197, 82, 12288, 104,
    846, 0, 82, 12288, 104, 846, 18, 82, 12288, 104, 846, 36, 82, 12288, 104,
    846, 54, 82, 12288, 104, 846, 72, 82, 4098, 202, 4097, 189, 0, 4098, 202,
    12288, 202, 82, 8194, 82, 45056, 202, 82, 2072, 45058, 202, 82, 2048,
    45056, 202, 82, 2088, 12288, 305, 0, 0, 82, 12288, 305, 0, 18, 82, 12288,
    305, 0, 36, 82, 4098, 202, 4097, 189, 0, 4098, 202, 12288, 202, 82, 8194,
    82, 45056, 202, 82, 2048, 24578, 21, 6400, 45056, 202, 82, 2048, 12288,
    305, 18, 0, 82, 12288, 305, 18, 18, 82, 12288, 305, 18, 36, 82, 4098, 202,
    4097, 189, 0, 4098, 202, 12288, 202, 82, 8194, 82, 45056, 202, 82, 2048,
    24578, 21, 6400, 45056, 202, 82, 2048, 12288, 305, 36, 0, 82, 12288, 305,
    36, 18, 82, 12288, 305, 36, 36, 82, 4098, 202, 4097, 189, 0, 4098, 202,
    12288, 202, 82, 8194, 82, 45056, 202, 82, 2048, 24578, 21, 6400, 45056,
    202, 82, 2048, 8194, 82, 4098, 202, 4097, 189, 0, 4098, 202, 12288, 202,
    82, 8194, 82, 45056, 202, 82, 2048, 24578, 21, 6400, 45056, 202, 82, 2048,
    8194, 82, 4098, 202, 4097, 189, 0, 4098, 202, 12288, 202, 82, 12288, 91,
    144, 0, 82, 12288, 91, 144, 18, 82, 12288, 91, 144, 36, 82, 45056, 202, 82,
    2064, 45058, 202, 82, 2048, 45056, 202, 82, 2080, 8194, 82, 4098, 202,
    4097, 189, 0, 4098, 202, 12288, 202, 82, 12288, 91, 144, 0, 82, 12288, 91,
    144, 18, 82, 12288, 91, 144, 36, 82, 8198, 82, 12288, 18, 864, 0, 82, 4098,
    202, 4097, 189, 0, 4098, 202, 12288, 202, 82, 12288, 91, 126, 0, 82, 12288,
    91, 126, 18, 82, 12288, 91, 126, 36, 82, 8197, 82, 12288, 33, 18, 264, 82,
    12288, 18, 882, 0, 82, 4098, 202, 4097, 189, 0, 36864, 202, 16, 4098, 202,
    12288, 202, 82, 45056, 202, 82, 40, 8196, 82, 12288, 101, 810, 0, 82,
    12288, 101, 810, 18, 82, 12288, 101, 810, 36, 82, 12288, 101, 810, 54, 82,
    4098, 202, 4097, 189, 1, 4099, 202, 12288, 202, 82, 12288, 91, 162, 0, 82,
    12288, 91, 162, 18, 82, 12288, 91, 162, 36, 82, 8193, 82, 12288, 101, 828,
    0, 82, 12288, 101, 828, 18, 82, 12288, 101, 828, 36, 82, 12288, 101, 828,
    54, 82, 4098, 202, 4097, 189, 1, 36864, 202, 16, 4099, 202, 12288, 202, 82,
    45056, 202, 82, 40, 8194, 82, 12288, 101, 846, 0, 82, 12288, 101, 846, 18,
    82, 12288, 101, 846, 36, 82, 12288, 101, 846, 54, 82, 4098, 202, 4097, 189,
    3, 4100, 202, 12288, 202, 82, 45056, 202, 82, 40, 8196, 82, 4098, 202,
    4097, 189, 3, 36864, 202, 16, 4101, 202, 8196, 82, 4098, 202, 4097, 189, 5,
    36864, 202, 16, 4100, 202, 45056, 202, 82, 40, 8194, 82, 4098, 202, 4097,
    189, 7, 4100, 202, 8194, 82, 4098, 202, 4097, 189, 7, 36864, 202, 16, 4099,
    202, 4096, 10, 0, 486, 4096, 10, 36, 504, 4096, 10, 0, 522, 4098, 202,
    4097, 189, 10, 36864, 202, 16, 4096, 202, 2, 4098, 202, 4112, 189, 20482,
    189, 1, 4097, 189
},
// skyBox12
{
    2570, 4102, 189, 20482, 189, 1, 4096, 189, 6, 4096, 370, 4097, 189, 0,
    12289, 19, 90, 468, 182, 12290, 19, 36, 468, 182, 45056, 19, 144, 468, 182,
    24, 4096, 370, 4097, 189, 0, 45057, 19, 90, 468, 182, 8, 45057, 19, 450,
    468, 182, 24, 12288, 19, 0, 468, 182, 12288, 19, 216, 468, 182, 4096, 370,
    4097, 189, 0, 12288, 19, 36, 468, 182, 45056, 19, 144, 468, 182, 24, 12288,
    21, 468, 0, 182, 12288, 21, 468, 18, 182, 12288, 19, 0, 468, 182, 45056,
    19, 450, 468, 182, 24, 4096, 370, 4097, 189, 0, 12288, 19, 18, 468, 182,
    45056, 19, 180, 468, 182, 16, 12288, 21, 486, 0, 182, 12288, 21, 486, 18,
    182, 12288, 19, 0, 468, 182, 45056, 19, 468, 468, 182, 16, 4096, 370, 4097,
    189, 0, 45057, 19, 90, 468, 182, 8, 45057, 19, 468, 468, 182, 16, 12288,
    19, 0, 468, 182, 12288, 19, 234, 468, 182, 4096, 370, 4097, 189, 0, 12289,
    19, 90, 468, 182, 12290, 19, 18, 468, 182, 45056, 19, 180, 468, 182, 16,
    4096, 370, 4097, 189, 6, 4096, 370, 4103, 189, 20482, 189, 1
},
// skyBox13
{
    5136, 4108, 189, 20482, 189, 1, 4096, 189, 12, 4096, 45, 4097, 189, 11,
    4096, 18, 864, 0, 4096, 45, 4097, 189, 10, 4096, 33, 18, 264, 4096, 18,
    882, 0, 4096, 45, 4097, 189, 10, 4097, 202, 4096, 45, 4097, 189, 11, 4096,
    202, 4096, 45, 4097, 189, 11, 4096, 202, 4096, 45, 4097, 189, 7, 4096, 45,
    2, 4096, 202, 4096, 45, 4097, 189, 4, 36864, 45, 8, 4103, 45, 4097, 189, 0,
    20480, 105, 540, 216, 15, 20480, 105, 540, 234, 15, 20480, 105, 540, 252,
    15, 4096, 45, 32768, 1, 4102, 202, 4096, 45, 4097, 189, 0, 20480, 105, 558,
    216, 15, 20480, 105, 558, 234, 15, 20480, 105, 558, 252, 15, 4096, 45,
    32768, 1, 4102, 202, 4096, 45, 4097, 189, 4, 36864, 45, 8, 4103, 45, 4097,
    189, 7, 4096, 45, 2, 4096, 202, 4096, 45, 4097, 189, 11, 4096, 202, 4096,
    45, 4097, 189, 11, 4096, 202, 4096, 45, 4097, 189, 10, 4097, 202, 4096, 45,
    4097, 189, 10, 4096, 21, 468, 0, 4096, 21, 468, 18, 4096, 45, 4097, 189,
    10, 4096, 21, 486, 0, 4096, 21, 486, 18, 4096, 45, 4097, 189, 12, 4096, 45,
    4109, 189, 20482, 189, 1
},
// skyBox14
{
    3081, 4100, 189, 20483, 189, 1, 4096, 189, 0, 36864, 357, 24, 2, 4099, 189,
    0, 4096, 357, 36864, 350, 40, 2, 4098, 189, 0, 4096, 357, 4096, 350, 36864,
    350, 40, 2, 4097, 189, 0, 4096, 357, 4097, 350, 36864, 350, 40, 0, 36864,
    370, 24, 4097, 189, 4096, 21, 468, 0, 4096, 21, 468, 18, 4099, 350, 36864,
    370, 8, 4097, 189, 4096, 21, 486, 0, 4096, 21, 486, 18, 4099, 350, 36864,
    370, 8, 4097, 189, 0, 4096, 357, 4097, 350, 36864, 350, 32, 0, 36864, 370,
    16, 4097, 189, 0, 4096, 357, 4096, 350, 36864, 350, 32, 2, 4097, 189, 0,
    4096, 357, 36864, 350, 32, 2, 4098, 189, 0, 36864, 357, 16, 2, 4103, 189,
    20483, 189, 1
},
// skyBox15
{
    3084, 4105, 189, 20481, 189, 1, 4096, 189, 0, 36864, 202, 24, 4099, 202,
    4096, 10, 36, 1782, 4096, 10, 0, 1800, 4096, 10, 36, 1818, 4096, 370, 4097,
    189, 0, 4096, 202, 12288, 202, 82, 8197, 82, 4096, 370, 4097, 189, 0, 4096,
    202, 45056, 202, 82, 40, 8197, 82, 4096, 370, 4097, 189, 0, 4096, 202,
    8194, 82, 12288, 19, 36, 486, 82, 8193, 82, 45056, 370, 82, 8, 4096, 370,
    4097, 189, 0, 4096, 202, 45056, 202, 82, 32, 12288, 21, 468, 0, 82, 12288,
    21, 468, 18, 82, 12288, 19, 0, 486, 82, 8193, 82, 12288, 370, 82, 4096,
    370, 4097, 189, 0, 4096, 202, 45056, 202, 82, 40, 12288, 21, 486, 0, 82,
    12288, 21, 486, 18, 82, 12288, 19, 0, 486, 82, 8193, 82, 12288, 370, 82,
    4096, 370, 4097, 189, 0, 4096, 202, 8194, 82, 12288, 19, 18, 486, 82, 8193,
    82, 45056, 370, 82, 8, 4096, 370, 4097, 189, 0, 4096, 202, 45056, 202, 82,
    32, 8197, 82, 4096, 370, 4097, 189, 0, 4096, 202, 12288, 202, 82, 8197, 82,
    4096, 370, 4097, 189, 0, 36864, 202, 16, 4099, 202, 4096, 10, 36, 1782,
    4096, 10, 0, 1800, 4096, 10, 0, 1818, 4096, 370, 4106, 189, 20481, 189, 1
},
// skyBox16
{
    5132, 4103, 189, 20482, 189, 1, 4109, 189, 4097, 202, 5, 4099, 189, 4096,
    202, 8198, 82, 4096, 45, 4098, 189, 4096, 202, 8198, 82, 4096, 45, 4098,
    189, 4096, 202, 8192, 82, 12288, 100, 36, 0, 82, 12288, 100, 36, 18, 82,
    12288, 19, 36, 558, 82, 8194, 82, 4097, 45, 4097, 189, 4096, 202, 8192, 82,
    12288, 100, 54, 0, 82, 12288, 100, 54, 18, 82, 12288, 19, 18, 558, 82,
    8192, 82, 12288, 172, 0, 608, 82, 12288, 172, 0, 626, 82, 4097, 45, 4097,
    189, 4096, 202, 8196, 82, 12288, 172, 18, 608, 82, 12288, 172, 18, 626, 82,
    4097, 45, 4097, 189, 4096, 202, 8192, 82, 8193, 90, 8193, 82, 12288, 90, 0,
    936, 82, 12288, 90, 0, 954, 82, 4097, 45, 4097, 189, 4096, 202, 8192, 82,
    8193, 90, 8193, 82, 12288, 90, 18, 936, 82, 12288, 90, 18, 954, 82, 4097,
    45, 4097, 189, 4096, 202, 8192, 82, 8193, 90, 8193, 82, 12288, 90, 36, 936,
    82, 12288, 90, 36, 954, 82, 4097, 45, 4097, 189, 4096, 202, 8192, 82, 8193,
    90, 8193, 82, 12288, 90, 54, 936, 82, 12288, 90, 54, 954, 82, 4097, 45,
    4097, 189, 4096, 202, 8196, 82, 12288, 172, 0, 608, 82, 12288, 172, 0, 626,
    82, 4097, 45, 4097, 189, 4096, 202, 8192, 82, 12288, 21, 468, 0, 82, 12288,
    21, 468, 18, 82, 12288, 19, 36, 558, 82, 8192, 82, 12288, 172, 18, 608, 82,
    12288, 172, 18, 626, 82, 4097, 45, 4097, 189, 4096, 202, 8192, 82, 12288,
    21, 486, 0, 82, 12288, 21, 486, 18, 82, 12288, 19, 18, 558, 82, 8194, 82,
    4097, 45, 4097, 189, 4096, 202, 8198, 82, 4096, 45, 4098, 189, 4096, 202,
    8198, 82, 4096, 45, 4098, 189, 4097, 202, 5, 4118, 189, 20482, 189, 1,
    4096, 189
},
// skyBox17
{
    3594, 4103, 189, 20481, 189, 1, 4096, 189, 4099, 202, 4096, 10, 36, 1134,
    4096, 10, 18, 1152, 4096, 10, 18, 1170, 4096, 202, 4097, 189, 4096, 202,
    8197, 182, 4096, 202, 4097, 189, 4096, 202, 8195, 182, 12288, 21, 468, 0,
    182, 12288, 21, 468, 18, 182, 4096, 202, 4097, 189, 4096, 202, 8195, 182,
    12288, 21, 486, 0, 182, 12288, 21, 486, 18, 182, 4096, 202, 4097, 189,
    4096, 202, 8194, 182, 12288, 33, 18, 0, 182, 12288, 87, 756, 0, 182, 12288,
    87, 756, 18, 182, 4096, 202, 4097, 189, 4096, 202, 8195, 182, 12288, 87,
    774, 0, 182, 12288, 87, 774, 18, 182, 4096, 202, 4097, 189, 4096, 202,
    8192, 182, 12288, 246, 0, 108, 182, 12288, 246, 0, 126, 182, 8192, 182,
    12288, 87, 792, 0, 182, 12288, 87, 792, 18, 182, 4096, 202, 4097, 189,
    4096, 202, 8192, 182, 12288, 246, 18, 108, 182, 12288, 246, 18, 126, 182,
    8193, 182, 12288, 18, 864, 0, 182, 4096, 202, 4097, 189, 4096, 202, 8192,
    182, 12288, 246, 36, 108, 182, 12288, 246, 36, 126, 182, 8193, 182, 12288,
    18, 882, 0, 182, 4096, 202, 4097, 189, 4096, 202, 8197, 182, 4096, 202,
    4097, 189, 4096, 202, 8197, 182, 4096, 202, 4097, 189, 4099, 202, 4096, 10,
    36, 1134, 4096, 10, 0, 1152, 4096, 10, 0, 1170, 4096, 202, 4104, 189,
    20481, 189, 1
},
// skyBox18
{
    6157, 4104, 189, 20483, 189, 1, 4096, 189, 0, 36864, 202, 24, 4097, 202, 4,
    4099, 189, 0, 4096, 202, 36864, 202, 24, 36864, 202, 32, 5, 4098, 189, 0,
    36864, 202, 8, 36864, 202, 32, 6, 4098, 189, 0, 4096, 202, 7, 4096, 202,
    4097, 189, 0, 4096, 202, 3, 4096, 305, 0, 0, 4096, 305, 0, 18, 4096, 305,
    0, 36, 4097, 202, 4097, 189, 0, 4096, 202, 24579, 82, 2048, 28672, 305, 18,
    0, 82, 2048, 28672, 305, 18, 18, 82, 2048, 28672, 305, 18, 36, 82, 2048,
    4097, 202, 4097, 189, 0, 4096, 202, 24579, 82, 2048, 28672, 305, 36, 0, 82,
    2048, 28672, 305, 36, 18, 82, 2048, 28672, 305, 36, 36, 82, 2048, 4097,
    202, 4097, 189, 0, 4096, 202, 6, 4097, 202, 4097, 189, 0, 4096, 202, 7,
    4096, 202, 4097, 189, 0, 4096, 202, 6, 4097, 202, 4097, 189, 0, 4096, 202,
    24580, 82, 2048, 28672, 21, 468, 0, 82, 2048, 28672, 21, 468, 18, 82, 2048,
    4097, 202, 4097, 189, 0, 4096, 202, 24580, 82, 2048, 28672, 21, 486, 0, 82,
    2048, 28672, 21, 486, 18, 82, 2048, 4097, 202, 4097, 189, 0, 4096, 202, 6,
    4097, 202, 4097, 189, 0, 4096, 202, 7, 4096, 202, 4097, 189, 0, 4096, 202,
    6, 4097, 202, 4097, 189, 0, 4096, 202, 24578, 82, 2048, 28672, 101, 810, 0,
    82, 2048, 28672, 101, 810, 18, 82, 2048, 28672, 101, 810, 36, 82, 2048,
    28672, 101, 810, 54, 82, 2048, 4097, 202, 4097, 189, 0, 4096, 202, 24578,
    82, 2048, 28672, 101, 828, 0, 82, 2048, 28672, 101, 828, 18, 82, 2048,
    28672, 101, 828, 36, 82, 2048, 28672, 101, 828, 54, 82, 2048, 4097, 202,
    4097, 189, 0, 4096, 202, 2, 4096, 101, 846, 0, 4096, 101, 846, 18, 4096,
    101, 846, 36, 4096, 101, 846, 54, 4097, 202, 4097, 189, 0, 4096, 202, 7,
    4096, 202, 4097, 189, 0, 36864, 202, 8, 36864, 202, 40, 6, 4098, 189, 0,
    4096, 202, 36864, 202, 16, 36864, 202, 40, 5, 4098, 189, 0, 36864, 202, 16,
    4097, 202, 4, 4107, 189, 20483, 189, 1
},
// skyBox19
{
    4111, 4107, 189, 20482, 189, 1, 4096, 189, 3, 4096, 202, 6, 4098, 189, 3,
    4096, 202, 8198, 182, 4096, 202, 4097, 189, 3, 4096, 202, 8197, 182, 45056,
    202, 182, 8, 4096, 202, 4097, 189, 3, 4096, 202, 8196, 182, 45056, 202,
    182, 8, 12288, 202, 182, 4096, 202, 4097, 189, 0, 36864, 202, 24, 4098,
    202, 8195, 182, 45056, 202, 182, 8, 12289, 202, 182, 4096, 202, 4097, 189,
    0, 4096, 202, 8193, 90, 12288, 19, 54, 396, 182, 8194, 182, 45056, 202,
    182, 8, 12290, 202, 182, 4096, 202, 4097, 189, 0, 4096, 202, 12288, 100, 0,
    396, 90, 12288, 100, 0, 414, 90, 12288, 19, 0, 396, 182, 8192, 182, 12288,
    21, 468, 0, 182, 12288, 21, 468, 18, 182, 12291, 202, 182, 4096, 202, 4097,
    189, 0, 4096, 202, 12288, 100, 18, 396, 90, 12288, 100, 18, 414, 90, 12288,
    19, 0, 396, 182, 8192, 182, 12288, 21, 486, 0, 182, 12288, 21, 486, 18,
    182, 12291, 202, 182, 4096, 202, 4097, 189, 0, 4096, 202, 8193, 90, 12288,
    19, 72, 396, 182, 8194, 182, 45056, 202, 182, 8, 12290, 202, 182, 4096,
    202, 4097, 189, 0, 36864, 202, 16, 4098, 202, 8195, 182, 45056, 202, 182,
    8, 12289, 202, 182, 4096, 202, 4097, 189, 3, 4096, 202, 8196, 182, 45056,
    202, 182, 8, 12288, 202, 182, 4096, 202, 4097, 189, 3, 4096, 202, 8197,
    182, 45056, 202, 182, 8, 4096, 202, 4097, 189, 3, 4096, 202, 8198, 182,
    4096, 202, 4097, 189, 3, 4096, 202, 6, 4109, 189, 20482, 189, 1
},
// skyBox20
{
    6418, 4105, 189, 20487, 189, 1, 4096, 189, 4111, 202, 4097, 189, 4098, 202,
    4096, 54, 4098, 202, 4096, 54, 4098, 202, 4096, 54, 4099, 202, 4097, 189,
    4096, 202, 4096, 54, 4098, 202, 4096, 54, 4098, 202, 4096, 54, 4098, 202,
    4096, 54, 4097, 202, 4097, 189, 4111, 202, 4097, 189, 4096, 202, 4096, 54,
    4096, 202, 8196, 132, 12288, 305, 0, 0, 132, 12288, 305, 0, 18, 132, 12288,
    305, 0, 36, 132, 4098, 202, 4096, 54, 4096, 202, 4097, 189, 4098, 202,
    8196, 132, 12288, 305, 18, 0, 132, 12288, 305, 18, 18, 132, 12288, 305, 18,
    36, 132, 4100, 202, 4097, 189, 4096, 202, 4096, 54, 4096, 202, 8196, 132,
    12288, 305, 36, 0, 132, 12288, 305, 36, 18, 132, 12288, 305, 36, 36, 132,
    4097, 202, 4096, 54, 4097, 202, 4097, 189, 4098, 202, 8199, 132, 4100, 202,
    4097, 189, 4096, 202, 4096, 54, 4096, 202, 8192, 132, 12288, 242, 216, 0,
    132, 12288, 242, 216, 18, 132, 12288, 242, 216, 36, 132, 12288, 242, 216,
    54, 132, 8194, 132, 4096, 202, 4096, 54, 4098, 202, 4097, 189, 4098, 202,
    8192, 132, 12288, 242, 234, 0, 132, 12288, 242, 234, 18, 132, 12288, 242,
    234, 36, 132, 12288, 242, 234, 54, 132, 8194, 132, 4100, 202, 4097, 189,
    4096, 202, 4096, 54, 4096, 202, 8192, 132, 12288, 242, 252, 0, 132, 12288,
    242, 252, 18, 132, 12288, 242, 252, 36, 132, 12288, 242, 252, 54, 132,
    8194, 132, 4097, 202, 4096, 54, 4097, 202, 4097, 189, 4098, 202, 8192, 132,
    12288, 242, 270, 0, 132, 12288, 242, 270, 18, 132, 12288, 242, 270, 36,
    132, 12288, 242, 270, 54, 132, 8194, 132, 4100, 202, 4097, 189, 4096, 202,
    4096, 54, 4096, 202, 8192, 132, 12288, 242, 288, 0, 132, 12288, 242, 288,
    18, 132, 12288, 242, 288, 36, 132, 12288, 242, 288, 54, 132, 8194, 132,
    4098, 202, 4096, 54, 4096, 202, 4097, 189, 4098, 202, 8192, 132, 12288,
    242, 306, 0, 132, 12288, 242, 306, 18, 132, 12288, 242, 306, 36, 132,
    12288, 242, 306, 54, 132, 8194, 132, 4100, 202, 4097, 189, 4096, 202, 4096,
    54, 4096, 202, 8197, 132, 12288, 21, 468, 0, 132, 12288, 21, 468, 18, 132,
    4097, 202, 4096, 54, 4097, 202, 4097, 189, 4098, 202, 8197, 132, 12288, 21,
    486, 0, 132, 12288, 21, 486, 18, 132, 4100, 202, 4097, 189, 4098, 202, 7,
    4096, 202, 4096, 54, 4098, 202, 4097, 189, 10, 36864, 202, 8, 4099, 202,
    4097, 189, 11, 4096, 202, 4096, 54, 4097, 202, 4097, 189, 11, 36864, 202,
    8, 4098, 202, 4097, 189, 12, 4096, 202, 4096, 54, 4096, 202, 4097, 189, 12,
    36864, 202, 8, 4097, 202, 4097, 189, 13, 4097, 202, 4110, 189, 20482, 189,
    1, 4096, 189
},
// skyBox21
{
    4624, 4107, 189, 20483, 189, 1, 4096, 189, 0, 36864, 202, 24, 4101, 202,
    4096, 10, 18, 1728, 4096, 10, 18, 1746, 4096, 10, 0, 1764, 4098, 202, 4097,
    189, 0, 4096, 202, 4100, 370, 4096, 202, 8194, 47, 4096, 202, 4096, 370,
    4096, 202, 4097, 189, 0, 4096, 202, 4096, 370, 4100, 202, 8194, 47, 4096,
    202, 4096, 370, 4096, 202, 4097, 189, 0, 4096, 202, 4096, 370, 4096, 202,
    12288, 305, 0, 0, 47, 12288, 305, 0, 18, 47, 12288, 305, 0, 36, 47, 12288,
    19, 54, 252, 47, 8194, 47, 4096, 202, 4096, 370, 4096, 202, 4097, 189, 0,
    4096, 202, 4096, 370, 4096, 202, 12288, 305, 18, 0, 47, 12288, 305, 18, 18,
    47, 12288, 305, 18, 36, 47, 12288, 19, 0, 252, 47, 8194, 47, 4096, 202,
    4096, 370, 4096, 202, 4097, 189, 0, 4096, 202, 4096, 370, 4096, 202, 12288,
    305, 36, 0, 47, 12288, 305, 36, 18, 47, 12288, 305, 36, 36, 47, 12288, 19,
    18, 252, 47, 8194, 47, 4096, 202, 4096, 370, 4096, 202, 4097, 189, 0, 4096,
    202, 4096, 370, 4096, 202, 8198, 47, 4096, 202, 4096, 370, 4096, 202, 4097,
    189, 0, 4096, 202, 4096, 370, 4096, 202, 8192, 47, 45056, 19, 36, 396, 47,
    8, 8193, 241, 12288, 19, 36, 396, 47, 8193, 47, 4096, 202, 4096, 370, 4096,
    202, 4097, 189, 0, 4096, 202, 4096, 370, 4096, 202, 8192, 47, 45056, 19, 0,
    396, 47, 8, 8193, 241, 12288, 19, 0, 396, 47, 8193, 47, 4096, 202, 4096,
    370, 4096, 202, 4097, 189, 0, 4096, 202, 4096, 370, 4096, 202, 8192, 47,
    45056, 19, 18, 396, 47, 8, 8193, 241, 12288, 19, 18, 396, 47, 8193, 47,
    4096, 202, 4096, 370, 4096, 202, 4097, 189, 0, 4096, 202, 4096, 370, 4096,
    202, 8198, 47, 4096, 202, 4096, 370, 4096, 202, 4097, 189, 0, 4096, 202,
    4096, 370, 4096, 202, 8195, 47, 12288, 21, 468, 0, 47, 12288, 21, 468, 18,
    47, 12288, 19, 36, 252, 47, 4096, 202, 4096, 370, 4096, 202, 4097, 189, 0,
    4096, 202, 4096, 370, 4096, 202, 8195, 47, 12288, 21, 486, 0, 47, 12288,
    21, 486, 18, 47, 12288, 19, 72, 252, 47, 4096, 202, 4096, 370, 4096, 202,
    4097, 189, 0, 4096, 202, 4096, 370, 4104, 202, 4096, 370, 4096, 202, 4097,
    189, 0, 4096, 202, 4106, 370, 4096, 202, 4097, 189, 0, 36864, 202, 16,
    4107, 202, 4105, 189, 20486, 189, 1
},
// skyBox22
{
    5901, 4106, 189, 20481, 189, 1, 4096, 189, 4096, 357, 36864, 357, 40, 6,
    36864, 357, 24, 4096, 357, 4097, 189, 4097, 357, 4102, 561, 4097, 357,
    4097, 189, 4097, 357, 8198, 183, 4097, 357, 4097, 189, 4097, 357, 8198,
    183, 4097, 357, 4097, 189, 4097, 357, 12294, 561, 183, 4097, 357, 4097,
    189, 4097, 357, 8198, 183, 4097, 357, 4097, 189, 4097, 357, 8198, 183,
    4097, 357, 4097, 189, 4097, 357, 12294, 561, 183, 4097, 357, 4097, 189,
    4097, 357, 8196, 183, 12288, 21, 468, 0, 183, 12288, 21, 468, 18, 183,
    4097, 357, 4097, 189, 4097, 357, 8196, 183, 12288, 21, 486, 0, 183, 12288,
    21, 486, 18, 183, 4097, 357, 4097, 189, 4097, 357, 12294, 561, 183, 4097,
    357, 4097, 189, 4096, 37, 4096, 357, 8195, 183, 12288, 93, 0, 486, 183,
    12288, 93, 0, 504, 183, 12288, 93, 0, 522, 183, 4097, 357, 4097, 189,
    36864, 37, 8, 45056, 37, 262, 32, 8192, 262, 8196, 183, 12288, 649, 0, 18,
    183, 4097, 357, 4097, 189, 1, 8193, 262, 8195, 183, 12288, 649, 18, 18,
    183, 4097, 37, 4097, 189, 2, 8193, 262, 8195, 183, 45056, 37, 262, 8, 4096,
    37, 4097, 189, 2, 8192, 262, 8194, 183, 12288, 648, 540, 36, 183, 12288,
    648, 540, 54, 183, 4096, 37, 4096, 357, 4097, 189, 36864, 37, 24, 12288,
    37, 262, 8192, 262, 8195, 183, 12288, 648, 558, 36, 183, 12288, 648, 558,
    54, 183, 4097, 357, 4097, 189, 4096, 37, 4096, 357, 8196, 183, 12288, 648,
    576, 36, 183, 12288, 648, 576, 54, 183, 4097, 357, 4097, 189, 4097, 357,
    8198, 183, 4097, 357, 4097, 189, 4097, 357, 4102, 561, 4097, 357, 4097,
    189, 4096, 357, 36864, 357, 32, 6, 36864, 357, 16, 4096, 357, 4107, 189,
    20481, 189, 1
},
// skyBox23
{
    2323, 4109, 189, 20483, 189, 1, 4097, 189, 3, 36864, 202, 8, 4107, 202,
    4097, 189, 3, 4097, 202, 12288, 202, 90, 4097, 202, 12288, 202, 90, 4102,
    202, 4097, 189, 0, 20480, 406, 0, 0, 14, 20480, 406, 0, 18, 14, 20480, 406,
    0, 36, 14, 4096, 202, 12288, 202, 89, 8193, 89, 12288, 21, 468, 0, 90,
    12288, 21, 468, 18, 90, 12288, 19, 54, 522, 90, 8192, 89, 12288, 305, 0, 0,
    89, 12288, 305, 0, 18, 89, 12288, 305, 0, 36, 89, 4097, 202, 4097, 189, 0,
    20480, 406, 18, 0, 14, 20480, 406, 18, 18, 14, 20480, 406, 18, 36, 14,
    4096, 202, 12288, 202, 89, 8193, 89, 12288, 21, 486, 0, 90, 12288, 21, 486,
    18, 90, 12288, 19, 18, 522, 90, 8192, 89, 12288, 305, 18, 0, 89, 12288,
    305, 18, 18, 89, 12288, 305, 18, 36, 89, 4097, 202, 4097, 189, 0, 20480,
    406, 36, 0, 14, 20480, 406, 36, 18, 14, 20480, 406, 36, 36, 14, 4096, 202,
    12288, 202, 89, 8197, 89, 12288, 305, 36, 0, 89, 12288, 305, 36, 18, 89,
    12288, 305, 36, 36, 89, 4097, 202, 4097, 189, 3, 4103, 202, 8194, 90, 4097,
    202, 4097, 189, 3, 36864, 202, 8, 4102, 202, 4096, 10, 36, 1890, 4096, 10,
    0, 1908, 4096, 10, 36, 1926, 4097, 202, 4112, 189, 20482, 189, 1
},
// skyBox24
{
    5135, 4107, 189, 20482, 189, 1, 4096, 189, 11, 4096, 357, 4097, 189, 10,
    4097, 357, 4097, 189, 1, 53248, 202, 26, 24, 20483, 202, 26, 53248, 202,
    26, 40, 2, 4097, 357, 4097, 189, 1, 20485, 202, 26, 20480, 10, 0, 486, 26,
    20480, 10, 36, 504, 26, 20480, 10, 36, 522, 26, 4097, 357, 4097, 189, 1,
    20481, 202, 26, 24582, 82, 6656, 4097, 357, 4097, 189, 1, 20481, 202, 26,
    24580, 82, 6656, 28672, 79, 72, 612, 82, 6656, 28672, 79, 72, 630, 82,
    6656, 4097, 357, 4097, 189, 1, 20481, 202, 26, 24580, 82, 6656, 28672, 79,
    90, 612, 82, 6656, 28672, 79, 90, 630, 82, 6656, 4097, 357, 4097, 189, 1,
    20481, 202, 26, 24580, 82, 6656, 28672, 79, 108, 612, 82, 6656, 28672, 79,
    108, 630, 82, 6656, 4097, 357, 4097, 189, 1, 20481, 202, 26, 24580, 82,
    6656, 28672, 79, 126, 612, 82, 6656, 28672, 79, 126, 630, 82, 6656, 4097,
    357, 4097, 189, 1, 20481, 202, 26, 24578, 82, 6656, 28672, 19, 36, 396, 82,
    6656, 24576, 82, 6656, 28672, 21, 468, 0, 82, 6656, 28672, 21, 468, 18, 82,
    6656, 4097, 357, 4097, 189, 1, 20481, 202, 26, 24577, 82, 6656, 28672, 33,
    18, 352, 82, 6656, 28672, 19, 18, 396, 82, 6656, 24576, 82, 6656, 28672,
    21, 486, 0, 82, 6656, 28672, 21, 486, 18, 82, 6656, 4097, 357, 4097, 189,
    1, 20481, 202, 26, 24582, 82, 6656, 4097, 357, 4097, 189, 1, 20481, 202,
    26, 24582, 82, 6656, 4097, 357, 4097, 189, 1, 20481, 202, 26, 24582, 82,
    6656, 4097, 357, 4097, 189, 1, 20485, 202, 26, 20480, 10, 18, 486, 26,
    20480, 10, 18, 504, 26, 20480, 10, 18, 522, 26, 4097, 357, 4097, 189, 1,
    53248, 202, 26, 16, 20483, 202, 26, 53248, 202, 26, 32, 2, 4097, 357, 4097,
    189, 10, 4097, 357, 4097, 189, 11, 4096, 357, 4108, 189, 20482, 189, 1
},
// skyBox25
{
    3083, 4104, 189, 20481, 189, 1, 4096, 189, 6, 4097, 370, 4097, 189, 6,
    32768, 1, 4096, 370, 4097, 189, 2, 36864, 370, 8, 4096, 370, 1, 32768, 1,
    4096, 370, 4097, 189, 2, 32768, 1, 4096, 370, 1, 32768, 1, 4096, 370, 4097,
    189, 0, 4096, 21, 468, 0, 4096, 21, 468, 18, 4101, 370, 4097, 189, 0, 4096,
    21, 486, 0, 4096, 21, 486, 18, 4101, 370, 4097, 189, 2, 32768, 1, 4096,
    370, 1, 32768, 1, 4096, 370, 4097, 189, 2, 36864, 370, 8, 4096, 370, 1,
    32768, 1, 4096, 370, 4097, 189, 6, 32768, 1, 4096, 370, 4097, 189, 6, 4097,
    370, 4105, 189, 20481, 189, 1
},
// skyBox26
{
    3591, 4099, 189, 20482, 189, 1, 4096, 189, 3, 4098, 189, 4, 4097, 189, 4,
    4097, 189, 2, 36864, 565, 0, 0, 4096, 36864, 565, 0, 18, 4096, 4097, 189,
    2, 36864, 565, 18, 0, 4096, 36864, 565, 18, 18, 4096, 4097, 189, 1, 8194,
    145, 4097, 189, 2, 12288, 21, 468, 0, 145, 12288, 21, 468, 18, 145, 4097,
    189, 2, 12288, 21, 486, 0, 145, 12288, 21, 486, 18, 145, 4097, 189, 1,
    4096, 305, 0, 0, 12288, 305, 0, 18, 145, 12288, 305, 0, 36, 145, 4097, 189,
    1, 4096, 305, 18, 0, 12288, 305, 18, 18, 145, 12288, 305, 18, 36, 145,
    4097, 189, 1, 12288, 305, 36, 0, 145, 12288, 305, 36, 18, 145, 12288, 305,
    36, 36, 145, 4097, 189, 3, 4101, 189, 20482, 189, 1
},
// skyBox27
{
    4370, 4109, 189, 20483, 189, 1, 4096, 189, 2, 4096, 158, 45056, 158, 139,
    40, 8192, 139, 7, 4099, 189, 2, 4098, 158, 7, 4096, 189, 4096, 158, 4097,
    189, 1, 36864, 158, 8, 4096, 158, 4102, 357, 4096, 10, 36, 1782, 4096, 10,
    36, 1800, 4096, 10, 0, 1818, 4097, 158, 4097, 189, 1, 4097, 158, 4096, 357,
    8200, 182, 4097, 158, 4097, 189, 1, 4097, 158, 4096, 357, 8192, 82, 8192,
    241, 8198, 82, 4097, 158, 4097, 189, 1, 4097, 158, 4096, 357, 8192, 182,
    8192, 88, 8196, 182, 12288, 21, 468, 0, 182, 12288, 21, 468, 18, 182, 4097,
    158, 4097, 189, 0, 36864, 158, 8, 4097, 158, 4096, 357, 8192, 182, 8192,
    88, 8196, 182, 12288, 21, 486, 0, 182, 12288, 21, 486, 18, 182, 4097, 158,
    4097, 189, 0, 4098, 158, 4096, 357, 8192, 82, 8192, 241, 8198, 82, 4097,
    158, 4097, 189, 0, 36864, 158, 8, 4097, 158, 4096, 357, 8192, 182, 8192,
    88, 8197, 182, 12288, 18, 864, 0, 182, 4097, 158, 4097, 189, 1, 4097, 158,
    4096, 357, 8192, 182, 8192, 88, 8196, 182, 12288, 33, 18, 264, 182, 12288,
    18, 882, 0, 182, 4097, 158, 4097, 189, 1, 4097, 158, 4096, 357, 8192, 82,
    8192, 241, 8198, 82, 4097, 158, 4097, 189, 1, 4097, 158, 4096, 357, 8200,
    182, 4097, 158, 4097, 189, 1, 36864, 158, 8, 4096, 158, 4102, 357, 4096,
    10, 18, 1782, 4096, 10, 0, 1800, 4096, 10, 18, 1818, 4097, 158, 4097, 189,
    2, 4098, 158, 7, 4096, 189, 4096, 158, 4097, 189, 2, 4096, 158, 45056, 158,
    139, 32, 8192, 139, 7, 4112, 189, 20483, 189, 1
},
// skyBox28
{
    4879, 4105, 189, 20483, 189, 1, 4097, 189, 0, 36864, 202, 24, 4106, 202,
    4097, 189, 0, 4107, 202, 4097, 189, 0, 4097, 202, 8199, 82, 4097, 202,
    4097, 189, 0, 4097, 202, 12295, 577, 82, 4097, 202, 4097, 189, 0, 4097,
    202, 8196, 82, 12288, 305, 0, 0, 82, 12288, 305, 0, 18, 82, 12288, 305, 0,
    36, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8193, 82, 8192, 21, 12288, 83,
    36, 0, 21, 12288, 380, 0, 72, 82, 12288, 305, 18, 0, 82, 12288, 305, 18,
    18, 82, 12288, 305, 18, 36, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8193,
    82, 8192, 21, 12288, 83, 36, 0, 21, 12288, 380, 36, 72, 82, 12288, 305, 36,
    0, 82, 12288, 305, 36, 18, 82, 12288, 305, 36, 36, 82, 4097, 202, 4097,
    189, 0, 4097, 202, 8199, 82, 4097, 202, 4097, 189, 0, 4097, 202, 12295,
    577, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8199, 82, 4097, 202, 4097,
    189, 0, 4097, 202, 8194, 82, 8192, 21, 12288, 83, 18, 0, 21, 12288, 380, 0,
    18, 82, 8193, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8194, 82, 8192, 21,
    12288, 83, 18, 0, 21, 12288, 380, 36, 18, 82, 12288, 21, 468, 0, 82, 12288,
    21, 468, 18, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8197, 82, 12288, 21,
    486, 0, 82, 12288, 21, 486, 18, 82, 4097, 202, 4097, 189, 0, 4097, 202,
    12295, 577, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8199, 82, 4097, 202,
    4097, 189, 0, 4101, 202, 45056, 202, 82, 40, 8194, 82, 4097, 202, 4097,
    189, 0, 36864, 202, 16, 4101, 202, 4096, 10, 54, 378, 4096, 10, 90, 396,
    4096, 10, 54, 414, 4097, 202, 4108, 189, 20482, 189, 1
},
// skyBox29
{
    5906, 4109, 189, 20483, 189, 1, 4096, 189, 13, 4096, 189, 4096, 202, 4097,
    189, 13, 4097, 202, 4097, 189, 0, 36864, 202, 24, 4104, 202, 4096, 10, 0,
    486, 4096, 10, 36, 504, 4096, 10, 0, 522, 4097, 202, 4097, 189, 0, 4104,
    202, 45056, 202, 82, 32, 8194, 82, 4097, 202, 4097, 189, 0, 4097, 202,
    8202, 82, 4097, 202, 4097, 189, 0, 4097, 202, 24586, 313, 3584, 4097, 202,
    4097, 189, 0, 4097, 202, 12288, 34, 54, 810, 82, 12288, 34, 54, 828, 82,
    12288, 34, 54, 846, 82, 8193, 82, 45056, 19, 36, 180, 82, 8, 8192, 21,
    12288, 83, 54, 0, 21, 12288, 380, 0, 36, 82, 8193, 82, 4097, 202, 4097,
    189, 0, 4097, 202, 12288, 34, 72, 810, 82, 12288, 34, 72, 828, 82, 12288,
    34, 72, 846, 82, 8193, 82, 45056, 19, 0, 180, 82, 8, 8192, 21, 12288, 83,
    54, 0, 21, 12288, 380, 18, 36, 82, 8193, 82, 4097, 202, 4097, 189, 0, 4097,
    202, 12288, 34, 90, 810, 82, 12288, 34, 90, 828, 82, 12288, 34, 90, 846,
    82, 8193, 82, 45056, 19, 0, 180, 82, 8, 8192, 21, 12288, 83, 54, 0, 21,
    12288, 380, 18, 36, 82, 8193, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8196,
    82, 45056, 19, 0, 180, 82, 8, 8192, 21, 12288, 83, 54, 0, 21, 12288, 380,
    18, 36, 82, 8193, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8192, 82, 45056,
    19, 36, 180, 82, 8, 8192, 21, 12288, 83, 90, 0, 21, 12288, 380, 0, 126, 82,
    45056, 19, 18, 180, 82, 8, 8192, 21, 12288, 83, 54, 0, 21, 12288, 380, 36,
    36, 82, 12288, 21, 468, 0, 82, 12288, 21, 468, 18, 82, 4097, 202, 4097,
    189, 0, 4097, 202, 8192, 82, 45056, 19, 0, 180, 82, 8, 8192, 21, 12288, 83,
    90, 0, 21, 12288, 380, 18, 126, 82, 8195, 82, 12288, 21, 486, 0, 82, 12288,
    21, 486, 18, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8192, 82, 45056, 19,
    0, 180, 82, 8, 8192, 21, 12288, 83, 90, 0, 21, 12288, 380, 18, 126, 82,
    12288, 548, 432, 0, 82, 12288, 548, 432, 18, 82, 12288, 548, 432, 36, 82,
    12288, 548, 432, 54, 82, 12288, 548, 432, 72, 82, 12288, 548, 432, 90, 82,
    4097, 202, 4097, 189, 0, 4097, 202, 8192, 82, 45056, 19, 0, 180, 82, 8,
    8192, 21, 12288, 83, 90, 0, 21, 12288, 380, 18, 126, 82, 12288, 548, 450,
    0, 82, 12288, 548, 450, 18, 82, 12288, 548, 450, 36, 82, 12288, 548, 450,
    54, 82, 12288, 548, 450, 72, 82, 12288, 548, 450, 90, 82, 4097, 202, 4097,
    189, 0, 4097, 202, 8192, 82, 45056, 19, 18, 180, 82, 8, 8192, 21, 12288,
    83, 90, 0, 21, 12288, 380, 36, 126, 82, 12288, 548, 468, 0, 82, 12288, 548,
    468, 18, 82, 12288, 548, 468, 36, 82, 12288, 548, 468, 54, 82, 12288, 548,
    468, 72, 82, 12288, 548, 468, 90, 82, 4097, 202, 4097, 189, 0, 4097, 202,
    24586, 313, 3584, 4097, 202, 4097, 189, 0, 4097, 202, 8202, 82, 4097, 202,
    4097, 189, 0, 4104, 202, 45056, 202, 82, 40, 8194, 82, 4097, 202, 4097,
    189, 0, 36864, 202, 16, 4104, 202, 4096, 10, 0, 486, 4096, 10, 18, 504,
    4096, 10, 18, 522, 4097, 202, 4097, 189, 13, 4097, 202, 4097, 189, 13,
    4096, 189, 4096, 202, 4110, 189, 20483, 189, 1
},
// skyBox30
{
    5134, 4106, 189, 20482, 189, 1, 4096, 189, 10, 4098, 189, 5, 4096, 202, 2,
    8192, 82, 4096, 357, 4097, 189, 0, 4101, 202, 12288, 10, 18, 486, 82,
    12288, 10, 18, 504, 82, 12288, 10, 0, 522, 82, 4097, 357, 4097, 189, 0,
    4097, 202, 8197, 82, 8192, 89, 4097, 357, 4097, 189, 0, 4096, 202, 8192,
    82, 8192, 89, 8195, 82, 8192, 89, 8192, 82, 4096, 202, 4096, 357, 4097,
    189, 36864, 202, 8, 4096, 202, 8193, 82, 8192, 89, 8193, 82, 8192, 89,
    12288, 21, 468, 0, 82, 12288, 21, 468, 18, 82, 4097, 357, 4097, 189, 36864,
    202, 8, 4096, 202, 8194, 82, 8193, 89, 8192, 82, 12288, 21, 486, 0, 82,
    12288, 21, 486, 18, 82, 4097, 357, 4097, 189, 0, 4096, 202, 8192, 89, 8193,
    82, 8193, 89, 8193, 82, 8192, 89, 4096, 202, 4096, 357, 4097, 189, 0, 4096,
    202, 8192, 82, 8193, 89, 8193, 82, 8193, 89, 8192, 82, 4097, 357, 4097,
    189, 0, 4096, 202, 8192, 82, 8193, 89, 8193, 82, 8193, 89, 8192, 82, 4097,
    357, 4097, 189, 0, 4096, 202, 8192, 89, 8193, 82, 8193, 89, 8193, 82, 8192,
    89, 4096, 202, 4096, 357, 4097, 189, 36864, 202, 8, 4096, 202, 8194, 82,
    8193, 89, 8193, 82, 12288, 18, 864, 0, 82, 4097, 357, 4097, 189, 36864,
    202, 8, 4096, 202, 8193, 82, 8192, 89, 8193, 82, 8192, 89, 8192, 82, 12288,
    18, 882, 0, 82, 4097, 357, 4097, 189, 0, 4096, 202, 8192, 82, 8192, 89,
    8195, 82, 8192, 89, 8192, 82, 4096, 202, 4096, 357, 4097, 189, 0, 4097,
    202, 8197, 82, 8192, 89, 4097, 357, 4097, 189, 0, 4101, 202, 12288, 10, 18,
    486, 82, 12288, 10, 0, 504, 82, 12288, 10, 0, 522, 82, 4097, 357, 4097,
    189, 5, 4096, 202, 2, 8192, 82, 4096, 357, 4097, 189, 10, 4108, 189, 20482,
    189, 1
},
// skyBox31
{
    7698, 4110, 189, 20482, 189, 1, 4096, 189, 14, 4096, 202, 4097, 189, 14,
    4096, 202, 4097, 189, 13, 36864, 202, 8, 4096, 202, 4097, 189, 2, 36864,
    202, 8, 4099, 202, 4096, 91, 144, 0, 4096, 91, 144, 18, 4096, 91, 144, 36,
    2, 4097, 202, 4097, 189, 2, 4097, 202, 12289, 202, 82, 12288, 91, 126, 0,
    82, 12288, 91, 126, 18, 82, 12288, 91, 126, 36, 82, 8195, 82, 4097, 202,
    4097, 189, 2, 4097, 202, 8192, 82, 8192, 90, 8198, 82, 4097, 202, 4097,
    189, 2, 4097, 202, 45064, 202, 82, 2048, 4097, 202, 4097, 189, 2, 4097,
    202, 45064, 202, 82, 2048, 4097, 202, 4097, 189, 2, 4097, 202, 8193, 82,
    8192, 90, 8197, 82, 4097, 202, 4097, 189, 2, 4097, 202, 8193, 82, 8192, 90,
    8197, 82, 4097, 202, 4097, 189, 2, 4097, 202, 45064, 202, 82, 2048, 4097,
    202, 4097, 189, 2, 4096, 202, 12288, 202, 82, 45064, 202, 82, 2048, 4097,
    202, 4097, 189, 2, 4097, 202, 8192, 82, 8193, 90, 8197, 82, 4097, 202,
    4097, 189, 0, 4096, 490, 0, 0, 4096, 490, 0, 18, 4097, 202, 8192, 82, 8193,
    90, 8195, 82, 12288, 21, 468, 0, 82, 12288, 21, 468, 18, 82, 4097, 202,
    4097, 189, 0, 4096, 490, 18, 0, 4096, 490, 18, 18, 4097, 202, 8192, 82,
    8193, 90, 8195, 82, 12288, 21, 486, 0, 82, 12288, 21, 486, 18, 82, 4097,
    202, 4097, 189, 2, 4097, 202, 8192, 82, 8193, 90, 8197, 82, 4097, 202,
    4097, 189, 2, 4096, 202, 12288, 202, 82, 45064, 202, 82, 2048, 4097, 202,
    4097, 189, 2, 4096, 202, 12288, 202, 82, 45064, 202, 82, 2048, 4097, 202,
    4097, 189, 2, 4096, 202, 12288, 202, 82, 8193, 82, 8192, 90, 8197, 82,
    4097, 202, 4097, 189, 2, 4097, 202, 8193, 82, 8192, 90, 8197, 82, 4097,
    202, 4097, 189, 2, 4097, 202, 45064, 202, 82, 2048, 4097, 202, 4097, 189,
    2, 4096, 202, 12288, 202, 82, 45064, 202, 82, 2048, 4097, 202, 4097, 189,
    2, 4097, 202, 8192, 82, 8192, 90, 8198, 82, 4097, 202, 4097, 189, 2, 4099,
    202, 12288, 91, 126, 0, 82, 12288, 91, 126, 18, 82, 12288, 91, 126, 36, 82,
    8195, 82, 4097, 202, 4097, 189, 2, 36864, 202, 8, 4099, 202, 4096, 91, 144,
    0, 4096, 91, 144, 18, 4096, 91, 144, 36, 2, 4097, 202, 4097, 189, 13,
    36864, 202, 8, 4096, 202, 4097, 189, 14, 4096, 202, 4097, 189, 14, 4096,
    202, 4111, 189, 20482, 189, 1
},
// skyBox32
{
    3092, 4112, 189, 20482, 189, 1, 4096, 189, 36864, 350, 24, 4107, 350,
    20480, 10, 18, 1782, 26, 20480, 10, 18, 1800, 26, 20480, 10, 0, 1818, 26,
    4097, 350, 4097, 189, 4096, 350, 61440, 350, 182, 6656, 32, 24589, 182,
    6656, 4097, 350, 4097, 189, 4096, 350, 24577, 182, 6656, 8192, 21, 12288,
    84, 108, 0, 21, 28672, 380, 0, 108, 182, 6656, 24578, 182, 6656, 8192, 21,
    12288, 84, 108, 0, 21, 28672, 380, 0, 108, 182, 6656, 24576, 182, 6656,
    28672, 305, 0, 0, 182, 6656, 28672, 305, 0, 18, 182, 6656, 28672, 305, 0,
    36, 182, 6656, 4097, 350, 4097, 189, 4096, 350, 24577, 182, 6656, 8192, 21,
    12288, 84, 108, 0, 21, 28672, 380, 36, 108, 182, 6656, 24578, 182, 6656,
    8192, 21, 12288, 84, 108, 0, 21, 28672, 380, 36, 108, 182, 6656, 24576,
    182, 6656, 28672, 305, 18, 0, 182, 6656, 28672, 305, 18, 18, 182, 6656,
    28672, 305, 18, 36, 182, 6656, 4097, 350, 4097, 189, 4096, 350, 24587, 182,
    6656, 28672, 305, 36, 0, 182, 6656, 28672, 305, 36, 18, 182, 6656, 28672,
    305, 36, 36, 182, 6656, 4097, 350, 4097, 189, 4096, 350, 28672, 91, 126, 0,
    182, 6656, 28672, 91, 126, 18, 182, 6656, 28672, 91, 126, 36, 182, 6656,
    24585, 182, 6656, 28672, 21, 468, 0, 182, 6656, 28672, 21, 468, 18, 182,
    6656, 4097, 350, 4097, 189, 4096, 350, 24580, 182, 6656, 8192, 21, 12288,
    84, 108, 0, 21, 28672, 380, 0, 108, 182, 6656, 24576, 182, 6656, 61440, 19,
    36, 0, 182, 6656, 8, 28672, 91, 162, 0, 182, 6656, 28672, 91, 162, 18, 182,
    6656, 28672, 91, 162, 36, 182, 6656, 28672, 21, 486, 0, 182, 6656, 28672,
    21, 486, 18, 182, 6656, 4097, 350, 4097, 189, 4096, 350, 28672, 91, 144, 0,
    182, 6656, 28672, 91, 144, 18, 182, 6656, 28672, 91, 144, 36, 182, 6656,
    24577, 182, 6656, 8192, 21, 12288, 84, 108, 0, 21, 28672, 380, 36, 108,
    182, 6656, 24576, 182, 6656, 61440, 19, 18, 0, 182, 6656, 8, 28672, 91, 54,
    0, 182, 6656, 28672, 91, 54, 18, 182, 6656, 28672, 91, 54, 36, 182, 6656,
    24577, 182, 6656, 4097, 350, 4097, 189, 4096, 350, 61440, 350, 182, 6656,
    40, 24589, 182, 6656, 4097, 350, 4097, 189, 36864, 350, 16, 4107, 350,
    20480, 10, 36, 1782, 26, 20480, 10, 0, 1800, 26, 20480, 10, 36, 1818, 26,
    4097, 350, 4113, 189, 20482, 189, 1
},
// skyBox33
{
    8211, 4111, 189, 20482, 189, 1, 4096, 189, 15, 4096, 202, 4097, 189, 14,
    36864, 202, 8, 4096, 202, 4097, 189, 14, 4097, 202, 4097, 189, 13, 36864,
    370, 8, 4097, 202, 4097, 189, 13, 4096, 370, 4097, 202, 4097, 189, 2,
    36864, 192, 24, 4096, 202, 24584, 313, 7168, 4096, 370, 4097, 202, 4097,
    189, 1, 36864, 192, 8, 12288, 202, 60, 4096, 202, 8193, 146, 8195, 167,
    12288, 305, 0, 0, 167, 12288, 305, 0, 18, 167, 12288, 305, 0, 36, 167,
    4096, 370, 4097, 202, 4097, 189, 1, 36864, 192, 8, 4097, 202, 8192, 146,
    8196, 167, 12288, 305, 18, 0, 167, 12288, 305, 18, 18, 167, 12288, 305, 18,
    36, 167, 4096, 370, 4097, 202, 4097, 189, 2, 4097, 202, 8197, 167, 12288,
    305, 36, 0, 167, 12288, 305, 36, 18, 167, 12288, 305, 36, 36, 167, 4096,
    370, 4097, 202, 4097, 189, 2, 4097, 202, 8198, 167, 8193, 146, 4096, 370,
    4097, 202, 4097, 189, 2, 4097, 202, 8198, 167, 12288, 239, 18, 0, 167,
    12288, 239, 18, 0, 146, 4096, 370, 4097, 202, 4097, 189, 2, 4097, 202,
    8199, 167, 12288, 239, 18, 0, 167, 4096, 370, 4097, 202, 4097, 189, 2,
    4097, 202, 8195, 167, 8192, 146, 8193, 167, 12288, 21, 468, 0, 167, 12288,
    21, 468, 18, 167, 4096, 370, 4097, 202, 4097, 189, 1, 36864, 192, 8, 4097,
    202, 8195, 167, 8193, 146, 8192, 167, 12288, 21, 486, 0, 167, 12288, 21,
    486, 18, 167, 4096, 370, 4097, 202, 4097, 189, 1, 4096, 192, 12288, 202,
    60, 4096, 202, 24584, 313, 7168, 4096, 370, 4097, 202, 4097, 189, 0, 36864,
    192, 8, 4096, 192, 12288, 202, 60, 4096, 202, 24584, 313, 7168, 4096, 370,
    4097, 202, 4097, 189, 0, 36864, 192, 8, 4096, 192, 12288, 202, 60, 4096,
    202, 8200, 167, 4096, 370, 4097, 202, 4097, 189, 1, 4096, 192, 12288, 202,
    60, 12288, 192, 60, 8192, 60, 8192, 167, 8192, 60, 8197, 167, 45056, 370,
    60, 16, 4097, 202, 4097, 189, 2, 4097, 192, 8194, 167, 8194, 60, 8193, 167,
    8192, 60, 45056, 192, 60, 8, 12288, 202, 60, 4096, 202, 4097, 189, 2,
    36864, 192, 16, 4096, 192, 8193, 146, 8198, 167, 12288, 192, 60, 12288,
    202, 60, 4096, 202, 4097, 189, 3, 8193, 60, 8192, 146, 8195, 167, 8192, 60,
    8193, 167, 4096, 370, 4097, 202, 4097, 189, 4, 8193, 60, 8192, 167, 8192,
    60, 8192, 167, 8193, 60, 8192, 167, 8192, 146, 4096, 370, 4097, 202, 4097,
    189, 5, 8196, 60, 8192, 167, 12288, 648, 864, 0, 167, 12288, 648, 864, 18,
    146, 4096, 370, 4097, 202, 4097, 189, 7, 8193, 60, 8193, 167, 12288, 648,
    882, 0, 167, 12288, 648, 882, 18, 167, 4096, 370, 4097, 202, 4097, 189, 8,
    8193, 60, 24576, 313, 7168, 28672, 648, 900, 0, 313, 7168, 28672, 648, 900,
    18, 313, 7168, 4096, 370, 4097, 202, 4097, 189, 13, 4096, 370, 4097, 202,
    4097, 189, 13, 36864, 370, 8, 4097, 202, 4097, 189, 14, 4097, 202, 4097,
    189, 14, 36864, 202, 8, 4096, 202, 4097, 189, 15, 4096, 202, 4112, 189,
    20482, 189, 1
},
// skyBox34
{
    4878, 4106, 189, 20482, 189, 1, 4096, 189, 10, 4096, 202, 4097, 189, 3,
    36864, 202, 16, 4097, 202, 4096, 10, 18, 486, 4096, 10, 0, 504, 4096, 10,
    0, 522, 4097, 202, 4097, 189, 4, 4097, 202, 8194, 82, 4097, 202, 4097, 189,
    0, 36864, 202, 24, 4100, 202, 8194, 82, 4097, 202, 4097, 189, 0, 4100, 202,
    45056, 202, 89, 32, 8192, 89, 12288, 88, 702, 0, 82, 12288, 88, 702, 18,
    82, 4097, 202, 4097, 189, 0, 4097, 202, 12288, 91, 54, 0, 82, 12288, 91,
    54, 18, 82, 12288, 91, 54, 36, 82, 8193, 89, 12288, 88, 720, 0, 82, 12288,
    88, 720, 18, 82, 4097, 202, 4097, 189, 0, 4097, 202, 12288, 91, 54, 0, 82,
    12288, 91, 54, 18, 82, 12288, 91, 54, 36, 82, 8192, 82, 12288, 33, 18, 264,
    82, 12288, 88, 738, 0, 82, 12288, 88, 738, 18, 82, 4097, 202, 4097, 189, 0,
    4097, 202, 8192, 82, 12288, 240, 1080, 108, 89, 12288, 240, 1080, 126, 89,
    12288, 240, 1080, 144, 89, 8194, 82, 4097, 202, 4097, 189, 0, 4097, 202,
    8192, 82, 12288, 240, 1098, 108, 89, 12288, 240, 1098, 126, 89, 12288, 240,
    1098, 144, 89, 8194, 82, 4097, 202, 4097, 189, 0, 4097, 202, 8192, 82,
    12288, 240, 1116, 108, 89, 12288, 240, 1116, 126, 89, 12288, 240, 1116,
    144, 89, 8194, 82, 4097, 202, 4097, 189, 0, 4097, 202, 12288, 91, 54, 0,
    82, 12288, 91, 54, 18, 82, 12288, 91, 54, 36, 82, 8192, 82, 12288, 93, 18,
    486, 82, 12288, 93, 18, 504, 82, 12288, 93, 18, 522, 82, 4097, 202, 4097,
    189, 0, 4097, 202, 12288, 91, 54, 0, 82, 12288, 91, 54, 18, 82, 12288, 91,
    54, 36, 82, 8193, 89, 12288, 21, 468, 0, 82, 12288, 21, 468, 18, 82, 4097,
    202, 4097, 189, 0, 4100, 202, 45056, 202, 89, 40, 8192, 89, 12288, 21, 486,
    0, 82, 12288, 21, 486, 18, 82, 4097, 202, 4097, 189, 0, 36864, 202, 16,
    4100, 202, 8194, 82, 4097, 202, 4097, 189, 4, 4097, 202, 8194, 82, 4097,
    202, 4097, 189, 3, 36864, 202, 24, 4097, 202, 4096, 10, 36, 486, 4096, 10,
    18, 504, 4096, 10, 36, 522, 4097, 202, 4097, 189, 10, 4096, 202, 4107, 189,
    20482, 189, 1
},
// skyBox35
{
    4373, 4113, 189, 20482, 189, 1, 4096, 189, 5, 36864, 357, 8, 36864, 357,
    40, 9, 4096, 357, 4097, 189, 5, 4097, 357, 4096, 561, 7, 4097, 357, 4097,
    189, 5, 4096, 357, 12288, 561, 179, 4101, 357, 20480, 10, 72, 378, 26,
    20480, 10, 90, 396, 26, 20480, 10, 54, 414, 26, 4097, 357, 4097, 189, 4,
    36864, 357, 8, 4098, 357, 24583, 82, 6656, 4097, 357, 4097, 189, 4, 4097,
    357, 12288, 561, 179, 4096, 357, 24577, 82, 6656, 28672, 33, 18, 264, 82,
    6656, 28672, 19, 90, 396, 82, 6682, 24576, 82, 6656, 28672, 305, 0, 0, 82,
    6656, 28672, 305, 0, 18, 82, 6656, 28672, 305, 0, 36, 82, 6656, 4097, 357,
    4097, 189, 3, 4097, 357, 12288, 561, 179, 4097, 357, 24580, 82, 6656,
    28672, 305, 18, 0, 82, 6656, 28672, 305, 18, 18, 82, 6656, 28672, 305, 18,
    36, 82, 6656, 4097, 357, 4097, 189, 2, 36864, 357, 24, 4096, 357, 12288,
    561, 179, 12288, 357, 179, 12288, 561, 179, 4096, 357, 24580, 82, 6656,
    28672, 305, 36, 0, 82, 6656, 28672, 305, 36, 18, 82, 6656, 28672, 305, 36,
    36, 82, 6656, 4097, 357, 4097, 189, 0, 36864, 357, 8, 4097, 357, 12288,
    561, 179, 12288, 357, 179, 12288, 561, 179, 4097, 357, 24583, 82, 6656,
    4097, 357, 4097, 189, 2, 36864, 357, 16, 4096, 357, 12288, 561, 179, 12288,
    357, 179, 12288, 561, 179, 4096, 357, 24581, 82, 6656, 28672, 21, 468, 0,
    82, 6656, 28672, 21, 468, 18, 82, 6656, 4097, 357, 4097, 189, 3, 4097, 357,
    12288, 561, 179, 4097, 357, 24576, 82, 6656, 28672, 245, 936, 0, 82, 6656,
    28672, 245, 936, 18, 82, 6656, 28672, 245, 936, 36, 82, 6656, 24577, 82,
    6656, 28672, 21, 486, 0, 82, 6656, 28672, 21, 486, 18, 82, 6656, 4097, 357,
    4097, 189, 4, 4097, 357, 12288, 561, 179, 4096, 357, 24576, 82, 6656,
    28672, 245, 954, 0, 82, 6656, 28672, 245, 954, 18, 82, 6656, 28672, 245,
    954, 36, 82, 6656, 24579, 82, 6656, 4097, 357, 4097, 189, 4, 36864, 357, 8,
    4098, 357, 24583, 82, 6656, 4097, 357, 4097, 189, 5, 4096, 357, 12288, 561,
    179, 4101, 357, 20480, 10, 54, 378, 26, 20480, 10, 90, 396, 26, 20480, 10,
    72, 414, 26, 4097, 357, 4097, 189, 5, 4097, 357, 4096, 561, 7, 4097, 357,
    4097, 189, 5, 36864, 357, 8, 36864, 357, 32, 9, 4096, 357, 4114, 189,
    20482, 189, 1
},
// skyBox36
{
    5392, 4108, 189, 20482, 189, 1, 4096, 189, 11, 4097, 202, 4097, 189, 1,
    4096, 202, 0, 4096, 202, 0, 4096, 202, 0, 4096, 202, 2, 4097, 202, 4097,
    189, 0, 4096, 202, 12289, 202, 82, 8192, 82, 12288, 202, 82, 8192, 82,
    12288, 202, 82, 8195, 82, 4097, 202, 4097, 189, 1, 12288, 202, 82, 8200,
    90, 4097, 202, 4097, 189, 0, 4096, 202, 8192, 82, 8193, 90, 8192, 241,
    8197, 90, 4097, 202, 4097, 189, 1, 12288, 202, 82, 8192, 90, 8194, 241,
    8196, 90, 4097, 202, 4097, 189, 0, 4096, 202, 8192, 82, 8193, 90, 8192,
    241, 8197, 90, 4097, 202, 4097, 189, 1, 12288, 202, 82, 8198, 90, 12288,
    21, 468, 0, 90, 12288, 21, 468, 18, 90, 4097, 202, 4097, 189, 0, 4096, 202,
    8192, 82, 8198, 90, 12288, 21, 486, 0, 90, 12288, 21, 486, 18, 90, 4097,
    202, 4097, 189, 1, 12288, 202, 82, 8194, 90, 12288, 245, 900, 0, 90, 12288,
    245, 900, 18, 90, 12288, 245, 900, 36, 90, 8194, 90, 4097, 202, 4097, 189,
    0, 4096, 202, 8192, 82, 8194, 90, 12288, 245, 918, 0, 90, 12288, 245, 918,
    18, 90, 12288, 245, 918, 36, 90, 8194, 90, 4097, 202, 4097, 189, 1, 12288,
    202, 82, 8200, 90, 4097, 202, 4097, 189, 0, 4096, 202, 8192, 82, 8193, 90,
    8192, 241, 8197, 90, 4097, 202, 4097, 189, 1, 12288, 202, 82, 8192, 90,
    8194, 241, 8196, 90, 4097, 202, 4097, 189, 0, 4096, 202, 8192, 82, 8193,
    90, 8192, 241, 8197, 90, 4097, 202, 4097, 189, 1, 12288, 202, 82, 8200, 90,
    4097, 202, 4097, 189, 0, 4096, 202, 12289, 202, 82, 8192, 82, 12288, 202,
    82, 8192, 82, 12288, 202, 82, 8195, 82, 4097, 202, 4097, 189, 1, 4096, 202,
    0, 4096, 202, 0, 4096, 202, 0, 4096, 202, 2, 4097, 202, 4097, 189, 11,
    4097, 202, 4109, 189, 20482, 189, 1
},
// skyBox37
{
    5904, 4108, 189, 20482, 189, 1, 4096, 189, 2, 36864, 313, 40, 8, 4098, 189,
    2, 4096, 313, 36864, 313, 40, 7, 4098, 189, 2, 4097, 313, 4100, 311, 4096,
    10, 0, 1512, 4096, 10, 36, 1530, 4096, 10, 0, 1548, 4096, 311, 4097, 189,
    1, 36864, 313, 24, 4097, 313, 4096, 311, 8198, 143, 4096, 311, 4097, 189,
    1, 4098, 313, 4096, 311, 8198, 143, 4096, 311, 4097, 189, 0, 36864, 313,
    24, 4098, 313, 4096, 311, 45056, 19, 36, 180, 143, 8, 12288, 91, 36, 0,
    143, 12288, 91, 36, 18, 143, 12288, 91, 36, 36, 143, 8194, 143, 4096, 311,
    4097, 189, 0, 4099, 313, 4096, 311, 45056, 19, 0, 180, 143, 8, 12288, 91,
    36, 0, 21, 12288, 91, 36, 18, 21, 12288, 91, 36, 36, 21, 12288, 19, 36,
    180, 143, 8193, 143, 4096, 311, 4097, 189, 0, 4099, 313, 4096, 311, 45056,
    19, 0, 180, 143, 8, 8194, 21, 12288, 19, 0, 180, 143, 8193, 143, 4096, 311,
    4097, 189, 0, 4099, 313, 4096, 311, 45056, 19, 0, 180, 143, 8, 8194, 21,
    12288, 19, 0, 180, 143, 12288, 21, 468, 0, 143, 12288, 21, 468, 18, 143,
    4096, 311, 4097, 189, 0, 4099, 313, 4096, 311, 45056, 19, 0, 180, 143, 8,
    8194, 21, 12288, 19, 0, 180, 143, 12288, 21, 486, 0, 143, 12288, 21, 486,
    18, 143, 4096, 311, 4097, 189, 0, 4099, 313, 4096, 311, 45056, 19, 0, 180,
    143, 8, 8194, 21, 12288, 19, 0, 180, 143, 8193, 143, 4096, 311, 4097, 189,
    0, 4099, 313, 4096, 311, 45056, 19, 0, 180, 143, 8, 12288, 91, 36, 0, 21,
    12288, 91, 36, 18, 21, 12288, 91, 36, 36, 21, 12288, 19, 18, 180, 143,
    12288, 79, 72, 612, 143, 12288, 79, 72, 630, 143, 4096, 311, 4097, 189, 0,
    4099, 313, 4096, 311, 45056, 19, 18, 180, 143, 8, 12288, 91, 36, 0, 143,
    12288, 91, 36, 18, 143, 12288, 91, 36, 36, 143, 8192, 143, 12288, 79, 90,
    612, 143, 12288, 79, 90, 630, 143, 4096, 311, 4097, 189, 0, 4099, 313,
    4096, 311, 8196, 143, 12288, 79, 108, 612, 143, 12288, 79, 108, 630, 143,
    4096, 311, 4097, 189, 0, 4099, 313, 4096, 311, 12288, 34, 54, 810, 143,
    12288, 34, 54, 828, 143, 12288, 34, 54, 846, 143, 8193, 143, 12288, 79,
    126, 612, 143, 12288, 79, 126, 630, 143, 4096, 311, 4097, 189, 0, 36864,
    313, 16, 4098, 313, 36864, 311, 64, 45056, 34, 72, 810, 143, 64, 12288, 34,
    72, 828, 143, 12288, 34, 72, 846, 143, 8195, 143, 4096, 311, 4097, 189, 1,
    4098, 313, 36864, 311, 64, 12288, 34, 90, 810, 143, 12288, 34, 90, 828,
    143, 12288, 34, 90, 846, 143, 8195, 143, 4096, 311, 4097, 189, 1, 36864,
    313, 16, 4097, 313, 36864, 311, 64, 8194, 143, 45056, 136, 36, 18, 143, 64,
    8194, 143, 4096, 311, 4097, 189, 2, 4097, 313, 36868, 311, 64, 4096, 10,
    36, 1512, 4096, 10, 18, 1530, 4096, 10, 18, 1548, 4096, 311, 4097, 189, 2,
    4096, 313, 36864, 313, 32, 7, 4098, 189, 2, 36864, 313, 32, 8, 4110, 189,
    20482, 189, 1
},
// skyBox38
{
    5139, 4110, 189, 20483, 189, 1, 4096, 189, 14, 4099, 189, 3, 4096, 312,
    24576, 139, 7168, 9, 4098, 189, 3, 4096, 312, 4107, 311, 4097, 189, 2,
    4097, 312, 12288, 311, 142, 0, 8192, 142, 0, 8192, 142, 0, 12288, 305, 0,
    0, 142, 4096, 305, 0, 18, 12288, 305, 0, 36, 142, 4096, 311, 36864, 311,
    32, 4098, 189, 2, 4097, 312, 12288, 311, 142, 0, 8192, 142, 0, 8192, 142,
    0, 12288, 305, 18, 0, 142, 4096, 305, 18, 18, 12288, 305, 18, 36, 142,
    4096, 311, 4099, 189, 1, 4098, 312, 12288, 311, 142, 0, 8192, 142, 0, 8192,
    142, 0, 12288, 305, 36, 0, 142, 4096, 305, 36, 18, 12288, 305, 36, 36, 142,
    4096, 311, 4099, 189, 1, 4098, 312, 12288, 311, 142, 0, 8192, 142, 0, 8192,
    142, 0, 8192, 142, 0, 8192, 142, 4096, 311, 4099, 189, 0, 4099, 312, 12288,
    311, 142, 0, 8192, 142, 0, 8192, 142, 0, 8192, 142, 4096, 21, 468, 0,
    12288, 21, 468, 18, 142, 4096, 311, 4099, 189, 0, 4099, 312, 12288, 311,
    142, 0, 8192, 142, 0, 8192, 142, 0, 8192, 142, 4096, 21, 486, 0, 12288, 21,
    486, 18, 142, 4096, 311, 4099, 189, 0, 4099, 312, 12288, 311, 142, 0, 8192,
    142, 0, 8192, 142, 0, 8192, 142, 0, 8192, 142, 4096, 311, 36864, 311, 40,
    4098, 189, 1, 4098, 312, 4101, 311, 4096, 10, 18, 486, 4096, 10, 36, 504,
    4096, 10, 0, 522, 4098, 311, 4097, 189, 1, 4098, 312, 4096, 311, 0, 36864,
    311, 2072, 36864, 311, 2080, 4, 4098, 311, 4097, 189, 2, 4097, 312, 4096,
    311, 36864, 311, 2072, 36864, 311, 2080, 5, 4098, 311, 4097, 189, 2, 4097,
    312, 4096, 311, 36864, 311, 2080, 6, 4098, 311, 4097, 189, 3, 4096, 312,
    4096, 311, 7, 4098, 311, 4097, 189, 3, 4096, 312, 24576, 139, 7168, 7,
    4098, 311, 4097, 189, 14, 4097, 311, 4097, 189, 15, 4096, 311, 4112, 189,
    20482, 189, 1
},
// skyBox39
{
    5903, 4105, 189, 20484, 189, 1, 4096, 189, 0, 36864, 202, 24, 4096, 202,
    36864, 202, 40, 5, 4100, 189, 0, 4100, 202, 4096, 42, 18, 720, 4096, 42,
    18, 738, 2, 4096, 189, 4096, 202, 4097, 189, 0, 36864, 202, 16, 4096, 202,
    4100, 311, 4096, 10, 0, 486, 4096, 10, 36, 504, 4096, 10, 36, 522, 4096,
    311, 4096, 202, 4097, 189, 1, 4096, 202, 4096, 311, 24576, 143, 5120,
    24576, 142, 768, 0, 24576, 143, 2048, 24576, 142, 768, 0, 24576, 143, 2048,
    4096, 311, 4096, 202, 4097, 189, 1, 4096, 202, 4096, 311, 24576, 143, 5120,
    24576, 142, 768, 0, 24576, 143, 2048, 24576, 142, 768, 0, 24576, 143, 2048,
    4096, 311, 4096, 202, 4097, 189, 1, 4096, 202, 4096, 311, 24576, 143, 5120,
    24576, 142, 768, 0, 24576, 143, 2048, 24576, 142, 768, 0, 24576, 143, 2048,
    4096, 311, 4096, 202, 4097, 189, 0, 36864, 202, 24, 4096, 202, 4096, 311,
    24576, 143, 5120, 24576, 142, 768, 0, 24576, 143, 2048, 28672, 21, 468, 0,
    142, 768, 4096, 21, 468, 18, 28672, 19, 36, 180, 143, 2048, 4096, 311,
    4096, 202, 4097, 189, 0, 4097, 202, 4096, 311, 24576, 143, 5120, 24576,
    142, 768, 0, 24576, 143, 2048, 28672, 21, 486, 0, 142, 768, 4096, 21, 486,
    18, 28672, 19, 18, 180, 143, 2048, 4096, 311, 4096, 202, 4097, 189, 0,
    36864, 202, 16, 4096, 202, 4096, 311, 24576, 143, 5120, 24576, 142, 768, 0,
    24576, 143, 2048, 24576, 142, 768, 0, 24576, 143, 2048, 4096, 311, 4096,
    202, 4097, 189, 1, 4096, 202, 4096, 311, 28672, 34, 0, 1188, 143, 5120,
    28672, 34, 0, 1206, 142, 768, 4096, 34, 0, 1224, 24576, 143, 2048, 24576,
    142, 768, 0, 24576, 143, 2048, 4096, 311, 4096, 202, 4097, 189, 1, 4096,
    202, 4096, 311, 28672, 34, 18, 1188, 143, 5120, 28672, 34, 18, 1206, 142,
    768, 4096, 34, 18, 1224, 24576, 143, 2048, 24576, 142, 768, 0, 24576, 143,
    2048, 4096, 311, 4096, 202, 4097, 189, 1, 4096, 202, 4096, 311, 28672, 34,
    36, 1188, 143, 5120, 28672, 34, 36, 1206, 142, 768, 4096, 34, 36, 1224,
    24576, 143, 2048, 24576, 142, 768, 0, 24576, 143, 2048, 4096, 311, 4096,
    202, 4097, 189, 0, 36864, 202, 24, 4096, 202, 4096, 311, 24576, 143, 5120,
    24576, 142, 768, 0, 24576, 143, 2048, 24576, 142, 768, 0, 24576, 143, 2048,
    4096, 311, 4096, 202, 4097, 189, 0, 4097, 202, 4096, 311, 24576, 143, 5120,
    24576, 142, 768, 0, 24576, 143, 2048, 28672, 103, 36, 0, 142, 768, 4096,
    14, 378, 0, 28672, 14, 378, 18, 143, 2048, 4096, 311, 4096, 202, 4097, 189,
    0, 36864, 202, 16, 4096, 202, 4096, 311, 24576, 143, 5120, 24576, 142, 768,
    0, 24576, 143, 2048, 28672, 103, 54, 0, 142, 768, 4096, 14, 396, 0, 28672,
    14, 396, 18, 143, 2048, 4096, 311, 4096, 202, 4097, 189, 1, 4096, 202,
    4096, 311, 24576, 143, 5120, 24576, 142, 768, 0, 24576, 143, 2048, 24576,
    142, 768, 4096, 14, 414, 0, 28672, 14, 414, 18, 143, 2048, 4096, 311, 4096,
    202, 4097, 189, 1, 4096, 202, 4096, 311, 24576, 143, 5120, 24576, 142, 768,
    0, 24576, 143, 2048, 24576, 142, 768, 0, 24576, 143, 2048, 4096, 311, 4096,
    202, 4097, 189, 1, 4096, 202, 4096, 311, 24576, 143, 5120, 24576, 142, 768,
    0, 24576, 143, 2048, 24576, 142, 768, 0, 24576, 143, 2048, 4096, 311, 4096,
    202, 4097, 189, 0, 36864, 202, 24, 4096, 202, 4100, 311, 4096, 10, 36, 486,
    4096, 10, 18, 504, 4096, 10, 0, 522, 4096, 311, 4096, 202, 4097, 189, 0,
    4100, 202, 4096, 42, 18, 720, 4096, 42, 18, 738, 2, 4096, 189, 4096, 202,
    4097, 189, 0, 36864, 202, 16, 4096, 202, 36864, 202, 32, 5, 4109, 189,
    20484, 189, 1
},
// skyBox40
{
    5649, 4108, 189, 20483, 189, 1, 4096, 189, 1, 4096, 312, 9, 4099, 189, 1,
    4096, 312, 10, 4098, 189, 1, 4096, 312, 4096, 202, 4097, 214, 4096, 19, 90,
    162, 4096, 42, 0, 216, 4096, 42, 0, 234, 4, 4096, 202, 4097, 189, 0, 4097,
    312, 4096, 202, 6, 8192, 245, 24577, 107, 6656, 4096, 202, 4097, 189, 0,
    4097, 312, 4096, 202, 36871, 311, 2048, 61441, 311, 107, 6656, 2048, 4096,
    202, 4097, 189, 0, 4097, 312, 4096, 202, 6, 8192, 245, 24577, 107, 6656,
    4096, 202, 4097, 189, 0, 4097, 312, 4096, 202, 7, 24577, 107, 6656, 4096,
    202, 4097, 189, 0, 4097, 312, 4096, 202, 7, 28672, 21, 468, 0, 107, 6656,
    28672, 21, 468, 18, 107, 6656, 4096, 202, 4097, 189, 0, 4097, 312, 4096,
    202, 6, 8192, 245, 28672, 21, 486, 0, 107, 6656, 28672, 21, 486, 18, 107,
    6656, 4096, 202, 4097, 189, 0, 4097, 312, 4096, 202, 7, 24577, 107, 6656,
    4096, 202, 4097, 189, 0, 4097, 312, 4096, 202, 7, 24577, 107, 6656, 4096,
    202, 4097, 189, 0, 4097, 312, 4096, 202, 6, 12288, 305, 0, 0, 245, 28672,
    305, 0, 18, 107, 6656, 28672, 305, 0, 36, 107, 6656, 4096, 202, 4097, 189,
    0, 4097, 312, 4096, 202, 6, 4096, 305, 18, 0, 28672, 305, 18, 18, 107,
    6656, 28672, 305, 18, 36, 107, 6656, 4096, 202, 4097, 189, 0, 4097, 312,
    4096, 202, 6, 4096, 305, 36, 0, 28672, 305, 36, 18, 107, 6656, 28672, 305,
    36, 36, 107, 6656, 4096, 202, 4097, 189, 0, 4097, 312, 4096, 202, 6, 8192,
    245, 24577, 107, 6656, 4096, 202, 4097, 189, 0, 4097, 312, 4096, 202,
    36871, 311, 2048, 61441, 311, 107, 6656, 2048, 4096, 202, 4097, 189, 0,
    4097, 312, 4096, 202, 6, 8192, 245, 24577, 107, 6656, 4096, 202, 4097, 189,
    1, 4096, 312, 4096, 202, 4097, 214, 4096, 19, 90, 162, 4096, 42, 0, 216,
    4096, 42, 0, 234, 4, 4096, 202, 4097, 189, 1, 4096, 312, 10, 4098, 189, 1,
    4096, 312, 9, 4111, 189, 20483, 189, 1
},
// skyBox41
{
    4883, 4110, 189, 20483, 189, 1, 4096, 189, 0, 4096, 202, 36864, 202, 40,
    11, 4099, 189, 0, 36864, 202, 8, 4096, 202, 4104, 311, 4096, 10, 18, 486,
    4096, 10, 0, 504, 4096, 10, 36, 522, 4097, 311, 4097, 189, 0, 36864, 202,
    8, 4096, 202, 4103, 311, 12288, 311, 142, 8194, 142, 4097, 311, 4097, 189,
    1, 4096, 202, 4096, 311, 45056, 311, 142, 32, 8201, 142, 4097, 311, 4097,
    189, 1, 4096, 202, 4096, 311, 8192, 21, 8199, 142, 12288, 79, 72, 612, 142,
    12288, 79, 72, 630, 142, 4097, 311, 4097, 189, 0, 36864, 202, 8, 4096, 202,
    12288, 311, 142, 8193, 142, 12288, 240, 648, 108, 142, 12288, 240, 648,
    126, 142, 12288, 240, 648, 144, 142, 8195, 142, 12288, 79, 90, 612, 142,
    12288, 79, 90, 630, 142, 4097, 311, 4097, 189, 0, 36864, 202, 8, 4096, 202,
    4096, 311, 8192, 21, 8192, 142, 12288, 240, 666, 108, 142, 12288, 240, 666,
    126, 142, 12288, 240, 666, 144, 142, 8195, 142, 12288, 79, 108, 612, 142,
    12288, 79, 108, 630, 142, 4097, 311, 4097, 189, 0, 4097, 202, 12288, 311,
    142, 8193, 142, 12288, 240, 684, 108, 142, 12288, 240, 684, 126, 142,
    12288, 240, 684, 144, 142, 8195, 142, 12288, 79, 126, 612, 142, 12288, 79,
    126, 630, 142, 4097, 311, 4097, 189, 1, 4096, 202, 4096, 311, 8192, 21,
    8201, 142, 4097, 311, 4097, 189, 0, 4097, 202, 12288, 311, 142, 8199, 142,
    12288, 19, 36, 396, 142, 8193, 142, 4097, 311, 4097, 189, 0, 36864, 202, 8,
    4096, 202, 4096, 311, 8192, 21, 8196, 142, 12288, 21, 468, 0, 142, 12288,
    21, 468, 18, 142, 12288, 19, 0, 396, 142, 8193, 142, 4097, 311, 4097, 189,
    0, 36864, 202, 8, 4096, 202, 12288, 311, 142, 8197, 142, 12288, 21, 486, 0,
    142, 12288, 21, 486, 18, 142, 12288, 19, 0, 396, 142, 8193, 142, 4097, 311,
    4097, 189, 1, 4096, 202, 4096, 311, 8192, 21, 8198, 142, 12288, 19, 18,
    396, 142, 8193, 142, 4097, 311, 4097, 189, 1, 4096, 202, 4096, 311, 45056,
    311, 142, 40, 8201, 142, 4097, 311, 4097, 189, 0, 36864, 202, 8, 4096, 202,
    4103, 311, 12288, 311, 142, 8194, 142, 4097, 311, 4097, 189, 0, 36864, 202,
    8, 4096, 202, 4104, 311, 4096, 10, 36, 486, 4096, 10, 18, 504, 4096, 10,
    36, 522, 4097, 311, 4097, 189, 0, 4096, 202, 36864, 202, 32, 11, 4113, 189,
    20483, 189, 1
},
// skyBox42
{
    6419, 4109, 189, 20484, 189, 1, 4096, 189, 13, 4100, 189, 6, 36864, 19,
    342, 576, 24, 6, 4099, 189, 5, 36864, 19, 144, 576, 24, 4100, 311, 4096,
    10, 0, 486, 4096, 10, 18, 504, 4096, 10, 0, 522, 4096, 202, 4096, 311,
    4097, 189, 4, 36864, 19, 144, 576, 24, 36864, 311, 24, 4096, 311, 8198, 82,
    4096, 311, 4096, 202, 4097, 189, 3, 36864, 19, 144, 576, 24, 36864, 311,
    24, 61440, 311, 45, 7168, 32, 4096, 311, 8192, 82, 8193, 21, 8195, 82,
    4096, 202, 4096, 311, 4097, 189, 2, 36864, 19, 144, 576, 24, 36864, 311,
    24, 61440, 311, 45, 7168, 32, 24576, 45, 7168, 4096, 311, 8192, 82, 8193,
    21, 8195, 82, 4096, 311, 4096, 202, 4097, 189, 1, 36864, 19, 144, 576, 24,
    36864, 311, 24, 61440, 311, 45, 7168, 32, 24576, 45, 7168, 61440, 311, 45,
    7168, 24, 4096, 311, 8192, 82, 8193, 21, 8194, 82, 45056, 19, 144, 576, 82,
    24, 4096, 202, 4096, 311, 4097, 189, 0, 36864, 19, 144, 576, 24, 36864,
    311, 24, 61440, 311, 45, 7168, 32, 24576, 45, 7168, 61440, 311, 45, 7168,
    24, 61440, 311, 45, 7168, 32, 4096, 311, 8195, 82, 12288, 21, 468, 0, 82,
    12288, 21, 468, 18, 82, 12288, 19, 216, 576, 82, 4096, 311, 4096, 202,
    4097, 189, 0, 20480, 158, 28, 61440, 311, 45, 7168, 32, 24576, 45, 7168,
    61440, 311, 45, 7168, 24, 61440, 311, 45, 7168, 32, 24576, 45, 7168, 4096,
    311, 8195, 82, 12288, 21, 486, 0, 82, 12288, 21, 486, 18, 82, 12288, 19,
    234, 576, 82, 4096, 202, 4096, 311, 4097, 189, 0, 20480, 158, 28, 24576,
    45, 7168, 61440, 311, 45, 7168, 24, 61440, 311, 45, 7168, 32, 24576, 45,
    7168, 61440, 311, 45, 7168, 24, 4096, 311, 8197, 82, 45056, 19, 180, 576,
    82, 16, 4096, 311, 4096, 202, 4097, 189, 0, 20480, 158, 28, 61440, 311, 45,
    7168, 24, 61440, 311, 45, 7168, 32, 24576, 45, 7168, 61440, 311, 45, 7168,
    24, 61440, 311, 45, 7168, 32, 4096, 311, 8192, 82, 12288, 246, 0, 756, 82,
    12288, 246, 0, 774, 82, 8195, 82, 4096, 202, 4096, 311, 4097, 189, 0,
    20485, 158, 28, 4096, 311, 8192, 82, 12288, 246, 18, 756, 82, 12288, 246,
    18, 774, 82, 8195, 82, 4096, 311, 4096, 202, 4097, 189, 0, 20480, 158, 28,
    61440, 311, 45, 7168, 16, 61440, 311, 45, 7168, 40, 24576, 45, 7168, 61440,
    311, 45, 7168, 16, 61440, 311, 45, 7168, 40, 4096, 311, 8192, 82, 12288,
    246, 36, 756, 82, 12288, 246, 36, 774, 82, 8195, 82, 4096, 202, 4096, 311,
    4097, 189, 0, 20480, 158, 28, 24576, 45, 7168, 61440, 311, 45, 7168, 16,
    61440, 311, 45, 7168, 40, 24576, 45, 7168, 61440, 311, 45, 7168, 16, 4096,
    311, 8198, 82, 4096, 311, 4096, 202, 4097, 189, 0, 20480, 158, 28, 61440,
    311, 45, 7168, 40, 24576, 45, 7168, 61440, 311, 45, 7168, 16, 61440, 311,
    45, 7168, 40, 24576, 45, 7168, 4096, 311, 8196, 82, 12288, 14, 378, 0, 82,
    12288, 14, 378, 18, 82, 4096, 202, 4096, 311, 4097, 189, 0, 36864, 19, 180,
    576, 16, 36864, 311, 16, 61440, 311, 45, 7168, 40, 24576, 45, 7168, 61440,
    311, 45, 7168, 16, 61440, 311, 45, 7168, 40, 4096, 311, 8196, 82, 12288,
    14, 396, 0, 82, 12288, 14, 396, 18, 82, 4096, 311, 4096, 202, 4097, 189, 1,
    36864, 19, 180, 576, 16, 36864, 311, 16, 61440, 311, 45, 7168, 40, 24576,
    45, 7168, 61440, 311, 45, 7168, 16, 4096, 311, 8192, 82, 8193, 21, 8192,
    82, 12288, 33, 18, 264, 82, 12288, 14, 414, 0, 82, 12288, 14, 414, 18, 82,
    4096, 202, 4096, 311, 4097, 189, 2, 36864, 19, 180, 576, 16, 36864, 311,
    16, 61440, 311, 45, 7168, 40, 24576, 45, 7168, 4096, 311, 8192, 82, 8193,
    21, 8195, 82, 4096, 311, 4096, 202, 4097, 189, 3, 36864, 19, 180, 576, 16,
    36864, 311, 16, 61440, 311, 45, 7168, 40, 4096, 311, 8192, 82, 8193, 21,
    8195, 82, 4096, 202, 4096, 311, 4097, 189, 4, 36864, 19, 180, 576, 16,
    36864, 311, 16, 4096, 311, 8198, 82, 4096, 311, 4096, 202, 4097, 189, 5,
    36864, 19, 180, 576, 16, 4100, 311, 4096, 10, 36, 486, 4096, 10, 36, 504,
    4096, 10, 18, 522, 4096, 202, 4096, 311, 4097, 189, 6, 36864, 19, 360, 576,
    16, 6, 4099, 189, 13, 4113, 189, 20484, 189, 1
},
// skyBox43
{
    4625, 4109, 189, 20482, 189, 1, 4096, 189, 0, 36864, 202, 24, 4103, 202,
    20480, 10, 0, 108, 28, 20480, 10, 18, 126, 28, 20480, 10, 18, 144, 28,
    4097, 202, 4097, 189, 0, 4096, 202, 12294, 202, 142, 45056, 202, 142, 32,
    8194, 142, 4096, 311, 4096, 202, 4097, 189, 0, 4096, 202, 12288, 202, 142,
    8201, 142, 4096, 311, 4096, 202, 4097, 189, 0, 4096, 202, 12288, 202, 142,
    8201, 142, 4096, 311, 4096, 202, 4097, 189, 0, 4096, 202, 12288, 202, 142,
    8193, 142, 8194, 89, 8194, 142, 12288, 33, 18, 264, 142, 12288, 18, 864, 0,
    142, 4096, 311, 4096, 202, 4097, 189, 0, 4096, 202, 12288, 202, 142, 8193,
    142, 8194, 89, 8195, 142, 12288, 18, 882, 0, 142, 4096, 311, 4096, 202,
    4097, 189, 0, 4096, 202, 12288, 202, 142, 8193, 142, 8194, 89, 8194, 142,
    12288, 21, 468, 0, 142, 12288, 21, 468, 18, 142, 4096, 311, 4096, 202,
    4097, 189, 0, 4096, 202, 12288, 202, 142, 8199, 142, 12288, 21, 486, 0,
    142, 12288, 21, 486, 18, 142, 4096, 311, 4096, 202, 4097, 189, 0, 4096,
    202, 12288, 202, 142, 12288, 91, 144, 0, 142, 12288, 91, 144, 18, 142,
    12288, 91, 144, 36, 142, 8198, 142, 4096, 311, 4096, 202, 4097, 189, 0,
    4096, 202, 12288, 202, 142, 8195, 142, 12288, 240, 1080, 0, 142, 12288,
    240, 1080, 18, 142, 12288, 240, 1080, 36, 142, 8194, 142, 4096, 311, 4096,
    202, 4097, 189, 0, 4096, 202, 12288, 202, 142, 12288, 91, 144, 0, 142,
    12288, 91, 144, 18, 142, 12288, 91, 144, 36, 142, 8192, 142, 12288, 240,
    1098, 0, 142, 12288, 240, 1098, 18, 142, 12288, 240, 1098, 36, 142, 8194,
    142, 4096, 311, 4096, 202, 4097, 189, 0, 4096, 202, 12288, 202, 142, 8195,
    142, 12288, 240, 1116, 0, 142, 12288, 240, 1116, 18, 142, 12288, 240, 1116,
    36, 142, 8194, 142, 4096, 311, 4096, 202, 4097, 189, 0, 4096, 202, 12288,
    202, 142, 12288, 91, 144, 0, 142, 12288, 91, 144, 18, 142, 12288, 91, 144,
    36, 142, 8198, 142, 4096, 311, 4096, 202, 4097, 189, 0, 4096, 202, 12288,
    202, 142, 8201, 142, 4096, 311, 4096, 202, 4097, 189, 0, 4097, 202, 12293,
    202, 142, 45056, 202, 142, 40, 8194, 142, 4096, 311, 4096, 202, 4097, 189,
    0, 36864, 202, 16, 4103, 202, 20480, 10, 36, 108, 28, 20480, 10, 0, 126,
    28, 20480, 10, 0, 144, 28, 4097, 202, 4110, 189, 20482, 189, 1
},
// skyBox44
{
    6423, 4114, 189, 20483, 189, 1, 4096, 189, 7, 36864, 54, 24, 4097, 54,
    4098, 202, 36864, 202, 40, 3, 4097, 202, 4097, 189, 5, 36864, 54, 24, 4096,
    54, 45056, 54, 21, 32, 8192, 21, 45056, 54, 21, 16, 4100, 202, 4096, 10,
    36, 486, 4096, 10, 18, 504, 4096, 10, 36, 522, 4097, 202, 4097, 189, 3,
    36864, 54, 24, 4096, 54, 45056, 54, 21, 32, 8195, 21, 8199, 82, 4097, 202,
    4097, 189, 2, 36864, 54, 24, 45056, 54, 21, 32, 12289, 214, 21, 12288, 19,
    90, 162, 21, 12288, 572, 0, 144, 21, 12288, 572, 0, 162, 21, 8192, 21,
    12288, 19, 36, 396, 82, 8194, 82, 12288, 19, 36, 396, 82, 8194, 82, 4097,
    202, 4097, 189, 1, 36864, 54, 24, 45056, 54, 21, 32, 8197, 21, 12288, 214,
    21, 12288, 19, 72, 396, 82, 12290, 214, 82, 12288, 19, 72, 396, 82, 12289,
    214, 82, 8192, 82, 4097, 202, 4097, 189, 1, 4096, 54, 8199, 21, 12288, 202,
    82, 8192, 82, 45056, 546, 82, 2072, 45058, 546, 21, 2048, 8193, 82, 4097,
    202, 4097, 189, 0, 36864, 54, 24, 45056, 54, 21, 32, 8199, 21, 12288, 202,
    82, 8192, 82, 45059, 546, 21, 2048, 8193, 82, 4097, 202, 4097, 189, 0,
    4096, 54, 8198, 21, 12288, 21, 468, 0, 21, 12288, 21, 468, 18, 21, 12288,
    202, 82, 45056, 202, 82, 40, 45056, 546, 82, 2064, 45058, 546, 21, 2048,
    8193, 82, 4097, 202, 4097, 189, 36864, 54, 24, 45056, 54, 21, 32, 8198, 21,
    12288, 21, 486, 0, 21, 12288, 21, 486, 18, 21, 12288, 202, 82, 45056, 202,
    82, 32, 8197, 82, 4097, 202, 4097, 189, 4096, 54, 8201, 21, 12288, 202, 82,
    12288, 591, 72, 0, 82, 12288, 591, 72, 18, 82, 12288, 591, 72, 36, 82,
    8195, 82, 4097, 202, 4097, 189, 4096, 54, 8199, 21, 12289, 575, 21, 12288,
    202, 82, 12288, 591, 90, 0, 82, 12288, 591, 90, 18, 82, 12288, 591, 90, 36,
    82, 8195, 82, 4097, 202, 4097, 189, 4096, 54, 8201, 21, 8199, 82, 4097,
    202, 4097, 189, 4096, 54, 12294, 214, 21, 12288, 19, 90, 162, 21, 12288,
    572, 0, 72, 21, 12288, 572, 0, 90, 21, 8199, 82, 4097, 202, 4097, 189,
    4096, 54, 8201, 21, 8199, 82, 4097, 202, 4097, 189, 36864, 54, 16, 45056,
    54, 21, 40, 8200, 21, 8199, 82, 12288, 202, 60, 4096, 202, 4097, 189, 0,
    4096, 54, 8200, 21, 8193, 82, 45056, 546, 82, 2072, 45058, 546, 21, 2048,
    8193, 82, 12288, 192, 60, 12288, 202, 60, 4097, 189, 0, 36864, 54, 16,
    45056, 54, 21, 40, 8199, 21, 8193, 82, 45059, 546, 21, 2048, 8193, 82,
    45056, 192, 82, 8, 12288, 192, 60, 4097, 189, 1, 4096, 54, 12289, 214, 21,
    12288, 19, 90, 162, 21, 12288, 572, 0, 108, 21, 12288, 572, 0, 126, 21,
    8194, 21, 8193, 82, 45056, 546, 82, 2064, 45058, 546, 21, 2048, 8193, 82,
    45056, 192, 82, 8, 12288, 192, 60, 4097, 189, 1, 36864, 54, 16, 45056, 54,
    21, 40, 8198, 21, 8199, 82, 12288, 192, 60, 12288, 202, 60, 4097, 189, 2,
    36864, 54, 16, 45056, 54, 21, 40, 8197, 21, 8199, 82, 12288, 192, 60, 4096,
    202, 4097, 189, 3, 36864, 54, 16, 4096, 54, 45056, 54, 21, 40, 8195, 21,
    8192, 82, 45056, 192, 82, 24, 12288, 192, 60, 12288, 192, 82, 8195, 82,
    12288, 202, 60, 4096, 202, 4097, 189, 5, 36864, 54, 16, 4096, 54, 45056,
    54, 21, 40, 8192, 21, 45056, 54, 21, 24, 4096, 202, 12288, 192, 60, 4098,
    202, 4096, 10, 18, 486, 4096, 10, 18, 504, 4096, 10, 18, 522, 4097, 202,
    4097, 189, 7, 36864, 54, 16, 4097, 54, 4098, 202, 36864, 202, 32, 3, 4097,
    202, 4115, 189, 20483, 189, 1
},
// skyBox45
{
    7955, 4111, 189, 20482, 189, 1, 4096, 189, 7, 36864, 54, 24, 4098, 311,
    36864, 311, 40, 2, 4096, 202, 4097, 189, 5, 36864, 54, 24, 4097, 54, 4096,
    311, 4098, 202, 4096, 10, 0, 486, 4096, 10, 18, 504, 4096, 10, 0, 522,
    4096, 202, 4097, 189, 4, 36864, 54, 24, 4096, 54, 45056, 54, 21, 32, 45056,
    54, 21, 16, 4098, 311, 45056, 311, 21, 32, 8194, 21, 4096, 202, 4097, 189,
    3, 36864, 54, 24, 4096, 54, 45056, 54, 21, 32, 8200, 21, 4096, 202, 4097,
    189, 2, 36864, 54, 8, 4096, 54, 45056, 54, 21, 32, 8201, 21, 4096, 202,
    4097, 189, 2, 36864, 54, 8, 4096, 54, 8195, 21, 12288, 73, 324, 0, 21,
    12288, 380, 0, 0, 21, 61440, 158, 21, 28, 40, 8195, 21, 4096, 202, 4097,
    189, 2, 36864, 54, 8, 4096, 54, 8195, 21, 12288, 82, 0, 0, 21, 12288, 380,
    18, 0, 21, 28672, 158, 21, 28, 28675, 575, 21, 28, 4096, 202, 4097, 189, 2,
    36864, 54, 8, 4096, 311, 45056, 311, 21, 40, 8194, 21, 12288, 73, 198, 0,
    21, 12288, 380, 18, 0, 21, 28672, 158, 21, 28, 8195, 21, 4096, 202, 4097,
    189, 2, 36864, 192, 24, 4096, 311, 45056, 311, 21, 16, 45056, 311, 21, 40,
    8193, 21, 12288, 3, 612, 0, 21, 12288, 380, 18, 0, 21, 28672, 158, 21, 28,
    8193, 21, 12288, 21, 468, 0, 21, 12288, 21, 468, 18, 21, 4096, 202, 4097,
    189, 1, 4096, 192, 12288, 192, 60, 4096, 311, 12288, 311, 21, 4096, 311,
    28672, 42, 18, 720, 313, 7168, 28672, 42, 18, 738, 313, 7168, 28672, 82, 0,
    0, 313, 7168, 28672, 380, 18, 0, 313, 7168, 28672, 158, 313, 7196, 24577,
    313, 7168, 28672, 21, 486, 0, 313, 7168, 28672, 21, 486, 18, 313, 7168,
    4096, 202, 4097, 189, 1, 36864, 192, 8, 4096, 192, 12288, 311, 60, 45056,
    311, 21, 24, 45056, 311, 21, 32, 8193, 21, 12288, 3, 306, 0, 21, 12288,
    380, 18, 0, 21, 28672, 158, 21, 28, 28675, 575, 21, 28, 4096, 202, 4097,
    189, 2, 36864, 54, 8, 4096, 311, 45056, 311, 21, 32, 8194, 21, 12288, 3,
    288, 0, 21, 12288, 380, 36, 0, 21, 61440, 158, 21, 28, 32, 8193, 21, 45056,
    192, 21, 8, 12288, 192, 60, 12288, 202, 60, 4097, 189, 2, 36864, 54, 8,
    4096, 54, 8201, 21, 45056, 192, 21, 16, 12288, 202, 60, 4097, 189, 2,
    36864, 54, 8, 4096, 54, 8202, 21, 4096, 202, 4097, 189, 2, 36864, 54, 8,
    4096, 54, 8202, 21, 4096, 202, 4097, 189, 2, 36864, 54, 8, 4096, 54, 8197,
    21, 12288, 547, 144, 0, 21, 12288, 547, 144, 18, 21, 12288, 547, 144, 36,
    21, 12288, 547, 144, 54, 21, 12288, 547, 144, 72, 21, 4096, 202, 4097, 189,
    2, 36864, 54, 8, 4096, 311, 45056, 311, 21, 40, 8196, 21, 12288, 547, 162,
    0, 21, 12288, 547, 162, 18, 21, 12288, 547, 162, 36, 21, 12288, 547, 162,
    54, 21, 12288, 547, 162, 72, 21, 4096, 202, 4097, 189, 3, 4096, 311, 45056,
    311, 21, 16, 45056, 311, 21, 40, 8198, 21, 12288, 82, 72, 0, 21, 12288, 78,
    0, 0, 21, 4096, 202, 4097, 189, 3, 4096, 311, 12288, 311, 21, 4096, 311,
    28672, 42, 18, 720, 313, 7168, 28672, 42, 18, 738, 313, 7168, 24576, 313,
    7168, 28672, 73, 342, 0, 313, 7168, 28672, 380, 0, 0, 313, 7168, 61440,
    158, 313, 7196, 40, 24578, 313, 7168, 4096, 202, 4097, 189, 3, 4096, 311,
    45056, 311, 21, 24, 45056, 311, 21, 32, 8194, 21, 12288, 83, 0, 0, 21,
    12288, 380, 18, 0, 21, 28672, 158, 21, 28, 28674, 575, 21, 28, 4096, 202,
    4097, 189, 2, 36864, 54, 8, 4096, 311, 45056, 311, 21, 32, 8195, 21, 12288,
    73, 774, 0, 21, 12288, 380, 36, 0, 21, 28672, 158, 21, 28, 8194, 21, 4096,
    202, 4097, 189, 2, 36864, 54, 8, 4096, 54, 8197, 21, 45056, 192, 21, 8,
    28672, 158, 60, 28, 61440, 158, 21, 28, 40, 8193, 21, 4096, 202, 4097, 189,
    2, 36864, 54, 8, 4096, 54, 8197, 21, 12289, 192, 21, 45056, 192, 21, 32,
    12288, 73, 324, 0, 21, 12288, 380, 54, 0, 21, 4096, 202, 4097, 189, 2,
    36864, 54, 8, 4096, 54, 45056, 54, 21, 40, 8200, 21, 28672, 575, 21, 28,
    4096, 202, 4097, 189, 3, 36864, 54, 16, 4096, 54, 45056, 54, 21, 40, 8199,
    21, 45056, 192, 21, 8, 4096, 202, 4097, 189, 4, 36864, 54, 16, 4096, 54,
    45056, 54, 21, 40, 45056, 54, 21, 24, 4098, 311, 45056, 311, 21, 40, 8194,
    21, 4096, 202, 4097, 189, 5, 36864, 54, 16, 4097, 54, 4096, 311, 4098, 202,
    4096, 10, 0, 486, 4096, 10, 0, 504, 4096, 10, 0, 522, 4096, 202, 4097, 189,
    8, 36864, 311, 16, 3, 36864, 311, 16, 4096, 311, 4096, 202, 4097, 189, 14,
    36864, 311, 16, 4096, 311, 4111, 189, 20483, 189, 1
},
// skyBox46
{
    3084, 4102, 189, 20483, 189, 1, 4097, 189, 5, 4099, 370, 4097, 189, 6,
    4097, 350, 4096, 370, 4097, 189, 0, 36864, 370, 8, 4097, 370, 36864, 370,
    40, 1, 4097, 350, 4096, 370, 4097, 189, 0, 32768, 1, 4097, 350, 4096, 370,
    1, 4097, 350, 4096, 370, 4097, 189, 4096, 21, 468, 0, 36864, 21, 468, 18,
    1, 4102, 350, 4096, 370, 4097, 189, 4096, 21, 486, 0, 36864, 21, 486, 18,
    1, 4102, 350, 4096, 370, 4097, 189, 0, 32768, 1, 4097, 350, 4096, 370, 1,
    4097, 350, 4096, 370, 4097, 189, 0, 36864, 370, 8, 4097, 370, 36864, 370,
    32, 1, 4097, 350, 4096, 370, 4097, 189, 6, 4097, 350, 4096, 370, 4097, 189,
    5, 4099, 370, 4103, 189, 20483, 189, 1, 4096, 189
},
// skyBox47
{
    3081, 4098, 189, 20484, 189, 1, 4097, 189, 4102, 311, 4097, 189, 4096, 311,
    8192, 82, 8192, 143, 12288, 305, 0, 0, 143, 12288, 305, 0, 18, 143, 12288,
    305, 0, 36, 82, 4096, 311, 4097, 189, 4096, 311, 8192, 82, 8192, 143,
    12288, 305, 18, 0, 143, 12288, 305, 18, 18, 143, 12288, 305, 18, 36, 82,
    4096, 311, 4097, 189, 4096, 311, 8192, 82, 8192, 143, 12288, 305, 36, 0,
    143, 12288, 305, 36, 18, 143, 12288, 305, 36, 36, 82, 4096, 311, 4097, 189,
    4096, 311, 12288, 245, 216, 0, 82, 12288, 245, 216, 18, 143, 12288, 245,
    216, 36, 143, 12288, 21, 468, 0, 143, 12288, 21, 468, 18, 82, 4096, 311,
    4097, 189, 4096, 311, 12288, 245, 234, 0, 82, 12288, 245, 234, 18, 143,
    12288, 245, 234, 36, 143, 12288, 21, 486, 0, 143, 12288, 21, 486, 18, 82,
    4096, 311, 4097, 189, 4096, 311, 8192, 82, 8193, 143, 12288, 14, 378, 0,
    143, 12288, 14, 378, 18, 82, 4096, 311, 4097, 189, 4096, 311, 8192, 82,
    8193, 143, 12288, 14, 396, 0, 143, 12288, 14, 396, 18, 82, 4096, 311, 4097,
    189, 4096, 311, 8192, 82, 8192, 143, 12288, 33, 18, 264, 143, 12288, 14,
    414, 0, 143, 12288, 14, 414, 18, 82, 4096, 311, 4097, 189, 4102, 311, 4099,
    189, 20484, 189, 1, 4096, 189
},
// skyBox48
{
    5134, 4106, 189, 20482, 189, 1, 4096, 189, 5, 4097, 202, 2, 4096, 202,
    4097, 189, 5, 4096, 202, 24578, 82, 7424, 24576, 82, 6400, 4096, 202, 4097,
    189, 3, 4097, 202, 24580, 82, 7424, 36864, 202, 4096, 4097, 189, 3, 4096,
    202, 24576, 82, 7424, 24576, 82, 6400, 24579, 82, 7424, 4096, 202, 4097,
    189, 1, 4097, 202, 24580, 82, 7424, 24576, 82, 6400, 24576, 82, 7424,
    36864, 202, 4096, 4097, 189, 1, 4096, 202, 24580, 82, 7424, 24576, 82,
    6400, 24577, 82, 7424, 4096, 202, 4097, 189, 0, 4096, 202, 24576, 82, 6400,
    24576, 82, 7424, 28672, 242, 216, 0, 82, 7424, 28672, 242, 216, 18, 82,
    6400, 28672, 242, 216, 36, 82, 7424, 28672, 242, 216, 54, 82, 7424, 24578,
    82, 7424, 4096, 202, 4097, 189, 0, 36864, 202, 4096, 24576, 82, 7424,
    24576, 82, 6400, 28672, 242, 234, 0, 82, 7424, 28672, 242, 234, 18, 82,
    7424, 28672, 242, 234, 36, 82, 7424, 28672, 242, 234, 54, 82, 7424, 24578,
    82, 7424, 36864, 202, 4096, 4097, 189, 0, 4096, 202, 24577, 82, 7424,
    28672, 242, 252, 0, 82, 7424, 28672, 242, 252, 18, 82, 7424, 28672, 242,
    252, 36, 82, 7424, 28672, 242, 252, 54, 82, 7424, 24576, 82, 7424, 28672,
    21, 468, 0, 82, 6400, 28672, 21, 468, 18, 82, 7424, 4096, 202, 4097, 189,
    0, 4096, 202, 24576, 82, 6400, 24576, 82, 7424, 28672, 242, 270, 0, 82,
    7424, 28672, 242, 270, 18, 82, 7424, 28672, 242, 270, 36, 82, 7424, 28672,
    242, 270, 54, 82, 7424, 24576, 82, 7424, 28672, 21, 486, 0, 82, 7424,
    28672, 21, 486, 18, 82, 7424, 4096, 202, 4097, 189, 0, 36864, 202, 4096,
    24576, 82, 7424, 24576, 82, 6400, 28672, 242, 288, 0, 82, 7424, 28672, 242,
    288, 18, 82, 7424, 28672, 242, 288, 36, 82, 7424, 28672, 242, 288, 54, 82,
    7424, 24578, 82, 7424, 36864, 202, 4096, 4097, 189, 0, 4096, 202, 24577,
    82, 7424, 28672, 242, 306, 0, 82, 7424, 28672, 242, 306, 18, 82, 7424,
    28672, 242, 306, 36, 82, 6400, 28672, 242, 306, 54, 82, 7424, 24576, 82,
    7424, 24576, 82, 6400, 24576, 82, 7424, 4096, 202, 4097, 189, 1, 4096, 202,
    24583, 82, 7424, 4096, 202, 4097, 189, 1, 4097, 202, 24576, 82, 7424,
    24576, 82, 6400, 24577, 82, 7424, 24576, 82, 6400, 24577, 82, 7424, 36864,
    202, 4096, 4097, 189, 3, 4096, 202, 24576, 82, 7424, 24576, 82, 6400,
    24579, 82, 7424, 4096, 202, 4097, 189, 3, 4097, 202, 24578, 82, 7424,
    24576, 82, 6400, 24576, 82, 7424, 36864, 202, 4096, 4097, 189, 5, 4096,
    202, 24579, 82, 7424, 4096, 202, 4097, 189, 5, 4097, 202, 2, 4096, 202,
    4107, 189, 20482, 189, 1
},
// skyBox49
{
    4628, 4111, 189, 20483, 189, 1, 4096, 189, 4, 8192, 145, 36864, 311, 40, 8,
    4099, 189, 3, 8193, 145, 12288, 311, 145, 4096, 311, 4097, 54, 4097, 311,
    4097, 54, 4099, 311, 4097, 189, 4, 8192, 145, 4096, 311, 45056, 311, 82,
    32, 8192, 21, 12288, 79, 72, 612, 21, 12288, 79, 72, 630, 21, 12288, 19,
    54, 180, 82, 8192, 21, 12288, 79, 72, 612, 21, 12288, 79, 72, 630, 82,
    12288, 19, 54, 180, 82, 4097, 311, 4097, 189, 1, 36866, 436, 342, 0, 24,
    45056, 436, 144, 0, 145, 24, 4096, 311, 8192, 82, 8192, 21, 12288, 79, 90,
    612, 21, 12288, 79, 90, 630, 21, 12288, 19, 0, 180, 82, 8192, 21, 12288,
    79, 90, 612, 21, 12288, 79, 90, 630, 82, 12288, 19, 0, 180, 82, 4097, 311,
    4097, 189, 0, 36864, 436, 144, 0, 24, 4096, 436, 270, 0, 12288, 305, 0, 0,
    90, 12288, 305, 0, 18, 90, 12288, 305, 0, 36, 90, 4096, 311, 8192, 82,
    45056, 54, 21, 2088, 12288, 79, 108, 612, 21, 12288, 79, 108, 630, 82,
    12288, 19, 0, 180, 82, 45056, 54, 21, 2088, 12288, 79, 108, 612, 21, 12288,
    79, 108, 630, 82, 12288, 19, 0, 180, 82, 4097, 311, 4097, 189, 0, 4096,
    436, 252, 0, 8192, 90, 12288, 305, 18, 0, 90, 12288, 305, 18, 18, 90,
    12288, 305, 18, 36, 90, 4096, 311, 8193, 82, 12288, 79, 126, 612, 82,
    12288, 79, 126, 630, 82, 12288, 19, 0, 180, 82, 8192, 82, 12288, 79, 126,
    612, 82, 12288, 79, 126, 630, 82, 12288, 19, 234, 180, 82, 4097, 311, 4097,
    189, 0, 36864, 436, 180, 0, 16, 4096, 436, 288, 0, 12288, 305, 36, 0, 90,
    12288, 305, 36, 18, 90, 12288, 305, 36, 36, 90, 4096, 311, 8192, 82, 12288,
    365, 82, 12288, 19, 90, 576, 82, 12288, 365, 82, 12288, 19, 18, 576, 82,
    12288, 365, 82, 12288, 19, 90, 576, 82, 12288, 365, 82, 45056, 19, 180,
    576, 82, 16, 4097, 311, 4097, 189, 1, 36866, 436, 360, 0, 16, 45056, 436,
    180, 0, 145, 16, 4096, 311, 8200, 82, 4097, 311, 4097, 189, 4, 8192, 145,
    4096, 311, 8200, 82, 4097, 311, 4097, 189, 3, 8193, 145, 4096, 311, 8200,
    82, 4097, 311, 4097, 189, 4, 8192, 145, 4096, 311, 8193, 82, 45056, 54, 21,
    2080, 8192, 21, 8196, 82, 4097, 311, 4097, 189, 3, 8193, 145, 4096, 311,
    8193, 82, 8192, 21, 12288, 21, 468, 0, 21, 12288, 21, 468, 18, 82, 12288,
    19, 36, 180, 82, 8194, 82, 4097, 311, 4097, 189, 4, 8192, 145, 4096, 311,
    45056, 311, 82, 40, 8192, 82, 8192, 21, 12288, 21, 486, 0, 21, 12288, 21,
    486, 18, 82, 12288, 19, 72, 180, 82, 8194, 82, 4097, 311, 4097, 189, 3,
    8193, 145, 12288, 311, 145, 4097, 311, 4097, 54, 4097, 311, 4096, 10, 18,
    486, 4096, 10, 18, 504, 4096, 10, 18, 522, 4097, 311, 4097, 189, 4, 8192,
    145, 36864, 311, 32, 8, 4097, 311, 4097, 189, 15, 4096, 189, 4096, 311,
    4113, 189, 20482, 189, 1
},
// skyBox50
{
    7188, 4111, 189, 20483, 189, 1, 4096, 189, 2, 4096, 311, 36864, 311, 40, 8,
    36864, 192, 8, 4098, 202, 4097, 189, 2, 4096, 311, 12288, 592, 0, 0, 82,
    12288, 592, 0, 18, 82, 12288, 592, 0, 36, 82, 8196, 82, 0, 8192, 60, 12289,
    192, 60, 4097, 202, 4097, 189, 1, 36864, 311, 8, 4096, 311, 12288, 592, 18,
    0, 82, 12288, 592, 18, 18, 82, 4096, 592, 18, 36, 8198, 82, 45056, 202, 60,
    24, 4098, 202, 4097, 189, 1, 12288, 311, 60, 4096, 311, 36864, 311, 32, 8,
    4099, 202, 4097, 189, 0, 12289, 192, 60, 4096, 311, 36864, 192, 40, 9,
    8194, 82, 4097, 189, 0, 45056, 311, 60, 8, 12289, 192, 60, 4097, 192, 8,
    8194, 82, 4097, 189, 0, 4098, 311, 10, 8194, 82, 4097, 189, 0, 4098, 311,
    36864, 311, 40, 9, 4098, 202, 4097, 189, 0, 4098, 311, 45056, 19, 90, 576,
    82, 8, 12288, 91, 144, 0, 82, 12288, 91, 144, 18, 82, 12288, 91, 144, 36,
    82, 8198, 82, 4098, 202, 4097, 189, 0, 4098, 311, 36864, 311, 32, 9, 4098,
    202, 4097, 189, 36864, 311, 8, 4098, 311, 11, 8193, 82, 4097, 189, 4099,
    311, 11, 8193, 82, 4097, 189, 4099, 311, 9, 4096, 21, 468, 0, 4096, 21,
    468, 18, 12289, 202, 82, 4097, 189, 4099, 311, 9, 4096, 21, 486, 0, 4096,
    21, 486, 18, 12289, 202, 82, 4097, 189, 4099, 311, 11, 8193, 82, 4097, 189,
    36864, 311, 8, 4098, 311, 11, 8193, 82, 4097, 189, 0, 4098, 311, 36864,
    311, 40, 9, 4098, 202, 4097, 189, 0, 4098, 311, 45056, 19, 90, 576, 82, 8,
    12288, 91, 144, 0, 82, 12288, 91, 144, 18, 82, 12288, 91, 144, 36, 82,
    8198, 82, 4098, 202, 4097, 189, 0, 4098, 311, 36864, 311, 32, 9, 4098, 202,
    4097, 189, 0, 4098, 311, 10, 8194, 82, 4097, 189, 0, 36864, 311, 8, 4097,
    311, 10, 8194, 82, 4097, 189, 1, 4097, 311, 10, 8194, 82, 4097, 189, 1,
    4097, 311, 36864, 311, 40, 8, 4099, 202, 4097, 189, 1, 36864, 311, 8, 4096,
    311, 12288, 592, 0, 0, 82, 12288, 592, 0, 18, 82, 12288, 592, 0, 36, 82,
    8198, 82, 4099, 202, 4097, 189, 2, 4096, 311, 12288, 592, 18, 0, 82, 12288,
    592, 18, 18, 82, 12288, 592, 18, 36, 82, 8198, 82, 4099, 202, 4097, 189, 2,
    4096, 311, 36864, 311, 32, 8, 4099, 202, 4112, 189, 20483, 189, 1
},
// skyBox51
{
    5650, 4110, 189, 20482, 189, 1, 4096, 189, 1, 53248, 313, 20, 8, 20480,
    313, 20, 10, 4098, 189, 1, 20480, 313, 20, 20481, 175, 20, 4096, 202,
    20481, 175, 20, 4096, 202, 20481, 175, 20, 36864, 202, 40, 2, 4096, 202,
    4097, 189, 0, 53248, 313, 20, 8, 20480, 313, 20, 20480, 175, 20, 4096, 202,
    20481, 175, 20, 4096, 202, 20481, 175, 20, 4096, 202, 20480, 175, 20, 4096,
    10, 18, 486, 4096, 10, 36, 504, 4096, 10, 36, 522, 4096, 202, 4097, 189, 0,
    20481, 313, 20, 28672, 274, 82, 20, 8202, 82, 4096, 202, 4097, 189, 53248,
    313, 20, 8, 20481, 313, 20, 28672, 274, 82, 20, 8192, 82, 45056, 54, 93,
    2072, 8193, 93, 45056, 54, 93, 2088, 8197, 82, 4096, 202, 4097, 189, 20482,
    313, 20, 28672, 274, 82, 20, 8192, 82, 8192, 93, 45056, 54, 93, 2080,
    45056, 54, 93, 2064, 8192, 93, 8192, 82, 45057, 54, 93, 2048, 8193, 82,
    45056, 202, 82, 8, 4096, 202, 4097, 189, 20482, 313, 20, 28672, 274, 82,
    20, 8192, 82, 8192, 93, 45056, 54, 93, 2088, 45056, 54, 93, 2072, 8192, 93,
    8192, 82, 45057, 54, 93, 2048, 8193, 82, 45056, 202, 82, 8, 4096, 202,
    4097, 189, 20482, 313, 20, 28672, 274, 82, 20, 8192, 82, 45056, 54, 93,
    2064, 8193, 93, 45056, 54, 93, 2080, 8193, 82, 12288, 93, 18, 486, 82,
    12288, 93, 18, 504, 82, 12288, 93, 18, 522, 82, 12288, 202, 82, 4096, 202,
    4097, 189, 20482, 313, 20, 28672, 274, 82, 20, 8201, 82, 12288, 202, 82,
    4096, 202, 4097, 189, 20482, 313, 20, 28672, 274, 82, 20, 8192, 82, 45056,
    54, 93, 2080, 45056, 54, 93, 2064, 45056, 54, 93, 2080, 45056, 54, 93,
    2064, 45056, 54, 93, 2080, 45056, 54, 93, 2064, 8192, 82, 12288, 21, 468,
    0, 82, 12288, 21, 468, 18, 82, 12288, 202, 82, 4096, 202, 4097, 189, 20482,
    313, 20, 28672, 274, 82, 20, 8192, 82, 45056, 54, 93, 2088, 45056, 54, 93,
    2072, 45056, 54, 93, 2088, 45056, 54, 93, 2072, 45056, 54, 93, 2088, 45056,
    54, 93, 2072, 8192, 82, 12288, 21, 486, 0, 82, 12288, 21, 486, 18, 82,
    12288, 202, 82, 4096, 202, 4097, 189, 20482, 313, 20, 28672, 274, 82, 20,
    8201, 82, 12288, 202, 82, 4096, 202, 4097, 189, 20482, 313, 20, 28672, 274,
    82, 20, 8192, 82, 45056, 54, 93, 2072, 8193, 93, 45056, 54, 93, 2088, 8193,
    82, 12288, 93, 18, 486, 82, 12288, 93, 18, 504, 82, 12288, 93, 18, 522, 82,
    12288, 202, 82, 4096, 202, 4097, 189, 20482, 313, 20, 28672, 274, 82, 20,
    8192, 82, 8192, 93, 45056, 54, 93, 2080, 45056, 54, 93, 2064, 8192, 93,
    8192, 82, 45057, 54, 93, 2048, 8193, 82, 45056, 202, 82, 8, 4096, 202,
    4097, 189, 20482, 313, 20, 28672, 274, 82, 20, 8192, 82, 8192, 93, 45056,
    54, 93, 2088, 45056, 54, 93, 2072, 8192, 93, 8192, 82, 45057, 54, 93, 2048,
    8193, 82, 45056, 202, 82, 8, 4096, 202, 4097, 189, 53248, 313, 20, 8,
    20481, 313, 20, 28672, 274, 82, 20, 8192, 82, 45056, 54, 93, 2064, 8193,
    93, 45056, 54, 93, 2080, 8197, 82, 4096, 202, 4097, 189, 0, 20481, 313, 20,
    28672, 274, 82, 20, 8202, 82, 4096, 202, 4097, 189, 0, 53248, 313, 20, 8,
    20480, 313, 20, 20480, 175, 20, 4096, 202, 20481, 175, 20, 4096, 202,
    20481, 175, 20, 4096, 202, 20480, 175, 20, 4096, 10, 36, 486, 4096, 10, 36,
    504, 4096, 10, 18, 522, 4096, 202, 4097, 189, 1, 20480, 313, 20, 20481,
    175, 20, 4096, 202, 20481, 175, 20, 4096, 202, 20481, 175, 20, 36864, 202,
    32, 2, 4096, 202, 4097, 189, 1, 53248, 313, 20, 8, 20480, 313, 20, 10,
    4112, 189, 20482, 189, 1
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getSkyBox(int skyBoxId, const std::vector<bool> &framedTiles)
{
    return {skyBoxData[skyBoxId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/SkyBoxes.h`
```
#ifndef SKYBOXES_H
#define SKYBOXES_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto skyBoxes = std::views::iota(0, 51);

TileBuffer getSkyBox(int skyBoxId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // SKYBOXES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/SwordShrines.cpp`
```
#include "structures/data/SwordShrines.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> shrineData{
// swordShrine1
{
    2308, 2, 36864, 273, 8, 2, 4096, 273, 1, 36864, 273, 8, 4096, 273, 4096,
    187, 918, 0, 4096, 187, 918, 18, 4097, 273, 4096, 187, 936, 0, 4096, 187,
    936, 18, 4097, 273, 4096, 187, 954, 0, 4096, 187, 954, 18, 4097, 273, 1,
    36864, 273, 8, 4096, 273, 2, 4096, 273, 2, 36864, 273, 8
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getSwordShrine(const std::vector<bool> &framedTiles)
{
    return {shrineData[0].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/SwordShrines.h`
```
#ifndef SWORDSHRINES_H
#define SWORDSHRINES_H

#include "TileBuffer.h"

namespace Data
{

TileBuffer getSwordShrine(const std::vector<bool> &framedTiles);

} // namespace Data

#endif // SWORDSHRINES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Torches.cpp`
```
#include "structures/data/Torches.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> torchData{
// torchFavor
{
    3861, 4122, 189, 13, 4099, 189, 7, 4097, 432, 4096, 369, 36864, 369, 40, 4,
    4098, 189, 5, 12289, 4, 0, 198, 73, 0, 4096, 432, 4096, 680, 4096, 357,
    4096, 369, 36864, 369, 40, 1, 4097, 369, 4097, 189, 4, 12288, 4, 0, 22, 73,
    12288, 4, 0, 198, 73, 12289, 4, 0, 220, 73, 12288, 4, 0, 352, 73, 20480,
    432, 3, 20480, 680, 3, 20481, 357, 27, 4096, 369, 36864, 369, 40, 36864,
    369, 8, 20480, 357, 27, 4096, 369, 4097, 189, 2, 12288, 4, 0, 22, 73,
    12288, 4, 0, 198, 73, 12288, 4, 0, 264, 73, 12288, 4, 0, 220, 73, 12288, 4,
    0, 132, 73, 12288, 4, 0, 110, 73, 12288, 4, 0, 132, 73, 20480, 432, 3,
    20480, 681, 3, 20482, 357, 26, 4097, 369, 20480, 357, 26, 4096, 369, 4097,
    189, 1, 12288, 4, 0, 22, 73, 12288, 4, 0, 198, 73, 12288, 4, 0, 264, 73,
    12289, 4, 0, 132, 73, 12290, 4, 0, 110, 73, 20480, 432, 3, 20480, 681, 3,
    20484, 357, 27, 20480, 357, 26, 4096, 369, 4097, 189, 2, 12288, 4, 0, 22,
    73, 12288, 4, 0, 198, 73, 12288, 4, 0, 264, 73, 12288, 4, 0, 132, 73,
    12290, 4, 0, 110, 73, 20480, 432, 3, 20480, 681, 3, 4097, 357, 20481, 357,
    27, 4096, 357, 20480, 357, 26, 4096, 369, 4097, 189, 4, 12288, 4, 0, 198,
    73, 12288, 4, 0, 264, 73, 12288, 4, 0, 132, 73, 12288, 4, 0, 110, 73,
    12288, 4, 0, 132, 73, 20480, 432, 3, 20480, 680, 3, 4100, 357, 20480, 357,
    27, 4096, 369, 4097, 189, 1, 12288, 4, 0, 22, 73, 2, 12288, 4, 0, 198, 73,
    12288, 4, 0, 352, 73, 12288, 4, 0, 132, 73, 12288, 4, 0, 220, 73, 20480,
    432, 3, 20480, 680, 3, 4098, 357, 4097, 369, 4096, 357, 4096, 369, 4097,
    189, 0, 12288, 4, 0, 22, 73, 12288, 4, 0, 264, 73, 12288, 4, 0, 198, 73, 0,
    12288, 4, 0, 198, 73, 12288, 4, 0, 264, 73, 12288, 4, 0, 132, 73, 12288, 4,
    0, 220, 73, 12288, 4, 0, 352, 73, 20480, 432, 15, 20480, 680, 3, 4097, 357,
    4096, 369, 36864, 369, 32, 36864, 369, 8, 4096, 357, 4096, 369, 4097, 189,
    1, 12288, 4, 0, 198, 73, 3, 12289, 4, 0, 44, 73, 0, 4096, 432, 4096, 680,
    4096, 357, 4096, 369, 36864, 369, 32, 1, 4097, 369, 4097, 189, 9, 4097,
    432, 4096, 369, 36864, 369, 32, 4, 4098, 189, 17, 4117, 189
},
// torchLeft
{
    5404, 4129, 189, 14, 4105, 189, 18, 4103, 189, 20, 4101, 189, 8, 12288, 4,
    0, 154, 73, 11, 4101, 189, 4, 12290, 4, 0, 44, 73, 1, 12289, 4, 0, 44, 73,
    10, 4100, 189, 1, 12289, 4, 0, 44, 73, 2, 12289, 4, 0, 44, 73, 12288, 4, 0,
    154, 73, 12288, 4, 0, 44, 73, 12289, 4, 0, 352, 73, 9, 4100, 189, 2, 12288,
    4, 0, 154, 73, 0, 12289, 4, 0, 44, 73, 12288, 4, 0, 352, 73, 12288, 4, 0,
    220, 73, 12289, 4, 0, 352, 73, 12288, 4, 0, 132, 73, 12288, 4, 0, 220, 73,
    12288, 4, 0, 44, 73, 8, 4100, 189, 2, 12288, 4, 0, 44, 73, 12288, 4, 0,
    352, 73, 12288, 4, 0, 44, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 132, 73,
    12288, 4, 0, 352, 73, 12288, 4, 0, 242, 73, 12288, 4, 0, 220, 73, 12288, 4,
    0, 242, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 154, 73, 53248, 635, 28,
    2088, 8, 4099, 189, 2, 12289, 4, 0, 44, 73, 0, 12288, 4, 0, 44, 73, 12290,
    4, 0, 220, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 44, 73, 36864, 325, 2072,
    36864, 325, 2048, 53248, 635, 28, 2048, 8, 4099, 189, 5, 12288, 4, 0, 154,
    73, 12288, 4, 0, 352, 73, 12288, 4, 0, 220, 73, 12289, 4, 0, 44, 73, 36864,
    325, 2072, 36864, 325, 2048, 61440, 635, 167, 28, 2048, 53249, 321, 28,
    2048, 7, 4099, 189, 4, 12288, 4, 0, 44, 73, 12289, 4, 0, 352, 73, 12288, 4,
    0, 220, 73, 12288, 4, 0, 352, 73, 36864, 325, 2072, 45056, 325, 167, 2048,
    61440, 635, 167, 28, 2048, 53250, 158, 28, 2048, 53248, 158, 28, 2088, 7,
    4098, 189, 6, 12288, 4, 0, 0, 73, 12288, 4, 0, 44, 73, 12288, 4, 0, 352,
    73, 45056, 325, 167, 2048, 53249, 635, 28, 2048, 53252, 158, 28, 2048,
    53248, 158, 28, 2088, 5, 4099, 189, 5, 12290, 4, 0, 44, 73, 53248, 635, 28,
    2048, 53248, 635, 28, 2080, 2, 53248, 158, 28, 2064, 53249, 158, 28, 2048,
    53248, 159, 28, 2048, 53248, 159, 28, 2088, 4, 4099, 189, 16, 53248, 159,
    28, 2064, 53248, 159, 28, 2048, 53248, 159, 28, 2088, 4, 4098, 189, 17,
    53248, 159, 28, 2064, 53248, 159, 28, 2048, 53248, 158, 28, 2048, 53248,
    158, 28, 2088, 2, 4099, 189, 17, 53248, 158, 28, 2064, 53250, 158, 28,
    2048, 53248, 158, 28, 2088, 0, 4100, 189, 18, 53248, 158, 28, 2064, 53250,
    158, 28, 2048, 4101, 189, 19, 53248, 158, 28, 2064, 53248, 158, 28, 2048,
    4104, 189, 18, 4124, 189
},
// torchRight
{
    5404, 4131, 189, 18, 4100, 189, 20, 53248, 158, 28, 2072, 53248, 158, 28,
    2048, 4100, 189, 18, 53248, 158, 28, 2072, 53250, 158, 28, 2048, 4099, 189,
    17, 53248, 158, 28, 2072, 53250, 158, 28, 2048, 53248, 158, 28, 2080, 0,
    4099, 189, 16, 53248, 159, 28, 2072, 53248, 159, 28, 2048, 53248, 158, 28,
    2048, 53248, 158, 28, 2080, 2, 4098, 189, 16, 53248, 159, 28, 2072, 53248,
    159, 28, 2048, 53248, 159, 28, 2080, 4, 4098, 189, 5, 12290, 4, 0, 44, 73,
    53248, 635, 28, 2048, 53248, 635, 28, 2088, 2, 53248, 158, 28, 2072, 53249,
    158, 28, 2048, 53248, 159, 28, 2048, 53248, 159, 28, 2080, 4, 4099, 189, 5,
    12288, 4, 0, 0, 73, 12288, 4, 0, 44, 73, 12288, 4, 0, 352, 73, 45056, 325,
    167, 2048, 53249, 635, 28, 2048, 53252, 158, 28, 2048, 53248, 158, 28,
    2080, 5, 4098, 189, 4, 12288, 4, 0, 44, 73, 12289, 4, 0, 352, 73, 12288, 4,
    0, 220, 73, 12288, 4, 0, 352, 73, 36864, 325, 2064, 45056, 325, 167, 2048,
    61440, 635, 167, 28, 2048, 53250, 158, 28, 2048, 53248, 158, 28, 2080, 7,
    4098, 189, 5, 12288, 4, 0, 154, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 220,
    73, 12289, 4, 0, 44, 73, 36864, 325, 2064, 36864, 325, 2048, 61440, 635,
    167, 28, 2048, 53249, 321, 28, 2048, 7, 4099, 189, 2, 12289, 4, 0, 44, 73,
    0, 12288, 4, 0, 44, 73, 12290, 4, 0, 220, 73, 12288, 4, 0, 352, 73, 12288,
    4, 0, 44, 73, 36864, 325, 2064, 36864, 325, 2048, 53248, 635, 28, 2048, 8,
    4099, 189, 2, 12288, 4, 0, 44, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 44,
    73, 12288, 4, 0, 352, 73, 12288, 4, 0, 132, 73, 12288, 4, 0, 352, 73,
    12288, 4, 0, 242, 73, 12288, 4, 0, 220, 73, 12288, 4, 0, 242, 73, 12288, 4,
    0, 352, 73, 12288, 4, 0, 154, 73, 53248, 635, 28, 2080, 8, 4099, 189, 2,
    12288, 4, 0, 154, 73, 0, 12289, 4, 0, 44, 73, 12288, 4, 0, 352, 73, 12288,
    4, 0, 220, 73, 12289, 4, 0, 352, 73, 12288, 4, 0, 132, 73, 12288, 4, 0,
    220, 73, 12288, 4, 0, 44, 73, 8, 4100, 189, 1, 12289, 4, 0, 44, 73, 2,
    12289, 4, 0, 44, 73, 12288, 4, 0, 154, 73, 12288, 4, 0, 44, 73, 12289, 4,
    0, 352, 73, 9, 4100, 189, 4, 12290, 4, 0, 44, 73, 1, 12289, 4, 0, 44, 73,
    10, 4100, 189, 8, 12288, 4, 0, 154, 73, 11, 4102, 189, 20, 4103, 189, 18,
    4107, 189, 14, 4130, 189
},
// torchUp
{
    3878, 4138, 189, 28, 4102, 189, 10, 36864, 208, 2048, 53248, 208, 28, 2048,
    53248, 635, 28, 2048, 18, 4099, 189, 7, 12288, 4, 0, 154, 73, 0, 12289, 4,
    0, 44, 73, 53249, 177, 3, 2048, 53249, 635, 28, 2048, 17, 4099, 189, 6,
    12289, 4, 0, 44, 73, 12288, 4, 0, 154, 73, 12289, 4, 0, 44, 73, 12288, 4,
    22, 44, 73, 12288, 4, 0, 154, 73, 53248, 177, 3, 2048, 53249, 635, 28,
    2048, 17, 4098, 189, 3, 12288, 4, 0, 44, 73, 12288, 4, 0, 418, 73, 12288,
    4, 0, 154, 73, 12290, 4, 0, 44, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 132,
    73, 12288, 4, 0, 352, 73, 12288, 4, 0, 418, 73, 53248, 177, 3, 2048, 53248,
    322, 28, 2048, 53249, 635, 28, 2048, 36867, 208, 2048, 9, 36864, 208, 2048,
    1, 4097, 189, 3, 12288, 4, 0, 154, 73, 12291, 4, 0, 44, 73, 12290, 4, 0,
    352, 73, 12288, 4, 0, 132, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 418, 73,
    53248, 177, 3, 2048, 53249, 322, 28, 2048, 53248, 635, 28, 2048, 36864,
    321, 2048, 53248, 322, 28, 2048, 36864, 321, 2048, 53248, 322, 28, 2048,
    36873, 208, 2048, 53248, 322, 28, 2048, 53249, 158, 28, 2048, 4097, 189, 1,
    12291, 4, 0, 44, 73, 12289, 4, 0, 352, 73, 12289, 4, 0, 132, 73, 12288, 4,
    0, 110, 73, 12288, 4, 0, 132, 73, 12288, 4, 0, 110, 73, 12288, 4, 0, 132,
    73, 12288, 4, 0, 418, 73, 53248, 177, 3, 2048, 36865, 322, 2048, 53248,
    322, 28, 2048, 36864, 321, 2048, 53248, 322, 28, 2048, 36864, 321, 2048,
    53259, 322, 28, 2048, 53249, 158, 28, 2048, 4097, 189, 2, 12289, 4, 0, 154,
    73, 12289, 4, 0, 44, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 44, 73, 12291,
    4, 0, 132, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 418, 73, 53248, 177, 3,
    2048, 36865, 322, 2048, 53248, 635, 28, 2048, 36864, 321, 2048, 53248, 322,
    28, 2048, 36864, 321, 2048, 53248, 322, 28, 2048, 36873, 208, 2048, 53248,
    322, 28, 2048, 53249, 158, 28, 2048, 4098, 189, 3, 12288, 4, 0, 154, 73,
    12288, 4, 0, 44, 73, 12288, 4, 0, 418, 73, 12288, 4, 0, 44, 73, 12288, 4,
    0, 352, 73, 12288, 4, 0, 44, 73, 12288, 4, 0, 352, 73, 12288, 4, 0, 44, 73,
    12288, 4, 0, 352, 73, 12288, 4, 0, 396, 73, 36864, 177, 2048, 36864, 322,
    2048, 53249, 635, 28, 2048, 36867, 208, 2048, 9, 36864, 208, 2048, 1, 4098,
    189, 5, 12288, 4, 0, 154, 73, 12289, 4, 0, 44, 73, 12288, 4, 0, 154, 73,
    12288, 4, 0, 418, 73, 12288, 4, 0, 44, 73, 12288, 4, 44, 418, 73, 12288, 4,
    0, 154, 73, 36864, 177, 2048, 53249, 635, 28, 2048, 17, 4098, 189, 5,
    12289, 4, 0, 154, 73, 1, 12289, 4, 0, 418, 73, 53248, 177, 3, 2048, 36864,
    177, 2048, 53249, 635, 28, 2048, 17, 4100, 189, 10, 36864, 208, 2048,
    53248, 208, 28, 2048, 53248, 635, 28, 2048, 18, 4102, 189, 28, 4137, 189
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getTorch(Torch torchId, const std::vector<bool> &framedTiles)
{
    return {torchData[static_cast<int>(torchId)].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Torches.h`
```
#ifndef TORCHES_H
#define TORCHES_H

#include "TileBuffer.h"

namespace Data
{

enum class Torch { favor = 0, left, right, up };

TileBuffer getTorch(Torch torchId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // TORCHES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Trees.cpp`
```
#include "structures/data/Trees.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> treeData{
// tree1
{
    778, 5, 4096, 5, 44, 242, 1, 4096, 5, 44, 176, 4096, 5, 22, 198, 4097, 5,
    0, 66, 4096, 5, 0, 0, 4096, 5, 22, 44, 4096, 5, 44, 66, 4096, 5, 110, 66,
    4096, 5, 0, 44, 4096, 5, 0, 88, 4096, 5, 66, 154, 5, 4096, 5, 88, 66, 2
},
// tree2
{
    777, 1, 4096, 5, 44, 242, 5, 4096, 5, 0, 220, 4096, 5, 44, 110, 4096, 5,
    88, 0, 4096, 5, 22, 66, 4096, 5, 66, 110, 4096, 5, 0, 66, 4096, 5, 0, 88,
    4096, 5, 44, 110, 4096, 5, 0, 176, 3, 4096, 5, 66, 242, 2, 4096, 5, 22, 176
},
// tree3
{
    781, 0, 4096, 5, 66, 0, 4, 4096, 5, 44, 242, 0, 4096, 5, 66, 0, 1, 4096, 5,
    44, 132, 4096, 5, 22, 220, 4096, 5, 110, 66, 4096, 5, 44, 66, 4096, 5, 0,
    44, 4096, 5, 0, 22, 4096, 5, 66, 110, 4096, 5, 44, 66, 4096, 5, 88, 44,
    4096, 5, 22, 110, 4096, 5, 110, 110, 4096, 5, 0, 22, 4096, 5, 0, 0, 4096,
    5, 66, 176, 0, 4096, 5, 88, 66, 2, 4096, 5, 66, 198, 2, 4096, 5, 88, 110, 2
},
// tree4
{
    779, 0, 4096, 5, 44, 198, 2, 4096, 5, 66, 44, 2, 4096, 5, 66, 0, 4096, 5,
    44, 176, 4096, 5, 22, 198, 4096, 5, 88, 0, 4096, 5, 0, 88, 4096, 5, 0, 110,
    4096, 5, 44, 88, 4096, 5, 88, 22, 4096, 5, 0, 88, 4096, 5, 66, 66, 4096, 5,
    0, 0, 4096, 5, 88, 44, 4096, 5, 66, 176, 6, 4096, 5, 66, 198, 2
},
// tree5
{
    782, 5, 4096, 5, 66, 44, 1, 4096, 5, 44, 198, 0, 4096, 5, 44, 220, 0, 4096,
    5, 44, 176, 4096, 5, 22, 198, 4096, 5, 22, 66, 4096, 5, 0, 22, 4096, 5, 0,
    44, 4096, 5, 0, 66, 4096, 5, 0, 22, 4096, 5, 88, 0, 4097, 5, 22, 22, 4096,
    5, 88, 0, 4096, 5, 22, 0, 4096, 5, 88, 44, 4096, 5, 0, 44, 4096, 5, 66,
    132, 13
},
// tree6
{
    775, 2, 4096, 5, 44, 198, 1, 4096, 5, 44, 132, 4096, 5, 22, 198, 4096, 5,
    0, 0, 4096, 5, 0, 88, 4096, 5, 88, 0, 4096, 5, 66, 110, 4096, 5, 22, 0,
    4096, 5, 88, 154, 3, 4096, 5, 66, 198, 0, 4096, 5, 22, 176
},
// tree7
{
    778, 8, 4096, 5, 44, 132, 4096, 5, 22, 198, 4096, 5, 44, 110, 4096, 5, 66,
    66, 4096, 5, 0, 44, 4096, 5, 22, 66, 4096, 5, 66, 66, 4096, 5, 0, 44, 4096,
    5, 0, 66, 4096, 5, 0, 44, 4096, 5, 88, 132, 1, 4096, 5, 88, 88, 1, 4096, 5,
    66, 198, 2, 4096, 5, 22, 154
},
// tree8
{
    784, 3, 4096, 5, 44, 242, 2, 4096, 5, 66, 44, 2, 4096, 5, 44, 198, 2, 4096,
    5, 22, 220, 4096, 5, 66, 66, 4096, 5, 0, 22, 4096, 5, 0, 44, 4096, 5, 88,
    22, 4097, 5, 0, 44, 4096, 5, 22, 22, 4096, 5, 110, 66, 4096, 5, 22, 66,
    4096, 5, 0, 0, 4096, 5, 22, 66, 4096, 5, 88, 44, 4096, 5, 0, 0, 4096, 5,
    22, 66, 4096, 5, 0, 176, 0, 4096, 5, 88, 110, 5, 4096, 5, 66, 242, 5, 4096,
    5, 22, 132
},
// tree9
{
    782, 5, 4096, 5, 44, 220, 6, 4096, 5, 22, 198, 4096, 5, 0, 66, 4096, 5, 44,
    66, 4096, 5, 0, 110, 4096, 5, 66, 88, 4096, 5, 0, 0, 4096, 5, 88, 44, 4096,
    5, 0, 66, 4096, 5, 44, 66, 4096, 5, 0, 0, 4096, 5, 44, 110, 4097, 5, 0, 22,
    4096, 5, 0, 176, 3, 4096, 5, 66, 220, 7, 4096, 5, 22, 176
},
// tree10
{
    781, 6, 4096, 5, 66, 22, 3, 4096, 5, 44, 132, 4096, 5, 22, 242, 4096, 5, 0,
    0, 4096, 5, 0, 110, 4096, 5, 22, 0, 4096, 5, 0, 22, 4096, 5, 0, 44, 4096,
    5, 0, 22, 4096, 5, 88, 22, 4096, 5, 0, 44, 4096, 5, 0, 22, 4096, 5, 66, 66,
    4096, 5, 0, 110, 4096, 5, 66, 154, 9, 4096, 5, 66, 198, 1
},
// tree11
{
    775, 1, 4096, 5, 66, 0, 2, 4096, 5, 44, 176, 4096, 5, 22, 242, 4096, 5, 44,
    66, 4096, 5, 110, 88, 4096, 5, 0, 0, 4096, 5, 22, 22, 4096, 5, 0, 110,
    4096, 5, 66, 176, 1, 4096, 5, 66, 242, 3
},
// tree12
{
    782, 7, 4096, 5, 44, 242, 3, 4096, 5, 44, 132, 4096, 5, 22, 198, 4096, 5,
    0, 0, 4096, 5, 0, 44, 4096, 5, 22, 66, 4096, 5, 22, 110, 4096, 5, 44, 88,
    4096, 5, 22, 44, 4096, 5, 0, 44, 4096, 5, 88, 44, 4096, 5, 0, 22, 4096, 5,
    0, 44, 4097, 5, 0, 0, 4096, 5, 88, 176, 12, 4096, 5, 22, 176
},
// tree13
{
    781, 10, 4096, 5, 66, 0, 4096, 5, 44, 176, 4096, 5, 22, 220, 4096, 5, 66,
    110, 4096, 5, 0, 22, 4096, 5, 0, 44, 4096, 5, 66, 88, 4096, 5, 22, 44,
    4096, 5, 22, 22, 4096, 5, 0, 88, 4096, 5, 66, 88, 4097, 5, 0, 110, 4096, 5,
    88, 0, 4096, 5, 88, 154, 0, 4096, 5, 88, 110, 1, 4096, 5, 66, 220, 2, 4096,
    5, 88, 88, 2, 4096, 5, 22, 176
},
// tree14
{
    773, 4, 4096, 5, 0, 220, 4096, 5, 0, 22, 4096, 5, 66, 88, 4096, 5, 22, 66,
    4096, 5, 0, 132, 1, 4096, 5, 66, 198, 0, 4096, 5, 22, 176
},
// tree15
{
    780, 0, 4096, 5, 44, 242, 8, 4096, 5, 44, 176, 4096, 5, 22, 242, 4096, 5,
    88, 44, 4096, 5, 0, 110, 4096, 5, 66, 66, 4096, 5, 0, 110, 4096, 5, 66,
    110, 4096, 5, 0, 22, 4097, 5, 22, 66, 4096, 5, 0, 22, 4096, 5, 0, 0, 4096,
    5, 66, 154, 2, 4096, 5, 88, 88, 0, 4096, 5, 88, 88, 5
},
// tree16
{
    780, 1, 4096, 5, 66, 44, 1, 4096, 5, 66, 22, 2, 4096, 5, 44, 198, 0, 4096,
    5, 44, 154, 4096, 5, 22, 220, 4096, 5, 0, 22, 4096, 5, 88, 22, 4096, 5, 0,
    44, 4096, 5, 22, 22, 4096, 5, 110, 66, 4096, 5, 0, 0, 4096, 5, 22, 66,
    4096, 5, 0, 44, 4096, 5, 110, 66, 4096, 5, 22, 44, 4096, 5, 88, 132, 4,
    4096, 5, 66, 242, 2, 4096, 5, 66, 242, 0, 4096, 5, 22, 176
},
// tree17
{
    781, 9, 4096, 5, 44, 220, 1, 4096, 5, 22, 242, 4096, 5, 0, 22, 4096, 5, 66,
    66, 4096, 5, 22, 66, 4096, 5, 0, 22, 4096, 5, 22, 66, 4097, 5, 0, 44, 4096,
    5, 22, 88, 4096, 5, 66, 88, 4096, 5, 88, 44, 4096, 5, 22, 0, 4096, 5, 0,
    176, 1, 4096, 5, 88, 110, 5, 4096, 5, 66, 198, 1, 4096, 5, 22, 154
},
// tree18
{
    775, 5, 4096, 5, 44, 176, 4096, 5, 22, 198, 4096, 5, 44, 66, 4096, 5, 22,
    44, 4096, 5, 22, 22, 4096, 5, 0, 22, 4096, 5, 0, 44, 4096, 5, 66, 154, 6
},
// tree19
{
    783, 1, 4096, 5, 44, 198, 0, 4096, 5, 44, 220, 0, 4096, 5, 66, 44, 7, 4096,
    5, 22, 220, 4096, 5, 44, 66, 4096, 5, 110, 110, 4096, 5, 44, 66, 4096, 5,
    110, 110, 4096, 5, 44, 66, 4096, 5, 88, 22, 4096, 5, 66, 88, 4096, 5, 44,
    110, 4096, 5, 0, 66, 4096, 5, 66, 88, 4096, 5, 22, 22, 4096, 5, 66, 88,
    4096, 5, 44, 66, 4096, 5, 0, 154, 1, 4096, 5, 88, 88, 0, 4096, 5, 88, 88,
    1, 4096, 5, 88, 88, 1, 4096, 5, 88, 88, 0, 4096, 5, 66, 220, 0, 4096, 5,
    22, 154
},
// tree20
{
    780, 4, 4096, 5, 66, 44, 0, 4096, 5, 66, 22, 0, 4096, 5, 44, 198, 1, 4096,
    5, 22, 198, 4096, 5, 0, 22, 4096, 5, 66, 66, 4096, 5, 44, 66, 4096, 5, 66,
    110, 4096, 5, 88, 22, 4096, 5, 0, 44, 4096, 5, 110, 110, 4096, 5, 44, 110,
    4096, 5, 110, 110, 4096, 5, 0, 0, 4096, 5, 0, 154, 1, 4096, 5, 88, 66, 0,
    4096, 5, 88, 88, 1, 4096, 5, 88, 66, 0, 4096, 5, 66, 242, 0, 4096, 5, 22,
    154
},
// tree21
{
    780, 7, 4096, 5, 66, 44, 1, 4096, 5, 44, 154, 4096, 5, 22, 242, 4096, 5,
    66, 88, 4096, 5, 0, 44, 4096, 5, 22, 110, 4096, 5, 0, 22, 4096, 5, 22, 0,
    4096, 5, 44, 66, 4096, 5, 0, 22, 4096, 5, 88, 0, 4096, 5, 22, 88, 4096, 5,
    22, 66, 4096, 5, 88, 132, 0, 4096, 5, 66, 242, 8, 4096, 5, 22, 154
},
// tree22
{
    781, 4, 4096, 5, 66, 0, 6, 4096, 5, 22, 198, 4096, 5, 44, 66, 4096, 5, 0,
    44, 4096, 5, 66, 110, 4096, 5, 0, 22, 4096, 5, 88, 22, 4097, 5, 22, 44,
    4096, 5, 0, 0, 4096, 5, 66, 88, 4096, 5, 0, 110, 4096, 5, 22, 110, 4096, 5,
    0, 154, 2, 4096, 5, 66, 242, 4, 4096, 5, 66, 242, 1, 4096, 5, 22, 132
},
// tree23
{
    773, 0, 4096, 5, 66, 0, 1, 4096, 5, 44, 132, 4096, 5, 22, 220, 4096, 5, 88,
    22, 4096, 5, 0, 22, 4096, 5, 0, 0, 4096, 5, 66, 154, 4
},
// tree24
{
    781, 2, 4096, 5, 66, 0, 1, 4096, 5, 44, 242, 1, 4096, 5, 44, 242, 1, 4096,
    5, 44, 176, 4096, 5, 22, 242, 4096, 5, 44, 66, 4096, 5, 0, 22, 4096, 5,
    110, 88, 4096, 5, 22, 88, 4096, 5, 22, 66, 4096, 5, 88, 0, 4096, 5, 0, 0,
    4096, 5, 22, 110, 4096, 5, 110, 66, 4096, 5, 0, 0, 4096, 5, 0, 66, 4096, 5,
    88, 154, 2, 4096, 5, 66, 242, 4, 4096, 5, 66, 220, 1, 4096, 5, 22, 176
},
// tree25
{
    773, 4, 4096, 5, 22, 242, 4097, 5, 0, 0, 4096, 5, 0, 44, 4096, 5, 0, 154,
    3, 4096, 5, 22, 154
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getTree(int treeId, const std::vector<bool> &framedTiles)
{
    return {treeData[treeId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Trees.h`
```
#ifndef TREES_H
#define TREES_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto trees = std::views::iota(0, 25);

TileBuffer getTree(int treeId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // TREES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Wrecks.cpp`
```
#include "structures/data/Wrecks.h"

namespace
{
// clang-format off
std::vector<std::vector<uint16_t>> wreckData{
// wreck1
{
    1287, 4098, 189, 53248, 189, 1, 16, 20480, 189, 1, 4098, 189, 20482, 150,
    28, 4097, 397, 4097, 189, 20482, 150, 28, 4097, 397, 4097, 189, 20482, 150,
    28, 4097, 397, 4099, 189, 53248, 189, 1, 24, 20480, 189, 1, 4097, 189
},
// wreck2
{
    1287, 4098, 189, 53248, 189, 1, 16, 20480, 189, 1, 4098, 189, 53250, 150,
    28, 2049, 4097, 397, 4097, 189, 53250, 150, 28, 2049, 4097, 397, 4097, 189,
    53250, 150, 28, 2049, 4097, 397, 4099, 189, 53248, 189, 1, 24, 20480, 189,
    1, 4097, 189
},
// wreck3
{
    1285, 4097, 189, 20482, 189, 1, 4096, 189, 36864, 376, 0, 0, 1, 36864, 376,
    0, 18, 1, 20480, 159, 28, 4097, 189, 36864, 376, 18, 0, 1, 36864, 376, 18,
    18, 1, 20480, 159, 28, 4097, 189, 32769, 1, 20480, 159, 28, 4099, 189,
    20481, 189, 1
},
// wreck4
{
    3338, 4101, 189, 20482, 189, 1, 4097, 189, 32773, 1, 4096, 189, 53248, 159,
    28, 24, 4097, 189, 32773, 1, 53248, 159, 28, 24, 53248, 159, 28, 32, 4097,
    189, 32772, 1, 53248, 159, 28, 24, 53248, 159, 28, 32, 4098, 189, 32771, 1,
    53248, 159, 28, 24, 53248, 159, 28, 32, 4099, 189, 32769, 1, 40960, 148, 1,
    61440, 159, 148, 28, 24, 53248, 159, 28, 32, 36865, 213, 1, 4098, 189,
    32768, 1, 40960, 148, 1, 61440, 159, 148, 28, 24, 61440, 159, 148, 28, 32,
    45056, 213, 148, 1, 36864, 213, 1, 4099, 189, 40960, 148, 1, 61440, 159,
    148, 28, 24, 61440, 159, 148, 28, 32, 40962, 148, 1, 4099, 189, 53248, 159,
    28, 24, 61440, 159, 148, 28, 32, 45058, 213, 148, 1, 40960, 148, 1, 4099,
    189, 53248, 159, 28, 32, 36865, 213, 1, 45056, 213, 148, 1, 40963, 148, 1,
    4097, 189, 32771, 1, 40962, 148, 1, 4098, 189, 32772, 1, 40961, 148, 1,
    4104, 189, 20482, 189, 1
},
// wreck5
{
    2568, 4099, 189, 20483, 189, 1, 4096, 189, 32771, 1, 20481, 158, 28, 4097,
    189, 32770, 1, 57344, 42, 7168, 1, 20481, 158, 28, 4097, 189, 61440, 240,
    594, 54, 139, 7168, 1, 61440, 240, 594, 72, 139, 7168, 1, 61440, 240, 594,
    90, 139, 7168, 1, 57344, 42, 7168, 1, 20481, 158, 28, 4097, 189, 61440,
    240, 612, 54, 139, 7168, 1, 61440, 240, 612, 72, 139, 7168, 1, 45056, 240,
    612, 90, 139, 1, 57344, 42, 7168, 1, 20481, 158, 28, 4097, 189, 61440, 240,
    630, 54, 139, 7168, 1, 61440, 240, 630, 72, 139, 7168, 1, 61440, 240, 630,
    90, 139, 7168, 1, 57344, 42, 7168, 1, 20481, 158, 28, 4097, 189, 32770, 1,
    57344, 42, 7168, 1, 20481, 158, 28, 4097, 189, 32771, 1, 20481, 158, 28,
    4097, 189, 32771, 1, 20480, 158, 28, 4101, 189, 20482, 189, 1, 4096, 189
},
// wreck6
{
    2567, 4100, 189, 20481, 189, 1, 4096, 189, 53248, 159, 28, 16, 61440, 159,
    148, 28, 40, 32769, 1, 4098, 189, 32768, 1, 61440, 159, 148, 28, 16, 53248,
    159, 28, 40, 20481, 321, 28, 4097, 189, 32769, 1, 53248, 159, 28, 16,
    53248, 159, 28, 40, 20480, 321, 28, 4097, 189, 32770, 1, 53248, 159, 28,
    16, 53248, 159, 28, 40, 4097, 189, 32770, 1, 20480, 321, 28, 53248, 159,
    28, 16, 4097, 189, 32770, 1, 20481, 321, 28, 4097, 189, 32770, 1, 20481,
    321, 28, 4097, 189, 32770, 1, 4096, 189, 20480, 321, 28, 4100, 189, 20482,
    189, 1
},
// wreck7
{
    2052, 4096, 189, 20482, 189, 1, 4097, 189, 20480, 321, 28, 4097, 189,
    20481, 321, 28, 4097, 189, 20481, 321, 28, 4097, 189, 20481, 321, 28, 4097,
    189, 20480, 321, 28, 4098, 189, 20480, 321, 28, 4098, 189, 20482, 189, 1
},
// wreck8
{
    3335, 4099, 189, 20482, 189, 1, 4096, 189, 32770, 1, 20480, 158, 28, 53248,
    158, 28, 40, 4097, 189, 32768, 1, 57345, 42, 7168, 1, 61440, 158, 42, 7196,
    8, 20480, 158, 28, 4097, 189, 57347, 42, 7168, 1, 20480, 158, 28, 4097,
    189, 57344, 42, 7168, 1, 32769, 1, 57344, 42, 7168, 1, 20480, 158, 28,
    4097, 189, 32770, 1, 57344, 42, 7168, 1, 20480, 158, 28, 4097, 189, 32769,
    1, 57344, 42, 7168, 1, 61440, 158, 42, 7196, 8, 20480, 158, 28, 4097, 189,
    32768, 1, 57345, 42, 7168, 1, 20480, 158, 28, 53248, 158, 28, 32, 4097,
    189, 32768, 1, 57344, 42, 7168, 1, 53248, 158, 28, 8, 20480, 158, 28, 4098,
    189, 32768, 1, 57344, 42, 7168, 1, 20480, 158, 28, 53248, 158, 28, 32,
    4098, 189, 32768, 1, 57344, 42, 7168, 1, 20480, 158, 28, 4099, 189, 32769,
    1, 20480, 158, 28, 4101, 189, 20483, 189, 1
},
// wreck9
{
    2312, 4099, 189, 20483, 189, 1, 4096, 189, 32771, 1, 53248, 30, 28, 40,
    4098, 189, 32771, 1, 20480, 30, 28, 53248, 30, 28, 40, 4097, 189, 32769, 1,
    57344, 42, 7168, 1, 32768, 1, 61440, 30, 42, 7196, 8, 20480, 30, 28, 4097,
    189, 32768, 1, 57347, 42, 7168, 1, 20480, 30, 28, 4097, 189, 53248, 575,
    28, 1, 61443, 575, 42, 7196, 1, 20480, 30, 28, 4097, 189, 32769, 1, 57346,
    42, 7168, 1, 20480, 30, 28, 4097, 189, 32772, 1, 20480, 30, 28, 4101, 189,
    20482, 189, 1
},
// wreck10
{
    2309, 4097, 189, 20482, 189, 1, 4096, 189, 32768, 1, 57344, 150, 7168, 1,
    20480, 321, 28, 4097, 189, 36864, 214, 1, 61440, 214, 150, 7168, 1, 20480,
    321, 28, 4097, 189, 32768, 1, 57344, 150, 7168, 1, 20480, 321, 28, 4097,
    189, 36864, 214, 1, 61440, 214, 150, 7168, 1, 20480, 321, 28, 4097, 189,
    32768, 1, 57344, 150, 7168, 1, 20480, 321, 28, 4097, 189, 36864, 214, 1,
    61440, 214, 150, 7168, 1, 20480, 321, 28, 4097, 189, 32768, 1, 57344, 150,
    7168, 1, 20480, 321, 28, 4098, 189, 20482, 189, 1
},
// wreck11
{
    1029, 4098, 189, 20481, 189, 1, 4096, 189, 53248, 159, 28, 8, 20481, 159,
    28, 4097, 189, 32768, 1, 20481, 159, 28, 4099, 189, 20481, 189, 1
},
};
// clang-format on
} // namespace

namespace Data
{

TileBuffer getWreck(int wreckId, const std::vector<bool> &framedTiles)
{
    return {wreckData[wreckId].data(), framedTiles};
}

} // namespace Data

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/data/Wrecks.h`
```
#ifndef WRECKS_H
#define WRECKS_H

#include "TileBuffer.h"
#include <ranges>

namespace Data
{

inline auto wrecks = std::views::iota(0, 11);

TileBuffer getWreck(int wreckId, const std::vector<bool> &framedTiles);

} // namespace Data

#endif // WRECKS_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/structures/hardmode`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/hardmode/LootRules.cpp`
```
#include "structures/hardmode/LootRules.h"

#include "Config.h"
#include "World.h"
#include "ids/ItemID.h"
#include "structures/StructureUtil.h"
#include <cmath>
#include <iostream>
#include <map>

void swapBottledHoney(int x, int y, Item &item, World &world)
{
    if (item.id == ItemID::bottledHoney) {
        Tile &tile = world.getTile(x, y);
        if (tile.blockID == TileID::chest &&
            (tile.frameX == 360 || tile.frameX == 1044)) {
            item.id = ItemID::honeyfin;
        }
    }
}

void swapEvilArrows(int x, int y, Item &item, World &world)
{
    if (item.id == ItemID::jestersArrow || item.id == ItemID::holyArrow) {
        Tile &tile = world.getTile(x, y);
        if (tile.blockID == TileID::chestGroup2 && tile.frameX == 108) {
            item.id = ItemID::cursedArrow;
        } else if (tile.blockID == TileID::chest && tile.frameX == 1548) {
            item.id = ItemID::ichorArrow;
        }
    }
}

void applyHardmodeLoot(World &world)
{
    std::cout << "Compounding interest\n";
    std::map<int, int> itemUpdates{
        {ItemID::copperBar,
         world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                              : ItemID::leadBar},
        {ItemID::tinBar,
         world.ironVariant == TileID::ironOre ? ItemID::ironBar
                                              : ItemID::leadBar},
        {ItemID::ironBar,
         world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                              : ItemID::platinumBar},
        {ItemID::leadBar,
         world.goldVariant == TileID::goldOre ? ItemID::goldBar
                                              : ItemID::platinumBar},
        {ItemID::silverBar, ItemID::meteoriteBar},
        {ItemID::tungstenBar, ItemID::meteoriteBar},
        {ItemID::goldBar,
         world.cobaltVariant == TileID::palladiumOre ? ItemID::palladiumBar
                                                     : ItemID::cobaltBar},
        {ItemID::platinumBar,
         world.cobaltVariant == TileID::cobaltOre ? ItemID::cobaltBar
                                                  : ItemID::palladiumBar},
        {ItemID::meteoriteBar,
         world.mythrilVariant == TileID::orichalcumOre ? ItemID::orichalcumBar
                                                       : ItemID::mythrilBar},
        {ItemID::demoniteBar,
         world.adamantiteVariant == TileID::titaniumOre
             ? ItemID::titaniumBar
             : ItemID::adamantiteBar},
        {ItemID::crimtaneBar,
         world.adamantiteVariant == TileID::adamantiteOre
             ? ItemID::adamantiteBar
             : ItemID::titaniumBar},
        {ItemID::woodenArrow, ItemID::unholyArrow},
        {ItemID::flamingArrow, ItemID::jestersArrow},
        {ItemID::jestersArrow, ItemID::holyArrow},
        {ItemID::silverBullet, ItemID::explodingBullet},
        {ItemID::tungstenBullet, ItemID::explodingBullet},
        {ItemID::lesserHealingPotion, ItemID::healingPotion},
        {ItemID::healingPotion, ItemID::greaterHealingPotion},
        {ItemID::spear, ItemID::swordfish},
        {ItemID::blowpipe, ItemID::blowgun},
        {ItemID::woodenBoomerang, ItemID::enchantedBoomerang},
        {ItemID::mace,
         world.isCrimson ? ItemID::theMeatball : ItemID::ballOHurt},
        {ItemID::boomstick, ItemID::quadBarrelShotgun},
    };
    int skipX = -1;
    int skipY = -1;
    if (world.conf.equipment != 0) {
        double minDist = 9999;
        for (int x = world.spawn.x - 80; x < world.spawn.x + 80; ++x) {
            for (int y = world.spawn.y - 40; y < world.spawn.y + 40; ++y) {
                Tile &tile = world.getTile(x, y);
                if ((tile.blockID == TileID::chest ||
                     tile.blockID == TileID::chestGroup2) &&
                    tile.frameX % 36 == 0 && tile.frameY == 0) {
                    double dist = hypot(world.spawn, {x, y});
                    if (dist < minDist) {
                        minDist = dist;
                        skipX = x;
                        skipY = y;
                    }
                }
            }
        }
    }
    for (auto &chest : world.getChests()) {
        if (chest.x == skipX && chest.y == skipY) {
            continue;
        }
        for (auto &item : chest.items) {
            auto itr = itemUpdates.find(item.id);
            if (itr != itemUpdates.end()) {
                item.id = itr->second;
            }
            swapBottledHoney(chest.x, chest.y, item, world);
            swapEvilArrows(chest.x, chest.y, item, world);
        }
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/hardmode/LootRules.h`
```
#ifndef HARDMODE_LOOTRULES_H
#define HARDMODE_LOOTRULES_H

class World;

void applyHardmodeLoot(World &world);

#endif // HARDMODE_LOOTRULES_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/structures/hiveQueen`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/hiveQueen/GlobalHive.cpp`
```
#include "structures/hiveQueen/GlobalHive.h"

#include "Config.h"
#include "Util.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "vendor/frozen/set.h"
#include <iostream>

void genGlobalHive(World &world)
{
    std::cout << "Globalizing bees\n";
    constexpr auto stoneTiles = frozen::make_set<int>(
        {TileID::stone,
         TileID::kryptonMossStone,
         TileID::xenonMossStone,
         TileID::argonMossStone,
         TileID::neonMossStone,
         TileID::lavaMossStone});
    parallelFor(
        std::views::iota(0, world.getWidth()),
        [&stoneTiles, &world](int x) {
            for (int y = 0; y < world.getHeight(); ++y) {
                Tile &tile = world.getTile(x, y);
                if (stoneTiles.contains(tile.blockID) && !tile.actuated &&
                    tile.blockPaint == Paint::none) {
                    switch (tile.flag) {
                    case Flag::hive:
                    case Flag::crispyHoney:
                        tile.blockID = tile.flag == Flag::hive
                                           ? TileID::hive
                                           : TileID::crispyHoney;
                        if (tile.wallID != WallID::empty &&
                            tile.wallPaint == Paint::none &&
                            !world.isExposed(x, y)) {
                            tile.wallID = WallID::Unsafe::hive;
                        }
                        break;
                    case Flag::yellow:
                        if (!world.conf.unpainted) {
                            tile.blockPaint = Paint::deepYellow;
                        }
                        break;
                    case Flag::orange:
                        if (!world.conf.unpainted) {
                            tile.blockPaint = Paint::deepOrange;
                        }
                        break;
                    default:
                        break;
                    }
                } else if (
                    tile.blockID == TileID::mud && tile.flag == Flag::hive &&
                    world.getBiome(x, y).active == Biome::jungle) {
                    std::vector<Point> locations;
                    iterateZone(
                        {x, y},
                        world,
                        [centroid = getHexCentroid(x, y, 10)](Point pt) {
                            return centroid == getHexCentroid(pt, 10);
                        },
                        [&locations, &world](Point pt) {
                            Tile &tile = world.getTile(pt);
                            if (tile.blockID == TileID::mud &&
                                tile.flag == Flag::hive && !tile.actuated &&
                                tile.blockPaint == Paint::none) {
                                locations.push_back(pt);
                            }
                        });
                    if (locations.size() > 115) {
                        for (Point pt : locations) {
                            world.getTile(pt).blockID = TileID::hive;
                        }
                    } else {
                        for (Point pt : locations) {
                            world.getTile(pt).flag = Flag::none;
                        }
                    }
                }
            }
        });
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/hiveQueen/GlobalHive.h`
```
#ifndef GLOBAL_HIVE_H
#define GLOBAL_HIVE_H

class World;

void genGlobalHive(World &world);

#endif // GLOBAL_HIVE_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/hiveQueen/Temple.cpp`
```
#include "structures/hiveQueen/Temple.h"

#include "Config.h"
#include "Random.h"
#include "World.h"
#include "biomes/BiomeUtil.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include "structures/Temple.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <iostream>
#include <map>
#include <set>

class HiveTemple
{
private:
    Random &rnd;
    World &world;
    double size;
    int roomSize;
    std::set<Point> connections;

    std::vector<Point> neighborCentroids(Point pt)
    {
        std::vector<Point> neighbors;
        for (auto [i, j] :
             {std::pair{0, -1.155 * roomSize},
              {0, 1.155 * roomSize},
              {-roomSize, -0.578 * roomSize},
              {-roomSize, 0.578 * roomSize},
              {roomSize, -0.578 * roomSize},
              {roomSize, 0.578 * roomSize}}) {
            neighbors.push_back(getHexCentroid(pt.x + i, pt.y + j, roomSize));
        }
        return neighbors;
    }

    void makeRoom(Point centroid)
    {
        std::map<Point, int> visitCount;
        iterateZone(
            centroid,
            world,
            [this, centroid](Point pt) {
                return getHexCentroid(pt, roomSize) == centroid;
            },
            [this, &visitCount](Point pt) {
                Tile &tile = world.getTile(pt);
                tile.blockID = TileID::lihzahrdBrick;
                tile.blockPaint = Paint::none;
                tile.wallID = WallID::Unsafe::lihzahrdBrick;
                for (int i = -2; i < 3; ++i) {
                    for (int j = -2; j < 3; ++j) {
                        Point probe = pt + Point{i, j};
                        visitCount[probe] += 1;
                        if (visitCount[probe] == 25) {
                            world.getTile(probe).blockID = TileID::empty;
                        }
                    }
                }
            });
    }

    bool hasHallway(Point a, Point b)
    {
        return connections.contains(a + b);
    }

    void makeHallway(Point a, Point b)
    {
        connections.insert(a + b);
        if (a.y > b.y) {
            std::swap(a, b);
        }
        double slope = static_cast<double>(b.x - a.x) / (b.y - a.y);
        double scanDist = 2.5 * (1 + std::abs(slope));
        for (int y = a.y; y <= b.y; ++y) {
            double centerX = slope * (y - a.y) + a.x;
            for (int x = std::round(centerX - scanDist); x < centerX + scanDist;
                 ++x) {
                world.getTile(x, y).blockID = TileID::empty;
            }
        }
    }

    void genMaze(Point center)
    {
        std::vector<Point> coreRing = neighborCentroids(center);
        for (Point pt : coreRing) {
            makeRoom(pt);
        }
        double coreSize = 1 + 1.22 * roomSize;
        for (int i = -coreSize; i < coreSize; ++i) {
            for (int j = -coreSize; j < coreSize; ++j) {
                if (std::hypot(i, j) < coreSize) {
                    Tile &tile = world.getTile(center.x + i, center.y + j);
                    tile.blockID = TileID::empty;
                    tile.blockPaint = Paint::none;
                    tile.wallID = WallID::Unsafe::lihzahrdBrick;
                }
            }
        }
        std::set<Point> core(coreRing.begin(), coreRing.end());
        core.insert(center);
        Point agent = rnd.select(coreRing);
        std::set<Point> connectedRooms{agent};
        std::vector<Point> junctions;
        double threshold = size - roomSize;
        while (true) {
            std::vector<Point> choices;
            for (Point candidate : neighborCentroids(agent)) {
                if (hypot(candidate, center) < threshold &&
                    !core.contains(candidate) &&
                    (!connectedRooms.contains(candidate) ||
                     hasHallway(agent, candidate))) {
                    choices.push_back(candidate);
                }
            }
            if (choices.size() == 1 && connectedRooms.contains(choices[0])) {
                if (junctions.empty()) {
                    break;
                }
                agent = junctions.back();
                junctions.pop_back();
            } else {
                for (Point choice : choices) {
                    if (!connectedRooms.contains(choice)) {
                        junctions.push_back(agent);
                        break;
                    }
                }
                Point next = rnd.select(choices);
                if (!connectedRooms.contains(next)) {
                    makeRoom(next);
                    makeHallway(agent, next);
                    connectedRooms.insert(next);
                }
                agent = next;
            }
        }
        std::vector<Point> border;
        for (int x = center.x - size; x < center.x + size; ++x) {
            for (int y = center.y - size; y < center.y + size; ++y) {
                if (world.getTile(x, y).wallID !=
                        WallID::Unsafe::lihzahrdBrick &&
                    !world.regionPasses(x - 2, y - 2, 5, 5, [](Tile &tile) {
                        return tile.wallID != WallID::Unsafe::lihzahrdBrick;
                    })) {
                    border.emplace_back(x, y);
                }
            }
        }
        for (Point pt : border) {
            Tile &tile = world.getTile(pt);
            tile.blockID = TileID::lihzahrdBrick;
            tile.blockPaint = Paint::none;
            tile.wallID = WallID::Unsafe::lihzahrdBrick;
        }
    }

    void addEntries(Point center)
    {
        int x = center.x - size;
        int y = center.y;
        while (world.getTile(x, y).blockID != TileID::lihzahrdBrick) {
            ++x;
        }
        std::tie(x, y) = getHexCentroid(x + roomSize / 2, y, roomSize).asPair();
        clearTempleSurface(
            {x - roomSize / 2, y - roomSize / 2},
            1.1 * roomSize,
            TileID::jungleGrass,
            rnd,
            world);
        for (bool inTemple = true; inTemple; --x) {
            inTemple = false;
            for (int j = -1; j < 2; ++j) {
                Tile &tile = world.getTile(x, y + j);
                if (tile.wallID == WallID::Unsafe::lihzahrdBrick) {
                    tile.blockID = TileID::empty;
                    inTemple = true;
                }
            }
        }
        world.placeFramedTile(x + 2, y - 1, TileID::door, Variant::lihzahrd);
        world.placeFramedTile(x + 4, y, TileID::pot, Variant::lihzahrd);

        x = 2 * center.x - x;
        while (world.getTile(x, y).blockID != TileID::lihzahrdBrick) {
            --x;
        }
        std::tie(x, y) = getHexCentroid(x - roomSize / 2, y, roomSize).asPair();
        clearTempleSurface(
            {x + roomSize / 2, y - roomSize / 2},
            1.1 * roomSize,
            TileID::jungleGrass,
            rnd,
            world);
        for (bool inTemple = true; inTemple; ++x) {
            inTemple = false;
            for (int j = -1; j < 2; ++j) {
                Tile &tile = world.getTile(x, y + j);
                if (tile.wallID == WallID::Unsafe::lihzahrdBrick) {
                    tile.blockID = TileID::empty;
                    inTemple = true;
                }
            }
        }
        world.placeFramedTile(x - 2, y - 1, TileID::door, Variant::lihzahrd);
        world.placeFramedTile(x - 5, y, TileID::pot, Variant::lihzahrd);
    }

    void placeAltar(Point center)
    {
        int altarLeft =
            scanWhileEmpty({center.x - roomSize, center.y}, {0, 1}, world).y;
        int altarRight =
            scanWhileEmpty({center.x + roomSize, center.y}, {0, 1}, world).y;
        world.placeFramedTile(
            center.x - 1 -
                (altarLeft < altarRight   ? roomSize
                 : altarLeft > altarRight ? -roomSize
                                          : rnd.select({-roomSize, roomSize})),
            std::min(altarLeft, altarRight) - 1,
            TileID::lihzahrdAltar);
    }

    std::vector<Point> placeTreasures(Point center)
    {
        std::vector<Point> locations;
        for (int x = center.x - size; x < center.x + size; ++x) {
            for (int y = center.y - size; y < center.y + size; ++y) {
                if (canPlaceTempleTreasureAt(x, y, world)) {
                    locations.emplace_back(x, y);
                }
            }
        }
        addTempleTreasures(locations, size * size / 127.7 + 20, rnd, world);
        return locations;
    }

    void placeLarvae(const std::vector<Point> &locations)
    {
        int numLarvae = size * size / 8000;
        for (auto itr = locations.begin();
             numLarvae > 0 && itr != locations.end();
             ++itr) {
            auto [x, y] = *itr;
            if (canPlaceTempleTreasureAt(x, y, world) &&
                canPlaceTempleTreasureAt(x + 2, y, world)) {
                world.placeFramedTile(x, y - 3, TileID::larva);
                --numLarvae;
            }
        }
    }

    void addSpikes(Point center)
    {
        for (int x = center.x - size; x < center.x + size; ++x) {
            for (int y = center.y - size; y < center.y + size; ++y) {
                if (world.regionPasses(x - 1, y - 1, 3, 3, [](Tile &tile) {
                        return tile.blockID == TileID::empty &&
                               tile.wallID == WallID::Unsafe::lihzahrdBrick;
                    })) {
                    addTempleSpikesAt({x, y}, rnd, world);
                }
            }
        }
    }

    void applyPaint(Point center, int paint)
    {
        for (int x = center.x - size; x < center.x + size; ++x) {
            for (int y = center.y - size; y < center.y + size; ++y) {
                Tile &tile = world.getTile(x, y);
                if (tile.wallID == WallID::Unsafe::lihzahrdBrick) {
                    if (tile.blockID == TileID::lihzahrdBrick ||
                        tile.blockID == TileID::pressurePlate ||
                        tile.blockID == TileID::trap) {
                        tile.blockPaint = paint;
                    }
                    tile.wallPaint = paint;
                }
            }
        }
    }

public:
    HiveTemple(double s, Random &r, World &w)
        : rnd(r), world(w), size(s), roomSize(20)
    {
    }

    void gen(Point center)
    {
        center = getHexCentroid(center, roomSize);
        genMaze(center);
        addEntries(center);
        placeAltar(center);
        std::vector<Point> flatLocations = placeTreasures(center);
        std::shuffle(flatLocations.begin(), flatLocations.end(), rnd.getPRNG());
        placeLarvae(flatLocations);
        addTempleTraps(flatLocations, 45, rnd, world);
        addSpikes(center);
        if (!world.conf.unpainted) {
            applyPaint(
                center,
                rnd.select(
                    {Paint::yellow,
                     Paint::orange,
                     Paint::deepYellow,
                     Paint::deepOrange}));
        }
    }
};

void genTempleHiveQueen(Random &rnd, World &world)
{
    if (world.conf.templeSize < 0.01) {
        return;
    }
    std::cout << "Training acolytes\n";
    rnd.shuffleNoise();
    double size = std::max(
        world.conf.templeSize * 0.022 *
            std::midpoint<double>(world.getWidth(), 3.55 * world.getHeight()),
        95.0);
    Point center = selectTempleCenter(
        [scanDist = 0.95 * size](Point center, World &world) {
            constexpr auto avoidBlocks = frozen::make_set<int>({
                TileID::aetherium,
                TileID::ash,
                TileID::blueBrick,
                TileID::corruptJungleGrass,
                TileID::crimsonJungleGrass,
                TileID::granite,
                TileID::greenBrick,
                TileID::hive,
                TileID::marble,
                TileID::mushroomGrass,
                TileID::pinkBrick,
            });
            return world.regionPasses(
                center.x - scanDist,
                center.y - scanDist,
                2 * scanDist,
                2 * scanDist,
                [&avoidBlocks](Tile &tile) {
                    return !avoidBlocks.contains(tile.blockID) ||
                           (tile.blockID == TileID::hive &&
                            tile.flag == Flag::border);
                });
        },
        rnd,
        world);
    if (center.x < 100) {
        return;
    }
    HiveTemple structure(size, rnd, world);
    structure.gen(center);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/hiveQueen/Temple.h`
```
#ifndef HIVEQUEEN_TEMPLE_H
#define HIVEQUEEN_TEMPLE_H

class World;
class Random;

void genTempleHiveQueen(Random &rnd, World &world);

#endif // HIVEQUEEN_TEMPLE_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/structures/sunken`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/sunken/Flood.cpp`
```
#include "structures/sunken/Flood.h"

#include "Config.h"
#include "World.h"
#include "ids/Paint.h"
#include "ids/WallID.h"
#include "structures/StructureUtil.h"
#include "vendor/frozen/set.h"
#include <algorithm>
#include <cmath>
#include <iostream>

inline constexpr auto skipWalls = frozen::make_set<int>({
    WallID::Unsafe::blueBrick,
    WallID::Unsafe::blueSlab,
    WallID::Unsafe::blueTiled,
    WallID::Unsafe::greenBrick,
    WallID::Unsafe::greenSlab,
    WallID::Unsafe::greenTiled,
    WallID::Unsafe::pinkBrick,
    WallID::Unsafe::pinkSlab,
    WallID::Unsafe::pinkTiled,
    WallID::Unsafe::lihzahrdBrick,
});

void floodFill(int startX, int startY, int minY, World &world)
{
    if (world.getTile(startX, startY).liquid != Liquid::none) {
        return;
    }
    constexpr auto hardenTiles = frozen::make_set<int>(
        {TileID::empty,
         TileID::ashTree,
         TileID::tree,
         TileID::minecartTrack,
         TileID::platform,
         TileID::woodenBeam});
    std::vector<Point> locations{{startX, startY}};
    while (!locations.empty()) {
        auto [x, y] = locations.back();
        locations.pop_back();
        if (x < 0 || x >= world.getWidth() || y < minY ||
            y > world.getUnderworldLevel()) {
            continue;
        }
        Tile &tile = world.getTile(x, y);
        if ((!isSolidBlock(tile.blockID) || tile.actuated) &&
            tile.blockID != TileID::bubble && tile.blockID != TileID::door &&
            !skipWalls.contains(tile.wallID) &&
            (tile.liquid == Liquid::none ||
             (tile.liquid != Liquid::water && tile.actuated))) {
            if (y + 10 > world.getUnderworldLevel() &&
                hardenTiles.contains(tile.blockID)) {
                int mixBlock = TileID::ash;
                if (world.conf.biomes != BiomeLayout::columns) {
                    switch (world.getBiome(x, y).active) {
                    case Biome::forest:
                        mixBlock = TileID::stone;
                        break;
                    case Biome::desert:
                        mixBlock = TileID::sandstone;
                        break;
                    case Biome::jungle:
                        mixBlock = TileID::mud;
                        break;
                    default:
                        break;
                    }
                }
                tile.blockID =
                    fnv1a32pt(x, y) % 7 < 2 ? mixBlock : TileID::obsidian;
                tile.frameX = 0;
                tile.frameY = 0;
                tile.blockPaint = Paint::none;
            } else {
                tile.liquid = Liquid::water;
            }
            if (y < world.getCavernLevel()) {
                for (auto [i, j] :
                     {std::pair{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {
                    locations.emplace_back(x + i, y + j);
                }
            } else {
                for (auto [i, j] : {std::pair{-1, 0}, {1, 0}, {0, 1}}) {
                    locations.emplace_back(x + i, y + j);
                }
            }
        } else if (
            tile.liquid == Liquid::lava &&
            (tile.blockID == TileID::empty ||
             tile.blockID == TileID::woodenBeam)) {
            tile.blockID = TileID::obsidian;
            tile.liquid = Liquid::none;
        }
    }
}

void floodBubbleInit(Point center, int size, World &world)
{
    for (int i = -size; i < size; ++i) {
        for (int j = -size; j < size; ++j) {
            if (std::hypot(i, j) < size) {
                Tile &tile = world.getTile(center + Point{i, j});
                if (tile.blockID == TileID::empty &&
                    !skipWalls.contains(tile.wallID)) {
                    tile.blockID = TileID::bubble;
                }
            }
        }
    }
}

void floodBubbleFinalize(Point center, int size, World &world)
{
    for (int i = -size; i < size; ++i) {
        for (int j = -size; j < size; ++j) {
            if (std::hypot(i, j) < size) {
                Tile &tile = world.getTile(center + Point{i, j});
                tile.liquid = Liquid::none;
                if (tile.blockID == TileID::bubble) {
                    tile.blockID = TileID::empty;
                }
            }
        }
    }
}

void genFlood(World &world)
{
    std::cout << "Flooding\n";
    int probeDelta = world.conf.shattered ? 120 : 130;
    int floodLevel =
        std::max(
            {world.getSurfaceLevel(world.getWidth() / 2 - probeDelta),
             world.getSurfaceLevel(world.getWidth() / 2),
             world.getSurfaceLevel(world.getWidth() / 2 + probeDelta)}) +
        (world.conf.shattered ? 3 : 0);
    if (floodLevel < world.dungeon.y + 4) {
        floodBubbleInit(world.dungeon, 85, world);
    }
    bool shouldBubbleSpawn =
        floodLevel < world.spawn.y - 2 &&
        world.spawn.y < (world.conf.shattered
                             ? world.getUnderworldLevel()
                             : world.getUndergroundLevel() + 30);
    if (shouldBubbleSpawn) {
        floodBubbleInit(world.spawn, 45, world);
    }
    for (int x = 0; x < world.getWidth(); ++x) {
        for (int y = floodLevel; y < world.getUndergroundLevel() + 30; ++y) {
            floodFill(x, y, floodLevel, world);
        }
    }
    if (floodLevel < world.dungeon.y + 4) {
        floodBubbleFinalize(world.dungeon, 82, world);
    }
    if (shouldBubbleSpawn) {
        floodBubbleFinalize(world.spawn, 42, world);
    }
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/structures/sunken/Flood.h`
```
#ifndef FLOOD_H
#define FLOOD_H

class World;

void genFlood(World &world);

#endif // FLOOD_H

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/vendor`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/INIReader.cpp`
```
// Read an INI file into easy-to-access name/value pairs.

// SPDX-License-Identifier: BSD-3-Clause

// Copyright (C) 2009-2020, Ben Hoyt

// inih and INIReader are released under the New BSD license (see LICENSE.txt).
// Go to the project home page for more info:
//
// https://github.com/benhoyt/inih

#include <algorithm>
#include <cctype>
#include <cstdlib>
#include "ini.h"
#include "INIReader.h"

using std::string;

INIReader::INIReader(const string& filename)
{
    _error = ini_parse(filename.c_str(), ValueHandler, this);
}

INIReader::INIReader(const char *buffer, size_t buffer_size)
{
  string content(buffer, buffer_size);
  _error = ini_parse_string(content.c_str(), ValueHandler, this);
}

int INIReader::ParseError() const
{
    return _error;
}

string INIReader::Get(const string& section, const string& name, const string& default_value) const
{
    string key = MakeKey(section, name);
    // Use _values.find() here instead of _values.at() to support pre C++11 compilers
    return _values.count(key) ? _values.find(key)->second : default_value;
}

string INIReader::GetString(const string& section, const string& name, const string& default_value) const
{
    const string str = Get(section, name, "");
    return str.empty() ? default_value : str;
}

long INIReader::GetInteger(const string& section, const string& name, long default_value) const
{
    string valstr = Get(section, name, "");
    const char* value = valstr.c_str();
    char* end;
    // This parses "1234" (decimal) and also "0x4D2" (hex)
    long n = strtol(value, &end, 0);
    return end > value ? n : default_value;
}

INI_API int64_t INIReader::GetInteger64(const string& section, const string& name, int64_t default_value) const
{
    string valstr = Get(section, name, "");
    const char* value = valstr.c_str();
    char* end;
    // This parses "1234" (decimal) and also "0x4D2" (hex)
    int64_t n = strtoll(value, &end, 0);
    return end > value ? n : default_value;
}

unsigned long INIReader::GetUnsigned(const string& section, const string& name, unsigned long default_value) const
{
    string valstr = Get(section, name, "");
    const char* value = valstr.c_str();
    char* end;
    // This parses "1234" (decimal) and also "0x4D2" (hex)
    unsigned long n = strtoul(value, &end, 0);
    return end > value ? n : default_value;
}

INI_API uint64_t INIReader::GetUnsigned64(const string& section, const string& name, uint64_t default_value) const
{
    string valstr = Get(section, name, "");
    const char* value = valstr.c_str();
    char* end;
    // This parses "1234" (decimal) and also "0x4D2" (hex)
    uint64_t n = strtoull(value, &end, 0);
    return end > value ? n : default_value;
}

double INIReader::GetReal(const string& section, const string& name, double default_value) const
{
    string valstr = Get(section, name, "");
    const char* value = valstr.c_str();
    char* end;
    double n = strtod(value, &end);
    return end > value ? n : default_value;
}

bool INIReader::GetBoolean(const string& section, const string& name, bool default_value) const
{
    string valstr = Get(section, name, "");
    // Convert to lower case to make string comparisons case-insensitive
    std::transform(valstr.begin(), valstr.end(), valstr.begin(),
        [](const unsigned char& ch) { return static_cast<unsigned char>(::tolower(ch)); });
    if (valstr == "true" || valstr == "yes" || valstr == "on" || valstr == "1")
        return true;
    else if (valstr == "false" || valstr == "no" || valstr == "off" || valstr == "0")
        return false;
    else
        return default_value;
}

std::vector<string> INIReader::Sections() const
{
    std::set<string> sectionSet;
    for (std::map<string, string>::const_iterator it = _values.begin(); it != _values.end(); ++it) {
        size_t pos = it->first.find('=');
        if (pos != string::npos) {
            sectionSet.insert(it->first.substr(0, pos));
        }
    }
    return std::vector<string>(sectionSet.begin(), sectionSet.end());
}

std::vector<string> INIReader::Keys(const string& section) const
{
    std::vector<string> keys;
    string keyPrefix = MakeKey(section, "");
    for (std::map<string, string>::const_iterator it = _values.begin(); it != _values.end(); ++it) {
        if (it->first.compare(0, keyPrefix.length(), keyPrefix) == 0) {
            keys.push_back(it->first.substr(keyPrefix.length()));
        }
    }
    return keys;
}

bool INIReader::HasSection(const string& section) const
{
    const string key = MakeKey(section, "");
    std::map<string, string>::const_iterator pos = _values.lower_bound(key);
    if (pos == _values.end())
        return false;
    // Does the key at the lower_bound pos start with "section"?
    return pos->first.compare(0, key.length(), key) == 0;
}

bool INIReader::HasValue(const string& section, const string& name) const
{
    string key = MakeKey(section, name);
    return _values.count(key);
}

string INIReader::MakeKey(const string& section, const string& name)
{
    string key = section + "=" + name;
    // Convert to lower case to make section/name lookups case-insensitive
    std::transform(key.begin(), key.end(), key.begin(),
        [](const unsigned char& ch) { return static_cast<unsigned char>(::tolower(ch)); });
    return key;
}

int INIReader::ValueHandler(void* user, const char* section, const char* name,
                            const char* value)
{
    if (!name)  // Happens when INI_CALL_HANDLER_ON_NEW_SECTION enabled
        return 1;
    INIReader* reader = static_cast<INIReader*>(user);
    string key = MakeKey(section, name);
    if (reader->_values[key].size() > 0)
        reader->_values[key] += "\n";
    reader->_values[key] += value ? value : "";
    return 1;
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/INIReader.h`
```
// Read an INI file into easy-to-access name/value pairs.

// SPDX-License-Identifier: BSD-3-Clause

// Copyright (C) 2009-2020, Ben Hoyt

// inih and INIReader are released under the New BSD license (see LICENSE.txt).
// Go to the project home page for more info:
//
// https://github.com/benhoyt/inih

#ifndef INIREADER_H
#define INIREADER_H

#include <map>
#include <string>
#include <cstdint>
#include <vector>
#include <set>

// Visibility symbols, required for Windows DLLs
#ifndef INI_API
#if defined _WIN32 || defined __CYGWIN__
#	ifdef INI_SHARED_LIB
#		ifdef INI_SHARED_LIB_BUILDING
#			define INI_API __declspec(dllexport)
#		else
#			define INI_API __declspec(dllimport)
#		endif
#	else
#		define INI_API
#	endif
#else
#	if defined(__GNUC__) && __GNUC__ >= 4
#		define INI_API __attribute__ ((visibility ("default")))
#	else
#		define INI_API
#	endif
#endif
#endif

// Read an INI file into easy-to-access name/value pairs. (Note that I've gone
// for simplicity here rather than speed, but it should be pretty decent.)
class INIReader
{
public:
    // Construct INIReader and parse given filename. See ini.h for more info
    // about the parsing.
    INI_API explicit INIReader(const std::string& filename);

    // Construct INIReader and parse given buffer. See ini.h for more info
    // about the parsing.
    INI_API explicit INIReader(const char *buffer, size_t buffer_size);

    // Return the result of ini_parse(), i.e., 0 on success, line number of
    // first error on parse error, or -1 on file open error.
    INI_API int ParseError() const;

    // Get a string value from INI file, returning default_value if not found.
    INI_API std::string Get(const std::string& section, const std::string& name,
                    const std::string& default_value) const;

    // Get a string value from INI file, returning default_value if not found,
    // empty, or contains only whitespace.
    INI_API std::string GetString(const std::string& section, const std::string& name,
                    const std::string& default_value) const;

    // Get an integer (long) value from INI file, returning default_value if
    // not found or not a valid integer (decimal "1234", "-1234", or hex "0x4d2").
    INI_API long GetInteger(const std::string& section, const std::string& name, long default_value) const;

    // Get a 64-bit integer (int64_t) value from INI file, returning default_value if
    // not found or not a valid integer (decimal "1234", "-1234", or hex "0x4d2").
    INI_API int64_t GetInteger64(const std::string& section, const std::string& name, int64_t default_value) const;

    // Get an unsigned integer (unsigned long) value from INI file, returning default_value if
    // not found or not a valid unsigned integer (decimal "1234", or hex "0x4d2").
    INI_API unsigned long GetUnsigned(const std::string& section, const std::string& name, unsigned long default_value) const;

    // Get an unsigned 64-bit integer (uint64_t) value from INI file, returning default_value if
    // not found or not a valid unsigned integer (decimal "1234", or hex "0x4d2").
    INI_API uint64_t GetUnsigned64(const std::string& section, const std::string& name, uint64_t default_value) const;

    // Get a real (floating point double) value from INI file, returning
    // default_value if not found or not a valid floating point value
    // according to strtod().
    INI_API double GetReal(const std::string& section, const std::string& name, double default_value) const;

    // Get a boolean value from INI file, returning default_value if not found or if
    // not a valid true/false value. Valid true values are "true", "yes", "on", "1",
    // and valid false values are "false", "no", "off", "0" (not case sensitive).
    INI_API bool GetBoolean(const std::string& section, const std::string& name, bool default_value) const;

    // Return a newly-allocated vector of all section names, in alphabetical order.
    INI_API std::vector<std::string> Sections() const;

    // Return a newly-allocated vector of keys in the given section, in alphabetical order.
    INI_API std::vector<std::string> Keys(const std::string& section) const;

    // Return true if the given section exists (section must contain at least
    // one name=value pair).
    INI_API bool HasSection(const std::string& section) const;

    // Return true if a value exists with the given section and field names.
    INI_API bool HasValue(const std::string& section, const std::string& name) const;

protected:
    int _error;
    std::map<std::string, std::string> _values;
    static std::string MakeKey(const std::string& section, const std::string& name);
    static int ValueHandler(void* user, const char* section, const char* name,
                            const char* value);
};

#endif  // INIREADER_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/OpenSimplexNoise.hpp`
```
#pragma once
// https://gist.github.com/Mashpoe/d2804c0f3647f36d2a863b22ddde9f38
/*******************************************************************************
  OpenSimplex Noise in C++
  Ported from https://gist.github.com/digitalshadow/134a3a02b67cecd72181
  Originally from https://gist.github.com/KdotJPG/b1270127455a94ac5d19
  Optimised by DigitalShadow
  This version by Mark A. Ropper (Markyparky56)
*******************************************************************************/
#include <array>
#include <vector>
#include <memory> // unique_ptr

class OpenSimplexNoise
{
  friend class StaticConstructor;
protected:
  // Contribution structs
  struct Contribution2
  {
  public:
    double dx, dy;
    int xsb, ysb;
    Contribution2 *Next;

    Contribution2(double multiplier, int _xsb, int _ysb)
      : xsb(_xsb)
      , ysb(_ysb)
      , Next(nullptr)
    {
      dx = -_xsb - multiplier * SQUISH_2D;
      dy = -_ysb - multiplier * SQUISH_2D;
    }
    ~Contribution2()
    {
      if (Next != nullptr)
      {
        delete Next;
      }
    }
  };
  using pContribution2 = std::unique_ptr<Contribution2>;
  struct Contribution3
  {
  public:
    double dx, dy, dz;
    int xsb, ysb, zsb;
    Contribution3 *Next;

    Contribution3(double multiplier, int _xsb, int _ysb, int _zsb)
      : xsb(_xsb)
      , ysb(_ysb)
      , zsb(_zsb)
      , Next(nullptr)
    {
      dx = -xsb - multiplier * SQUISH_3D;
      dy = -ysb - multiplier * SQUISH_3D;
      dz = -zsb - multiplier * SQUISH_3D;
    }
    ~Contribution3()
    {
      if (Next != nullptr)
      {
        delete Next;
      }
    }
  };
  using pContribution3 = std::unique_ptr<Contribution3>;
  struct Contribution4
  {
  public:
    double dx, dy, dz, dw;
    int xsb, ysb, zsb, wsb;
    Contribution4 *Next;

    Contribution4(double multiplier, int _xsb, int _ysb, int _zsb, int _wsb)
      : xsb(_xsb)
      , ysb(_ysb)
      , zsb(_zsb)
      , wsb(_wsb)
      , Next(nullptr)
    {
      dx = -xsb - multiplier * SQUISH_4D;
      dy = -ysb - multiplier * SQUISH_4D;
      dz = -zsb - multiplier * SQUISH_4D;
      dw = -wsb - multiplier * SQUISH_4D;
    }
    ~Contribution4()
    {
      if (Next != nullptr)
      {
        delete Next;
      }
    }
  };
  using pContribution4 = std::unique_ptr<Contribution4>;

  // Constants
  inline static const double STRETCH_2D = -0.211324865405187;
  inline static const double STRETCH_3D = -1.0 / 6.0;
  inline static const double STRETCH_4D = -0.138196601125011;
  inline static const double SQUISH_2D = 0.366025403784439;
  inline static const double SQUISH_3D = 1.0 / 3.0;
  inline static const double SQUISH_4D = 0.309016994374947;
  inline static const double NORM_2D = 1.0 / 47.0;
  inline static const double NORM_3D = 1.0 / 103.0;
  inline static const double NORM_4D = 1.0 / 30.0;

  std::array<unsigned char, 256> perm;
  std::array<unsigned char, 256> perm2D;
  std::array<unsigned char, 256> perm3D;
  std::array<unsigned char, 256> perm4D;

  inline static std::array<double, 16> gradients2D;
  inline static std::array<double, 72> gradients3D;
  inline static std::array<double, 256> gradients4D;

  inline static std::vector<OpenSimplexNoise::Contribution2*> lookup2D;
  inline static std::vector<OpenSimplexNoise::Contribution3*> lookup3D;
  inline static std::vector<OpenSimplexNoise::Contribution4*> lookup4D;

  inline static std::vector<OpenSimplexNoise::pContribution2> contributions2D;
  inline static std::vector<OpenSimplexNoise::pContribution3> contributions3D;
  inline static std::vector<OpenSimplexNoise::pContribution4> contributions4D;

  struct StaticConstructor 
  {
    StaticConstructor() 
    { 
      gradients2D =
      {
         5,  2,    2,  5,
        -5,  2,   -2,  5,
         5, -2,    2, -5,
        -5, -2,   -2, -5,
      };
      gradients3D =
      {
        -11,  4,  4,     -4,  11,  4,    -4,  4,  11,
        11,  4,  4,      4,  11,  4,     4,  4,  11,
        -11, -4,  4,     -4, -11,  4,    -4, -4,  11,
        11, -4,  4,      4, -11,  4,     4, -4,  11,
        -11,  4, -4,     -4,  11, -4,    -4,  4, -11,
        11,  4, -4,      4,  11, -4,     4,  4, -11,
        -11, -4, -4,     -4, -11, -4,    -4, -4, -11,
        11, -4, -4,      4, -11, -4,     4, -4, -11,
      };
      gradients4D =
      {
        3,  1,  1,  1,      1,  3,  1,  1,      1,  1,  3,  1,      1,  1,  1,  3,
        -3,  1,  1,  1,     -1,  3,  1,  1,     -1,  1,  3,  1,     -1,  1,  1,  3,
        3, -1,  1,  1,      1, -3,  1,  1,      1, -1,  3,  1,      1, -1,  1,  3,
        -3, -1,  1,  1,     -1, -3,  1,  1,     -1, -1,  3,  1,     -1, -1,  1,  3,
        3,  1, -1,  1,      1,  3, -1,  1,      1,  1, -3,  1,      1,  1, -1,  3,
        -3,  1, -1,  1,     -1,  3, -1,  1,     -1,  1, -3,  1,     -1,  1, -1,  3,
        3, -1, -1,  1,      1, -3, -1,  1,      1, -1, -3,  1,      1, -1, -1,  3,
        -3, -1, -1,  1,     -1, -3, -1,  1,     -1, -1, -3,  1,     -1, -1, -1,  3,
        3,  1,  1, -1,      1,  3,  1, -1,      1,  1,  3, -1,      1,  1,  1, -3,
        -3,  1,  1, -1,     -1,  3,  1, -1,     -1,  1,  3, -1,     -1,  1,  1, -3,
        3, -1,  1, -1,      1, -3,  1, -1,      1, -1,  3, -1,      1, -1,  1, -3,
        -3, -1,  1, -1,     -1, -3,  1, -1,     -1, -1,  3, -1,     -1, -1,  1, -3,
        3,  1, -1, -1,      1,  3, -1, -1,      1,  1, -3, -1,      1,  1, -1, -3,
        -3,  1, -1, -1,     -1,  3, -1, -1,     -1,  1, -3, -1,     -1,  1, -1, -3,
        3, -1, -1, -1,      1, -3, -1, -1,      1, -1, -3, -1,      1, -1, -1, -3,
        -3, -1, -1, -1,     -1, -3, -1, -1,     -1, -1, -3, -1,     -1, -1, -1, -3,
      };
      
      // Create Contribution2s for lookup2D
      std::vector<std::vector<int>> base2D =
      {
        { 1, 1, 0, 1, 0, 1, 0, 0, 0 },
        { 1, 1, 0, 1, 0, 1, 2, 1, 1 }
      };
      std::vector<int> p2D =
      {
        0,  0,  1, -1, 0,  0, -1,  1, 0,  2,  1,  1, 1,  2,  2,  0, 1,  2,  0,  2, 1,  0,  0,  0
      };
      std::vector<int> lookupPairs2D =
      {
        0, 1,  1, 0,  4, 1, 17, 0, 20, 2, 21, 2, 22, 5, 23, 5, 26, 4, 39, 3, 42, 4, 43, 3
      };

      contributions2D.resize(6);
      for (int i = 0; i < static_cast<int>(p2D.size()); i += 4)
      {
        std::vector<int> baseSet = base2D[p2D[i]];
        Contribution2 *previous = nullptr, *current = nullptr;
        for (int k = 0; k < static_cast<int>(baseSet.size()); k += 3)
        {
          current = 
            new Contribution2(baseSet[k], baseSet[k + 1], baseSet[k + 2]);
          if (previous == nullptr)
          {
            contributions2D[i / 4].reset(current);
          }
          else
          {
            previous->Next = current;
          }
          previous = current;
        }
        current->Next = new Contribution2(p2D[i + 1], p2D[i + 2], p2D[i + 3]);
      }

      lookup2D.resize(64);
      for (int i = 0; i < static_cast<int>(lookupPairs2D.size()); i += 2)
      {
        lookup2D[lookupPairs2D[i]] = 
          contributions2D[lookupPairs2D[i + 1]].get();
      }

      // Create Contribution3s for lookup3D
      std::vector<std::vector<int>> base3D = 
      {
        { 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1 },
        { 2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1, 3, 1, 1, 1 },
        { 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1 }
      };
      std::vector<int> p3D =
      { 
        0, 0, 1, -1, 0, 0, 1, 0, -1, 0, 0, -1, 1, 0, 0, 0, 1, -1, 0, 0, -1, 0, 1, 0, 0, -1, 1, 0, 2, 1, 1, 0, 1, 1, 1, -1, 0, 2, 1, 0, 1, 1, 1, -1, 1, 0, 2, 0, 1, 1, 1, -1, 1, 1, 1, 3, 2, 1, 0, 3, 1, 2, 0, 1, 3, 2, 0, 1, 3, 1, 0, 2, 1, 3, 0, 2, 1, 3, 0, 1, 2, 1, 1, 1, 0, 0, 2, 2, 0, 0, 1, 1, 0, 1, 0, 2, 0, 2, 0, 1, 1, 0, 0, 1, 2, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1, -1, 1, 2, 0, 0, 0, 0, 1, -1, 1, 1, 2, 0, 0, 0, 0, 1, 1, 1, -1, 2, 3, 1, 1, 1, 2, 0, 0, 2, 2, 3, 1, 1, 1, 2, 2, 0, 0, 2, 3, 1, 1, 1, 2, 0, 2, 0, 2, 1, 1, -1, 1, 2, 0, 0, 2, 2, 1, 1, -1, 1, 2, 2, 0, 0, 2, 1, -1, 1, 1, 2, 0, 0, 2, 2, 1, -1, 1, 1, 2, 0, 2, 0, 2, 1, 1, 1, -1, 2, 2, 0, 0, 2, 1, 1, 1, -1, 2, 0, 2, 0 
      };
      std::vector<int> lookupPairs3D = 
      { 
        0, 2, 1, 1, 2, 2, 5, 1, 6, 0, 7, 0, 32, 2, 34, 2, 129, 1, 133, 1, 160, 5, 161, 5, 518, 0, 519, 0, 546, 4, 550, 4, 645, 3, 647, 3, 672, 5, 673, 5, 674, 4, 677, 3, 678, 4, 679, 3, 680, 13, 681, 13, 682, 12, 685, 14, 686, 12, 687, 14, 712, 20, 714, 18, 809, 21, 813, 23, 840, 20, 841, 21, 1198, 19, 1199, 22, 1226, 18, 1230, 19, 1325, 23, 1327, 22, 1352, 15, 1353, 17, 1354, 15, 1357, 17, 1358, 16, 1359, 16, 1360, 11, 1361, 10, 1362, 11, 1365, 10, 1366, 9, 1367, 9, 1392, 11, 1394, 11, 1489, 10, 1493, 10, 1520, 8, 1521, 8, 1878, 9, 1879, 9, 1906, 7, 1910, 7, 2005, 6, 2007, 6, 2032, 8, 2033, 8, 2034, 7, 2037, 6, 2038, 7, 2039, 6 
      };

      contributions3D.resize(p3D.size() / 9);
      for (int i = 0; i < static_cast<int>(p3D.size()); i += 9)
      {
        auto baseSet = base3D[p3D[i]];
        Contribution3 *previous = nullptr, *current = nullptr;
        for (int k = 0; k < static_cast<int>(baseSet.size()); k += 4)
        {
          current =
            new Contribution3(baseSet[k], baseSet[k + 1], 
                              baseSet[k + 2], baseSet[k + 3]);
          if (previous == nullptr)
          {
            contributions3D[i / 9] = pContribution3(current);
          }
          else
          {
            previous->Next = current;
          }
          previous = current;
        }
        current->Next = new Contribution3(p3D[i + 1], p3D[i + 2], p3D[i + 3], p3D[i + 4]);
        current->Next->Next = new Contribution3(p3D[i + 5], p3D[i + 6], p3D[i + 7], p3D[i + 8]);
      }

      lookup3D.resize(2048);
      for (int i = 0; i < static_cast<int>(lookupPairs3D.size()); i += 2)
      {
        lookup3D[lookupPairs3D[i]] = 
          contributions3D[lookupPairs3D[i + 1]].get();
      }

      // Create Contribution4s for lookup4D
      std::vector<std::vector<int>> base4D = 
      {
        { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1 },
        { 3, 1, 1, 1, 0, 3, 1, 1, 0, 1, 3, 1, 0, 1, 1, 3, 0, 1, 1, 1, 4, 1, 1, 1, 1 },
        { 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 2, 1, 1, 0, 0, 2, 1, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 1, 1, 0, 2, 0, 1, 0, 1, 2, 0, 0, 1, 1 },
        { 3, 1, 1, 1, 0, 3, 1, 1, 0, 1, 3, 1, 0, 1, 1, 3, 0, 1, 1, 1, 2, 1, 1, 0, 0, 2, 1, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 1, 1, 0, 2, 0, 1, 0, 1, 2, 0, 0, 1, 1 }
      };
      std::vector<int> p4D =
      { 
        0, 0, 1, -1, 0, 0, 0, 1, 0, -1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 0, 0, 1, -1, 0, 0, 0, 1, 0, -1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, -1, 0, 0, -1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 2, 1, 1, 0, 0, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 0, 2, 1, 0, 1, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 0, 2, 0, 1, 1, 0, 1, -1, 1, 1, 0, 1, 0, 1, 1, -1, 0, 2, 1, 0, 0, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1, 0, 2, 0, 1, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 1, 0, 2, 0, 0, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 1, 4, 2, 1, 1, 0, 4, 1, 2, 1, 0, 4, 1, 1, 2, 0, 1, 4, 2, 1, 0, 1, 4, 1, 2, 0, 1, 4, 1, 1, 0, 2, 1, 4, 2, 0, 1, 1, 4, 1, 0, 2, 1, 4, 1, 0, 1, 2, 1, 4, 0, 2, 1, 1, 4, 0, 1, 2, 1, 4, 0, 1, 1, 2, 1, 2, 1, 1, 0, 0, 3, 2, 1, 0, 0, 3, 1, 2, 0, 0, 1, 2, 1, 0, 1, 0, 3, 2, 0, 1, 0, 3, 1, 0, 2, 0, 1, 2, 0, 1, 1, 0, 3, 0, 2, 1, 0, 3, 0, 1, 2, 0, 1, 2, 1, 0, 0, 1, 3, 2, 0, 0, 1, 3, 1, 0, 0, 2, 1, 2, 0, 1, 0, 1, 3, 0, 2, 0, 1, 3, 0, 1, 0, 2, 1, 2, 0, 0, 1, 1, 3, 0, 0, 2, 1, 3, 0, 0, 1, 2, 2, 3, 1, 1, 1, 0, 2, 1, 1, 1, -1, 2, 2, 0, 0, 0, 2, 3, 1, 1, 0, 1, 2, 1, 1, -1, 1, 2, 2, 0, 0, 0, 2, 3, 1, 0, 1, 1, 2, 1, -1, 1, 1, 2, 2, 0, 0, 0, 2, 3, 1, 1, 1, 0, 2, 1, 1, 1, -1, 2, 0, 2, 0, 0, 2, 3, 1, 1, 0, 1, 2, 1, 1, -1, 1, 2, 0, 2, 0, 0, 2, 3, 0, 1, 1, 1, 2, -1, 1, 1, 1, 2, 0, 2, 0, 0, 2, 3, 1, 1, 1, 0, 2, 1, 1, 1, -1, 2, 0, 0, 2, 0, 2, 3, 1, 0, 1, 1, 2, 1, -1, 1, 1, 2, 0, 0, 2, 0, 2, 3, 0, 1, 1, 1, 2, -1, 1, 1, 1, 2, 0, 0, 2, 0, 2, 3, 1, 1, 0, 1, 2, 1, 1, -1, 1, 2, 0, 0, 0, 2, 2, 3, 1, 0, 1, 1, 2, 1, -1, 1, 1, 2, 0, 0, 0, 2, 2, 3, 0, 1, 1, 1, 2, -1, 1, 1, 1, 2, 0, 0, 0, 2, 2, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 0, 0, 0, 0, 0, 2, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 0, 0, 0, 0, 0, 2, 1, -1, 1, 1, 0, 1, 0, 1, 1, -1, 0, 0, 0, 0, 0, 2, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0, 0, 2, 1, -1, 1, 0, 1, 1, 0, 1, -1, 1, 0, 0, 0, 0, 0, 2, 1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 0, 0, 0, 0, 0, 2, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 2, 2, 0, 0, 0, 2, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 2, 2, 0, 0, 0, 2, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1, 2, 2, 0, 0, 0, 2, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 2, 0, 2, 0, 0, 2, 1, -1, 1, 1, 0, 1, 0, 1, 1, -1, 2, 0, 2, 0, 0, 2, 1, -1, 1, 0, 1, 1, 0, 1, -1, 1, 2, 0, 2, 0, 0, 2, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 2, 0, 0, 2, 0, 2, 1, -1, 1, 1, 0, 1, 0, 1, 1, -1, 2, 0, 0, 2, 0, 2, 1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 2, 0, 0, 2, 0, 2, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1, 2, 0, 0, 0, 2, 2, 1, -1, 1, 0, 1, 1, 0, 1, -1, 1, 2, 0, 0, 0, 2, 2, 1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 2, 0, 0, 0, 2, 3, 1, 1, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, 1, 1, -1, 3, 1, 0, 1, 0, 0, 2, 0, 2, 0, 0, 2, 1, 1, 1, -1, 3, 1, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, 1, 1, 1, -1, 3, 1, 1, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, 1, -1, 1, 3, 1, 0, 1, 0, 0, 2, 0, 2, 0, 0, 2, 1, 1, -1, 1, 3, 1, 0, 0, 0, 1, 2, 0, 0, 0, 2, 2, 1, 1, -1, 1, 3, 1, 1, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, -1, 1, 1, 3, 1, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, 1, -1, 1, 1, 3, 1, 0, 0, 0, 1, 2, 0, 0, 0, 2, 2, 1, -1, 1, 1, 3, 1, 0, 1, 0, 0, 2, 0, 2, 0, 0, 2, -1, 1, 1, 1, 3, 1, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, -1, 1, 1, 1, 3, 1, 0, 0, 0, 1, 2, 0, 0, 0, 2, 2, -1, 1, 1, 1, 3, 3, 2, 1, 0, 0, 3, 1, 2, 0, 0, 4, 1, 1, 1, 1, 3, 3, 2, 0, 1, 0, 3, 1, 0, 2, 0, 4, 1, 1, 1, 1, 3, 3, 0, 2, 1, 0, 3, 0, 1, 2, 0, 4, 1, 1, 1, 1, 3, 3, 2, 0, 0, 1, 3, 1, 0, 0, 2, 4, 1, 1, 1, 1, 3, 3, 0, 2, 0, 1, 3, 0, 1, 0, 2, 4, 1, 1, 1, 1, 3, 3, 0, 0, 2, 1, 3, 0, 0, 1, 2, 4, 1, 1, 1, 1, 3, 3, 2, 1, 0, 0, 3, 1, 2, 0, 0, 2, 1, 1, 1, -1, 3, 3, 2, 0, 1, 0, 3, 1, 0, 2, 0, 2, 1, 1, 1, -1, 3, 3, 0, 2, 1, 0, 3, 0, 1, 2, 0, 2, 1, 1, 1, -1, 3, 3, 2, 1, 0, 0, 3, 1, 2, 0, 0, 2, 1, 1, -1, 1, 3, 3, 2, 0, 0, 1, 3, 1, 0, 0, 2, 2, 1, 1, -1, 1, 3, 3, 0, 2, 0, 1, 3, 0, 1, 0, 2, 2, 1, 1, -1, 1, 3, 3, 2, 0, 1, 0, 3, 1, 0, 2, 0, 2, 1, -1, 1, 1, 3, 3, 2, 0, 0, 1, 3, 1, 0, 0, 2, 2, 1, -1, 1, 1, 3, 3, 0, 0, 2, 1, 3, 0, 0, 1, 2, 2, 1, -1, 1, 1, 3, 3, 0, 2, 1, 0, 3, 0, 1, 2, 0, 2, -1, 1, 1, 1, 3, 3, 0, 2, 0, 1, 3, 0, 1, 0, 2, 2, -1, 1, 1, 1, 3, 3, 0, 0, 2, 1, 3, 0, 0, 1, 2, 2, -1, 1, 1, 1 
      };
      std::vector<int> lookupPairs4D = 
      {  
        0, 3, 1, 2, 2, 3, 5, 2, 6, 1, 7, 1, 8, 3, 9, 2, 10, 3, 13, 2, 16, 3, 18, 3, 22, 1, 23, 1, 24, 3, 26, 3, 33, 2, 37, 2, 38, 1, 39, 1, 41, 2, 45, 2, 54, 1, 55, 1, 56, 0, 57, 0, 58, 0, 59, 0, 60, 0, 61, 0, 62, 0, 63, 0, 256, 3, 258, 3, 264, 3, 266, 3, 272, 3, 274, 3, 280, 3, 282, 3, 2049, 2, 2053, 2, 2057, 2, 2061, 2, 2081, 2, 2085, 2, 2089, 2, 2093, 2, 2304, 9, 2305, 9, 2312, 9, 2313, 9, 16390, 1, 16391, 1, 16406, 1, 16407, 1, 16422, 1, 16423, 1, 16438, 1, 16439, 1, 16642, 8, 16646, 8, 16658, 8, 16662, 8, 18437, 6, 18439, 6, 18469, 6, 18471, 6, 18688, 9, 18689, 9, 18690, 8, 18693, 6, 18694, 8, 18695, 6, 18696, 9, 18697, 9, 18706, 8, 18710, 8, 18725, 6, 18727, 6, 131128, 0, 131129, 0, 131130, 0, 131131, 0, 131132, 0, 131133, 0, 131134, 0, 131135, 0, 131352, 7, 131354, 7, 131384, 7, 131386, 7, 133161, 5, 133165, 5, 133177, 5, 133181, 5, 133376, 9, 133377, 9, 133384, 9, 133385, 9, 133400, 7, 133402, 7, 133417, 5, 133421, 5, 133432, 7, 133433, 5, 133434, 7, 133437, 5, 147510, 4, 147511, 4, 147518, 4, 147519, 4, 147714, 8, 147718, 8, 147730, 8, 147734, 8, 147736, 7, 147738, 7, 147766, 4, 147767, 4, 147768, 7, 147770, 7, 147774, 4, 147775, 4, 149509, 6, 149511, 6, 149541, 6, 149543, 6, 149545, 5, 149549, 5, 149558, 4, 149559, 4, 149561, 5, 149565, 5, 149566, 4, 149567, 4, 149760, 9, 149761, 9, 149762, 8, 149765, 6, 149766, 8, 149767, 6, 149768, 9, 149769, 9, 149778, 8, 149782, 8, 149784, 7, 149786, 7, 149797, 6, 149799, 6, 149801, 5, 149805, 5, 149814, 4, 149815, 4, 149816, 7, 149817, 5, 149818, 7, 149821, 5, 149822, 4, 149823, 4, 149824, 37, 149825, 37, 149826, 36, 149829, 34, 149830, 36, 149831, 34, 149832, 37, 149833, 37, 149842, 36, 149846, 36, 149848, 35, 149850, 35, 149861, 34, 149863, 34, 149865, 33, 149869, 33, 149878, 32, 149879, 32, 149880, 35, 149881, 33, 149882, 35, 149885, 33, 149886, 32, 149887, 32, 150080, 49, 150082, 48, 150088, 49, 150098, 48, 150104, 47, 150106, 47, 151873, 46, 151877, 45, 151881, 46, 151909, 45, 151913, 44, 151917, 44, 152128, 49, 152129, 46, 152136, 49, 152137, 46, 166214, 43, 166215, 42, 166230, 43, 166247, 42, 166262, 41, 166263, 41, 166466, 48, 166470, 43, 166482, 48, 166486, 43, 168261, 45, 168263, 42, 168293, 45, 168295, 42, 168512, 31, 168513, 28, 168514, 31, 168517, 28, 168518, 25, 168519, 25, 280952, 40, 280953, 39, 280954, 40, 280957, 39, 280958, 38, 280959, 38, 281176, 47, 281178, 47, 281208, 40, 281210, 40, 282985, 44, 282989, 44, 283001, 39, 283005, 39, 283208, 30, 283209, 27, 283224, 30, 283241, 27, 283256, 22, 283257, 22, 297334, 41, 297335, 41, 297342, 38, 297343, 38, 297554, 29, 297558, 24, 297562, 29, 297590, 24, 297594, 21, 297598, 21, 299365, 26, 299367, 23, 299373, 26, 299383, 23, 299389, 20, 299391, 20, 299584, 31, 299585, 28, 299586, 31, 299589, 28, 299590, 25, 299591, 25, 299592, 30, 299593, 27, 299602, 29, 299606, 24, 299608, 30, 299610, 29, 299621, 26, 299623, 23, 299625, 27, 299629, 26, 299638, 24, 299639, 23, 299640, 22, 299641, 22, 299642, 21, 299645, 20, 299646, 21, 299647, 20, 299648, 61, 299649, 60, 299650, 61, 299653, 60, 299654, 59, 299655, 59, 299656, 58, 299657, 57, 299666, 55, 299670, 54, 299672, 58, 299674, 55, 299685, 52, 299687, 51, 299689, 57, 299693, 52, 299702, 54, 299703, 51, 299704, 56, 299705, 56, 299706, 53, 299709, 50, 299710, 53, 299711, 50, 299904, 61, 299906, 61, 299912, 58, 299922, 55, 299928, 58, 299930, 55, 301697, 60, 301701, 60, 301705, 57, 301733, 52, 301737, 57, 301741, 52, 301952, 79, 301953, 79, 301960, 76, 301961, 76, 316038, 59, 316039, 59, 316054, 54, 316071, 51, 316086, 54, 316087, 51, 316290, 78, 316294, 78, 316306, 73, 316310, 73, 318085, 77, 318087, 77, 318117, 70, 318119, 70, 318336, 79, 318337, 79, 318338, 78, 318341, 77, 318342, 78, 318343, 77, 430776, 56, 430777, 56, 430778, 53, 430781, 50, 430782, 53, 430783, 50, 431000, 75, 431002, 72, 431032, 75, 431034, 72, 432809, 74, 432813, 69, 432825, 74, 432829, 69, 433032, 76, 433033, 76, 433048, 75, 433065, 74, 433080, 75, 433081, 74, 447158, 71, 447159, 68, 447166, 71, 447167, 68, 447378, 73, 447382, 73, 447386, 72, 447414, 71, 447418, 72, 447422, 71, 449189, 70, 449191, 70, 449197, 69, 449207, 68, 449213, 69, 449215, 68, 449408, 67, 449409, 67, 449410, 66, 449413, 64, 449414, 66, 449415, 64, 449416, 67, 449417, 67, 449426, 66, 449430, 66, 449432, 65, 449434, 65, 449445, 64, 449447, 64, 449449, 63, 449453, 63, 449462, 62, 449463, 62, 449464, 65, 449465, 63, 449466, 65, 449469, 63, 449470, 62, 449471, 62, 449472, 19, 449473, 19, 449474, 18, 449477, 16, 449478, 18, 449479, 16, 449480, 19, 449481, 19, 449490, 18, 449494, 18, 449496, 17, 449498, 17, 449509, 16, 449511, 16, 449513, 15, 449517, 15, 449526, 14, 449527, 14, 449528, 17, 449529, 15, 449530, 17, 449533, 15, 449534, 14, 449535, 14, 449728, 19, 449729, 19, 449730, 18, 449734, 18, 449736, 19, 449737, 19, 449746, 18, 449750, 18, 449752, 17, 449754, 17, 449784, 17, 449786, 17, 451520, 19, 451521, 19, 451525, 16, 451527, 16, 451528, 19, 451529, 19, 451557, 16, 451559, 16, 451561, 15, 451565, 15, 451577, 15, 451581, 15, 451776, 19, 451777, 19, 451784, 19, 451785, 19, 465858, 18, 465861, 16, 465862, 18, 465863, 16, 465874, 18, 465878, 18, 465893, 16, 465895, 16, 465910, 14, 465911, 14, 465918, 14, 465919, 14, 466114, 18, 466118, 18, 466130, 18, 466134, 18, 467909, 16, 467911, 16, 467941, 16, 467943, 16, 468160, 13, 468161, 13, 468162, 13, 468163, 13, 468164, 13, 468165, 13, 468166, 13, 468167, 13, 580568, 17, 580570, 17, 580585, 15, 580589, 15, 580598, 14, 580599, 14, 580600, 17, 580601, 15, 580602, 17, 580605, 15, 580606, 14, 580607, 14, 580824, 17, 580826, 17, 580856, 17, 580858, 17, 582633, 15, 582637, 15, 582649, 15, 582653, 15, 582856, 12, 582857, 12, 582872, 12, 582873, 12, 582888, 12, 582889, 12, 582904, 12, 582905, 12, 596982, 14, 596983, 14, 596990, 14, 596991, 14, 597202, 11, 597206, 11, 597210, 11, 597214, 11, 597234, 11, 597238, 11, 597242, 11, 597246, 11, 599013, 10, 599015, 10, 599021, 10, 599023, 10, 599029, 10, 599031, 10, 599037, 10, 599039, 10, 599232, 13, 599233, 13, 599234, 13, 599235, 13, 599236, 13, 599237, 13, 599238, 13, 599239, 13, 599240, 12, 599241, 12, 599250, 11, 599254, 11, 599256, 12, 599257, 12, 599258, 11, 599262, 11, 599269, 10, 599271, 10, 599272, 12, 599273, 12, 599277, 10, 599279, 10, 599282, 11, 599285, 10, 599286, 11, 599287, 10, 599288, 12, 599289, 12, 599290, 11, 599293, 10, 599294, 11, 599295, 10 
};

      contributions4D.resize(p4D.size() / 16);
      for (int i = 0; i < static_cast<int>(p4D.size()); i += 16)
      {
        auto baseSet = base4D[p4D[i]];
        Contribution4 *previous = nullptr, *current = nullptr;
        for (int k = 0; k < static_cast<int>(baseSet.size()); k += 5)
        {
          current = 
            new Contribution4(baseSet[k], baseSet[k + 1], 
                              baseSet[k + 2], baseSet[k + 3], 
                              baseSet[k + 4]);
          if (previous == nullptr)
          {
            contributions4D[i / 16] = pContribution4(current);
          }
          else
          {
            previous->Next = current;
          }
          previous = current;
        }
        current->Next = 
          new Contribution4(p4D[i + 1], p4D[i + 2], 
                            p4D[i + 3], p4D[i + 4], p4D[i + 5]);
        current->Next->Next = 
          new Contribution4(p4D[i + 6], p4D[i + 7], 
                            p4D[i + 8], p4D[i + 9], p4D[i + 10]);
        current->Next->Next->Next = 
          new Contribution4(p4D[i + 11], p4D[i + 12], 
                            p4D[i + 13], p4D[i + 14], p4D[i + 15]);
      }

      lookup4D.resize(1048576);
      for (int i = 0; i < static_cast<int>(lookupPairs4D.size()); i += 2)
      {
        lookup4D[lookupPairs4D[i]] = 
          contributions4D[lookupPairs4D[i+1]].get();
      }
    }
  };
  // Initialise our static tables
  inline static StaticConstructor staticConstructor;

public:
  OpenSimplexNoise(int64_t seed)
  {
    std::array<char, 256> source;
    for (int i = 0; i < 256; i++)
    {
      source[i] = i;
    }
    for (int i = 255; i >= 0; i--)
    {
      seed = seed * 6364136223846793005L + 1442695040888963407L;
      int r = static_cast<int>((seed + 31) % (i + 1));
      if (r < 0)
      {
        r += (i + 1);
      }
      perm[i] = source[r];
      perm2D[i] = perm[i] & 0x0E;
      perm3D[i] = (perm[i] % 24) * 3;
      perm4D[i] = perm[i] & 0xFC;
      source[r] = source[i];
    }
  }

  double Evaluate(double x, double y)
  {
    double stretchOffset = (x + y) * STRETCH_2D;
    double xs = x + stretchOffset;
    double ys = y + stretchOffset;

    int xsb = std::floor(xs);
    int ysb = std::floor(ys);

    double squishOffset = (xsb + ysb) * SQUISH_2D;
    double dx0 = x - (xsb + squishOffset);
    double dy0 = y - (ysb + squishOffset);

    double xins = xs - xsb;
    double yins = ys - ysb;

    double inSum = xins + yins;
    int hash =
      static_cast<int>(xins - yins + 1) |
      static_cast<int>(inSum) << 1 |
      static_cast<int>(inSum + yins) << 2 |
      static_cast<int>(inSum + xins) << 4;

    Contribution2 *c = lookup2D[hash];

    double value = 0.0;
    while (c != nullptr)
    {
      double dx = dx0 + c->dx;
      double dy = dy0 + c->dy;
      double attn = 2 - dx * dx - dy * dy;
      if (attn > 0)
      {
        int px = xsb + c->xsb;
        int py = ysb + c->ysb;
        
        int i = perm2D[(perm[px & 0xFF] + py) & 0xFF];
        double valuePart = 
                       gradients2D[i    ] * dx 
                     + gradients2D[i + 1] * dy;

        attn *= attn;
        value += attn * attn * valuePart;
      }
      c = c->Next;
    }

    return value * NORM_2D;
  }

  double Evaluate(double x, double y, double z)
  {
    double stretchOffset = (x + y + z) * STRETCH_3D;
    double xs = x + stretchOffset;
    double ys = y + stretchOffset;
    double zs = z + stretchOffset;

    int xsb = std::floor(xs);
    int ysb = std::floor(ys);
    int zsb = std::floor(zs);

    double squishOffset = (xsb + ysb + zsb) * SQUISH_3D;
    double dx0 = x - (xsb + squishOffset);
    double dy0 = y - (ysb + squishOffset);
    double dz0 = z - (zsb + squishOffset);

    double xins = xs - xsb;
    double yins = ys - ysb;
    double zins = zs - zsb;
    
    double inSum = xins + yins + zins;
    int hash =
      static_cast<int>(yins - zins + 1) |
      static_cast<int>(xins - yins + 1) << 1 |
      static_cast<int>(xins - zins + 1) << 2 |
      static_cast<int>(inSum) << 3 |
      static_cast<int>(inSum + zins) << 5 |
      static_cast<int>(inSum + yins) << 7 |
      static_cast<int>(inSum + xins) << 9;

    Contribution3 *c = lookup3D[hash];

    double value = 0.0;
    while (c != nullptr)
    {
      double dx = dx0 + c->dx;
      double dy = dy0 + c->dy;
      double dz = dz0 + c->dz;

      double attn = 2 - dx * dx - dy * dy - dz * dz;
      if (attn > 0)
      {
        int px = xsb + c->xsb;
        int py = ysb + c->ysb;
        int pz = zsb + c->zsb;

        int i = perm3D[(perm[(perm[px & 0xFF] + py) & 0xFF] + pz) & 0xFF];
        double valuePart = 
                       gradients3D[i    ] * dx 
                     + gradients3D[i + 1] * dy 
                     + gradients3D[i + 2] * dz;

        attn *= attn;
        value += attn * attn * valuePart;
      }
      c = c->Next;
    }

    return value * NORM_3D;
  }

  double Evaluate(double x, double y, double z, double w)
  {
    double stretchOffset = (x + y + z + w) * STRETCH_4D;
    double xs = x + stretchOffset;
    double ys = y + stretchOffset;
    double zs = z + stretchOffset;
    double ws = w + stretchOffset;

    int xsb = std::floor(xs);
    int ysb = std::floor(ys);
    int zsb = std::floor(zs);
    int wsb = std::floor(ws);

    double squishOffset = (xsb + ysb + zsb + wsb) * SQUISH_4D;
    double dx0 = x - (xsb + squishOffset);
    double dy0 = y - (ysb + squishOffset);
    double dz0 = z - (zsb + squishOffset);
    double dw0 = w - (wsb + squishOffset);

    double xins = xs - xsb;
    double yins = ys - ysb;
    double zins = zs - zsb;
    double wins = ws - wsb;

    double inSum = xins + yins + zins + wins;

    int hash =
      static_cast<int>(zins - wins + 1) |
      static_cast<int>(yins - zins + 1) << 1 |
      static_cast<int>(yins - wins + 1) << 2 |
      static_cast<int>(xins - yins + 1) << 3 |
      static_cast<int>(xins - zins + 1) << 4 |
      static_cast<int>(xins - wins + 1) << 5 |
      static_cast<int>(inSum) << 6 |
      static_cast<int>(inSum + wins) << 8 |
      static_cast<int>(inSum + zins) << 11 |
      static_cast<int>(inSum + yins) << 14 |
      static_cast<int>(inSum + xins) << 17;

    Contribution4 *c = lookup4D[hash];

    double value = 0.0;
    while (c != nullptr)
    {
      double dx = dx0 + c->dx;
      double dy = dy0 + c->dy;
      double dz = dz0 + c->dz;
      double dw = dw0 + c->dw;

      double attn = 2 - dx  *dx - dy * dy - dz * dz - dw * dw;
      if (attn > 0)
      {
        int px = xsb + c->xsb;
        int py = ysb + c->ysb;
        int pz = zsb + c->zsb;
        int pw = wsb + c->wsb;

        int i = perm4D[(
                        perm[(
                          perm[(
                            perm[px & 0xFF] + py) & 0xFF]
                          + pz) & 0xFF]
                        + pw) & 0xFF];
        double valuePart = 
            gradients4D[i] * dx
          + gradients4D[i + 1] * dy
          + gradients4D[i + 2] * dz
          + gradients4D[i + 3] * dw;

        attn *= attn;
        value += attn * attn * valuePart;
      }
      c = c->Next;
    }

    return value * NORM_4D;
  }
};

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/fpng.cpp`
```
// https://github.com/richgel999/fpng
#pragma GCC diagnostic ignored "-Wtype-limits"
#if defined(__clang__)
    #pragma GCC diagnostic ignored "-Wtautological-constant-out-of-range-compare"
    #pragma GCC diagnostic ignored "-Wunused-function"
#endif
// fpng.cpp 1.0.6 - Fast 24/32bpp .PNG image writer/reader. See unlicense at the end of this file.
// PNG's generated by this code have been tested to load successfully with stb_image.h, lodepng.cpp, wuffs, libpng, and pngcheck.
//
// Uses code from the simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299
// Some low-level Deflate/Huffman functions derived from the original 2011 Google Code version of miniz (public domain by R. Geldreich, Jr.): https://code.google.com/archive/p/miniz/
// Low-level Huffman code size function: public domain, originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
//
// Optional config macros:
// FPNG_NO_SSE - Set to 1 to completely disable SSE usage, even on x86/x64. By default, on x86/x64 it's enabled.
// FPNG_DISABLE_DECODE_CRC32_CHECKS - Set to 1 to disable PNG chunk CRC-32 tests, for improved fuzzing. Defaults to 0.
// FPNG_USE_UNALIGNED_LOADS - Set to 1 to indicate it's OK to read/write unaligned 32-bit/64-bit values. Defaults to 0, unless x86/x64.
//
// With gcc/clang on x86, compile with -msse4.1 -mpclmul -fno-strict-aliasing
// Only tested with -fno-strict-aliasing (which the Linux kernel uses, and MSVC's default).
//
#include "fpng.h"
#include <assert.h>
#include <string.h>

#ifdef _MSC_VER
	#pragma warning (disable:4127) // conditional expression is constant
#endif

// Set FPNG_NO_SSE to 1 to completely disable SSE usage.
#ifndef FPNG_NO_SSE
	#define FPNG_NO_SSE (0)
#endif

// Detect if we're compiling on x86/x64
#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
	#define FPNG_X86_OR_X64_CPU (1)
#else
	#define FPNG_X86_OR_X64_CPU (0)
#endif

#if FPNG_X86_OR_X64_CPU && !FPNG_NO_SSE
	#ifdef _MSC_VER
		#include <intrin.h>
	#endif
	#include <xmmintrin.h>		// SSE
	#include <emmintrin.h>		// SSE2
	#include <smmintrin.h>		// SSE4.1
	#include <wmmintrin.h>		// pclmul
#endif

#ifndef FPNG_NO_STDIO
	#include <stdio.h>
#endif

// Allow the disabling of the chunk data CRC32 checks, for fuzz testing of the decoder
#ifndef FPNG_DISABLE_DECODE_CRC32_CHECKS
	#define FPNG_DISABLE_DECODE_CRC32_CHECKS (0)
#endif

// Using unaligned loads and stores causes errors when using UBSan. Jam it off.
#if defined(__has_feature)
	#if __has_feature(undefined_behavior_sanitizer)
		#undef FPNG_USE_UNALIGNED_LOADS
		#define FPNG_USE_UNALIGNED_LOADS (0)
	#endif
#endif

// Set to 0 if your platform doesn't support unaligned 32-bit/64-bit reads/writes. 
#ifndef FPNG_USE_UNALIGNED_LOADS
	#if FPNG_X86_OR_X64_CPU
		// On x86/x64 we default to enabled, for a noticeable perf gain.
		#define FPNG_USE_UNALIGNED_LOADS (1)
	#else
		#define FPNG_USE_UNALIGNED_LOADS (0)
	#endif
#endif

#if defined(_MSC_VER) || defined(__MINGW32__) || FPNG_X86_OR_X64_CPU
	#ifndef __LITTLE_ENDIAN
	#define __LITTLE_ENDIAN 1234
	#endif
	#ifndef __BIG_ENDIAN
	#define __BIG_ENDIAN 4321
	#endif

	// Assume little endian on Windows/x86/x64.
	#define __BYTE_ORDER __LITTLE_ENDIAN
#elif defined(__APPLE__)
	#define __BYTE_ORDER __BYTE_ORDER__
	#define __LITTLE_ENDIAN __LITTLE_ENDIAN__
	#define __BIG_ENDIAN __BIG_ENDIAN__
#else
	// for __BYTE_ORDER (__LITTLE_ENDIAN or __BIG_ENDIAN)
	#include <sys/param.h>

	#ifndef __LITTLE_ENDIAN
	#define __LITTLE_ENDIAN 1234
	#endif
	#ifndef __BIG_ENDIAN
	#define __BIG_ENDIAN 4321
	#endif
#endif

#if !defined(__BYTE_ORDER)
	#error __BYTE_ORDER undefined. Compile with -D__BYTE_ORDER=1234 for little endian or -D__BYTE_ORDER=4321 for big endian.
#endif

namespace fpng
{
	static const int FPNG_FALSE = 0;
	static const uint8_t FPNG_FDEC_VERSION = 0;
	static const uint32_t FPNG_MAX_SUPPORTED_DIM = 1 << 24;

	template <typename S> static inline S maximum(S a, S b) { return (a > b) ? a : b; }
	template <typename S> static inline S minimum(S a, S b) { return (a < b) ? a : b; }

	static inline uint32_t simple_swap32(uint32_t x) { return (x >> 24) | ((x >> 8) & 0x0000FF00) | ((x << 8) & 0x00FF0000) | (x << 24); }
	static inline uint64_t simple_swap64(uint64_t x) { return (((uint64_t)simple_swap32((uint32_t)x)) << 32U) | simple_swap32((uint32_t)(x >> 32U)); }

	static inline uint32_t swap32(uint32_t x)
	{
#if defined(__GNUC__) || defined(__clang__)
		return __builtin_bswap32(x);
#else
		return simple_swap32(x);
#endif
	}

	static inline uint64_t swap64(uint64_t x)
	{
#if defined(__GNUC__) || defined(__clang__)
		return __builtin_bswap64(x);
#else
		return simple_swap64(x);
#endif
	}

#if FPNG_USE_UNALIGNED_LOADS
	#if __BYTE_ORDER == __BIG_ENDIAN
		#define READ_LE32(p) swap32(*reinterpret_cast<const uint32_t *>(p))
		#define WRITE_LE32(p, v) *reinterpret_cast<uint32_t *>(p) = swap32((uint32_t)(v))
		#define WRITE_LE64(p, v) *reinterpret_cast<uint64_t *>(p) = swap64((uint64_t)(v))

		#define READ_BE32(p) *reinterpret_cast<const uint32_t *>(p)
	#else
		#define READ_LE32(p) (*reinterpret_cast<const uint32_t *>(p))
		#define WRITE_LE32(p, v) *reinterpret_cast<uint32_t *>(p) = (uint32_t)(v)
		#define WRITE_LE64(p, v) *reinterpret_cast<uint64_t *>(p) = (uint64_t)(v)

		#define READ_BE32(p) swap32(*reinterpret_cast<const uint32_t *>(p))
	#endif
#else
	// A good compiler should be able to optimize these routines - hopefully. They are crucial for performance.
	static inline uint32_t READ_LE32(const void* p)
	{
		const uint8_t* pBytes = (const uint8_t*)p;
		return ((uint32_t)pBytes[0]) | (((uint32_t)pBytes[1]) << 8U) | (((uint32_t)pBytes[2]) << 16U) | (((uint32_t)pBytes[3]) << 24U);
	}

	static inline uint32_t READ_BE32(const void* p)
	{
		const uint8_t* pBytes = (const uint8_t*)p;
		return ((uint32_t)pBytes[3]) | (((uint32_t)pBytes[2]) << 8U) | (((uint32_t)pBytes[1]) << 16U) | (((uint32_t)pBytes[0]) << 24U);
	}

	static inline void WRITE_LE32(const void* p, uint32_t v)
	{
		uint8_t* pBytes = (uint8_t*)p;
		pBytes[0] = (uint8_t)(v);
		pBytes[1] = (uint8_t)(v >> 8);
		pBytes[2] = (uint8_t)(v >> 16);
		pBytes[3] = (uint8_t)(v >> 24);
	}

	static inline void WRITE_LE64(const void* p, uint64_t v)
	{
		uint8_t* pBytes = (uint8_t*)p;
		pBytes[0] = (uint8_t)(v);
		pBytes[1] = (uint8_t)(v >> 8);
		pBytes[2] = (uint8_t)(v >> 16);
		pBytes[3] = (uint8_t)(v >> 24);
		pBytes[4] = (uint8_t)(v >> 32);
		pBytes[5] = (uint8_t)(v >> 40);
		pBytes[6] = (uint8_t)(v >> 48);
		pBytes[7] = (uint8_t)(v >> 56);
	}
#endif

	// Customized the very common case of reading a 24bpp pixel from memory
	static inline uint32_t READ_RGB_PIXEL(const void* p)
	{
#if FPNG_USE_UNALIGNED_LOADS 
		return READ_LE32(p) & 0xFFFFFF;
#else
		const uint8_t* pBytes = (const uint8_t*)p;
		return ((uint32_t)pBytes[0]) | (((uint32_t)pBytes[1]) << 8U) | (((uint32_t)pBytes[2]) << 16U);
#endif
	}

	// See "Slicing by 4" CRC-32 algorithm here: 
	// https://create.stephan-brumme.com/crc32/

	// Precomputed 4KB of CRC-32 tables
	static const uint32_t g_crc32_4[4][256] = {
	{00, 016701630226, 035603460454, 023102250672, 0733342031, 016032572217, 035130722465, 023631112643, 01666704062, 017167134244, 034065364436, 022764554610, 01155446053, 017654276275, 034756026407, 022057616621, 03555610144, 015254020362, 036356270510, 020457440736, 03266552175, 015567362353, 036465132521, 020364702707, 02333114126, 014432724300, 037530574572, 021231344754, 02400256117, 014301466331, 037203636543, 021502006765,
	07333420310, 011432210136, 032530040744, 024231670562, 07400762321, 011301152107, 032203302775, 024502532553, 06555324372, 010254514154, 033356744726, 025457174500, 06266066343, 010567656165, 033465406717, 025364236531, 04666230254, 012167400072, 031065650600, 027764060426, 04155172265, 012654742043, 031756512631, 027057322417, 05000534236, 013701304010, 030603154662, 026102764444, 05733676207, 013032046021, 030130216653, 026631426475,
	016667040620, 0166670406, 023064420274, 035765210052, 016154302611, 0655532437, 023757762245, 035056152063, 017001744642, 01700174464, 022602324216, 034103514030, 017732406673, 01033236455, 022131066227, 034630656001, 015332650764, 03433060542, 020531230330, 036230400116, 015401512755, 03300322573, 020202172301, 036503742127, 014554154706, 02255764520, 021357534352, 037456304174, 014267216737, 02566426511, 021464676363, 037365046145,
	011554460530, 07255250716, 024357000164, 032456630342, 011267722501, 07566112727, 024464342155, 032365572373, 010332364552, 06433554774, 025531704106, 033230134320, 010401026563, 06300616745, 025202446137, 033503276311, 012001270474, 04700440652, 027602610020, 031103020206, 012732132445, 04033702663, 027131552011, 031630362237, 013667574416, 05166344630, 026064114042, 030765724264, 013154636427, 05655006601, 026757256073, 030056466255,
	035556101440, 023257731666, 0355561014, 016454351232, 035265243471, 023564473657, 0466623025, 016367013203, 034330605422, 022431035604, 01533265076, 017232455250, 034403547413, 022302377635, 01200127047, 017501717261, 036003711504, 020702121722, 03600371150, 015101541376, 036730453535, 020031263713, 03133033161, 015632603347, 037665015566, 021164625740, 02066475132, 014767245314, 037156357557, 021657567771, 02755737103, 014054107325,
	032665521750, 024164311576, 07066141304, 011767771122, 032156663761, 024657053547, 07755203335, 011054433113, 033003225732, 025702415514, 06600645366, 010101075140, 033730167703, 025031757525, 06133507357, 010632337171, 031330331614, 027431501432, 04533751240, 012232161066, 031403073625, 027302643403, 04200413271, 012501223057, 030556435676, 026257205450, 05355055222, 013454665004, 030265777647, 026564147461, 05466317213, 013367527035,
	023331141260, 035430771046, 016532521634, 0233311412, 023402203251, 035303433077, 016201663605, 0500053423, 022557645202, 034256075024, 017354225656, 01455415470, 022264507233, 034565337015, 017467167667, 01366757441, 020664751324, 036165161102, 015067331770, 03766501556, 020157413315, 036656223133, 015754073741, 03055643567, 021002055346, 037703665160, 014601435712, 02100205534, 021731317377, 037030527151, 014132777723, 02633147505,
	024002561170, 032703351356, 011601101524, 07100731702, 024731623141, 032030013367, 011132243515, 07633473733, 025664265112, 033165455334, 010067605546, 06766035760, 025157127123, 033656717305, 010754547577, 06055377751, 027557371034, 031256541212, 012354711460, 04455121646, 027264033005, 031565603223, 012467453451, 04366263677, 026331475056, 030430245270, 013532015402, 05233625624, 026402737067, 030303107241, 013201357433, 05500567615,
	}, { 00,03106630501,06215461202,05313251703,014433142404,017535772105,012626523606,011720313307,031066305010,032160535511,037273764212,034375154713,025455247414,026553477115,023640626616,020746016317,011260411121,012366221420,017075070323,014173640622,05653553525,06755363024,03446132727,0540702226,020206714131,023300124430,026013375333,025115545632,034635656535,037733066034,032420237737,031526407236,
	022541022242,021447612743,024754443040,027652273541,036172160646,035074750347,030367501444,033261331145,013527327252,010421517753,015732746050,016634176551,07114265656,04012455357,01301604454,02207034155,033721433363,030627203662,035534052161,036432662460,027312571767,024214341266,021107110565,022001720064,02747736373,01641106672,04552357171,07454567470,016374674777,015272044276,010161215575,013067425074,
	036036247405,035130477104,030223626607,033325016306,022405305001,021503535500,024610764203,027716154702,07050142415,04156772114,01245523617,02343313316,013463000011,010565630510,015676461213,016770251712,027256656524,024350066025,021043237726,022145407227,033665714120,030763124421,035470375322,036576545623,016230553534,015336363035,010025132736,013123702237,02603411130,01705221431,04416070332,07510640633,
	014577265647,017471455346,012762604445,011664034144,0144327243,03042517742,06351746041,05257176540,025511160657,026417750356,023704501455,020602331154,031122022253,032024612752,037337443051,034231273550,05717674766,06611044267,03502215564,0404425065,011324736362,012222106663,017131357160,014037567461,034771571776,037677341277,032564110574,031462720075,020342433372,023244203673,026157052170,025051662471,
	07340714113,04246124412,01155375311,02053545610,013773656517,010675066016,015566237715,016460407214,036326411103,035220221402,030133070301,033035640600,022715553507,021613363006,024500132705,027406702204,016120305032,015026535533,010335764230,013233154731,02513247436,01415477137,04706626634,07600016335,027146000022,024040630523,021353461220,022255251721,033575142426,030473772127,035760523624,036666313325,
	025601736351,026707106650,023414357153,020512567452,031232674755,032334044254,037027215557,034121425056,014667433341,017761203640,012472052143,011574662442,0254571745,03352341244,06041110547,05147720046,034461327270,037567517771,032674746072,031772176573,020052265674,023154455375,026247604476,025341034177,05407022260,06501612761,03612443062,0714273563,011034160664,012132750365,017221501466,014327331167,
	031376553516,032270363017,037163132714,034065702215,025745411112,026643221413,023550070310,020456640611,0310656506,03216066007,06105237704,05003407205,014723714102,017625124403,012536375300,011430545601,020116142437,023010772136,026303523635,025205313334,034525000033,037423630532,032730461231,031636251730,011170247427,012076477126,017365626625,014263016324,05543305023,06445535522,03756764221,0650154720,
	013637571754,010731341255,015422110556,016524720057,07204433350,04302203651,01011052152,02117662453,022651674744,021757044245,024444215546,027542425047,036262736340,035364106641,030077357142,033171567443,02457160675,01551750374,04642501477,07744331176,016064022271,015162612770,010271443073,013377273572,033431265665,030537455364,035624604467,036722034166,027002327261,024104517760,021217746063,022311176562,
	}, { 00,0160465067,0341152156,0221537131,0702324334,0662741353,0443276262,0523613205,01604650670,01764235617,01545702726,01425367741,01106574544,01066111523,01247426412,01327043475,03411521560,03571144507,03750473436,03630016451,03313605654,03273260633,03052757702,03132332765,02215371310,02375714377,02154223246,02034646221,02517055024,02477430043,02656107172,02736562115,
	07023243340,07143626327,07362311216,07202774271,07721167074,07641502013,07460035122,07500450145,06627413530,06747076557,06566541466,06406124401,06125737604,06045352663,06264665752,06304200735,04432762620,04552307647,04773630776,04613255711,04330446514,04250023573,04071514442,04111171425,05236132050,05356557037,05177060106,05017405161,05534216364,05454673303,05675344232,05715721255,
	016046506700,016126163767,016307454656,016267031631,016744622434,016624247453,016405770562,016565315505,017642356170,017722733117,017503204026,017463661041,017140072244,017020417223,017201120312,017361545375,015457027260,015537442207,015716175336,015676510351,015355303154,015235766133,015014251002,015174634065,014253677410,014333212477,014112725546,014072340521,014551553724,014431136743,014610401672,014770064615,
	011065745440,011105320427,011324617516,011244272571,011767461774,011607004713,011426533622,011546156645,010661115230,010701570257,010520047366,010440422301,010163231104,010003654163,010222363052,010342706035,012474264120,012514601147,012735336076,012655753011,012376140214,012216525273,012037012342,012157477325,013270434750,013310051737,013131566606,013051103661,013572710464,013412375403,013633642532,013753227555,
	034115215600,034075670667,034254347756,034334722731,034617131534,034777554553,034556063462,034436406405,035711445070,035671020017,035450517126,035530172141,035013761344,035173304323,035352633212,035232256275,037504734360,037464351307,037645666236,037725203251,037206410054,037366075033,037147542102,037027127165,036300164510,036260501577,036041036446,036121453421,036402240624,036562625643,036743312772,036623777715,
	033136056540,033056433527,033277104416,033317561471,033634372674,033754717613,033575220722,033415645745,032732606330,032652263357,032473754266,032513331201,032030522004,032150147063,032371470152,032211015135,030527577020,030447112047,030666425176,030706040111,030225653314,030345236373,030164701242,030004364225,031323327650,031243742637,031062275706,031102610761,031421003564,031541466503,031760151432,031600534455,
	022153713100,022033376167,022212641056,022372224031,022651437234,022731052253,022510565362,022470100305,023757143770,023637526717,023416011626,023576474641,023055267444,023135602423,023314335512,023274750575,021542232460,021422657407,021603360536,021763705551,021240116754,021320573733,021101044602,021061421665,020346462210,020226007277,020007530346,020167155321,020444746124,020524323143,020705614072,020665271015,
	025170550240,025010135227,025231402316,025351067371,025672674174,025712211113,025533726022,025453343045,024774300430,024614765457,024435252566,024555637501,024076024704,024116441763,024337176652,024257513635,026561071720,026401414747,026620123676,026740546611,026263355414,026303730473,026122207542,026042662525,027365621150,027205244137,027024773006,027144316061,027467505264,027507160203,027726457332,027646032355,
	}, { 00,027057063545,025202344213,02255327756,021730513527,06767570062,04532657734,023565634271,030555024357,017502047612,015757360144,032700303401,011265537670,036232554335,034067673463,013030610126,012006253637,035051230372,037204117424,010253174161,033736740310,014761723655,016534404103,031563467446,022553277560,05504214025,07751133773,020706150236,03263764047,024234707502,026061420254,01036443711,
	024014527476,03043544133,01216663665,026241600320,05724034151,022773057414,020526370342,07571313607,014541503721,033516560264,031743647532,016714624077,035271010206,012226073743,010073354015,037024337550,036012774241,011045717704,013210430052,034247453517,017722267766,030775204223,032520123575,015577140030,06547750116,021510733453,023745414305,04712477640,027277243431,0220220174,02075107622,025022164367,
	023305054075,04352037530,06107310266,021150373723,02435547552,025462524017,027637603741,0660660204,013650070322,034607013667,036452334131,011405357474,032160563605,015137500340,017362627416,030335644153,031303207642,016354264307,014101143451,033156120114,010433714365,037464777620,035631450176,012666433433,01656223515,026601240050,024454167706,03403104243,020166730032,07131753577,05364474221,022333417764,
	07311573403,020346510146,022113637610,05144654355,026421060124,01476003461,03623324337,024674347672,037644557754,010613534211,012446613547,035411670002,016174044273,031123027736,033376300060,014321363525,015317720234,032340743771,030115464027,017142407562,034427233713,013470250256,011625177500,036672114045,025642704163,02615767426,0440440370,027417423635,04172217444,023125274101,021370153657,06327130312,
	035526333073,012571350536,010724077260,037773014725,014216620554,033241643011,031014564747,016043507202,05073317324,022024374661,020271053137,07226030472,024743604603,03714667346,01541540410,026516523155,027520160644,0577103301,02722224457,025775247112,06210473363,021247410626,023012737170,04045754435,017075144513,030022127056,032277200700,015220263245,036745457034,011712434571,013547713227,034510770762,
	011532614405,036565677140,034730550616,013767533353,030202307122,017255364467,015000043331,032057020674,021067630752,06030653217,04265574541,023232517004,0757323275,027700340730,025555067066,02502004523,03534447232,024563424777,026736703021,01761760564,022204154715,05253137250,07006210506,020051273043,033061463165,014036400420,016263727376,031234744633,012751170442,035706113107,037553234651,010504257314,
	016623367006,031674304543,033421023215,014476040750,037113674521,010144617064,012311530732,035346553277,026376343351,01321320614,03174007142,024123064407,07446650676,020411633333,022644514465,05613577120,04625134631,023672157374,021427270422,06470213167,025115427316,02142444653,0317763105,027340700440,034370110566,013327173023,011172254775,036125237230,015440403041,032417460504,030642747252,017615724717,
	032637640470,015660623135,017435504663,030462567326,013107353157,034150330412,036305017344,011352074601,02362664727,025335607262,027160520534,0137543071,023452377200,04405314745,06650033013,021607050556,020631413247,07666470702,05433757054,022464734511,01101100760,026156163225,024303244573,03354227036,010364437110,037333454455,035166773303,012131710646,031454124437,016403147172,014656260624,033601203361,
	} };

	static uint32_t crc32_slice_by_4(const void* pData, size_t data_len, uint32_t cur_crc32 = 0)
	{
		uint32_t crc = ~cur_crc32;
		const uint32_t* pData32 = static_cast<const uint32_t*>(pData);

		for (; data_len >= sizeof(uint32_t); ++pData32, data_len -= 4)
		{
			uint32_t v = READ_LE32(pData32) ^ crc;
			crc = g_crc32_4[0][v >> 24] ^ g_crc32_4[1][(v >> 16) & 0xFF] ^ g_crc32_4[2][(v >> 8) & 0xFF] ^ g_crc32_4[3][v & 0xFF];
		}

		for (const uint8_t* pData8 = reinterpret_cast<const uint8_t*>(pData32); data_len; --data_len)
			crc = (crc >> 8) ^ g_crc32_4[0][(crc & 0xFF) ^ *pData8++];

		return ~crc;
	}

#if FPNG_X86_OR_X64_CPU && !FPNG_NO_SSE 
	// See Fast CRC Computation for Generic Polynomials Using PCLMULQDQ Instruction":
	// https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/fast-crc-computation-generic-polynomials-pclmulqdq-paper.pdf
	// Requires PCLMUL and SSE 4.1. This function skips Step 1 (fold by 4) for simplicity/less code.
	static uint32_t crc32_pclmul(const uint8_t* p, size_t size, uint32_t crc)
	{
		assert(size >= 16);

		// See page 22 (bit reflected constants for gzip)
#ifdef _MSC_VER
		static const uint64_t __declspec(align(16)) 
#else
		static const uint64_t __attribute__((aligned(16)))
#endif
			s_u[2] = { 0x1DB710641, 0x1F7011641 }, s_k5k0[2] = { 0x163CD6124, 0 }, s_k3k4[2] = { 0x1751997D0, 0xCCAA009E };

		// Load first 16 bytes, apply initial CRC32
		__m128i b = _mm_xor_si128(_mm_cvtsi32_si128(~crc), _mm_loadu_si128(reinterpret_cast<const __m128i*>(p)));

		// We're skipping directly to Step 2 page 12 - iteratively folding by 1 (by 4 is overkill for our needs)
		const __m128i k3k4 = _mm_load_si128(reinterpret_cast<const __m128i*>(s_k3k4));

		for (size -= 16, p += 16; size >= 16; size -= 16, p += 16)
			b = _mm_xor_si128(_mm_xor_si128(_mm_clmulepi64_si128(b, k3k4, 17), _mm_loadu_si128(reinterpret_cast<const __m128i*>(p))), _mm_clmulepi64_si128(b, k3k4, 0));

		// Final stages: fold to 64-bits, 32-bit Barrett reduction
		const __m128i z = _mm_set_epi32(0, ~0, 0, ~0), u = _mm_load_si128(reinterpret_cast<const __m128i*>(s_u));
		b = _mm_xor_si128(_mm_srli_si128(b, 8), _mm_clmulepi64_si128(b, k3k4, 16));
		b = _mm_xor_si128(_mm_clmulepi64_si128(_mm_and_si128(b, z), _mm_loadl_epi64(reinterpret_cast<const __m128i*>(s_k5k0)), 0), _mm_srli_si128(b, 4));
		return ~_mm_extract_epi32(_mm_xor_si128(b, _mm_clmulepi64_si128(_mm_and_si128(_mm_clmulepi64_si128(_mm_and_si128(b, z), u, 16), z), u, 0)), 1);
	}

	static uint32_t crc32_sse41_simd(const unsigned char* buf, size_t len, uint32_t prev_crc32)
	{
		if (len < 16)
			return crc32_slice_by_4(buf, len, prev_crc32);

		uint32_t simd_len = len & ~15;
		uint32_t c = crc32_pclmul(buf, simd_len, prev_crc32);
		return crc32_slice_by_4(buf + simd_len, len - simd_len, c);
	}
#endif

#if FPNG_X86_OR_X64_CPU && !FPNG_NO_SSE 

#ifndef _MSC_VER
	static void do_cpuid(uint32_t eax, uint32_t ecx, uint32_t* regs)
	{
		uint32_t ebx = 0, edx = 0;

#if defined(__PIC__) && defined(__i386__)
		__asm__("movl %%ebx, %%edi;"
			"cpuid;"
			"xchgl %%ebx, %%edi;"
			: "=D"(ebx), "+a"(eax), "+c"(ecx), "=d"(edx));
#else
		__asm__("cpuid;" : "+b"(ebx), "+a"(eax), "+c"(ecx), "=d"(edx));
#endif

		regs[0] = eax; regs[1] = ebx; regs[2] = ecx; regs[3] = edx;
	}
#endif

	struct cpu_info
	{
		cpu_info() { memset(this, 0, sizeof(*this)); }

		bool m_initialized, m_has_fpu, m_has_mmx, m_has_sse, m_has_sse2, m_has_sse3, m_has_ssse3, m_has_sse41, m_has_sse42, m_has_avx, m_has_avx2, m_has_pclmulqdq;
				
		void init()
		{
			if (m_initialized)
				return;

			int regs[4];

#ifdef _MSC_VER
			__cpuid(regs, 0);
#else
			do_cpuid(0, 0, (uint32_t*)regs);
#endif

			const uint32_t max_eax = regs[0];
			if (max_eax >= 1U)
			{
#ifdef _MSC_VER
				__cpuid(regs, 1);
#else
				do_cpuid(1, 0, (uint32_t*)regs);
#endif
				extract_x86_flags(regs[2], regs[3]);
			}

			if (max_eax >= 7U)
			{
#ifdef _MSC_VER
				__cpuidex(regs, 7, 0);
#else
				do_cpuid(7, 0, (uint32_t*)regs);
#endif
				extract_x86_extended_flags(regs[1]);
			}

			m_initialized = true;
		}

		bool can_use_sse41() const { return m_has_sse && m_has_sse2 && m_has_sse3 && m_has_ssse3 && m_has_sse41; }
		bool can_use_pclmul() const	{ return m_has_pclmulqdq && can_use_sse41(); }

	private:
		void extract_x86_flags(uint32_t ecx, uint32_t edx)
		{
			m_has_fpu = (edx & (1 << 0)) != 0;	m_has_mmx = (edx & (1 << 23)) != 0;	m_has_sse = (edx & (1 << 25)) != 0; m_has_sse2 = (edx & (1 << 26)) != 0;
			m_has_sse3 = (ecx & (1 << 0)) != 0; m_has_ssse3 = (ecx & (1 << 9)) != 0; m_has_sse41 = (ecx & (1 << 19)) != 0; m_has_sse42 = (ecx & (1 << 20)) != 0;
			m_has_pclmulqdq = (ecx & (1 << 1)) != 0; m_has_avx = (ecx & (1 << 28)) != 0;
		}

		void extract_x86_extended_flags(uint32_t ebx) { m_has_avx2 = (ebx & (1 << 5)) != 0; }
	};

	cpu_info g_cpu_info;
		
	void fpng_init()
	{
		g_cpu_info.init();
	}
#else
	void fpng_init()
	{
	}
#endif

	bool fpng_cpu_supports_sse41()
	{
#if FPNG_X86_OR_X64_CPU && !FPNG_NO_SSE 
		assert(g_cpu_info.m_initialized);
		return g_cpu_info.can_use_sse41();
#else
		return false;
#endif
	}

	uint32_t fpng_crc32(const void* pData, size_t size, uint32_t prev_crc32)
	{
#if FPNG_X86_OR_X64_CPU && !FPNG_NO_SSE 
		if (g_cpu_info.can_use_pclmul())
			return crc32_sse41_simd(static_cast<const uint8_t *>(pData), size, prev_crc32);
#endif

		return crc32_slice_by_4(pData, size, prev_crc32);
	}

#if FPNG_X86_OR_X64_CPU && !FPNG_NO_SSE 
	// See "Fast Computation of Adler32 Checksums":
	// https://www.intel.com/content/www/us/en/developer/articles/technical/fast-computation-of-adler32-checksums.html
	// SSE 4.1, 16 bytes per iteration
	static uint32_t adler32_sse_16(const uint8_t* p, size_t len, uint32_t initial)
	{
		uint32_t s1 = initial & 0xFFFF, s2 = initial >> 16;
		const uint32_t K = 65521;

		while (len >= 16)
		{
			__m128i a = _mm_setr_epi32(s1, 0, 0, 0), b = _mm_setzero_si128(), c = _mm_setzero_si128(), d = _mm_setzero_si128(), 
				e = _mm_setzero_si128(), f = _mm_setzero_si128(), g = _mm_setzero_si128(), h = _mm_setzero_si128();

			const size_t n = minimum<size_t>(len >> 4, 5552);

			for (size_t i = 0; i < n; i++)
			{
				const __m128i v = _mm_loadu_si128((const __m128i*)(p + i * 16));
				a = _mm_add_epi32(a, _mm_cvtepu8_epi32(_mm_shuffle_epi32(v, _MM_SHUFFLE(0, 0, 0, 0)))); b = _mm_add_epi32(b, a);
				c = _mm_add_epi32(c, _mm_cvtepu8_epi32(_mm_shuffle_epi32(v, _MM_SHUFFLE(1, 1, 1, 1)))); d = _mm_add_epi32(d, c);
				e = _mm_add_epi32(e, _mm_cvtepu8_epi32(_mm_shuffle_epi32(v, _MM_SHUFFLE(2, 2, 2, 2)))); f = _mm_add_epi32(f, e);
				g = _mm_add_epi32(g, _mm_cvtepu8_epi32(_mm_shuffle_epi32(v, _MM_SHUFFLE(3, 3, 3, 3)))); h = _mm_add_epi32(h, g);
			}

			uint32_t sa[16], sb[16];
			_mm_storeu_si128((__m128i*)sa, a); _mm_storeu_si128((__m128i*)(sa + 4), c);
			_mm_storeu_si128((__m128i*)sb, b); _mm_storeu_si128((__m128i*)(sb + 4), d);
			_mm_storeu_si128((__m128i*)(sa + 8), e); _mm_storeu_si128((__m128i*)(sa + 12), g);
			_mm_storeu_si128((__m128i*)(sb + 8), f); _mm_storeu_si128((__m128i*)(sb + 12), h);

			// This could be vectorized, but it's only executed every 5552*16 iterations.
			uint64_t vs1 = 0;
			for (uint32_t i = 0; i < 16; i++)
				vs1 += sa[i];

			uint64_t vs2_a = 0;
			for (uint32_t i = 0; i < 16; i++)
				vs2_a += sa[i] * (uint64_t)i;
			uint64_t vs2_b = 0;
			for (uint32_t i = 0; i < 16; i++)
				vs2_b += sb[i];
			vs2_b *= 16U;
			uint64_t vs2 = vs2_b - vs2_a + s2;

			s1 = (uint32_t)(vs1 % K);
			s2 = (uint32_t)(vs2 % K);

			p += n * 16;
			len -= n * 16;
		}

		for (; len; len--)
		{
			s1 += *p++;
			s2 += s1;
		}

		return (s1 % K) | ((s2 % K) << 16);
	}
#endif

	static uint32_t fpng_adler32_scalar(const uint8_t* ptr, size_t buf_len, uint32_t adler)
	{
		uint32_t i, s1 = (uint32_t)(adler & 0xffff), s2 = (uint32_t)(adler >> 16); uint32_t block_len = (uint32_t)(buf_len % 5552);
		if (!ptr) return FPNG_ADLER32_INIT;
		while (buf_len) {
			for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
				s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;
				s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;
			}
			for (; i < block_len; ++i) s1 += *ptr++, s2 += s1;
			s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;
		}
		return (s2 << 16) + s1;
	}

	uint32_t fpng_adler32(const void* pData, size_t size, uint32_t adler)
	{
#if FPNG_X86_OR_X64_CPU && !FPNG_NO_SSE 
		if (g_cpu_info.can_use_sse41())
			return adler32_sse_16((const uint8_t*)pData, size, adler);
#endif
		return fpng_adler32_scalar((const uint8_t*)pData, size, adler);
	}

	// Ensure we've been configured for endianness correctly.
	static inline bool endian_check()
	{
		uint32_t endian_check = 0;
		WRITE_LE32(&endian_check, 0x1234ABCD);
		const uint32_t first_byte = reinterpret_cast<const uint8_t*>(&endian_check)[0];
		return first_byte == 0xCD;
	}
		
	static const uint16_t g_defl_len_sym[256] = {
	  257,258,259,260,261,262,263,264,265,265,266,266,267,267,268,268,269,269,269,269,270,270,270,270,271,271,271,271,272,272,272,272,
	  273,273,273,273,273,273,273,273,274,274,274,274,274,274,274,274,275,275,275,275,275,275,275,275,276,276,276,276,276,276,276,276,
	  277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,
	  279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,
	  281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,
	  282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,
	  283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,
	  284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,285 };

	static const uint8_t g_defl_len_extra[256] = {
	  0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
	  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
	  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0 };

	static const uint8_t g_defl_small_dist_sym[512] = {
	  0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,
	  11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
	  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,
	  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
	  14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,
	  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17 };
		
	static const uint32_t g_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

	// Huffman tables generated by fpng_test -t @filelist.txt. Total alpha files : 1440, Total opaque files : 5627.
	// Feel free to retrain the encoder on your opaque/alpha PNG files by setting FPNG_TRAIN_HUFFMAN_TABLES and running fpng_test with the -t option.
	static const uint8_t g_dyn_huff_3[] = {
	120, 1, 237, 195, 9, 148, 212, 245, 97, 0, 224, 143, 229, 198, 5, 17, 24, 102, 61, 192, 24, 17, 150, 186, 85, 116, 157, 0, 2, 213, 10, 27, 
	44, 157, 36, 198, 216, 52, 230, 168, 53, 109, 211, 198, 102, 219, 218, 218, 164, 173, 181, 66, 82, 147, 38, 77, 163, 237, 166, 166, 77, 219, 164, 105, 
	18, 237, 17, 173, 73, 166, 68, 178, 44, 197, 2, 2, 14, 43, 104, 214, 178, 139, 168, 81, 60, 118, 24, 16, 132, 21, 132, 229, 232, 239, 189, 255, 
	123, 243, 230, 237, 49, 204, 158, 44, 78, 223, 251  };
	const uint32_t DYN_HUFF_3_BITBUF = 62, DYN_HUFF_3_BITBUF_SIZE = 7;
	static const struct { uint8_t m_code_size; uint16_t m_code; } g_dyn_huff_3_codes[288] = {
	{1,0},{9,195},{8,101},{9,451},{9,35},{9,291},{9,163},{9,419},{9,99},{9,355},{9,227},{10,359},{8,229},{9,483},{9,19},{10,871},{9,275},{10,231},{9,147},{9,403},{9,83},{7,49},{9,339},{7,113},{8,21},{10,743},{10,487},{10,999},{10,23},{9,211},{9,467},{10,535},
	{11,239},{10,279},{11,1263},{10,791},{9,51},{10,151},{9,307},{9,179},{8,149},{9,435},{12,831},{10,663},{8,85},{12,2879},{10,407},{10,919},{9,115},{10,87},{10,599},{8,213},{10,343},{7,9},{11,751},{9,371},{9,243},{9,499},{10,855},{9,11},{9,267},{9,139},{12,1855},{10,215},
	{10,727},{12,3903},{10,471},{9,395},{9,75},{8,53},{11,1775},{9,331},{10,983},{12,191},{9,203},{12,2239},{7,73},{11,495},{11,1519},{11,1007},{10,55},{11,2031},{10,567},{11,31},{10,311},{12,1215},{11,1055},{12,3263},{11,543},{10,823},{11,1567},{11,287},{11,1311},{11,799},{12,703},{10,183},
	{12,2751},{10,695},{11,1823},{12,1727},{12,3775},{12,447},{11,159},{12,2495},{12,1471},{11,1183},{10,439},{12,3519},{11,671},{8,181},{12,959},{12,3007},{12,1983},{10,951},{12,4031},{12,127},{10,119},{12,2175},{11,1695},{11,415},{12,1151},{12,3199},{12,639},{10,631},{12,2687},{10,375},{12,1663},{10,887},
	{9,459},{9,43},{11,1439},{11,927},{12,3711},{10,247},{11,1951},{11,95},{12,383},{11,1119},{11,607},{12,2431},{11,1631},{12,1407},{11,351},{10,759},{10,503},{12,3455},{12,895},{8,117},{11,1375},{12,2943},{10,1015},{11,863},{12,1919},{12,3967},{11,1887},{12,255},{12,2303},{12,1279},{11,223},{11,1247},
	{12,3327},{11,735},{12,767},{11,1759},{11,479},{11,1503},{10,15},{10,527},{12,2815},{12,1791},{12,3839},{12,511},{11,991},{10,271},{10,783},{12,2559},{10,143},{11,2015},{11,63},{11,1087},{7,41},{12,1535},{9,299},{11,575},{10,655},{9,171},{11,1599},{8,245},{9,427},{8,13},{9,107},{12,3583},
	{9,363},{10,399},{12,1023},{9,235},{9,491},{9,27},{10,911},{9,283},{9,155},{9,411},{10,79},{7,105},{9,91},{8,141},{10,591},{9,347},{9,219},{10,335},{10,847},{11,319},{8,77},{10,207},{12,3071},{9,475},{8,205},{8,45},{9,59},{10,719},{9,315},{10,463},{10,975},{10,47},
	{11,1343},{10,559},{10,303},{9,187},{10,815},{10,175},{10,687},{10,431},{8,173},{7,25},{9,443},{7,89},{9,123},{9,379},{10,943},{9,251},{9,507},{10,111},{9,7},{9,263},{8,109},{10,623},{9,135},{9,391},{10,367},{9,71},{9,327},{8,237},{9,199},{9,455},{9,39},{9,295},
	{12,2047},{5,1},{0,0},{0,0},{6,17},{0,0},{0,0},{7,57},{0,0},{7,121},{0,0},{8,29},{8,157},{8,93},{8,221},{7,5},{9,167},{7,69},{8,61},{8,189},{8,125},{8,253},{8,3},{8,131},{9,423},{8,67},{9,103},{10,879},{7,37},{12,4095},{0,0},{0,0} 
	};

	static const uint8_t g_dyn_huff_4[] = {
	120, 1, 229, 196, 99, 180, 37, 103, 218, 128, 225, 251, 121, 171, 106, 243, 216, 231, 180, 109, 196, 182, 51, 51, 73, 6, 201, 216, 182, 109, 219, 182,
	17, 140, 98, 219, 102, 219, 60, 125, 172, 205, 170, 122, 159, 111, 213, 143, 179, 214, 94, 189, 58, 153, 104, 166, 103, 190, 247, 199, 117 };
	const uint32_t DYN_HUFF_4_BITBUF = 1, DYN_HUFF_4_BITBUF_SIZE = 2;
	static const struct { uint8_t m_code_size; uint16_t m_code; } g_dyn_huff_4_codes[288] = {
	{2,0},{4,2},{5,6},{6,30},{6,62},{6,1},{7,41},{7,105},{7,25},{7,89},{7,57},{7,121},{8,117},{8,245},{8,13},{8,141},{8,77},{8,205},{8,45},{8,173},{8,109},{8,237},{8,29},{8,157},{8,93},{8,221},{8,61},{9,83},{9,339},{9,211},{9,467},{9,51},
	{9,307},{9,179},{9,435},{9,115},{9,371},{9,243},{9,499},{9,11},{9,267},{9,139},{9,395},{9,75},{9,331},{9,203},{9,459},{9,43},{9,299},{10,7},{10,519},{10,263},{10,775},{10,135},{10,647},{10,391},{10,903},{10,71},{10,583},{10,327},{10,839},{10,199},{10,711},{10,455},
	{10,967},{10,39},{10,551},{10,295},{10,807},{10,167},{10,679},{10,423},{10,935},{10,103},{10,615},{11,463},{11,1487},{11,975},{10,359},{10,871},{10,231},{11,1999},{11,47},{11,1071},{11,559},{10,743},{10,487},{11,1583},{11,303},{11,1327},{11,815},{11,1839},{11,175},{11,1199},{11,687},{11,1711},
	{11,431},{11,1455},{11,943},{11,1967},{11,111},{11,1135},{11,623},{11,1647},{11,367},{11,1391},{11,879},{11,1903},{11,239},{11,1263},{11,751},{11,1775},{11,495},{11,1519},{11,1007},{11,2031},{11,31},{11,1055},{11,543},{11,1567},{11,287},{11,1311},{11,799},{11,1823},{11,159},{11,1183},{11,671},{11,1695},
	{11,415},{11,1439},{11,927},{11,1951},{11,95},{11,1119},{11,607},{11,1631},{11,351},{11,1375},{11,863},{11,1887},{11,223},{11,1247},{11,735},{11,1759},{11,479},{11,1503},{11,991},{11,2015},{11,63},{11,1087},{11,575},{11,1599},{11,319},{11,1343},{11,831},{11,1855},{11,191},{11,1215},{11,703},{11,1727},
	{11,447},{11,1471},{11,959},{11,1983},{11,127},{11,1151},{11,639},{11,1663},{11,383},{10,999},{10,23},{10,535},{10,279},{11,1407},{11,895},{11,1919},{11,255},{11,1279},{10,791},{10,151},{10,663},{10,407},{10,919},{10,87},{10,599},{10,343},{10,855},{10,215},{10,727},{10,471},{10,983},{10,55},
	{10,567},{10,311},{10,823},{10,183},{10,695},{10,439},{10,951},{10,119},{10,631},{10,375},{10,887},{10,247},{10,759},{10,503},{10,1015},{10,15},{10,527},{10,271},{10,783},{10,143},{10,655},{10,399},{9,171},{9,427},{9,107},{9,363},{9,235},{9,491},{9,27},{9,283},{9,155},{9,411},
	{9,91},{9,347},{9,219},{9,475},{9,59},{9,315},{9,187},{9,443},{8,189},{9,123},{8,125},{8,253},{8,3},{8,131},{8,67},{8,195},{8,35},{8,163},{8,99},{8,227},{8,19},{7,5},{7,69},{7,37},{7,101},{7,21},{7,85},{6,33},{6,17},{6,49},{5,22},{4,10},
	{12,2047},{0,0},{6,9},{0,0},{0,0},{0,0},{8,147},{0,0},{0,0},{7,53},{0,0},{9,379},{0,0},{9,251},{10,911},{10,79},{11,767},{10,591},{10,335},{10,847},{10,207},{10,719},{11,1791},{11,511},{9,507},{11,1535},{11,1023},{12,4095},{5,14},{0,0},{0,0},{0,0}
	};

#define PUT_BITS(bb, ll) do { uint32_t b = bb, l = ll; assert((l) >= 0 && (l) <= 16); assert((b) < (1ULL << (l))); bit_buf |= (((uint64_t)(b)) << bit_buf_size); bit_buf_size += (l); assert(bit_buf_size <= 64); } while(0)
#define PUT_BITS_CZ(bb, ll) do { uint32_t b = bb, l = ll; assert((l) >= 1 && (l) <= 16); assert((b) < (1ULL << (l))); bit_buf |= (((uint64_t)(b)) << bit_buf_size); bit_buf_size += (l); assert(bit_buf_size <= 64); } while(0)

#define PUT_BITS_FLUSH do { \
	if ((dst_ofs + 8) > dst_buf_size) \
		return 0; \
	WRITE_LE64(pDst + dst_ofs, bit_buf); \
	uint32_t bits_to_shift = bit_buf_size & ~7; \
	dst_ofs += (bits_to_shift >> 3); \
	assert(bits_to_shift < 64); \
	bit_buf = bit_buf >> bits_to_shift; \
	bit_buf_size -= bits_to_shift; \
} while(0)

#define PUT_BITS_FORCE_FLUSH do { \
	while (bit_buf_size > 0) \
	{ \
		if ((dst_ofs + 1) > dst_buf_size) \
			return 0; \
		*(uint8_t*)(pDst + dst_ofs) = (uint8_t)bit_buf; \
		dst_ofs++; \
		bit_buf >>= 8; \
		bit_buf_size -= 8; \
	} \
} while(0)

	enum
	{
		DEFL_MAX_HUFF_TABLES = 3,
		DEFL_MAX_HUFF_SYMBOLS = 288,	
		DEFL_MAX_HUFF_SYMBOLS_0 = 288,	
		DEFL_MAX_HUFF_SYMBOLS_1 = 32,
		DEFL_MAX_HUFF_SYMBOLS_2 = 19,
		DEFL_LZ_DICT_SIZE = 32768,
		DEFL_LZ_DICT_SIZE_MASK = DEFL_LZ_DICT_SIZE - 1,
		DEFL_MIN_MATCH_LEN = 3,
		DEFL_MAX_MATCH_LEN = 258
	};

#if FPNG_TRAIN_HUFFMAN_TABLES
	uint64_t g_huff_counts[HUFF_COUNTS_SIZE];
#endif

	struct defl_huff
	{
		uint16_t m_huff_count[DEFL_MAX_HUFF_TABLES][DEFL_MAX_HUFF_SYMBOLS];
		uint16_t m_huff_codes[DEFL_MAX_HUFF_TABLES][DEFL_MAX_HUFF_SYMBOLS];
		uint8_t m_huff_code_sizes[DEFL_MAX_HUFF_TABLES][DEFL_MAX_HUFF_SYMBOLS];
	};

	struct defl_sym_freq
	{
		uint16_t m_key;
		uint16_t m_sym_index;
	};

#define DEFL_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))

	static defl_sym_freq* defl_radix_sort_syms(uint32_t num_syms, defl_sym_freq* pSyms0, defl_sym_freq* pSyms1)
	{
		uint32_t total_passes = 2, pass_shift, pass, i, hist[256 * 2]; defl_sym_freq* pCur_syms = pSyms0, * pNew_syms = pSyms1; DEFL_CLEAR_OBJ(hist);
		for (i = 0; i < num_syms; i++) { uint32_t freq = pSyms0[i].m_key; hist[freq & 0xFF]++; hist[256 + ((freq >> 8) & 0xFF)]++; }
		while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256])) total_passes--;
		for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
		{
			const uint32_t* pHist = &hist[pass << 8];
			uint32_t offsets[256], cur_ofs = 0;
			for (i = 0; i < 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }
			for (i = 0; i < num_syms; i++) pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
			{ defl_sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t; }
		}
		return pCur_syms;
	}

	// defl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
	static void defl_calculate_minimum_redundancy(defl_sym_freq* A, int n)
	{
		int root, leaf, next, avbl, used, dpth;
		if (n == 0) return; else if (n == 1) { A[0].m_key = 1; return; }
		A[0].m_key += A[1].m_key; root = 0; leaf = 2;
		for (next = 1; next < n - 1; next++)
		{
			if (leaf >= n || A[root].m_key < A[leaf].m_key) { A[next].m_key = A[root].m_key; A[root++].m_key = (uint16_t)next; }
			else A[next].m_key = A[leaf++].m_key;
			if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key)) { A[next].m_key = (uint16_t)(A[next].m_key + A[root].m_key); A[root++].m_key = (uint16_t)next; }
			else A[next].m_key = (uint16_t)(A[next].m_key + A[leaf++].m_key);
		}
		A[n - 2].m_key = 0; for (next = n - 3; next >= 0; next--) A[next].m_key = A[A[next].m_key].m_key + 1;
		avbl = 1; used = dpth = 0; root = n - 2; next = n - 1;
		while (avbl > 0)
		{
			while (root >= 0 && (int)A[root].m_key == dpth) { used++; root--; }
			while (avbl > used) { A[next--].m_key = (uint16_t)(dpth); avbl--; }
			avbl = 2 * used; dpth++; used = 0;
		}
	}

	// Limits canonical Huffman code table's max code size.
	enum { DEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };
	static void defl_huffman_enforce_max_code_size(int* pNum_codes, int code_list_len, int max_code_size)
	{
		int i; uint32_t total = 0; if (code_list_len <= 1) return;
		for (i = max_code_size + 1; i <= DEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];
		for (i = max_code_size; i > 0; i--) total += (((uint32_t)pNum_codes[i]) << (max_code_size - i));
		while (total != (1UL << max_code_size))
		{
			pNum_codes[max_code_size]--;
			for (i = max_code_size - 1; i > 0; i--) if (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; break; }
			total--;
		}
	}

	static void defl_optimize_huffman_table(defl_huff* d, int table_num, int table_len, int code_size_limit, int static_table)
	{
		int i, j, l, num_codes[1 + DEFL_MAX_SUPPORTED_HUFF_CODESIZE]; uint32_t next_code[DEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1]; DEFL_CLEAR_OBJ(num_codes);
		if (static_table)
		{
			for (i = 0; i < table_len; i++) num_codes[d->m_huff_code_sizes[table_num][i]]++;
		}
		else
		{
			defl_sym_freq syms0[DEFL_MAX_HUFF_SYMBOLS], syms1[DEFL_MAX_HUFF_SYMBOLS], * pSyms;
			int num_used_syms = 0;
			const uint16_t* pSym_count = &d->m_huff_count[table_num][0];
			for (i = 0; i < table_len; i++) if (pSym_count[i]) { syms0[num_used_syms].m_key = (uint16_t)pSym_count[i]; syms0[num_used_syms++].m_sym_index = (uint16_t)i; }

			pSyms = defl_radix_sort_syms(num_used_syms, syms0, syms1); defl_calculate_minimum_redundancy(pSyms, num_used_syms);

			for (i = 0; i < num_used_syms; i++) num_codes[pSyms[i].m_key]++;

			defl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);

			DEFL_CLEAR_OBJ(d->m_huff_code_sizes[table_num]); DEFL_CLEAR_OBJ(d->m_huff_codes[table_num]);
			for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
				for (l = num_codes[i]; l > 0; l--) d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (uint8_t)(i);
		}

		next_code[1] = 0; for (j = 0, i = 2; i <= code_size_limit; i++) next_code[i] = j = ((j + num_codes[i - 1]) << 1);

		for (i = 0; i < table_len; i++)
		{
			uint32_t rev_code = 0, code, code_size; if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;
			code = next_code[code_size]++; for (l = code_size; l > 0; l--, code >>= 1) rev_code = (rev_code << 1) | (code & 1);
			d->m_huff_codes[table_num][i] = (uint16_t)rev_code;
		}
	}

#define DEFL_RLE_PREV_CODE_SIZE() { if (rle_repeat_count) { \
  if (rle_repeat_count < 3) { \
    d->m_huff_count[2][prev_code_size] = (uint16_t)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
    while (rle_repeat_count--) packed_code_sizes[num_packed_code_sizes++] = prev_code_size; \
  } else { \
    d->m_huff_count[2][16] = (uint16_t)(d->m_huff_count[2][16] + 1); packed_code_sizes[num_packed_code_sizes++] = 16; packed_code_sizes[num_packed_code_sizes++] = (uint8_t)(rle_repeat_count - 3); \
} rle_repeat_count = 0; } }

#define DEFL_RLE_ZERO_CODE_SIZE() { if (rle_z_count) { \
  if (rle_z_count < 3) { \
    d->m_huff_count[2][0] = (uint16_t)(d->m_huff_count[2][0] + rle_z_count); while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \
  } else if (rle_z_count <= 10) { \
    d->m_huff_count[2][17] = (uint16_t)(d->m_huff_count[2][17] + 1); packed_code_sizes[num_packed_code_sizes++] = 17; packed_code_sizes[num_packed_code_sizes++] = (uint8_t)(rle_z_count - 3); \
  } else { \
    d->m_huff_count[2][18] = (uint16_t)(d->m_huff_count[2][18] + 1); packed_code_sizes[num_packed_code_sizes++] = 18; packed_code_sizes[num_packed_code_sizes++] = (uint8_t)(rle_z_count - 11); \
} rle_z_count = 0; } }

	static uint8_t g_defl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

#define DEFL_DYN_PUT_BITS(bb, ll) \
do { \
	uint32_t b = (bb), l = (ll); \
	assert((l) >= 1 && (l) <= 16); assert((b) < (1ULL << (l))); \
	bit_buf |= (((uint64_t)(b)) << bit_buf_size); bit_buf_size += (l); assert(bit_buf_size <= 64); \
	while (bit_buf_size >= 8) \
	{ \
		if ((dst_ofs + 1) > dst_buf_size) \
			return false; \
		*(uint8_t*)(pDst + dst_ofs) = (uint8_t)bit_buf; \
		dst_ofs++; \
		bit_buf >>= 8; \
		bit_buf_size -= 8; \
	} \
} while(0)

	static bool defl_start_dynamic_block(defl_huff* d, uint8_t* pDst, uint32_t& dst_ofs, uint32_t dst_buf_size, uint64_t& bit_buf, int& bit_buf_size)
	{
		int num_lit_codes, num_dist_codes, num_bit_lengths; uint32_t i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
		uint8_t code_sizes_to_pack[DEFL_MAX_HUFF_SYMBOLS_0 + DEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[DEFL_MAX_HUFF_SYMBOLS_0 + DEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;

#if FPNG_TRAIN_HUFFMAN_TABLES
		assert(HUFF_COUNTS_SIZE == DEFL_MAX_HUFF_SYMBOLS_0);
		for (uint32_t i = 0; i < DEFL_MAX_HUFF_SYMBOLS_0; i++)
			g_huff_counts[i] += d->m_huff_count[0][i];
#endif

		d->m_huff_count[0][256] = 1;

		defl_optimize_huffman_table(d, 0, DEFL_MAX_HUFF_SYMBOLS_0, 12, FPNG_FALSE);
		defl_optimize_huffman_table(d, 1, DEFL_MAX_HUFF_SYMBOLS_1, 12, FPNG_FALSE);

		for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--) if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
		for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--) if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;

		memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
		memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
		total_code_sizes_to_pack = num_lit_codes + num_dist_codes; num_packed_code_sizes = 0; rle_z_count = 0; rle_repeat_count = 0;

		memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * DEFL_MAX_HUFF_SYMBOLS_2);
		for (i = 0; i < total_code_sizes_to_pack; i++)
		{
			uint8_t code_size = code_sizes_to_pack[i];
			if (!code_size)
			{
				DEFL_RLE_PREV_CODE_SIZE();
				if (++rle_z_count == 138) { DEFL_RLE_ZERO_CODE_SIZE(); }
			}
			else
			{
				DEFL_RLE_ZERO_CODE_SIZE();
				if (code_size != prev_code_size)
				{
					DEFL_RLE_PREV_CODE_SIZE();
					d->m_huff_count[2][code_size] = (uint16_t)(d->m_huff_count[2][code_size] + 1); packed_code_sizes[num_packed_code_sizes++] = code_size;
				}
				else if (++rle_repeat_count == 6)
				{
					DEFL_RLE_PREV_CODE_SIZE();
				}
			}
			prev_code_size = code_size;
		}
		if (rle_repeat_count) { DEFL_RLE_PREV_CODE_SIZE(); }
		else { DEFL_RLE_ZERO_CODE_SIZE(); }

		defl_optimize_huffman_table(d, 2, DEFL_MAX_HUFF_SYMBOLS_2, 7, FPNG_FALSE);

		// max of 2+5+5+4+18*3+(288+32)*7=2310 bits
		DEFL_DYN_PUT_BITS(2, 2);

		DEFL_DYN_PUT_BITS(num_lit_codes - 257, 5);
		DEFL_DYN_PUT_BITS(num_dist_codes - 1, 5);

		for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--) if (d->m_huff_code_sizes[2][g_defl_packed_code_size_syms_swizzle[num_bit_lengths]]) break;
		num_bit_lengths = maximum<int>(4, (num_bit_lengths + 1)); DEFL_DYN_PUT_BITS(num_bit_lengths - 4, 4);
		for (i = 0; (int)i < num_bit_lengths; i++) DEFL_DYN_PUT_BITS(d->m_huff_code_sizes[2][g_defl_packed_code_size_syms_swizzle[i]], 3);

		for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes; )
		{
			uint32_t code = packed_code_sizes[packed_code_sizes_index++]; assert(code < DEFL_MAX_HUFF_SYMBOLS_2);
			DEFL_DYN_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
			if (code >= 16) DEFL_DYN_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
		}

		return true;
	}

	static uint32_t write_raw_block(const uint8_t* pSrc, uint32_t src_len, uint8_t* pDst, uint32_t dst_buf_size)
	{
		if (dst_buf_size < 2)
			return 0;

		pDst[0] = 0x78;
		pDst[1] = 0x01;

		uint32_t dst_ofs = 2;

		uint32_t src_ofs = 0;
		while (src_ofs < src_len)
		{
			const uint32_t src_remaining = src_len - src_ofs;
			const uint32_t block_size = minimum<uint32_t>(UINT16_MAX, src_remaining);
			const bool final_block = (block_size == src_remaining);

			if ((dst_ofs + 5 + block_size) > dst_buf_size)
				return 0;

			pDst[dst_ofs + 0] = final_block ? 1 : 0;

			pDst[dst_ofs + 1] = block_size & 0xFF;
			pDst[dst_ofs + 2] = (block_size >> 8) & 0xFF;

			pDst[dst_ofs + 3] = (~block_size) & 0xFF;
			pDst[dst_ofs + 4] = ((~block_size) >> 8) & 0xFF;

			memcpy(pDst + dst_ofs + 5, pSrc + src_ofs, block_size);

			src_ofs += block_size;
			dst_ofs += 5 + block_size;
		}

		uint32_t src_adler32 = fpng_adler32(pSrc, src_len, FPNG_ADLER32_INIT);

		for (uint32_t i = 0; i < 4; i++)
		{
			if (dst_ofs + 1 > dst_buf_size)
				return 0;

			pDst[dst_ofs] = (uint8_t)(src_adler32 >> 24);
			dst_ofs++;

			src_adler32 <<= 8;
		}

		return dst_ofs;
	}

	static void adjust_freq32(uint32_t num_freq, uint32_t* pFreq, uint16_t* pFreq16)
	{
		uint32_t total_freq = 0;
		for (uint32_t i = 0; i < num_freq; i++)
			total_freq += pFreq[i];

		if (!total_freq)
		{
			memset(pFreq16, 0, num_freq * sizeof(uint16_t));
			return;
		}

		uint32_t total_freq16 = 0;
		for (uint32_t i = 0; i < num_freq; i++)
		{
			uint64_t f = pFreq[i];
			if (!f)
			{
				pFreq16[i] = 0;
				continue;
			}

			pFreq16[i] = (uint16_t)maximum<uint32_t>(1, (uint32_t)((f * UINT16_MAX) / total_freq));

			total_freq16 += pFreq16[i];
		}

		while (total_freq16 > UINT16_MAX)
		{
			total_freq16 = 0;
			for (uint32_t i = 0; i < num_freq; i++)
			{
				if (pFreq[i])
				{
					pFreq[i] = maximum<uint32_t>(1, pFreq[i] >> 1);
					total_freq16 += pFreq[i];
				}
			}
		}
	}

#if FPNG_TRAIN_HUFFMAN_TABLES
	bool create_dynamic_block_prefix(uint64_t* pFreq, uint32_t num_chans, std::vector<uint8_t>& prefix, uint64_t& bit_buf, int &bit_buf_size, uint32_t* pCodes, uint8_t* pCodesizes)
	{
		assert((num_chans == 3) || (num_chans == 4));
		assert(HUFF_COUNTS_SIZE == DEFL_MAX_HUFF_SYMBOLS_0); // must be equal
				
		defl_huff dh;
		memset(&dh, 0, sizeof(dh));

		uint32_t lit_freq[DEFL_MAX_HUFF_SYMBOLS_0];
		
		uint32_t shift_len = 0;
		for (; ; )
		{
			uint32_t i;
			for (i = 0; i < DEFL_MAX_HUFF_SYMBOLS_0; i++)
			{
				uint64_t f = pFreq[i];
				if (f)
					f = maximum<uint64_t>(1U, f >> shift_len);

				if (f > UINT32_MAX)
					break;

				lit_freq[i] = (uint32_t)pFreq[i];
			}

			if (i == DEFL_MAX_HUFF_SYMBOLS_0)
				break;
			
			shift_len++;
		}
				
		// Ensure all valid Deflate literal/EOB/length syms are non-zero, so anything can be coded.
		for (uint32_t i = 0; i <= 256; i++)
		{
			if (!lit_freq[i])
				lit_freq[i] = 1;
		}

		for (uint32_t len = num_chans; len <= DEFL_MAX_MATCH_LEN; len += num_chans)
		{
			uint32_t sym = g_defl_len_sym[len - 3];
			if (!lit_freq[sym])
				lit_freq[sym] = 1;
		}

		adjust_freq32(DEFL_MAX_HUFF_SYMBOLS_0, lit_freq, &dh.m_huff_count[0][0]);
		
		const uint32_t dist_sym = g_defl_small_dist_sym[num_chans - 1];
		dh.m_huff_count[1][dist_sym] = 1;
		dh.m_huff_count[1][dist_sym + 1] = 1; // to workaround a bug in wuffs decoder
			
		prefix.resize(4096);
		uint8_t* pDst = prefix.data();
		uint32_t dst_buf_size = (uint32_t)prefix.size();

		uint32_t dst_ofs = 0;

		// zlib header
		PUT_BITS(0x78, 8);
		PUT_BITS(0x01, 8);

		// write BFINAL bit
		PUT_BITS(1, 1);
				
		if (!defl_start_dynamic_block(&dh, pDst, dst_ofs, dst_buf_size, bit_buf, bit_buf_size))
			return false;

		prefix.resize(dst_ofs);

		for (uint32_t i = 0; i < DEFL_MAX_HUFF_SYMBOLS_0; i++)
		{
			pCodes[i] = dh.m_huff_codes[0][i];
			pCodesizes[i] = dh.m_huff_code_sizes[0][i];
		}

		return true;
	}
#endif

	static uint32_t pixel_deflate_dyn_3_rle(
		const uint8_t* pImg, uint32_t w, uint32_t h,
		uint8_t* pDst, uint32_t dst_buf_size)
	{
		const uint32_t bpl = 1 + w * 3;

		uint64_t bit_buf = 0;
		int bit_buf_size = 0;

		uint32_t dst_ofs = 0;

		// zlib header
		PUT_BITS(0x78, 8);
		PUT_BITS(0x01, 8);

		// write BFINAL bit
		PUT_BITS(1, 1);

		std::vector<uint32_t> codes((w + 1) * h);
		uint32_t* pDst_codes = codes.data();

		uint32_t lit_freq[DEFL_MAX_HUFF_SYMBOLS_0];
		memset(lit_freq, 0, sizeof(lit_freq));
		
		const uint8_t* pSrc = pImg;
		uint32_t src_ofs = 0;

		uint32_t src_adler32 = fpng_adler32(pImg, bpl * h, FPNG_ADLER32_INIT);

		const uint32_t dist_sym = g_defl_small_dist_sym[3 - 1];
				
		for (uint32_t y = 0; y < h; y++)
		{
			const uint32_t end_src_ofs = src_ofs + bpl;

			const uint32_t filter_lit = pSrc[src_ofs++];
			*pDst_codes++ = 1 | (filter_lit << 8);
			lit_freq[filter_lit]++;

			uint32_t prev_lits;

			{
				uint32_t lits = READ_RGB_PIXEL(pSrc + src_ofs);

				*pDst_codes++ = lits << 8;

				lit_freq[lits & 0xFF]++;
				lit_freq[(lits >> 8) & 0xFF]++;
				lit_freq[lits >> 16]++;

				src_ofs += 3;

				prev_lits = lits;
			}

			while (src_ofs < end_src_ofs)
			{
				uint32_t lits = READ_RGB_PIXEL(pSrc + src_ofs);

				if (lits == prev_lits)
				{
					uint32_t match_len = 3;
					uint32_t max_match_len = minimum<int>(255, (int)(end_src_ofs - src_ofs));

					while (match_len < max_match_len)
					{
						if (READ_RGB_PIXEL(pSrc + src_ofs + match_len) != lits)
							break;
						match_len += 3;
					}
										
					*pDst_codes++ = match_len - 1;

					uint32_t adj_match_len = match_len - 3;

					lit_freq[g_defl_len_sym[adj_match_len]]++;
					
					src_ofs += match_len;
				}
				else
				{
					*pDst_codes++ = lits << 8;

					lit_freq[lits & 0xFF]++;
					lit_freq[(lits >> 8) & 0xFF]++;
					lit_freq[lits >> 16]++;

					prev_lits = lits;

					src_ofs += 3;
				}

			} // while (src_ofs < end_src_ofs)

		} // y

		assert(src_ofs == h * bpl);
		const uint32_t total_codes = (uint32_t)(pDst_codes - codes.data());
		assert(total_codes <= codes.size());
								
		defl_huff dh;
		
		lit_freq[256] = 1;

		adjust_freq32(DEFL_MAX_HUFF_SYMBOLS_0, lit_freq, &dh.m_huff_count[0][0]);

		memset(&dh.m_huff_count[1][0], 0, sizeof(dh.m_huff_count[1][0]) * DEFL_MAX_HUFF_SYMBOLS_1);
		dh.m_huff_count[1][dist_sym] = 1;
		dh.m_huff_count[1][dist_sym + 1] = 1; // to workaround a bug in wuffs decoder

		if (!defl_start_dynamic_block(&dh, pDst, dst_ofs, dst_buf_size, bit_buf, bit_buf_size))
			return 0;

		assert(bit_buf_size <= 7);
		assert(dh.m_huff_codes[1][dist_sym] == 0 && dh.m_huff_code_sizes[1][dist_sym] == 1);
				
		for (uint32_t i = 0; i < total_codes; i++)
		{
			uint32_t c = codes[i];

			uint32_t c_type = c & 0xFF;
			if (c_type == 0)
			{
				uint32_t lits = c >> 8;

				PUT_BITS_CZ(dh.m_huff_codes[0][lits & 0xFF], dh.m_huff_code_sizes[0][lits & 0xFF]);
				lits >>= 8;

				PUT_BITS_CZ(dh.m_huff_codes[0][lits & 0xFF], dh.m_huff_code_sizes[0][lits & 0xFF]);
				lits >>= 8;

				PUT_BITS_CZ(dh.m_huff_codes[0][lits], dh.m_huff_code_sizes[0][lits]);
			}
			else if (c_type == 1)
			{
				uint32_t lit = c >> 8;
				PUT_BITS_CZ(dh.m_huff_codes[0][lit], dh.m_huff_code_sizes[0][lit]);
			}
			else
			{
				uint32_t match_len = c_type + 1;

				uint32_t adj_match_len = match_len - 3;
				
				PUT_BITS_CZ(dh.m_huff_codes[0][g_defl_len_sym[adj_match_len]], dh.m_huff_code_sizes[0][g_defl_len_sym[adj_match_len]]);
				PUT_BITS(adj_match_len & g_bitmasks[g_defl_len_extra[adj_match_len]], g_defl_len_extra[adj_match_len] + 1); // up to 6 bits, +1 for the match distance Huff code which is always 0

				// no need to write the distance code, it's always 0
				//PUT_BITS_CZ(dh.m_huff_codes[1][dist_sym], dh.m_huff_code_sizes[1][dist_sym]);
			}

			// up to 55 bits
			PUT_BITS_FLUSH;
		}

		PUT_BITS_CZ(dh.m_huff_codes[0][256], dh.m_huff_code_sizes[0][256]);

		PUT_BITS_FORCE_FLUSH;

		// Write zlib adler32
		for (uint32_t i = 0; i < 4; i++)
		{
			if ((dst_ofs + 1) > dst_buf_size)
				return 0;
			*(uint8_t*)(pDst + dst_ofs) = (uint8_t)(src_adler32 >> 24);
			dst_ofs++;

			src_adler32 <<= 8;
		}

		return dst_ofs;
	}

	static uint32_t pixel_deflate_dyn_3_rle_one_pass(
		const uint8_t* pImg, uint32_t w, uint32_t h,
		uint8_t* pDst, uint32_t dst_buf_size)
	{
		const uint32_t bpl = 1 + w * 3;

		if (dst_buf_size < sizeof(g_dyn_huff_3))
			return false;
		memcpy(pDst, g_dyn_huff_3, sizeof(g_dyn_huff_3));
		uint32_t dst_ofs = sizeof(g_dyn_huff_3);

		uint64_t bit_buf = DYN_HUFF_3_BITBUF;
		int bit_buf_size = DYN_HUFF_3_BITBUF_SIZE;

		const uint8_t* pSrc = pImg;
		uint32_t src_ofs = 0;

		uint32_t src_adler32 = fpng_adler32(pImg, bpl * h, FPNG_ADLER32_INIT);

		for (uint32_t y = 0; y < h; y++)
		{
			const uint32_t end_src_ofs = src_ofs + bpl;

			const uint32_t filter_lit = pSrc[src_ofs++];
			PUT_BITS_CZ(g_dyn_huff_3_codes[filter_lit].m_code, g_dyn_huff_3_codes[filter_lit].m_code_size);

			uint32_t prev_lits;

			{
				uint32_t lits = READ_RGB_PIXEL(pSrc + src_ofs);

				PUT_BITS_CZ(g_dyn_huff_3_codes[lits & 0xFF].m_code, g_dyn_huff_3_codes[lits & 0xFF].m_code_size);
				PUT_BITS_CZ(g_dyn_huff_3_codes[(lits >> 8) & 0xFF].m_code, g_dyn_huff_3_codes[(lits >> 8) & 0xFF].m_code_size);
				PUT_BITS_CZ(g_dyn_huff_3_codes[(lits >> 16)].m_code, g_dyn_huff_3_codes[(lits >> 16)].m_code_size);

				src_ofs += 3;
			
				prev_lits = lits;
			}

			PUT_BITS_FLUSH;

			while (src_ofs < end_src_ofs)
			{
				uint32_t lits = READ_RGB_PIXEL(pSrc + src_ofs);

				if (lits == prev_lits)
				{
					uint32_t match_len = 3;
					uint32_t max_match_len = minimum<int>(255, (int)(end_src_ofs - src_ofs));

					while (match_len < max_match_len)
					{
						if (READ_RGB_PIXEL(pSrc + src_ofs + match_len) != lits)
							break;
						match_len += 3;
					}
										
					uint32_t adj_match_len = match_len - 3;

					PUT_BITS_CZ(g_dyn_huff_3_codes[g_defl_len_sym[adj_match_len]].m_code, g_dyn_huff_3_codes[g_defl_len_sym[adj_match_len]].m_code_size);
					PUT_BITS(adj_match_len & g_bitmasks[g_defl_len_extra[adj_match_len]], g_defl_len_extra[adj_match_len] + 1); // up to 6 bits, +1 for the match distance Huff code which is always 0

					src_ofs += match_len;
				}
				else
				{
					PUT_BITS_CZ(g_dyn_huff_3_codes[lits & 0xFF].m_code, g_dyn_huff_3_codes[lits & 0xFF].m_code_size);
					PUT_BITS_CZ(g_dyn_huff_3_codes[(lits >> 8) & 0xFF].m_code, g_dyn_huff_3_codes[(lits >> 8) & 0xFF].m_code_size);
					PUT_BITS_CZ(g_dyn_huff_3_codes[(lits >> 16)].m_code, g_dyn_huff_3_codes[(lits >> 16)].m_code_size);
					
					prev_lits = lits;

					src_ofs += 3;
				}

				PUT_BITS_FLUSH;

			} // while (src_ofs < end_src_ofs)

		} // y

		assert(src_ofs == h * bpl);
		
		assert(bit_buf_size <= 7);

		PUT_BITS_CZ(g_dyn_huff_3_codes[256].m_code, g_dyn_huff_3_codes[256].m_code_size);

		PUT_BITS_FORCE_FLUSH;

		// Write zlib adler32
		for (uint32_t i = 0; i < 4; i++)
		{
			if ((dst_ofs + 1) > dst_buf_size)
				return 0;
			*(uint8_t*)(pDst + dst_ofs) = (uint8_t)(src_adler32 >> 24);
			dst_ofs++;

			src_adler32 <<= 8;
		}

		return dst_ofs;
	}

	static uint32_t pixel_deflate_dyn_4_rle(
		const uint8_t* pImg, uint32_t w, uint32_t h,
		uint8_t* pDst, uint32_t dst_buf_size)
	{
		const uint32_t bpl = 1 + w * 4;

		uint64_t bit_buf = 0;
		int bit_buf_size = 0;

		uint32_t dst_ofs = 0;

		// zlib header
		PUT_BITS(0x78, 8);
		PUT_BITS(0x01, 8);

		// write BFINAL bit
		PUT_BITS(1, 1);

		std::vector<uint64_t> codes;
		codes.resize((w + 1) * h);
		uint64_t* pDst_codes = codes.data();

		uint32_t lit_freq[DEFL_MAX_HUFF_SYMBOLS_0];
		memset(lit_freq, 0, sizeof(lit_freq));

		const uint8_t* pSrc = pImg;
		uint32_t src_ofs = 0;

		uint32_t src_adler32 = fpng_adler32(pImg, bpl * h, FPNG_ADLER32_INIT);

		const uint32_t dist_sym = g_defl_small_dist_sym[4 - 1];

		for (uint32_t y = 0; y < h; y++)
		{
			const uint32_t end_src_ofs = src_ofs + bpl;

			const uint32_t filter_lit = pSrc[src_ofs++];
			*pDst_codes++ = 1 | (filter_lit << 8);
			lit_freq[filter_lit]++;

			uint32_t prev_lits;
			{
				uint32_t lits = READ_LE32(pSrc + src_ofs);

				*pDst_codes++ = (uint64_t)lits << 8;

				lit_freq[lits & 0xFF]++;
				lit_freq[(lits >> 8) & 0xFF]++;
				lit_freq[(lits >> 16) & 0xFF]++;
				lit_freq[lits >> 24]++;

				src_ofs += 4;
				
				prev_lits = lits;
			}

			while (src_ofs < end_src_ofs)
			{
				uint32_t lits = READ_LE32(pSrc + src_ofs);

				if (lits == prev_lits)
				{
					uint32_t match_len = 4;
					uint32_t max_match_len = minimum<int>(252, (int)(end_src_ofs - src_ofs));

					while (match_len < max_match_len)
					{
						if (READ_LE32(pSrc + src_ofs + match_len) != lits)
							break;
						match_len += 4;
					}
										
					*pDst_codes++ = match_len - 1;

					uint32_t adj_match_len = match_len - 3;

					lit_freq[g_defl_len_sym[adj_match_len]]++;
					
					src_ofs += match_len;
				}
				else
				{
					*pDst_codes++ = (uint64_t)lits << 8;

					lit_freq[lits & 0xFF]++;
					lit_freq[(lits >> 8) & 0xFF]++;
					lit_freq[(lits >> 16) & 0xFF]++;
					lit_freq[lits >> 24]++;
					
					prev_lits = lits;

					src_ofs += 4;
				}

			} // while (src_ofs < end_src_ofs)

		} // y

		assert(src_ofs == h * bpl);
		const uint32_t total_codes = (uint32_t)(pDst_codes - codes.data());
		assert(total_codes <= codes.size());
						
		defl_huff dh;
		
		lit_freq[256] = 1;

		adjust_freq32(DEFL_MAX_HUFF_SYMBOLS_0, lit_freq, &dh.m_huff_count[0][0]);
		
		memset(&dh.m_huff_count[1][0], 0, sizeof(dh.m_huff_count[1][0]) * DEFL_MAX_HUFF_SYMBOLS_1);
		dh.m_huff_count[1][dist_sym] = 1;
		dh.m_huff_count[1][dist_sym + 1] = 1; // to workaround a bug in wuffs decoder

		if (!defl_start_dynamic_block(&dh, pDst, dst_ofs, dst_buf_size, bit_buf, bit_buf_size))
			return 0;

		assert(bit_buf_size <= 7);
		assert(dh.m_huff_codes[1][dist_sym] == 0 && dh.m_huff_code_sizes[1][dist_sym] == 1);

		for (uint32_t i = 0; i < total_codes; i++)
		{
			uint64_t c = codes[i];

			uint32_t c_type = (uint32_t)(c & 0xFF);
			if (c_type == 0)
			{
				uint32_t lits = (uint32_t)(c >> 8);

				PUT_BITS_CZ(dh.m_huff_codes[0][lits & 0xFF], dh.m_huff_code_sizes[0][lits & 0xFF]);
				lits >>= 8;

				PUT_BITS_CZ(dh.m_huff_codes[0][lits & 0xFF], dh.m_huff_code_sizes[0][lits & 0xFF]);
				lits >>= 8;

				PUT_BITS_CZ(dh.m_huff_codes[0][lits & 0xFF], dh.m_huff_code_sizes[0][lits & 0xFF]);
				lits >>= 8;

				if (bit_buf_size >= 49)
				{
					PUT_BITS_FLUSH;
				}

				PUT_BITS_CZ(dh.m_huff_codes[0][lits], dh.m_huff_code_sizes[0][lits]);
			}
			else if (c_type == 1)
			{
				uint32_t lit = (uint32_t)(c >> 8);
				PUT_BITS_CZ(dh.m_huff_codes[0][lit], dh.m_huff_code_sizes[0][lit]);
			}
			else
			{
				uint32_t match_len = c_type + 1;

				uint32_t adj_match_len = match_len - 3;
				
				PUT_BITS_CZ(dh.m_huff_codes[0][g_defl_len_sym[adj_match_len]], dh.m_huff_code_sizes[0][g_defl_len_sym[adj_match_len]]);
				PUT_BITS(adj_match_len & g_bitmasks[g_defl_len_extra[adj_match_len]], g_defl_len_extra[adj_match_len] + 1); // up to 6 bits, +1 for the match distance Huff code which is always 0

				// no need to write the distance code, it's always 0
			}

			// up to 55 bits
			PUT_BITS_FLUSH;
		}

		PUT_BITS_CZ(dh.m_huff_codes[0][256], dh.m_huff_code_sizes[0][256]);

		PUT_BITS_FORCE_FLUSH;

		// Write zlib adler32
		for (uint32_t i = 0; i < 4; i++)
		{
			if ((dst_ofs + 1) > dst_buf_size)
				return 0;
			*(uint8_t*)(pDst + dst_ofs) = (uint8_t)(src_adler32 >> 24);
			dst_ofs++;

			src_adler32 <<= 8;
		}

		return dst_ofs;
	}

	static uint32_t pixel_deflate_dyn_4_rle_one_pass(
		const uint8_t* pImg, uint32_t w, uint32_t h,
		uint8_t* pDst, uint32_t dst_buf_size)
	{
		const uint32_t bpl = 1 + w * 4;

		if (dst_buf_size < sizeof(g_dyn_huff_4))
			return false;
		memcpy(pDst, g_dyn_huff_4, sizeof(g_dyn_huff_4));
		uint32_t dst_ofs = sizeof(g_dyn_huff_4);

		uint64_t bit_buf = DYN_HUFF_4_BITBUF;
		int bit_buf_size = DYN_HUFF_4_BITBUF_SIZE;

		const uint8_t* pSrc = pImg;
		uint32_t src_ofs = 0;

		uint32_t src_adler32 = fpng_adler32(pImg, bpl * h, FPNG_ADLER32_INIT);

		for (uint32_t y = 0; y < h; y++)
		{
			const uint32_t end_src_ofs = src_ofs + bpl;

			const uint32_t filter_lit = pSrc[src_ofs++];
			PUT_BITS_CZ(g_dyn_huff_4_codes[filter_lit].m_code, g_dyn_huff_4_codes[filter_lit].m_code_size);

			PUT_BITS_FLUSH;

			uint32_t prev_lits;
			{
				uint32_t lits = READ_LE32(pSrc + src_ofs);

				PUT_BITS_CZ(g_dyn_huff_4_codes[lits & 0xFF].m_code, g_dyn_huff_4_codes[lits & 0xFF].m_code_size);
				PUT_BITS_CZ(g_dyn_huff_4_codes[(lits >> 8) & 0xFF].m_code, g_dyn_huff_4_codes[(lits >> 8) & 0xFF].m_code_size);
				PUT_BITS_CZ(g_dyn_huff_4_codes[(lits >> 16) & 0xFF].m_code, g_dyn_huff_4_codes[(lits >> 16) & 0xFF].m_code_size);

				if (bit_buf_size >= 49)
				{
					PUT_BITS_FLUSH;
				}
				
				PUT_BITS_CZ(g_dyn_huff_4_codes[(lits >> 24)].m_code, g_dyn_huff_4_codes[(lits >> 24)].m_code_size);

				src_ofs += 4;
				
				prev_lits = lits;
			}

			PUT_BITS_FLUSH;

			while (src_ofs < end_src_ofs)
			{
				uint32_t lits = READ_LE32(pSrc + src_ofs);
								
				if (lits == prev_lits)
				{
					uint32_t match_len = 4;
					uint32_t max_match_len = minimum<int>(252, (int)(end_src_ofs - src_ofs));

					while (match_len < max_match_len)
					{
						if (READ_LE32(pSrc + src_ofs + match_len) != lits)
							break;
						match_len += 4;
					}

					uint32_t adj_match_len = match_len - 3;

					const uint32_t match_code_bits = g_dyn_huff_4_codes[g_defl_len_sym[adj_match_len]].m_code_size;
					const uint32_t len_extra_bits = g_defl_len_extra[adj_match_len];

					if (match_len == 4)
					{
						// This check is optional - see if just encoding 4 literals would be cheaper than using a short match.
						uint32_t lit_bits = g_dyn_huff_4_codes[lits & 0xFF].m_code_size + g_dyn_huff_4_codes[(lits >> 8) & 0xFF].m_code_size + 
							g_dyn_huff_4_codes[(lits >> 16) & 0xFF].m_code_size + g_dyn_huff_4_codes[(lits >> 24)].m_code_size;
						
						if ((match_code_bits + len_extra_bits + 1) > lit_bits)
							goto do_literals;
					}

					PUT_BITS_CZ(g_dyn_huff_4_codes[g_defl_len_sym[adj_match_len]].m_code, match_code_bits);
					PUT_BITS(adj_match_len & g_bitmasks[g_defl_len_extra[adj_match_len]], len_extra_bits + 1); // up to 6 bits, +1 for the match distance Huff code which is always 0

					src_ofs += match_len;
				}
				else
				{
do_literals:
					PUT_BITS_CZ(g_dyn_huff_4_codes[lits & 0xFF].m_code, g_dyn_huff_4_codes[lits & 0xFF].m_code_size);
					PUT_BITS_CZ(g_dyn_huff_4_codes[(lits >> 8) & 0xFF].m_code, g_dyn_huff_4_codes[(lits >> 8) & 0xFF].m_code_size);
					PUT_BITS_CZ(g_dyn_huff_4_codes[(lits >> 16) & 0xFF].m_code, g_dyn_huff_4_codes[(lits >> 16) & 0xFF].m_code_size);

					if (bit_buf_size >= 49)
					{
						PUT_BITS_FLUSH;
					}

					PUT_BITS_CZ(g_dyn_huff_4_codes[(lits >> 24)].m_code, g_dyn_huff_4_codes[(lits >> 24)].m_code_size);

					src_ofs += 4;
					
					prev_lits = lits;
				}

				PUT_BITS_FLUSH;

			} // while (src_ofs < end_src_ofs)

		} // y

		assert(src_ofs == h * bpl);

		assert(bit_buf_size <= 7);

		PUT_BITS_CZ(g_dyn_huff_4_codes[256].m_code, g_dyn_huff_4_codes[256].m_code_size);

		PUT_BITS_FORCE_FLUSH;

		// Write zlib adler32
		for (uint32_t i = 0; i < 4; i++)
		{
			if ((dst_ofs + 1) > dst_buf_size)
				return 0;
			*(uint8_t*)(pDst + dst_ofs) = (uint8_t)(src_adler32 >> 24);
			dst_ofs++;

			src_adler32 <<= 8;
		}

		return dst_ofs;
	}

	static void vector_append(std::vector<uint8_t>& buf, const void* pData, size_t len)
	{
		if (len)
		{
			size_t l = buf.size();
			buf.resize(l + len);
			memcpy(buf.data() + l, pData, len);
		}
	}
		
	static void apply_filter(uint32_t filter, int w, int h, uint32_t num_chans, uint32_t bpl, const uint8_t* pSrc, const uint8_t* pPrev_src, uint8_t* pDst)
	{
		(void)h;

		switch (filter)
		{
		case 0:
		{
			*pDst++ = 0;

			memcpy(pDst, pSrc, bpl);
			break;
		}
		case 2:
		{
			assert(pPrev_src);

			// Previous scanline
			*pDst++ = 2;

#if FPNG_X86_OR_X64_CPU && !FPNG_NO_SSE
			if (g_cpu_info.can_use_sse41())
			{
				uint32_t bytes_to_process = w * num_chans, ofs = 0;
				for (; bytes_to_process >= 16; bytes_to_process -= 16, ofs += 16)
					_mm_storeu_si128((__m128i*)(pDst + ofs), _mm_sub_epi8(_mm_loadu_si128((const __m128i*)(pSrc + ofs)), _mm_loadu_si128((const __m128i*)(pPrev_src + ofs))));

				for (; bytes_to_process; bytes_to_process--, ofs++)
					pDst[ofs] = (uint8_t)(pSrc[ofs] - pPrev_src[ofs]);
			}
			else
#endif
			{
				if (num_chans == 3)
				{
					for (uint32_t x = 0; x < (uint32_t)w; x++)
					{
						pDst[0] = (uint8_t)(pSrc[0] - pPrev_src[0]);
						pDst[1] = (uint8_t)(pSrc[1] - pPrev_src[1]);
						pDst[2] = (uint8_t)(pSrc[2] - pPrev_src[2]);

						pSrc += 3;
						pPrev_src += 3;
						pDst += 3;
					}
				}
				else
				{
					for (uint32_t x = 0; x < (uint32_t)w; x++)
					{
						pDst[0] = (uint8_t)(pSrc[0] - pPrev_src[0]);
						pDst[1] = (uint8_t)(pSrc[1] - pPrev_src[1]);
						pDst[2] = (uint8_t)(pSrc[2] - pPrev_src[2]);
						pDst[3] = (uint8_t)(pSrc[3] - pPrev_src[3]);

						pSrc += 4;
						pPrev_src += 4;
						pDst += 4;
					}
				}
			}

			break;
		}
		default:
			assert(0);
			break;
		}
	}

	bool fpng_encode_image_to_memory(const void* pImage, uint32_t w, uint32_t h, uint32_t num_chans, std::vector<uint8_t>& out_buf, uint32_t flags)
	{
		if (!endian_check())
		{
			assert(0);
			return false;
		}

		if ((w < 1) || (h < 1) || (w * (uint64_t)h > UINT32_MAX) || (w > FPNG_MAX_SUPPORTED_DIM) || (h > FPNG_MAX_SUPPORTED_DIM))
		{
			assert(0);
			return false;
		}

		if ((num_chans != 3) && (num_chans != 4))
		{
			assert(0);
			return false;
		}

		int i, bpl = w * num_chans;
		uint32_t y;

		std::vector<uint8_t> temp_buf;
		temp_buf.resize((bpl + 1) * h + 7);
		uint32_t temp_buf_ofs = 0;

		for (y = 0; y < h; ++y)
		{
			const uint8_t* pSrc = (uint8_t*)pImage + y * bpl;
			const uint8_t* pPrev_src = y ? ((uint8_t*)pImage + (y - 1) * bpl) : nullptr;

			uint8_t* pDst = &temp_buf[temp_buf_ofs];

			apply_filter(y ? 2 : 0, w, h, num_chans, bpl, pSrc, pPrev_src, pDst);

			temp_buf_ofs += 1 + bpl;
		}

		const uint32_t PNG_HEADER_SIZE = 58;
				
		uint32_t out_ofs = PNG_HEADER_SIZE;
				
		out_buf.resize((out_ofs + (bpl + 1) * h + 7) & ~7);

		uint32_t defl_size = 0;
		if ((flags & FPNG_FORCE_UNCOMPRESSED) == 0)
		{
			if (num_chans == 3)
			{
				if (flags & FPNG_ENCODE_SLOWER)
					defl_size = pixel_deflate_dyn_3_rle(temp_buf.data(), w, h, &out_buf[out_ofs], (uint32_t)out_buf.size() - out_ofs);
				else
					defl_size = pixel_deflate_dyn_3_rle_one_pass(temp_buf.data(), w, h, &out_buf[out_ofs], (uint32_t)out_buf.size() - out_ofs);
			}
			else
			{
				if (flags & FPNG_ENCODE_SLOWER)
					defl_size = pixel_deflate_dyn_4_rle(temp_buf.data(), w, h, &out_buf[out_ofs], (uint32_t)out_buf.size() - out_ofs);
				else
					defl_size = pixel_deflate_dyn_4_rle_one_pass(temp_buf.data(), w, h, &out_buf[out_ofs], (uint32_t)out_buf.size() - out_ofs);
			}
		}

		uint32_t zlib_size = defl_size;
		
		if (!defl_size)
		{
			// Dynamic block failed to compress - fall back to uncompressed blocks, filter 0.

			temp_buf_ofs = 0;

			for (y = 0; y < h; ++y)
			{
				const uint8_t* pSrc = (uint8_t*)pImage + y * bpl;

				uint8_t* pDst = &temp_buf[temp_buf_ofs];

				apply_filter(0, w, h, num_chans, bpl, pSrc, nullptr, pDst);

				temp_buf_ofs += 1 + bpl;
			}

			assert(temp_buf_ofs <= temp_buf.size());
						
			out_buf.resize(out_ofs + 6 + temp_buf_ofs + ((temp_buf_ofs + 65534) / 65535) * 5);

			uint32_t raw_size = write_raw_block(temp_buf.data(), (uint32_t)temp_buf_ofs, out_buf.data() + out_ofs, (uint32_t)out_buf.size() - out_ofs);
			if (!raw_size)
			{
				// Somehow we miscomputed the size of the output buffer.
				assert(0);
				return false;
			}

			zlib_size = raw_size;
		}
		
		assert((out_ofs + zlib_size) <= out_buf.size());

		out_buf.resize(out_ofs + zlib_size);

		const uint32_t idat_len = (uint32_t)out_buf.size() - PNG_HEADER_SIZE;

		// Write real PNG header, fdEC chunk, and the beginning of the IDAT chunk
		{
			static const uint8_t s_color_type[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };

			uint8_t pnghdr[58] = { 
				0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a,   // PNG sig
				0x00,0x00,0x00,0x0d, 'I','H','D','R',  // IHDR chunk len, type
			    0,0,(uint8_t)(w >> 8),(uint8_t)w, // width
				0,0,(uint8_t)(h >> 8),(uint8_t)h, // height
				8,   //bit_depth
				s_color_type[num_chans], // color_type
				0, // compression
				0, // filter
				0, // interlace
				0, 0, 0, 0, // IHDR crc32
				0, 0, 0, 5, 'f', 'd', 'E', 'C', 82, 36, 147, 227, FPNG_FDEC_VERSION,   0xE5, 0xAB, 0x62, 0x99, // our custom private, ancillary, do not copy, fdEC chunk
			  (uint8_t)(idat_len >> 24),(uint8_t)(idat_len >> 16),(uint8_t)(idat_len >> 8),(uint8_t)idat_len, 'I','D','A','T' // IDATA chunk len, type
			}; 

			// Compute IHDR CRC32
			uint32_t c = (uint32_t)fpng_crc32(pnghdr + 12, 17, FPNG_CRC32_INIT);
			for (i = 0; i < 4; ++i, c <<= 8)
				((uint8_t*)(pnghdr + 29))[i] = (uint8_t)(c >> 24);

			memcpy(out_buf.data(), pnghdr, PNG_HEADER_SIZE);
		}

		// Write IDAT chunk's CRC32 and a 0 length IEND chunk
		vector_append(out_buf, "\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16); // IDAT CRC32, followed by the IEND chunk

		// Compute IDAT crc32
		uint32_t c = (uint32_t)fpng_crc32(out_buf.data() + PNG_HEADER_SIZE - 4, idat_len + 4, FPNG_CRC32_INIT);
		
		for (i = 0; i < 4; ++i, c <<= 8)
			(out_buf.data() + out_buf.size() - 16)[i] = (uint8_t)(c >> 24);
				
		return true;
	}

#ifndef FPNG_NO_STDIO
	bool fpng_encode_image_to_file(const char* pFilename, const void* pImage, uint32_t w, uint32_t h, uint32_t num_chans, uint32_t flags)
	{
		std::vector<uint8_t> out_buf;
		if (!fpng_encode_image_to_memory(pImage, w, h, num_chans, out_buf, flags))
			return false;

		FILE* pFile = nullptr;
#ifdef _MSC_VER
		fopen_s(&pFile, pFilename, "wb");
#else
		pFile = fopen(pFilename, "wb");
#endif
		if (!pFile)
			return false;

		if (fwrite(out_buf.data(), 1, out_buf.size(), pFile) != out_buf.size())
		{
			fclose(pFile);
			return false;
		}

		return (fclose(pFile) != EOF);
	}
#endif

	// Decompression

	const uint32_t FPNG_DECODER_TABLE_BITS = 12;
	const uint32_t FPNG_DECODER_TABLE_SIZE = 1 << FPNG_DECODER_TABLE_BITS;

	static bool build_decoder_table(uint32_t num_syms, uint8_t* pCode_sizes, uint32_t* pTable)
	{
		uint32_t num_codes[16];

		memset(num_codes, 0, sizeof(num_codes));
		for (uint32_t i = 0; i < num_syms; i++)
		{
			assert(pCode_sizes[i] <= FPNG_DECODER_TABLE_SIZE);
			num_codes[pCode_sizes[i]]++;
		}

		uint32_t next_code[17];
		next_code[0] = next_code[1] = 0;
		uint32_t total = 0;
		for (uint32_t i = 1; i <= 15; i++)
			next_code[i + 1] = (uint32_t)(total = ((total + ((uint32_t)num_codes[i])) << 1));

		if (total != 0x10000)
		{
			uint32_t j = 0;

			for (uint32_t i = 15; i != 0; i--)
				if ((j += num_codes[i]) > 1)
					return false;
			
			if (j != 1)
				return false;
		}

		uint32_t rev_codes[DEFL_MAX_HUFF_SYMBOLS];

		for (uint32_t i = 0; i < num_syms; i++)
			rev_codes[i] = next_code[pCode_sizes[i]]++;

		memset(pTable, 0, sizeof(uint32_t) * FPNG_DECODER_TABLE_SIZE);

		for (uint32_t i = 0; i < num_syms; i++)
		{
			const uint32_t code_size = pCode_sizes[i];
			if (!code_size)
				continue;

			uint32_t old_code = rev_codes[i], new_code = 0;
			for (uint32_t j = code_size; j != 0; j--)
			{
				new_code = (new_code << 1) | (old_code & 1);
				old_code >>= 1;
			}

			uint32_t j = 1 << code_size;

			while (new_code < FPNG_DECODER_TABLE_SIZE)
			{
				pTable[new_code] = i | (code_size << 9);
				new_code += j;
			}
		}

		return true;
	}

	static const uint16_t g_run_len3_to_4[259] = 
	{
		0,
		0, 0, 4, 0, 0, 8, 0, 0, 12, 0, 0, 16, 0, 0, 20, 0, 0, 24, 0, 0, 28, 0, 0,
		32, 0, 0, 36, 0, 0, 40, 0, 0, 44, 0, 0, 48, 0, 0, 52, 0, 0, 56, 0, 0,
		60, 0, 0, 64, 0, 0, 68, 0, 0, 72, 0, 0, 76, 0, 0, 80, 0, 0, 84, 0, 0,
		88, 0, 0, 92, 0, 0, 96, 0, 0, 100, 0, 0, 104, 0, 0, 108, 0, 0, 112, 0, 0,
		116, 0, 0, 120, 0, 0, 124, 0, 0, 128, 0, 0, 132, 0, 0, 136, 0, 0, 140, 0, 0,
		144, 0, 0, 148, 0, 0, 152, 0, 0, 156, 0, 0, 160, 0, 0, 164, 0, 0, 168, 0, 0,
		172, 0, 0, 176, 0, 0, 180, 0, 0, 184, 0, 0, 188, 0, 0, 192, 0, 0, 196, 0, 0,
		200, 0, 0, 204, 0, 0, 208, 0, 0, 212, 0, 0, 216, 0, 0, 220, 0, 0, 224, 0, 0,
		228, 0, 0, 232, 0, 0, 236, 0, 0, 240, 0, 0, 244, 0, 0, 248, 0, 0, 252, 0, 0,
		256, 0, 0, 260, 0, 0, 264, 0, 0, 268, 0, 0, 272, 0, 0, 276, 0, 0, 280, 0, 0,
		284, 0, 0, 288, 0, 0, 292, 0, 0, 296, 0, 0, 300, 0, 0, 304, 0, 0, 308, 0, 0,
		312, 0, 0, 316, 0, 0, 320, 0, 0, 324, 0, 0, 328, 0, 0, 332, 0, 0, 336, 0, 0,
		340, 0, 0, 
		344,
	};

	static const int s_length_extra[] = { 0,0,0,0, 0,0,0,0, 1,1,1,1, 2,2,2,2, 3,3,3,3, 4,4,4,4, 5,5,5,5, 0,    0,0 };
	static const int s_length_range[] = { 3,4,5,6, 7,8,9,10, 11,13,15,17, 19,23,27,31, 35,43,51,59, 67,83,99,115, 131,163,195,227, 258,    0,0 };

#define ENSURE_32BITS() do { \
	if (bit_buf_size < 32) { \
		if ((src_ofs + 4) > src_len) return false; \
		bit_buf |= ((uint64_t)READ_LE32(pSrc + src_ofs)) << bit_buf_size; \
		src_ofs += 4; bit_buf_size += 32; } \
	} while(0)

#define GET_BITS(b, ll) do { \
	uint32_t l = ll; assert(l && (l <= 32)); \
	b = (uint32_t)(bit_buf & g_bitmasks[l]); \
	bit_buf >>= l; \
	bit_buf_size -= l; \
	ENSURE_32BITS(); \
	} while(0)

#define SKIP_BITS(ll) do { \
	uint32_t l = ll; assert(l <= 32); \
	bit_buf >>= l; \
	bit_buf_size -= l; \
	ENSURE_32BITS(); \
	} while(0)

#define GET_BITS_NE(b, ll) do { \
	uint32_t l = ll; assert(l && (l <= 32) && (bit_buf_size >= l)); \
	b = (uint32_t)(bit_buf & g_bitmasks[l]); \
	bit_buf >>= l; \
	bit_buf_size -= l; \
	} while(0)

#define SKIP_BITS_NE(ll) do { \
	uint32_t l = ll; assert(l <= 32 && (bit_buf_size >= l)); \
	bit_buf >>= l; \
	bit_buf_size -= l; \
	} while(0)

	static bool prepare_dynamic_block(
		const uint8_t* pSrc, uint32_t src_len, uint32_t& src_ofs,
		uint32_t& bit_buf_size, uint64_t& bit_buf,
		uint32_t* pLit_table, uint32_t num_chans)
	{
		static const uint8_t s_bit_length_order[] = { 16, 17, 18, 0, 8,  7,  9, 6, 10,  5, 11, 4, 12,  3, 13, 2, 14,  1, 15 };

		uint32_t num_lit_codes, num_dist_codes, num_clen_codes;

		GET_BITS(num_lit_codes, 5);
		num_lit_codes += 257;

		GET_BITS(num_dist_codes, 5);
		num_dist_codes += 1;
		
		uint32_t total_codes = num_lit_codes + num_dist_codes;
		if (total_codes > (DEFL_MAX_HUFF_SYMBOLS_0 + DEFL_MAX_HUFF_SYMBOLS_1))
			return false;

		uint8_t code_sizes[DEFL_MAX_HUFF_SYMBOLS_0 + DEFL_MAX_HUFF_SYMBOLS_1];
		memset(code_sizes, 0, sizeof(code_sizes));

		GET_BITS(num_clen_codes, 4);
		num_clen_codes += 4;

		uint8_t clen_codesizes[DEFL_MAX_HUFF_SYMBOLS_2];
		memset(clen_codesizes, 0, sizeof(clen_codesizes));

		for (uint32_t i = 0; i < num_clen_codes; i++)
		{
			uint32_t len = 0;
			GET_BITS(len, 3);
			clen_codesizes[s_bit_length_order[i]] = (uint8_t)len;
		}

		uint32_t clen_table[FPNG_DECODER_TABLE_SIZE];
		if (!build_decoder_table(DEFL_MAX_HUFF_SYMBOLS_2, clen_codesizes, clen_table))
			return false;

		uint32_t min_code_size = 15;

		for (uint32_t cur_code = 0; cur_code < total_codes; )
		{
			uint32_t sym = clen_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
			uint32_t sym_len = sym >> 9;
			if (!sym_len)
				return false;
			SKIP_BITS(sym_len);
			sym &= 511;
						
			if (sym <= 15)
			{
				// Can't be a fpng Huffman table
				if (sym > FPNG_DECODER_TABLE_BITS)
					return false;

				if (sym)
					min_code_size = minimum(min_code_size, sym);

				code_sizes[cur_code++] = (uint8_t)sym;
				continue;
			}

			uint32_t rep_len = 0, rep_code_size = 0;

			switch (sym)
			{
			case 16:
			{
				GET_BITS(rep_len, 2);
				rep_len += 3;
				if (!cur_code)
					return false;
				rep_code_size = code_sizes[cur_code - 1];
				break;
			}
			case 17:
			{
				GET_BITS(rep_len, 3);
				rep_len += 3;
				rep_code_size = 0;
				break;
			}
			case 18:
			{
				GET_BITS(rep_len, 7);
				rep_len += 11;
				rep_code_size = 0;
				break;
			}
			}

			if ((cur_code + rep_len) > total_codes)
				return false;

			for (; rep_len; rep_len--)
				code_sizes[cur_code++] = (uint8_t)rep_code_size;
		}

		uint8_t lit_codesizes[DEFL_MAX_HUFF_SYMBOLS_0];

		memcpy(lit_codesizes, code_sizes, num_lit_codes);
		memset(lit_codesizes + num_lit_codes, 0, DEFL_MAX_HUFF_SYMBOLS_0 - num_lit_codes);

		uint32_t total_valid_distcodes = 0;
		for (uint32_t i = 0; i < num_dist_codes; i++)
			total_valid_distcodes += (code_sizes[num_lit_codes + i] == 1);
		
		// 1 or 2 because the first version of FPNG only issued 1 valid distance code, but that upset wuffs. So we let 1 or 2 through.
		if ((total_valid_distcodes < 1) || (total_valid_distcodes > 2))
			return false;

		if (code_sizes[num_lit_codes + (num_chans - 1)] != 1)
			return false;

		if (total_valid_distcodes == 2)
		{
			// If there are two valid distance codes, make sure the first is 1 bit.
			if (code_sizes[num_lit_codes + num_chans] != 1)
				return false;
		}
						
		if (!build_decoder_table(num_lit_codes, lit_codesizes, pLit_table))
			return false;

		// Add next symbol to decoder table, when it fits
		for (uint32_t i = 0; i < FPNG_DECODER_TABLE_SIZE; i++)
		{
			uint32_t sym = pLit_table[i] & 511;
			if (sym >= 256)
				continue;

			uint32_t sym_bits = (pLit_table[i] >> 9) & 15;
			if (!sym_bits)
				continue;
			assert(sym_bits <= FPNG_DECODER_TABLE_BITS);

			uint32_t bits_left = FPNG_DECODER_TABLE_BITS - sym_bits;
			if (bits_left < min_code_size)
				continue;

			uint32_t next_bits = i >> sym_bits;
			uint32_t next_sym = pLit_table[next_bits] & 511;
			uint32_t next_sym_bits = (pLit_table[next_bits] >> 9) & 15;
			if ((!next_sym_bits) || (bits_left < next_sym_bits))
				continue;

			pLit_table[i] |= (next_sym << 16) | (next_sym_bits << (16 + 9));
		}

		return true;
	}
		
	static bool fpng_pixel_zlib_raw_decompress(
		const uint8_t* pSrc, uint32_t src_len, uint32_t zlib_len,
		uint8_t* pDst, uint32_t w, uint32_t h,
		uint32_t src_chans, uint32_t dst_chans)
	{
		assert((src_chans == 3) || (src_chans == 4));
		assert((dst_chans == 3) || (dst_chans == 4));
		
		const uint32_t src_bpl = w * src_chans;
		const uint32_t dst_bpl = w * dst_chans;
		const uint32_t dst_len = dst_bpl * h;

		uint32_t src_ofs = 2;
		uint32_t dst_ofs = 0;
		uint32_t raster_ofs = 0;
		uint32_t comp_ofs = 0;

		for (; ; )
		{
			if ((src_ofs + 1) > src_len)
				return false;

			const bool bfinal = (pSrc[src_ofs] & 1) != 0;
			const uint32_t btype = (pSrc[src_ofs] >> 1) & 3;
			if (btype != 0)
				return false;

			src_ofs++;

			if ((src_ofs + 4) > src_len)
				return false;
			uint32_t len = pSrc[src_ofs + 0] | (pSrc[src_ofs + 1] << 8);
			uint32_t nlen = pSrc[src_ofs + 2] | (pSrc[src_ofs + 3] << 8);
			src_ofs += 4;

			if (len != (~nlen & 0xFFFF))
				return false;

			if ((src_ofs + len) > src_len)
				return false;

			// Raw blocks are a relatively uncommon case so this isn't well optimized.
			// Supports 3->4 and 4->3 byte/pixel conversion.
			for (uint32_t i = 0; i < len; i++)
			{
				uint32_t c = pSrc[src_ofs + i];

				if (!raster_ofs)
				{
					// Check filter type
					if (c != 0)
						return false;
					
					assert(!comp_ofs);
				}
				else
				{
					if (comp_ofs < dst_chans)
					{
						if (dst_ofs == dst_len)
							return false;

						pDst[dst_ofs++] = (uint8_t)c;
					}
					
					if (++comp_ofs == src_chans)
					{
						if (dst_chans > src_chans)
						{
							if (dst_ofs == dst_len)
								return false;

							pDst[dst_ofs++] = (uint8_t)0xFF;
						}

						comp_ofs = 0;
					}
				}

				if (++raster_ofs == (src_bpl + 1))
				{
					assert(!comp_ofs);
					raster_ofs = 0;
				}
			}

			src_ofs += len;

			if (bfinal)
				break;
		}

		if (comp_ofs != 0)
			return false;

		// Check for zlib adler32
		if ((src_ofs + 4) != zlib_len)
			return false;

		return (dst_ofs == dst_len);
	}
	
	template<uint32_t dst_comps>
	static bool fpng_pixel_zlib_decompress_3(
		const uint8_t* pSrc, uint32_t src_len, uint32_t zlib_len,
		uint8_t* pDst, uint32_t w, uint32_t h)
	{
		assert(src_len >= (zlib_len + 4));

		const uint32_t dst_bpl = w * dst_comps;
		//const uint32_t dst_len = dst_bpl * h;

		if (zlib_len < 7)
			return false;

		// check zlib header
		if ((pSrc[0] != 0x78) || (pSrc[1] != 0x01))
			return false;

		uint32_t src_ofs = 2;
		
		if ((pSrc[src_ofs] & 6) == 0)
			return fpng_pixel_zlib_raw_decompress(pSrc, src_len, zlib_len, pDst, w, h, 3, dst_comps);
		
		if ((src_ofs + 4) > src_len)
			return false;
		uint64_t bit_buf = READ_LE32(pSrc + src_ofs);
		src_ofs += 4;

		uint32_t bit_buf_size = 32;

		uint32_t bfinal, btype;
		GET_BITS(bfinal, 1);
		GET_BITS(btype, 2);

		// Must be the final block or it's not valid, and type=2 (dynamic)
		if ((bfinal != 1) || (btype != 2))
			return false;
		
		uint32_t lit_table[FPNG_DECODER_TABLE_SIZE];
		if (!prepare_dynamic_block(pSrc, src_len, src_ofs, bit_buf_size, bit_buf, lit_table, 3))
			return false;

		const uint8_t* pPrev_scanline = nullptr;
		uint8_t* pCur_scanline = pDst;

		for (uint32_t y = 0; y < h; y++)
		{
			// At start of PNG scanline, so read the filter literal
			assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
			uint32_t filter = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
			uint32_t filter_len = (filter >> 9) & 15;
			if (!filter_len)
				return false;
			SKIP_BITS(filter_len);
			filter &= 511;

			uint32_t expected_filter = (y ? 2 : 0);
			if (filter != expected_filter)
				return false;

			uint32_t x_ofs = 0;
			uint8_t prev_delta_r = 0, prev_delta_g = 0, prev_delta_b = 0;
			do
			{
				assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
				uint32_t lit0_tab = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
				
				uint32_t lit0 = lit0_tab;
				uint32_t lit0_len = (lit0_tab >> 9) & 15;
				if (!lit0_len)
					return false;
				SKIP_BITS(lit0_len);

				if (lit0 & 256)
				{
					lit0 &= 511;

					// Can't be EOB - we still have more pixels to decompress.
					if (lit0 == 256)
						return false;

					// Must be an RLE match against the previous pixel.
					uint32_t run_len = s_length_range[lit0 - 257];
					if (lit0 >= 265)
					{
						uint32_t e;
						GET_BITS_NE(e, s_length_extra[lit0 - 257]);

						run_len += e;
					}
					
					// Skip match distance - it's always the same (3)
					SKIP_BITS_NE(1);

					// Matches must always be a multiple of 3/4 bytes
					assert((run_len % 3) == 0);
																				
					if (dst_comps == 4)
					{
						const uint32_t x_ofs_end = x_ofs + g_run_len3_to_4[run_len];
						
						// Check for valid run lengths
						if (x_ofs == x_ofs_end)
							return false;

						// Matches cannot cross scanlines.
						if (x_ofs_end > dst_bpl)
							return false;

						if (pPrev_scanline)
						{
							if ((prev_delta_r | prev_delta_g | prev_delta_b) == 0)
							{
								memcpy(pCur_scanline + x_ofs, pPrev_scanline + x_ofs, x_ofs_end - x_ofs);
								x_ofs = x_ofs_end;
							}
							else
							{
								do
								{
									pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + prev_delta_r);
									pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + prev_delta_g);
									pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + prev_delta_b);
									pCur_scanline[x_ofs + 3] = 0xFF;
									x_ofs += 4;
								} while (x_ofs < x_ofs_end);
							}
						}
						else
						{
							do
							{
								pCur_scanline[x_ofs] = prev_delta_r;
								pCur_scanline[x_ofs + 1] = prev_delta_g;
								pCur_scanline[x_ofs + 2] = prev_delta_b;
								pCur_scanline[x_ofs + 3] = 0xFF;
								x_ofs += 4;
							} while (x_ofs < x_ofs_end);
						}
					}
					else
					{
						// Check for valid run lengths
						if (!g_run_len3_to_4[run_len])
							return false;

						const uint32_t x_ofs_end = x_ofs + run_len;

						// Matches cannot cross scanlines.
						if (x_ofs_end > dst_bpl)
							return false;

						if (pPrev_scanline)
						{
							if ((prev_delta_r | prev_delta_g | prev_delta_b) == 0)
							{
								memcpy(pCur_scanline + x_ofs, pPrev_scanline + x_ofs, run_len);
								x_ofs = x_ofs_end;
							}
							else
							{
								do
								{
									pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + prev_delta_r);
									pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + prev_delta_g);
									pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + prev_delta_b);
									x_ofs += 3;
								} while (x_ofs < x_ofs_end);
							}
						}
						else
						{
							do
							{
								pCur_scanline[x_ofs] = prev_delta_r;
								pCur_scanline[x_ofs + 1] = prev_delta_g;
								pCur_scanline[x_ofs + 2] = prev_delta_b;
								x_ofs += 3;
							} while (x_ofs < x_ofs_end);
						}
					}
				}
				else
				{
					uint32_t lit1, lit2;

					uint32_t lit1_spec_len = (lit0_tab >> (16 + 9));
					uint32_t lit2_len;
					if (lit1_spec_len)
					{
						lit1 = (lit0_tab >> 16) & 511;
						SKIP_BITS_NE(lit1_spec_len);

						assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
						lit2 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
						lit2_len = (lit2 >> 9) & 15;
						if (!lit2_len)
							return false;
					}
					else
					{
						assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
						lit1 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
						uint32_t lit1_len = (lit1 >> 9) & 15;
						if (!lit1_len)
							return false;
						SKIP_BITS_NE(lit1_len);

						lit2_len = (lit1 >> (16 + 9));
						if (lit2_len)
							lit2 = lit1 >> 16;
						else
						{
							assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
							lit2 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
							lit2_len = (lit2 >> 9) & 15;
							if (!lit2_len)
								return false;
						}
					}

					SKIP_BITS(lit2_len);
					
					// Check for matches
					if ((lit1 | lit2) & 256)
						return false;

					if (dst_comps == 4)
					{
						if (pPrev_scanline)
						{
							pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + lit0);
							pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + lit1);
							pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + lit2);
							pCur_scanline[x_ofs + 3] = 0xFF;
						}
						else
						{
							pCur_scanline[x_ofs] = (uint8_t)lit0;
							pCur_scanline[x_ofs + 1] = (uint8_t)lit1;
							pCur_scanline[x_ofs + 2] = (uint8_t)lit2;
							pCur_scanline[x_ofs + 3] = 0xFF;
						}
						x_ofs += 4;
					}
					else
					{
						if (pPrev_scanline)
						{
							pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + lit0);
							pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + lit1);
							pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + lit2);
						}
						else
						{
							pCur_scanline[x_ofs] = (uint8_t)lit0;
							pCur_scanline[x_ofs + 1] = (uint8_t)lit1;
							pCur_scanline[x_ofs + 2] = (uint8_t)lit2;
						}
						x_ofs += 3;
					}

					prev_delta_r = (uint8_t)lit0;
					prev_delta_g = (uint8_t)lit1;
					prev_delta_b = (uint8_t)lit2;
										
					// See if we can decode one more pixel.
					uint32_t spec_next_len0_len = lit2 >> (16 + 9);
					if ((spec_next_len0_len) && (x_ofs < dst_bpl))
					{
						lit0 = (lit2 >> 16) & 511;
						if (lit0 < 256)
						{
							SKIP_BITS_NE(spec_next_len0_len);

							assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
							lit1 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
							uint32_t lit1_len = (lit1 >> 9) & 15;
							if (!lit1_len)
								return false;
							SKIP_BITS(lit1_len);

							lit2_len = (lit1 >> (16 + 9));
							if (lit2_len)
								lit2 = lit1 >> 16;
							else
							{
								assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
								lit2 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
								lit2_len = (lit2 >> 9) & 15;
								if (!lit2_len)
									return false;
							}

							SKIP_BITS_NE(lit2_len);

							// Check for matches
							if ((lit1 | lit2) & 256)
								return false;
					
							if (dst_comps == 4)
							{
								if (pPrev_scanline)
								{
									pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + lit0);
									pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + lit1);
									pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + lit2);
									pCur_scanline[x_ofs + 3] = 0xFF;
								}
								else
								{
									pCur_scanline[x_ofs] = (uint8_t)lit0;
									pCur_scanline[x_ofs + 1] = (uint8_t)lit1;
									pCur_scanline[x_ofs + 2] = (uint8_t)lit2;
									pCur_scanline[x_ofs + 3] = 0xFF;
								}
								x_ofs += 4;
							}
							else
							{
								if (pPrev_scanline)
								{
									pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + lit0);
									pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + lit1);
									pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + lit2);
								}
								else
								{
									pCur_scanline[x_ofs] = (uint8_t)lit0;
									pCur_scanline[x_ofs + 1] = (uint8_t)lit1;
									pCur_scanline[x_ofs + 2] = (uint8_t)lit2;
								}
								x_ofs += 3;
							}

							prev_delta_r = (uint8_t)lit0;
							prev_delta_g = (uint8_t)lit1;
							prev_delta_b = (uint8_t)lit2;
																				
						} // if (lit0 < 256)

					} // if ((spec_next_len0_len) && (x_ofs < bpl))
				}

			} while (x_ofs < dst_bpl);

			pPrev_scanline = pCur_scanline;
			pCur_scanline += dst_bpl;

		} // y

		// The last symbol should be EOB
		assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
		uint32_t lit0 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
		uint32_t lit0_len = (lit0 >> 9) & 15;
		if (!lit0_len)
			return false;
		lit0 &= 511;
		if (lit0 != 256)
			return false;

		bit_buf_size -= lit0_len;
		bit_buf >>= lit0_len;

		uint32_t align_bits = bit_buf_size & 7;
		bit_buf_size -= align_bits;
		bit_buf >>= align_bits;

		if (src_ofs < (bit_buf_size >> 3))
			return false;
		src_ofs -= (bit_buf_size >> 3);

		// We should be at the very end, because the bit buf reads ahead 32-bits (which contains the zlib adler32).
		if ((src_ofs + 4) != zlib_len)
			return false;

		return true;
	}

	template<uint32_t dst_comps>
	static bool fpng_pixel_zlib_decompress_4(
		const uint8_t* pSrc, uint32_t src_len, uint32_t zlib_len,
		uint8_t* pDst, uint32_t w, uint32_t h)
	{
		assert(src_len >= (zlib_len + 4));

		const uint32_t dst_bpl = w * dst_comps;
		//const uint32_t dst_len = dst_bpl * h;

		if (zlib_len < 7)
			return false;

		// check zlib header
		if ((pSrc[0] != 0x78) || (pSrc[1] != 0x01))
			return false;

		uint32_t src_ofs = 2;

		if ((pSrc[src_ofs] & 6) == 0)
			return fpng_pixel_zlib_raw_decompress(pSrc, src_len, zlib_len, pDst, w, h, 4, dst_comps);

		if ((src_ofs + 4) > src_len)
			return false;
		uint64_t bit_buf = READ_LE32(pSrc + src_ofs);
		src_ofs += 4;

		uint32_t bit_buf_size = 32;

		uint32_t bfinal, btype;
		GET_BITS(bfinal, 1);
		GET_BITS(btype, 2);

		// Must be the final block or it's not valid, and type=2 (dynamic)
		if ((bfinal != 1) || (btype != 2))
			return false;

		uint32_t lit_table[FPNG_DECODER_TABLE_SIZE];
		if (!prepare_dynamic_block(pSrc, src_len, src_ofs, bit_buf_size, bit_buf, lit_table, 4))
			return false;

		const uint8_t* pPrev_scanline = nullptr;
		uint8_t* pCur_scanline = pDst;

		for (uint32_t y = 0; y < h; y++)
		{
			// At start of PNG scanline, so read the filter literal
			assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
			uint32_t filter = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
			uint32_t filter_len = (filter >> 9) & 15;
			if (!filter_len)
				return false;
			SKIP_BITS(filter_len);
			filter &= 511;

			uint32_t expected_filter = (y ? 2 : 0);
			if (filter != expected_filter)
				return false;

			uint32_t x_ofs = 0;
			uint8_t prev_delta_r = 0, prev_delta_g = 0, prev_delta_b = 0, prev_delta_a = 0;
			do
			{
				assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
				uint32_t lit0_tab = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];

				uint32_t lit0 = lit0_tab;
				uint32_t lit0_len = (lit0_tab >> 9) & 15;
				if (!lit0_len)
					return false;
				SKIP_BITS(lit0_len);

				if (lit0 & 256)
				{
					lit0 &= 511;

					// Can't be EOB - we still have more pixels to decompress.
					if (lit0 == 256)
						return false;

					// Must be an RLE match against the previous pixel.
					uint32_t run_len = s_length_range[lit0 - 257];
					if (lit0 >= 265)
					{
						uint32_t e;
						GET_BITS_NE(e, s_length_extra[lit0 - 257]);

						run_len += e;
					}

					// Skip match distance - it's always the same (4)
					SKIP_BITS_NE(1);

					// Matches must always be a multiple of 3/4 bytes
					if (run_len & 3)
						return false;
										
					if (dst_comps == 3)
					{
						const uint32_t run_len3 = (run_len >> 2) * 3;
						const uint32_t x_ofs_end = x_ofs + run_len3;

						// Matches cannot cross scanlines.
						if (x_ofs_end > dst_bpl)
							return false;

						if (pPrev_scanline)
						{
							if ((prev_delta_r | prev_delta_g | prev_delta_b | prev_delta_a) == 0)
							{
								memcpy(pCur_scanline + x_ofs, pPrev_scanline + x_ofs, run_len3);
								x_ofs = x_ofs_end;
							}
							else
							{
								do
								{
									pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + prev_delta_r);
									pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + prev_delta_g);
									pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + prev_delta_b);
									x_ofs += 3;
								} while (x_ofs < x_ofs_end);
							}
						}
						else
						{
							do
							{
								pCur_scanline[x_ofs] = prev_delta_r;
								pCur_scanline[x_ofs + 1] = prev_delta_g;
								pCur_scanline[x_ofs + 2] = prev_delta_b;
								x_ofs += 3;
							} while (x_ofs < x_ofs_end);
						}
					}
					else
					{
						const uint32_t x_ofs_end = x_ofs + run_len;

						// Matches cannot cross scanlines.
						if (x_ofs_end > dst_bpl)
							return false;

						if (pPrev_scanline)
						{
							if ((prev_delta_r | prev_delta_g | prev_delta_b | prev_delta_a) == 0)
							{
								memcpy(pCur_scanline + x_ofs, pPrev_scanline + x_ofs, run_len);
								x_ofs = x_ofs_end;
							}
							else
							{
								do
								{
									pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + prev_delta_r);
									pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + prev_delta_g);
									pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + prev_delta_b);
									pCur_scanline[x_ofs + 3] = (uint8_t)(pPrev_scanline[x_ofs + 3] + prev_delta_a);
									x_ofs += 4;
								} while (x_ofs < x_ofs_end);
							}
						}
						else
						{
							do
							{
								pCur_scanline[x_ofs] = prev_delta_r;
								pCur_scanline[x_ofs + 1] = prev_delta_g;
								pCur_scanline[x_ofs + 2] = prev_delta_b;
								pCur_scanline[x_ofs + 3] = prev_delta_a;
								x_ofs += 4;
							} while (x_ofs < x_ofs_end);
						}
					}
				}
				else
				{
					uint32_t lit1, lit2;

					uint32_t lit1_spec_len = (lit0_tab >> (16 + 9));
					uint32_t lit2_len;
					if (lit1_spec_len)
					{
						lit1 = (lit0_tab >> 16) & 511;
						SKIP_BITS_NE(lit1_spec_len);

						assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
						lit2 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
						lit2_len = (lit2 >> 9) & 15;
						if (!lit2_len)
							return false;
					}
					else
					{
						assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
						lit1 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
						uint32_t lit1_len = (lit1 >> 9) & 15;
						if (!lit1_len)
							return false;
						SKIP_BITS_NE(lit1_len);

						lit2_len = (lit1 >> (16 + 9));
						if (lit2_len)
							lit2 = lit1 >> 16;
						else
						{
							assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
							lit2 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
							lit2_len = (lit2 >> 9) & 15;
							if (!lit2_len)
								return false;
						}
					}

					uint32_t lit3;
					uint32_t lit3_len = lit2 >> (16 + 9);
					
					if (lit3_len)
					{
						lit3 = (lit2 >> 16);
						SKIP_BITS(lit2_len + lit3_len);
					}
					else
					{
						SKIP_BITS(lit2_len);

						assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
						lit3 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
						lit3_len = (lit3 >> 9) & 15;
						if (!lit3_len)
							return false;

						SKIP_BITS_NE(lit3_len);
					}
										
					// Check for matches
					if ((lit1 | lit2 | lit3) & 256)
						return false;

					if (dst_comps == 3)
					{
						if (pPrev_scanline)
						{
							pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + lit0);
							pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + lit1);
							pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + lit2);
						}
						else
						{
							pCur_scanline[x_ofs] = (uint8_t)lit0;
							pCur_scanline[x_ofs + 1] = (uint8_t)lit1;
							pCur_scanline[x_ofs + 2] = (uint8_t)lit2;
						}

						x_ofs += 3;
					}
					else
					{
						if (pPrev_scanline)
						{
							pCur_scanline[x_ofs] = (uint8_t)(pPrev_scanline[x_ofs] + lit0);
							pCur_scanline[x_ofs + 1] = (uint8_t)(pPrev_scanline[x_ofs + 1] + lit1);
							pCur_scanline[x_ofs + 2] = (uint8_t)(pPrev_scanline[x_ofs + 2] + lit2);
							pCur_scanline[x_ofs + 3] = (uint8_t)(pPrev_scanline[x_ofs + 3] + lit3);
						}
						else
						{
							pCur_scanline[x_ofs] = (uint8_t)lit0;
							pCur_scanline[x_ofs + 1] = (uint8_t)lit1;
							pCur_scanline[x_ofs + 2] = (uint8_t)lit2;
							pCur_scanline[x_ofs + 3] = (uint8_t)lit3;
						}
						
						x_ofs += 4;
					}

					prev_delta_r = (uint8_t)lit0;
					prev_delta_g = (uint8_t)lit1;
					prev_delta_b = (uint8_t)lit2;
					prev_delta_a = (uint8_t)lit3;
				}

			} while (x_ofs < dst_bpl);

			pPrev_scanline = pCur_scanline;
			pCur_scanline += dst_bpl;
		} // y

		// The last symbol should be EOB
		assert(bit_buf_size >= FPNG_DECODER_TABLE_BITS);
		uint32_t lit0 = lit_table[bit_buf & (FPNG_DECODER_TABLE_SIZE - 1)];
		uint32_t lit0_len = (lit0 >> 9) & 15;
		if (!lit0_len)
			return false;
		lit0 &= 511;
		if (lit0 != 256)
			return false;

		bit_buf_size -= lit0_len;
		bit_buf >>= lit0_len;

		uint32_t align_bits = bit_buf_size & 7;
		bit_buf_size -= align_bits;
		bit_buf >>= align_bits;

		if (src_ofs < (bit_buf_size >> 3))
			return false;
		src_ofs -= (bit_buf_size >> 3);

		// We should be at the very end, because the bit buf reads ahead 32-bits (which contains the zlib adler32).
		if ((src_ofs + 4) != zlib_len)
			return false;

		return true;
	}

#pragma pack(push)
#pragma pack(1)
	struct png_chunk_prefix
	{
		uint32_t m_length;
		uint8_t m_type[4];
	};
	struct png_ihdr
	{
		png_chunk_prefix m_prefix;
		uint32_t m_width;
		uint32_t m_height;
		uint8_t m_bitdepth;
		uint8_t m_color_type;
		uint8_t m_comp_method;
		uint8_t m_filter_method;
		uint8_t m_interlace_method;
		uint32_t m_crc32;
	};
	const uint32_t IHDR_EXPECTED_LENGTH = 13;
	struct png_iend
	{
		png_chunk_prefix m_prefix;
		uint32_t m_crc32;
	};
#pragma pack(pop)

	static int fpng_get_info_internal(const void* pImage, uint32_t image_size, uint32_t& width, uint32_t& height, uint32_t& channels_in_file, uint32_t &idat_ofs, uint32_t &idat_len)
	{
		static const uint8_t s_png_sig[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };

		if (!endian_check())
		{
			assert(0);
			return false;
		}
				
		width = 0;
		height = 0;
		channels_in_file = 0;
		idat_ofs = 0, idat_len = 0;
				
		// Ensure the file has at least a minimum possible size
		if (image_size < (sizeof(s_png_sig) + sizeof(png_ihdr) + sizeof(png_chunk_prefix) + 1 + sizeof(uint32_t) + sizeof(png_iend)))
			return FPNG_DECODE_FAILED_NOT_PNG;

		if (memcmp(pImage, s_png_sig, 8) != 0)
			return FPNG_DECODE_FAILED_NOT_PNG;

		const uint8_t* pImage_u8 = static_cast<const uint8_t*>(pImage) + 8;

		const png_ihdr& ihdr = *reinterpret_cast<const png_ihdr*>(pImage_u8);
		pImage_u8 += sizeof(png_ihdr);

		if (READ_BE32(&ihdr.m_prefix.m_length) != IHDR_EXPECTED_LENGTH)
			return FPNG_DECODE_FAILED_NOT_PNG;

		if (fpng_crc32(ihdr.m_prefix.m_type, 4 + IHDR_EXPECTED_LENGTH, FPNG_CRC32_INIT) != READ_BE32(&ihdr.m_crc32))
			return FPNG_DECODE_FAILED_HEADER_CRC32;

		width = READ_BE32(&ihdr.m_width);
		height = READ_BE32(&ihdr.m_height);
				
		if (!width || !height || (width > FPNG_MAX_SUPPORTED_DIM) || (height > FPNG_MAX_SUPPORTED_DIM))
			return FPNG_DECODE_FAILED_INVALID_DIMENSIONS;

		uint64_t total_pixels = (uint64_t)width * height;
		if (total_pixels > (1 << 30))
			return FPNG_DECODE_FAILED_INVALID_DIMENSIONS;

		if ((ihdr.m_comp_method) || (ihdr.m_filter_method) || (ihdr.m_interlace_method) || (ihdr.m_bitdepth != 8))
			return FPNG_DECODE_NOT_FPNG;

		if (ihdr.m_color_type == 2)
			channels_in_file = 3;
		else if (ihdr.m_color_type == 6)
			channels_in_file = 4;

		if (!channels_in_file)
			return FPNG_DECODE_NOT_FPNG;

		// Scan all the chunks. Look for one IDAT, IEND, and our custom fdEC chunk that indicates the file was compressed by us. Skip any ancillary chunks.
		bool found_fdec_chunk = false;
		
		for (; ; )
		{
			const size_t src_ofs = pImage_u8 - static_cast<const uint8_t*>(pImage);
			if (src_ofs >= image_size)
				return FPNG_DECODE_FAILED_CHUNK_PARSING;

			const uint32_t bytes_remaining = image_size - (uint32_t)src_ofs;
			if (bytes_remaining < sizeof(uint32_t) * 3)
				return FPNG_DECODE_FAILED_CHUNK_PARSING;

			const png_chunk_prefix* pChunk = reinterpret_cast<const png_chunk_prefix*>(pImage_u8);

			const uint32_t chunk_len = READ_BE32(&pChunk->m_length);
			if ((src_ofs + sizeof(uint32_t) * 2 + (uint64_t)chunk_len + sizeof(uint32_t)) > image_size)
				return FPNG_DECODE_FAILED_CHUNK_PARSING;

			for (uint32_t i = 0; i < 4; i++)
			{
				const uint8_t c = pChunk->m_type[i];
				const bool is_upper = (c >= 65) && (c <= 90), is_lower = (c >= 97) && (c <= 122);
				if ((!is_upper) && (!is_lower))
					return FPNG_DECODE_FAILED_CHUNK_PARSING;
			}

			const uint32_t expected_crc32 = READ_BE32(pImage_u8 + sizeof(uint32_t) * 2 + chunk_len);

			char chunk_type[5] = { (char)pChunk->m_type[0], (char)pChunk->m_type[1], (char)pChunk->m_type[2], (char)pChunk->m_type[3], 0 };
			const bool is_idat = strcmp(chunk_type, "IDAT") == 0;

#if !FPNG_DISABLE_DECODE_CRC32_CHECKS
			if (!is_idat)
			{
				uint32_t actual_crc32 = fpng_crc32(pImage_u8 + sizeof(uint32_t), sizeof(uint32_t) + chunk_len, FPNG_CRC32_INIT);
				if (actual_crc32 != expected_crc32)
					return FPNG_DECODE_FAILED_HEADER_CRC32;
			}
#endif

			const uint8_t* pChunk_data = pImage_u8 + sizeof(uint32_t) * 2;

			if (strcmp(chunk_type, "IEND") == 0)
				break;
			else if (is_idat)
			{
				// If there were multiple IDAT's, or we didn't find the fdEC chunk, then it's not FPNG.
				if ((idat_ofs) || (!found_fdec_chunk))
					return FPNG_DECODE_NOT_FPNG;

				idat_ofs = (uint32_t)src_ofs;
				idat_len = chunk_len;

				// Sanity check the IDAT chunk length
				if (idat_len < 7)
					return FPNG_DECODE_FAILED_INVALID_IDAT;
			}
			else if (strcmp(chunk_type, "fdEC") == 0)
			{
				if (found_fdec_chunk)
					return FPNG_DECODE_NOT_FPNG;

				// We've got our fdEC chunk. Now make sure it's big enough and check its contents.
				if (chunk_len != 5)
					return FPNG_DECODE_NOT_FPNG;

				// Check fdEC chunk sig
				if ((pChunk_data[0] != 82) || (pChunk_data[1] != 36) || (pChunk_data[2] != 147) || (pChunk_data[3] != 227))
					return FPNG_DECODE_NOT_FPNG;

				// Check fdEC version
				if (pChunk_data[4] != FPNG_FDEC_VERSION)
					return FPNG_DECODE_NOT_FPNG;

				found_fdec_chunk = true;
			}
			else
			{
				// Bail if it's a critical chunk - can't be FPNG
				if ((chunk_type[0] & 32) == 0)
					return FPNG_DECODE_NOT_FPNG;

				// ancillary chunk - skip it
			}

			pImage_u8 += sizeof(png_chunk_prefix) + chunk_len + sizeof(uint32_t);
		}

		if ((!found_fdec_chunk) || (!idat_ofs))
			return FPNG_DECODE_NOT_FPNG;
		
		return FPNG_DECODE_SUCCESS;
	}

	int fpng_get_info(const void* pImage, uint32_t image_size, uint32_t& width, uint32_t& height, uint32_t& channels_in_file)
	{
		uint32_t idat_ofs = 0, idat_len = 0;
		return fpng_get_info_internal(pImage, image_size, width, height, channels_in_file, idat_ofs, idat_len);
	}

	int fpng_decode_memory(const void *pImage, uint32_t image_size, std::vector<uint8_t> &out, uint32_t& width, uint32_t& height, uint32_t &channels_in_file, uint32_t desired_channels)
	{
		out.resize(0);
		width = 0;
		height = 0;
		channels_in_file = 0;

		if ((!pImage) || (!image_size) || ((desired_channels != 3) && (desired_channels != 4)))
		{
			assert(0);
			return FPNG_DECODE_INVALID_ARG;
		}

		uint32_t idat_ofs = 0, idat_len = 0;
		int status = fpng_get_info_internal(pImage, image_size, width, height, channels_in_file, idat_ofs, idat_len);
		if (status)
			return status;
				
		const uint64_t mem_needed = (uint64_t)width * height * desired_channels;
		if (mem_needed > UINT32_MAX)
			return FPNG_DECODE_FAILED_DIMENSIONS_TOO_LARGE;

		// On 32-bit systems do a quick sanity check before we try to resize the output buffer.
		if ((sizeof(size_t) == sizeof(uint32_t)) && (mem_needed >= 0x80000000))
			return FPNG_DECODE_FAILED_DIMENSIONS_TOO_LARGE;

		out.resize(mem_needed);
		
		const uint8_t* pIDAT_data = static_cast<const uint8_t*>(pImage) + idat_ofs + sizeof(uint32_t) * 2;
		const uint32_t src_len = image_size - (idat_ofs + sizeof(uint32_t) * 2);

		bool decomp_status;
		if (desired_channels == 3)
		{
			if (channels_in_file == 3)
				decomp_status = fpng_pixel_zlib_decompress_3<3>(pIDAT_data, src_len, idat_len, out.data(), width, height);
			else
				decomp_status = fpng_pixel_zlib_decompress_4<3>(pIDAT_data, src_len, idat_len, out.data(), width, height);
		}
		else
		{
			if (channels_in_file == 3)
				decomp_status = fpng_pixel_zlib_decompress_3<4>(pIDAT_data, src_len, idat_len, out.data(), width, height);
			else
				decomp_status = fpng_pixel_zlib_decompress_4<4>(pIDAT_data, src_len, idat_len, out.data(), width, height);
		}
		if (!decomp_status)
		{
			// Something went wrong. Either the file data was corrupted, or it doesn't conform to one of our zlib/Deflate constraints.
			// The conservative thing to do is indicate it wasn't written by us, and let the general purpose PNG decoder handle it.
			return FPNG_DECODE_NOT_FPNG;
		}

		return FPNG_DECODE_SUCCESS;
	}

#ifndef FPNG_NO_STDIO
	int fpng_decode_file(const char* pFilename, std::vector<uint8_t>& out, uint32_t& width, uint32_t& height, uint32_t& channels_in_file, uint32_t desired_channels)
	{
		FILE* pFile = nullptr;

#ifdef _MSC_VER
		fopen_s(&pFile, pFilename, "rb");
#else
		pFile = fopen(pFilename, "rb");
#endif

		if (!pFile)
			return FPNG_DECODE_FILE_OPEN_FAILED;

		if (fseek(pFile, 0, SEEK_END) != 0)
		{
			fclose(pFile);
			return FPNG_DECODE_FILE_SEEK_FAILED;
		}

#ifdef _WIN32
		int64_t filesize = _ftelli64(pFile);
#else
		int64_t filesize = ftello(pFile);
#endif

		if (fseek(pFile, 0, SEEK_SET) != 0)
		{
			fclose(pFile);
			return FPNG_DECODE_FILE_SEEK_FAILED;
		}

		if ( (filesize < 0) || (filesize > UINT32_MAX) || ( (sizeof(size_t) == sizeof(uint32_t)) && (filesize > 0x70000000) ) )
		{
			fclose(pFile);
			return FPNG_DECODE_FILE_TOO_LARGE;
		}

		std::vector<uint8_t> buf((size_t)filesize);
		if (fread(buf.data(), 1, buf.size(), pFile) != buf.size())
		{
			fclose(pFile);
			return FPNG_DECODE_FILE_READ_FAILED;
		}

		fclose(pFile);

		return fpng_decode_memory(buf.data(), (uint32_t)buf.size(), out, width, height, channels_in_file, desired_channels);
	}
#endif

} // namespace fpng

/*
	This is free and unencumbered software released into the public domain.

	Anyone is free to copy, modify, publish, use, compile, sell, or
	distribute this software, either in source code form or as a compiled
	binary, for any purpose, commercial or non-commercial, and by any
	means.

	In jurisdictions that recognize copyright laws, the author or authors
	of this software dedicate any and all copyright interest in the
	software to the public domain. We make this dedication for the benefit
	of the public at large and to the detriment of our heirs and
	successors. We intend this dedication to be an overt act of
	relinquishment in perpetuity of all present and future rights to this
	software under copyright law.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
	OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.

	For more information, please refer to <http://unlicense.org/>

	Richard Geldreich, Jr.
	12/30/2021
*/

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/fpng.h`
```
// https://github.com/richgel999/fpng
// fpng.h - unlicense (see end of fpng.cpp)
#pragma once

#include <stdlib.h>
#include <stdint.h>
#include <vector>

#ifndef FPNG_TRAIN_HUFFMAN_TABLES
	// Set to 1 when using the -t (training) option in fpng_test to generate new opaque/alpha Huffman tables for the single pass encoder.
	#define FPNG_TRAIN_HUFFMAN_TABLES (0)
#endif

namespace fpng
{
	// ---- Library initialization - call once to identify if the processor supports SSE.
	// Otherwise you'll only get scalar fallbacks.
	void fpng_init();

	// ---- Useful Utilities

	// Returns true if the CPU supports SSE 4.1, and SSE support wasn't disabled by setting FPNG_NO_SSE=1.
	// fpng_init() must have been called first, or it'll assert and return false.
	bool fpng_cpu_supports_sse41();

	// Fast CRC-32 SSE4.1+pclmul or a scalar fallback (slice by 4)
	const uint32_t FPNG_CRC32_INIT = 0;
	uint32_t fpng_crc32(const void* pData, size_t size, uint32_t prev_crc32 = FPNG_CRC32_INIT);

	// Fast Adler32 SSE4.1 Adler-32 with a scalar fallback.
	const uint32_t FPNG_ADLER32_INIT = 1;
	uint32_t fpng_adler32(const void* pData, size_t size, uint32_t adler = FPNG_ADLER32_INIT);

	// ---- Compression
	enum
	{
		// Enables computing custom Huffman tables for each file, instead of using the custom global tables. 
		// Results in roughly 6% smaller files on average, but compression is around 40% slower.
		FPNG_ENCODE_SLOWER = 1, 
		
		// Only use raw Deflate blocks (no compression at all). Intended for testing.
		FPNG_FORCE_UNCOMPRESSED = 2,
	};

	// Fast PNG encoding. The resulting file can be decoded either using a standard PNG decoder or by the fpng_decode_memory() function below.
	// pImage: pointer to RGB or RGBA image pixels, R first in memory, B/A last.
	// w/h - image dimensions. Image's row pitch in bytes must is w*num_chans.
	// num_chans must be 3 or 4. 
	bool fpng_encode_image_to_memory(const void* pImage, uint32_t w, uint32_t h, uint32_t num_chans, std::vector<uint8_t>& out_buf, uint32_t flags = 0);

#ifndef FPNG_NO_STDIO
	// Fast PNG encoding to the specified file.
	bool fpng_encode_image_to_file(const char* pFilename, const void* pImage, uint32_t w, uint32_t h, uint32_t num_chans, uint32_t flags = 0);
#endif

	// ---- Decompression
		
	enum
	{
		FPNG_DECODE_SUCCESS = 0,				// file is a valid PNG file and written by FPNG and the decode succeeded
		
		FPNG_DECODE_NOT_FPNG,					// file is a valid PNG file, but it wasn't written by FPNG so you should try decoding it with a general purpose PNG decoder

		FPNG_DECODE_INVALID_ARG,				// invalid function parameter

		FPNG_DECODE_FAILED_NOT_PNG,				// file cannot be a PNG file
		FPNG_DECODE_FAILED_HEADER_CRC32,		// a chunk CRC32 check failed, file is likely corrupted or not PNG
		FPNG_DECODE_FAILED_INVALID_DIMENSIONS,  // invalid image dimensions in IHDR chunk (0 or too large)
		FPNG_DECODE_FAILED_DIMENSIONS_TOO_LARGE, // decoding the file fully into memory would likely require too much memory (only on 32bpp builds)
		FPNG_DECODE_FAILED_CHUNK_PARSING,		// failed while parsing the chunk headers, or file is corrupted
		FPNG_DECODE_FAILED_INVALID_IDAT,		// IDAT data length is too small and cannot be valid, file is either corrupted or it's a bug

		// fpng_decode_file() specific errors
		FPNG_DECODE_FILE_OPEN_FAILED,
		FPNG_DECODE_FILE_TOO_LARGE,
		FPNG_DECODE_FILE_READ_FAILED,
		FPNG_DECODE_FILE_SEEK_FAILED
	};

	// Fast PNG decoding of files ONLY created by fpng_encode_image_to_memory() or fpng_encode_image_to_file().
	// If fpng_get_info() or fpng_decode_memory() returns FPNG_DECODE_NOT_FPNG, you should decode the PNG by falling back to a general purpose decoder.
	//
	// fpng_get_info() parses the PNG header and iterates through all chunks to determine if it's a file written by FPNG, but does not decompress the actual image data so it's relatively fast.
	// 
	// pImage, image_size: Pointer to PNG image data and its size
	// width, height: output image's dimensions
	// channels_in_file: will be 3 or 4
	// 
	// Returns FPNG_DECODE_SUCCESS on success, otherwise one of the failure codes above.
	// If FPNG_DECODE_NOT_FPNG is returned, you must decompress the file with a general purpose PNG decoder.
	// If another error occurs, the file is likely corrupted or invalid, but you can still try to decompress the file with another decoder (which will likely fail).
	int fpng_get_info(const void* pImage, uint32_t image_size, uint32_t& width, uint32_t& height, uint32_t& channels_in_file);

	// fpng_decode_memory() decompresses 24/32bpp PNG files ONLY encoded by this module.
	// If the image was written by FPNG, it will decompress the image data, otherwise it will return FPNG_DECODE_NOT_FPNG in which case you should fall back to a general purpose PNG decoder (lodepng, stb_image, libpng, etc.)
	//
	// pImage, image_size: Pointer to PNG image data and its size
	// out: Output 24/32bpp image buffer
	// width, height: output image's dimensions
	// channels_in_file: will be 3 or 4
	// desired_channels: must be 3 or 4 
	// 
	// If the image is 24bpp and 32bpp is requested, the alpha values will be set to 0xFF. 
	// If the image is 32bpp and 24bpp is requested, the alpha values will be discarded.
	// 
	// Returns FPNG_DECODE_SUCCESS on success, otherwise one of the failure codes above.
	// If FPNG_DECODE_NOT_FPNG is returned, you must decompress the file with a general purpose PNG decoder.
	// If another error occurs, the file is likely corrupted or invalid, but you can still try to decompress the file with another decoder (which will likely fail).
	int fpng_decode_memory(const void* pImage, uint32_t image_size, std::vector<uint8_t>& out, uint32_t& width, uint32_t& height, uint32_t& channels_in_file, uint32_t desired_channels);

#ifndef FPNG_NO_STDIO
	int fpng_decode_file(const char* pFilename, std::vector<uint8_t>& out, uint32_t& width, uint32_t& height, uint32_t& channels_in_file, uint32_t desired_channels);
#endif

	// ---- Internal API used for Huffman table training purposes

#if FPNG_TRAIN_HUFFMAN_TABLES
	const uint32_t HUFF_COUNTS_SIZE = 288;
	extern uint64_t g_huff_counts[HUFF_COUNTS_SIZE];
	bool create_dynamic_block_prefix(uint64_t* pFreq, uint32_t num_chans, std::vector<uint8_t>& prefix, uint64_t& bit_buf, int& bit_buf_size, uint32_t *pCodes, uint8_t *pCodesizes);
#endif

} // namespace fpng

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/bits`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/bits/algorithms.h`
```
/*
 * Frozen
 * Copyright 2016 QuarksLab
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_LETITGO_BITS_ALGORITHMS_H
#define FROZEN_LETITGO_BITS_ALGORITHMS_H

#include "vendor/frozen/bits/basic_types.h"

#include <limits>
#include <tuple>

namespace frozen {

namespace bits {

auto constexpr next_highest_power_of_two(std::size_t v) {
  // https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
  constexpr auto trip_count = std::numeric_limits<decltype(v)>::digits;
  v--;
  for(std::size_t i = 1; i < trip_count; i <<= 1)
    v |= v >> i;
  v++;
  return v;
}

template<class T>
auto constexpr log(T v) {
  std::size_t n = 0;
  while (v > 1) {
    n += 1;
    v >>= 1;
  }
  return n;
}

constexpr std::size_t bit_weight(std::size_t n) {
  return (n <= 8*sizeof(unsigned int))
    + (n <= 8*sizeof(unsigned long))
    + (n <= 8*sizeof(unsigned long long))
    + (n <= 128);
}

unsigned int select_uint_least(std::integral_constant<std::size_t, 4>);
unsigned long select_uint_least(std::integral_constant<std::size_t, 3>);
unsigned long long select_uint_least(std::integral_constant<std::size_t, 2>);
template<std::size_t N>
unsigned long long select_uint_least(std::integral_constant<std::size_t, N>) {
  static_assert(N < 2, "unsupported type size");
  return {};
}


template<std::size_t N>
using select_uint_least_t = decltype(select_uint_least(std::integral_constant<std::size_t, bit_weight(N)>()));

template <typename Iter, typename Compare>
constexpr auto min_element(Iter begin, const Iter end,
                           Compare const &compare) {
  auto result = begin;
  while (begin != end) {
    if (compare(*begin, *result)) {
      result = begin;
    }
    ++begin;
  }
  return result;
}

template <class T>
constexpr void cswap(T &a, T &b) {
  auto tmp = a;
  a = b;
  b = tmp;
}

template <class T, class U>
constexpr void cswap(std::pair<T, U> & a, std::pair<T, U> & b) {
  cswap(a.first, b.first);
  cswap(a.second, b.second);
}

template <class... Tys, std::size_t... Is>
constexpr void cswap(std::tuple<Tys...> &a, std::tuple<Tys...> &b, std::index_sequence<Is...>) {
  using swallow = int[];
  (void) swallow{(cswap(std::get<Is>(a), std::get<Is>(b)), 0)...};
}

template <class... Tys>
constexpr void cswap(std::tuple<Tys...> &a, std::tuple<Tys...> &b) {
  cswap(a, b, std::make_index_sequence<sizeof...(Tys)>());
}

template <typename Iter>
constexpr void iter_swap(Iter a, Iter b) {
  cswap(*a, *b);
}

template <typename Iterator, class Compare>
constexpr Iterator partition(Iterator left, Iterator right, Compare const &compare) {
  auto pivot = left + (right - left) / 2;
  iter_swap(right, pivot);
  pivot = right;
  for (auto it = left; 0 < right - it; ++it) {
    if (compare(*it, *pivot)) {
      iter_swap(it, left);
      left++;
    }
  }
  iter_swap(pivot, left);
  pivot = left;
  return pivot;
}

template <typename Iterator, class Compare>
constexpr void quicksort(Iterator left, Iterator right, Compare const &compare) {
  while (0 < right - left) {
    auto new_pivot = bits::partition(left, right, compare);
    quicksort(left, new_pivot, compare);
    left = new_pivot + 1;
  }
}

template <typename Container, class Compare>
constexpr Container quicksort(Container const &array,
                                     Compare const &compare) {
  Container res = array;
  quicksort(res.begin(), res.end() - 1, compare);
  return res;
}

template <class T, class Compare> struct LowerBound {
  T const &value_;
  Compare const &compare_;
  constexpr LowerBound(T const &value, Compare const &compare)
      : value_(value), compare_(compare) {}

  template <class ForwardIt>
  inline constexpr ForwardIt doit_fast(ForwardIt first,
                                  std::integral_constant<std::size_t, 0>) {
    return first;
  }

  template <class ForwardIt, std::size_t N>
  inline constexpr ForwardIt doit_fast(ForwardIt first,
                                  std::integral_constant<std::size_t, N>) {
    auto constexpr step = N / 2;
    static_assert(N/2 == N - N / 2 - 1, "power of two minus 1");
    auto it = first + step;
    auto next_it = compare_(*it, value_) ? it + 1 : first;
    return doit_fast(next_it, std::integral_constant<std::size_t, N / 2>{});
  }

  template <class ForwardIt, std::size_t N>
  inline constexpr ForwardIt doitfirst(ForwardIt first, std::integral_constant<std::size_t, N>, std::integral_constant<bool, true>) {
    return doit_fast(first, std::integral_constant<std::size_t, N>{});
  }

  template <class ForwardIt, std::size_t N>
  inline constexpr ForwardIt doitfirst(ForwardIt first, std::integral_constant<std::size_t, N>, std::integral_constant<bool, false>) {
    auto constexpr next_power = next_highest_power_of_two(N);
    auto constexpr next_start = next_power / 2 - 1;
    auto it = first + next_start;
    if (compare_(*it, value_)) {
      auto constexpr next = N - next_start - 1;
      return doitfirst(it + 1, std::integral_constant<std::size_t, next>{}, std::integral_constant<bool, next_highest_power_of_two(next) - 1 == next>{});
    }
    else
      return doit_fast(first, std::integral_constant<std::size_t, next_start>{});
  }

  template <class ForwardIt>
  inline constexpr ForwardIt doitfirst(ForwardIt first, std::integral_constant<std::size_t, 1>, std::integral_constant<bool, false>) {
    return doit_fast(first, std::integral_constant<std::size_t, 1>{});
  }
};

template <std::size_t N, class ForwardIt, class T, class Compare>
constexpr ForwardIt lower_bound(ForwardIt first, const T &value, Compare const &compare) {
  return LowerBound<T, Compare>{value, compare}.doitfirst(first, std::integral_constant<std::size_t, N>{}, std::integral_constant<bool, next_highest_power_of_two(N) - 1 == N>{});
}

template <std::size_t N, class Compare, class ForwardIt, class T>
constexpr bool binary_search(ForwardIt first, const T &value,
                             Compare const &compare) {
  ForwardIt where = lower_bound<N>(first, value, compare);
  return (!(where == first + N) && !(compare(value, *where)));
}


template<class InputIt1, class InputIt2>
constexpr bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2)
{
  for (; first1 != last1; ++first1, ++first2) {
    if (!(*first1 == *first2)) {
      return false;
    }
  }
  return true;
}

template<class InputIt1, class InputIt2>
constexpr bool lexicographical_compare(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2)
{
  for (; (first1 != last1) && (first2 != last2); ++first1, ++first2) {
    if (*first1 < *first2)
      return true;
    if (*first2 < *first1)
      return false;
  }
  return (first1 == last1) && (first2 != last2);
}

} // namespace bits
} // namespace frozen

#endif

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/bits/basic_types.h`
```
/*
 * Frozen
 * Copyright 2016 QuarksLab
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_LETITGO_BASIC_TYPES_H
#define FROZEN_LETITGO_BASIC_TYPES_H

#include "vendor/frozen/bits/exceptions.h"
#include "vendor/frozen/bits/constexpr_assert.h"

#include <array>
#include <utility>
#include <string>
#include <type_traits>

namespace frozen {

namespace bits {

// used as a fake argument for frozen::make_set and frozen::make_map in the case of N=0
struct ignored_arg {};

template <class T, std::size_t N>
class cvector {
  T data [N] = {}; // zero-initialization for scalar type T, default-initialized otherwise
  std::size_t dsize = 0;

public:
  // Container typdefs
  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;
  using pointer = value_type *;
  using const_pointer = const value_type *;
  using iterator = pointer;
  using const_iterator = const_pointer;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;

  // Constructors
  constexpr cvector(void) = default;
  constexpr cvector(size_type count, const T& value) : dsize(count) {
    for (std::size_t i = 0; i < N; ++i)
      data[i] = value;
  }

  // Iterators
  constexpr       iterator begin() noexcept { return data; }
  constexpr       iterator end() noexcept { return data + dsize; }
  constexpr const_iterator begin() const noexcept { return data; }
  constexpr const_iterator end() const noexcept { return data + dsize; }

  // Capacity
  constexpr size_type size() const { return dsize; }

  // Element access
  constexpr       reference operator[](std::size_t index) { return data[index]; }
  constexpr const_reference operator[](std::size_t index) const { return data[index]; }

  constexpr       reference back() { return data[dsize - 1]; }
  constexpr const_reference back() const { return data[dsize - 1]; }

  // Modifiers
  constexpr void push_back(const T & a) { data[dsize++] = a; }
  constexpr void push_back(T && a) { data[dsize++] = std::move(a); }
  constexpr void pop_back() { --dsize; }

  constexpr void clear() { dsize = 0; }
};

template <class T, std::size_t N>
class carray {
  T data_ [N] = {}; // zero-initialization for scalar type T, default-initialized otherwise

  template <class Iter, std::size_t... I>
  constexpr carray(Iter iter, std::index_sequence<I...>)
      : data_{((void)I, *iter++)...} {}
  template <std::size_t... I>
  constexpr carray(const T& value, std::index_sequence<I...>)
      : data_{((void)I, value)...} {}

  static constexpr void check_initializer(std::initializer_list<T> init) {
    (void)init;
    constexpr_assert(init.size() == N, "Cannot initialize a carray with an initializer list of different size.");
  }

public:
  // Container typdefs
  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;
  using pointer = value_type *;
  using const_pointer = const value_type *;
  using iterator = pointer;
  using const_iterator = const_pointer;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;

  // Constructors
  constexpr carray() = default;
  constexpr carray(const value_type& val)
    : carray(val, std::make_index_sequence<N>()) {}
  template <typename U, std::enable_if_t<std::is_convertible<U, T>::value, std::size_t> M>
  constexpr carray(U const (&init)[M])
    : carray(init, std::make_index_sequence<N>())
  {
    static_assert(M >= N, "Cannot initialize a carray with an smaller array");
  }
  template <typename U, std::enable_if_t<std::is_convertible<U, T>::value, std::size_t> M>
  constexpr carray(std::array<U, M> const &init)
    : carray(init.begin(), std::make_index_sequence<N>())
  {
    static_assert(M >= N, "Cannot initialize a carray with an smaller array");
  }
  template <typename U, std::enable_if_t<std::is_convertible<U, T>::value>* = nullptr>
  constexpr carray(std::initializer_list<U> init)
    : carray((check_initializer(init), init.begin()), std::make_index_sequence<N>())
  {
  }
  template <typename U, std::enable_if_t<std::is_convertible<U, T>::value>* = nullptr>
  constexpr carray(const carray<U, N>& rhs)
    : carray(rhs.begin(), std::make_index_sequence<N>())
  {
  }

  // Iterators
  constexpr iterator begin() noexcept { return data_; }
  constexpr const_iterator begin() const noexcept { return data_; }
  constexpr iterator end() noexcept { return data_ + N; }
  constexpr const_iterator end() const noexcept { return data_ + N; }

  // Capacity
  constexpr size_type size() const { return N; }
  constexpr size_type max_size() const { return N; }

  // Element access
  constexpr       reference operator[](std::size_t index) { return data_[index]; }
  constexpr const_reference operator[](std::size_t index) const { return data_[index]; }

  constexpr       reference at(std::size_t index) {
    if (index > N)
      FROZEN_THROW_OR_ABORT(std::out_of_range("Index (" + std::to_string(index) + ") out of bound (" + std::to_string(N) + ')'));
    return data_[index];
  }
  constexpr const_reference at(std::size_t index) const {
    if (index > N)
      FROZEN_THROW_OR_ABORT(std::out_of_range("Index (" + std::to_string(index) + ") out of bound (" + std::to_string(N) + ')'));
    return data_[index];
  }

  constexpr       reference front() { return data_[0]; }
  constexpr const_reference front() const { return data_[0]; }

  constexpr       reference back() { return data_[N - 1]; }
  constexpr const_reference back() const { return data_[N - 1]; }

  constexpr       value_type* data() noexcept { return data_; }
  constexpr const value_type* data() const noexcept { return data_; }
};
template <class T>
class carray<T, 0> {

public:
  // Container typdefs
  using value_type = T;
  using reference = value_type &;
  using const_reference = const value_type &;
  using pointer = value_type *;
  using const_pointer = const value_type *;
  using iterator = pointer;
  using const_iterator = const_pointer;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;

  // Constructors
  constexpr carray(void) = default;

};

} // namespace bits

} // namespace frozen

#endif

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/bits/constexpr_assert.h`
```
/*
 * Frozen
 * Copyright 2016 QuarksLab
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_LETITGO_CONSTEXPR_ASSERT_H
#define FROZEN_LETITGO_CONSTEXPR_ASSERT_H

#include <cassert>

#ifdef _MSC_VER

// FIXME: find a way to implement that correctly for msvc
#define constexpr_assert(cond, msg)
#else

#define constexpr_assert(cond, msg)\
    assert(cond && msg)
#endif

#endif


```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/bits/defines.h`
```
/*
 * Frozen
 * Copyright 2016 QuarksLab
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_LETITGO_DEFINES_H
#define FROZEN_LETITGO_DEFINES_H

#if defined(_MSVC_LANG) && !(defined(__EDG__) && defined(__clang__)) // TRANSITION, VSO#273681
  #define FROZEN_LETITGO_IS_MSVC
#endif

// Code taken from https://stackoverflow.com/questions/43639122/which-values-can-msvc-lang-have
#if defined(FROZEN_LETITGO_IS_MSVC)
  #if _MSVC_LANG > 201402
    #define FROZEN_LETITGO_HAS_CXX17  1
  #else /* _MSVC_LANG > 201402 */
    #define FROZEN_LETITGO_HAS_CXX17  0
  #endif /* _MSVC_LANG > 201402 */
#else /* _MSVC_LANG etc. */
  #if __cplusplus > 201402
    #define FROZEN_LETITGO_HAS_CXX17  1
  #else /* __cplusplus > 201402 */
    #define FROZEN_LETITGO_HAS_CXX17  0
  #endif /* __cplusplus > 201402 */
#endif /* _MSVC_LANG etc. */
// End if taken code

#if FROZEN_LETITGO_HAS_CXX17 == 1 && defined(FROZEN_LETITGO_IS_MSVC)
  #define FROZEN_LETITGO_HAS_STRING_VIEW // We assume Visual Studio always has string_view in C++17
#else
  #if FROZEN_LETITGO_HAS_CXX17 == 1 && __has_include(<string_view>)
    #define FROZEN_LETITGO_HAS_STRING_VIEW
  #endif
#endif

#ifdef __cpp_char8_t
  #define FROZEN_LETITGO_HAS_CHAR8T
#endif

#if defined(__cpp_deduction_guides) && __cpp_deduction_guides >= 201703L
  #define FROZEN_LETITGO_HAS_DEDUCTION_GUIDES
#endif

#if defined(__cpp_lib_constexpr_string) && __cpp_lib_constexpr_string >= 201907L
  #define FROZEN_LETITGO_HAS_CONSTEXPR_STRING
#endif

#endif // FROZEN_LETITGO_DEFINES_H

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/bits/exceptions.h`
```
/*
 * Frozen
 * Copyright 2016 QuarksLab
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_LETITGO_EXCEPTIONS_H
#define FROZEN_LETITGO_EXCEPTIONS_H

#if defined(FROZEN_NO_EXCEPTIONS) || (defined(_MSC_VER) && !defined(_CPPUNWIND)) || (!defined(_MSC_VER) && !defined(__cpp_exceptions))

#include <cstdlib>
#define FROZEN_THROW_OR_ABORT(_) std::abort()

#else

#include <stdexcept>
#define FROZEN_THROW_OR_ABORT(err) throw err


#endif

#endif

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/bits/mpl.h`
```
/*
 * Frozen
 * Copyright 2022 Giel van Schijndel
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_LETITGO_BITS_MPL_H
#define FROZEN_LETITGO_BITS_MPL_H

#include <utility>

namespace frozen {

namespace bits {

// Forward declarations
template <class, std::size_t>
class carray;

template <typename T>
struct remove_cv : std::remove_cv<T> {};

template <typename... T>
struct remove_cv<std::pair<T...>> {
  using type = std::pair<typename remove_cv<T>::type...>;
};

template <typename T, std::size_t N>
struct remove_cv<carray<T, N>> {
  using type = carray<typename remove_cv<T>::type, N>;
};

template <typename T>
using remove_cv_t = typename remove_cv<T>::type;

} // namespace bits

} // namespace frozen

#endif

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/bits/version.h`
```
/*
 * Frozen
 * Copyright 2016 QuarksLab
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_LETITGO_VERSION_H
#define FROZEN_LETITGO_VERSION_H

#define FROZEN_MAJOR_VERSION 1
#define FROZEN_MINOR_VERSION 1
#define FROZEN_PATCH_VERSION 1

#endif

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/map.h`
```
// https://github.com/serge-sans-paille/frozen
/*
 * Frozen
 * Copyright 2016 QuarksLab
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_LETITGO_MAP_H
#define FROZEN_LETITGO_MAP_H

#include "vendor/frozen/bits/algorithms.h"
#include "vendor/frozen/bits/basic_types.h"
#include "vendor/frozen/bits/exceptions.h"
#include "vendor/frozen/bits/mpl.h"
#include "vendor/frozen/bits/version.h"

#include <iterator>
#include <utility>

namespace frozen {

namespace impl {

template <class Comparator> class CompareKey : private Comparator {
public:
  constexpr Comparator const& key_comp() const noexcept {
    return static_cast<Comparator const&>(*this);
  }

  constexpr CompareKey(Comparator const &comparator)
      : Comparator(comparator) {}

  template <class Key1, class Key2, class Value>
  constexpr auto operator()(std::pair<Key1, Value> const &self,
                           std::pair<Key2, Value> const &other) const -> decltype(key_comp()(std::get<0>(self), std::get<0>(other))) {
    return key_comp()(std::get<0>(self), std::get<0>(other));
  }

  template <class Key1, class Key2, class Value>
  constexpr auto operator()(Key1 const &self_key,
                           std::pair<Key2, Value> const &other) const -> decltype(key_comp()(self_key, std::get<0>(other))) {
    return key_comp()(self_key, std::get<0>(other));
  }

  template <class Key1, class Key2, class Value>
  constexpr auto operator()(std::pair<Key1, Value> const &self,
                           Key2 const &other_key) const -> decltype(key_comp()(std::get<0>(self), other_key)) {
    return key_comp()(std::get<0>(self), other_key);
  }

  template <class Key1, class Key2>
  constexpr auto operator()(Key1 const &self_key, Key2 const &other_key) const -> decltype(key_comp()(self_key, other_key)) {
    return key_comp()(self_key, other_key);
  }
};

} // namespace impl

template <class Key, class Value, std::size_t N, class Compare = std::less<Key>>
class map : private impl::CompareKey<Compare> {
  using container_type = bits::carray<std::pair<const Key, Value>, N>;
  container_type items_;

public:
  using key_type = Key;
  using mapped_type = Value;
  using value_type = typename container_type::value_type;
  using size_type = typename container_type::size_type;
  using difference_type = typename container_type::difference_type;
  using key_compare = Compare;
  using value_compare = impl::CompareKey<Compare>;
  using reference = typename container_type::reference;
  using const_reference = typename container_type::const_reference;
  using pointer = typename container_type::pointer;
  using const_pointer = typename container_type::const_pointer;
  using iterator = typename container_type::iterator;
  using const_iterator = typename container_type::const_iterator;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

public:
  /* constructors */
  constexpr map(container_type items, Compare const &compare)
      : impl::CompareKey<Compare>{compare}
      , items_{bits::quicksort(bits::remove_cv_t<container_type>(items), value_comp())} {}

  explicit constexpr map(container_type items)
      : map{items, Compare{}} {}

  constexpr map(std::initializer_list<value_type> items, Compare const &compare)
      : map{container_type {items}, compare} {
      }

  constexpr map(std::initializer_list<value_type> items)
      : map{items, Compare{}} {}

  /* element access */
  constexpr Value const& at(Key const &key) const {
    return at_impl(*this, key);
  }
  constexpr Value& at(Key const &key) {
    return at_impl(*this, key);
  }

  /* iterators */
  constexpr iterator begin() { return items_.begin(); }
  constexpr const_iterator begin() const { return items_.begin(); }
  constexpr const_iterator cbegin() const { return items_.begin(); }
  constexpr iterator end() { return items_.end(); }
  constexpr const_iterator end() const { return items_.end(); }
  constexpr const_iterator cend() const { return items_.end(); }

  constexpr reverse_iterator rbegin() { return reverse_iterator{items_.end()}; }
  constexpr const_reverse_iterator rbegin() const { return const_reverse_iterator{items_.end()}; }
  constexpr const_reverse_iterator crbegin() const { return const_reverse_iterator{items_.end()}; }
  constexpr reverse_iterator rend() { return reverse_iterator{items_.begin()}; }
  constexpr const_reverse_iterator rend() const { return const_reverse_iterator{items_.begin()}; }
  constexpr const_reverse_iterator crend() const { return const_reverse_iterator{items_.begin()}; }

  /* capacity */
  constexpr bool empty() const { return !N; }
  constexpr size_type size() const { return N; }
  constexpr size_type max_size() const { return N; }

  /* lookup */
  
  template <class KeyType>
  constexpr std::size_t count(KeyType const &key) const {
    return bits::binary_search<N>(items_.begin(), key, value_comp());
  }
  
  template <class KeyType>
  constexpr const_iterator find(KeyType const &key) const {
    return map::find_impl(*this, key);
  }
  template <class KeyType>
  constexpr iterator find(KeyType const &key) {
    return map::find_impl(*this, key);
  }
  
  template <class KeyType>
  constexpr bool contains(KeyType const &key) const {
    return this->find(key) != this->end();
  }
  
  template <class KeyType>
  constexpr std::pair<const_iterator, const_iterator>
  equal_range(KeyType const &key) const {
    return equal_range_impl(*this, key);
  }
  template <class KeyType>
  constexpr std::pair<iterator, iterator> equal_range(KeyType const &key) {
    return equal_range_impl(*this, key);
  }
  
  template <class KeyType>
  constexpr const_iterator lower_bound(KeyType const &key) const {
    return lower_bound_impl(*this, key);
  }
  template <class KeyType>
  constexpr iterator lower_bound(KeyType const &key) {
    return lower_bound_impl(*this, key);
  }
  
  template <class KeyType>
  constexpr const_iterator upper_bound(KeyType const &key) const {
    return upper_bound_impl(*this, key);
  }
  template <class KeyType>
  constexpr iterator upper_bound(KeyType const &key) {
    return upper_bound_impl(*this, key);
  }

  /* observers */
  constexpr const key_compare& key_comp() const { return value_comp().key_comp(); }
  constexpr const value_compare& value_comp() const { return static_cast<impl::CompareKey<Compare> const&>(*this); }

 private:
  template <class This, class KeyType>
  static inline constexpr auto& at_impl(This&& self, KeyType const &key) {
    auto where = self.find(key);
    if (where != self.end())
      return where->second;
    else
      FROZEN_THROW_OR_ABORT(std::out_of_range("unknown key"));
  }

  template <class This, class KeyType>
  static inline constexpr auto find_impl(This&& self, KeyType const &key) {
    auto where = self.lower_bound(key);
    if (where != self.end() && !self.value_comp()(key, *where))
      return where;
    else
      return self.end();
  }

  template <class This, class KeyType>
  static inline constexpr auto equal_range_impl(This&& self, KeyType const &key) {
    auto lower = self.lower_bound(key);
    using lower_t = decltype(lower);
    if (lower != self.end() && !self.value_comp()(key, *lower))
      return std::pair<lower_t, lower_t>{lower, lower + 1};
    else
      return std::pair<lower_t, lower_t>{lower, lower};
  }

  template <class This, class KeyType>
  static inline constexpr auto lower_bound_impl(This&& self, KeyType const &key) -> decltype(self.end()) {
    return bits::lower_bound<N>(self.items_.begin(), key, self.value_comp());
  }

  template <class This, class KeyType>
  static inline constexpr auto upper_bound_impl(This&& self, KeyType const &key) {
    auto lower = self.lower_bound(key);
    if (lower != self.end() && !self.value_comp()(key, *lower))
      return lower + 1;
    else
      return lower;
  }
};

template <class Key, class Value, class Compare>
class map<Key, Value, 0, Compare> : private impl::CompareKey<Compare> {
  using container_type = bits::carray<std::pair<Key, Value>, 0>;

public:
  using key_type = Key;
  using mapped_type = Value;
  using value_type = typename container_type::value_type;
  using size_type = typename container_type::size_type;
  using difference_type = typename container_type::difference_type;
  using key_compare = Compare;
  using value_compare = impl::CompareKey<Compare>;
  using reference = typename container_type::reference;
  using const_reference = typename container_type::const_reference;
  using pointer = typename container_type::pointer;
  using const_pointer = typename container_type::const_pointer;
  using iterator = pointer;
  using const_iterator = const_pointer;
  using reverse_iterator = pointer;
  using const_reverse_iterator = const_pointer;

public:
  /* constructors */
  constexpr map(const map &other) = default;
  constexpr map(std::initializer_list<value_type>, Compare const &compare)
      : impl::CompareKey<Compare>{compare} {}
  constexpr map(std::initializer_list<value_type> items)
      : map{items, Compare{}} {}

  /* element access */
  template <class KeyType>
  constexpr mapped_type at(KeyType const &) const {
    FROZEN_THROW_OR_ABORT(std::out_of_range("invalid key"));
  }
  template <class KeyType>
  constexpr mapped_type at(KeyType const &) {
    FROZEN_THROW_OR_ABORT(std::out_of_range("invalid key"));
  }

  /* iterators */
  constexpr iterator begin() { return nullptr; }
  constexpr const_iterator begin() const { return nullptr; }
  constexpr const_iterator cbegin() const { return nullptr; }
  constexpr iterator end() { return nullptr; }
  constexpr const_iterator end() const { return nullptr; }
  constexpr const_iterator cend() const { return nullptr; }

  constexpr reverse_iterator rbegin() { return nullptr; }
  constexpr const_reverse_iterator rbegin() const { return nullptr; }
  constexpr const_reverse_iterator crbegin() const { return nullptr; }
  constexpr reverse_iterator rend() { return nullptr; }
  constexpr const_reverse_iterator rend() const { return nullptr; }
  constexpr const_reverse_iterator crend() const { return nullptr; }

  /* capacity */
  constexpr bool empty() const { return true; }
  constexpr size_type size() const { return 0; }
  constexpr size_type max_size() const { return 0; }

  /* lookup */

  template <class KeyType>
  constexpr std::size_t count(KeyType const &) const { return 0; }

  template <class KeyType>
  constexpr const_iterator find(KeyType const &) const { return end(); }
  template <class KeyType>
  constexpr iterator find(KeyType const &) { return end(); }

  template <class KeyType>
  constexpr std::pair<const_iterator, const_iterator>
  equal_range(KeyType const &) const { return {end(), end()}; }
  template <class KeyType>
  constexpr std::pair<iterator, iterator>
  equal_range(KeyType const &) { return {end(), end()}; }

  template <class KeyType>
  constexpr const_iterator lower_bound(KeyType const &) const { return end(); }
  template <class KeyType>
  constexpr iterator lower_bound(KeyType const &) { return end(); }

  template <class KeyType>
  constexpr const_iterator upper_bound(KeyType const &) const { return end(); }
  template <class KeyType>
  constexpr iterator upper_bound(KeyType const &) { return end(); }

/* observers */
  constexpr key_compare const& key_comp() const { return value_comp().key_comp(); }
  constexpr value_compare const& value_comp() const { return static_cast<impl::CompareKey<Compare> const&>(*this); }
};

template <typename T, typename U, typename Compare = std::less<T>>
constexpr auto make_map(bits::ignored_arg = {}/* for consistency with the initializer below for N = 0*/) {
  return map<T, U, 0, Compare>{};
}

template <typename T, typename U, std::size_t N>
constexpr auto make_map(std::pair<T, U> const (&items)[N]) {
  return map<T, U, N>{items};
}

template <typename T, typename U, std::size_t N>
constexpr auto make_map(std::array<std::pair<T, U>, N> const &items) {
  return map<T, U, N>{items};
}

template <typename T, typename U, typename Compare, std::size_t N>
constexpr auto make_map(std::pair<T, U> const (&items)[N], Compare const& compare = Compare{}) {
  return map<T, U, N, Compare>{items, compare};
}

template <typename T, typename U, typename Compare, std::size_t N>
constexpr auto make_map(std::array<std::pair<T, U>, N> const &items, Compare const& compare = Compare{}) {
  return map<T, U, N, Compare>{items, compare};
}

} // namespace frozen

#endif

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/frozen/set.h`
```
// https://github.com/serge-sans-paille/frozen
/*
 * Frozen
 * Copyright 2016 QuarksLab
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#ifndef FROZEN_SET_H
#define FROZEN_SET_H

#include "vendor/frozen/bits/algorithms.h"
#include "vendor/frozen/bits/basic_types.h"
#include "vendor/frozen/bits/version.h"
#include "vendor/frozen/bits/defines.h"

#include <iterator>
#include <utility>

namespace frozen {

template <class Key, std::size_t N, class Compare = std::less<Key>> class set : private Compare {
  using container_type = bits::carray<Key, N>;
  container_type keys_;

public:
  /* container typedefs*/
  using key_type = Key;
  using value_type = Key;
  using size_type = typename container_type::size_type;
  using difference_type = typename container_type::size_type;
  using key_compare = Compare;
  using value_compare = Compare;
  using reference = typename container_type::const_reference;
  using const_reference = reference;
  using pointer = typename container_type::const_pointer;
  using const_pointer = pointer;
  using iterator = typename container_type::const_iterator;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_iterator = iterator;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

public:
  /* constructors */
  constexpr set(const set &other) = default;

  constexpr set(container_type keys, Compare const & comp)
      : Compare{comp}
      , keys_(bits::quicksort(keys, value_comp())) {
      }

  explicit constexpr set(container_type keys)
      : set{keys, Compare{}} {}

  constexpr set(std::initializer_list<Key> keys, Compare const & comp)
      : set{container_type{keys}, comp} {
      }

  constexpr set(std::initializer_list<Key> keys)
      : set{keys, Compare{}} {}

  constexpr set& operator=(const set &other) = default;

  /* capacity */
  constexpr bool empty() const { return !N; }
  constexpr size_type size() const { return N; }
  constexpr size_type max_size() const { return N; }

  /* lookup */
  template <class KeyType>
  constexpr std::size_t count(KeyType const &key) const {
    return bits::binary_search<N>(keys_.begin(), key, value_comp());
  }

  template <class KeyType>
  constexpr const_iterator find(KeyType const &key) const {
    const_iterator where = lower_bound(key);
    if ((where != end()) && !value_comp()(key, *where))
      return where;
    else
      return end();
  }
  
  template <class KeyType>
  constexpr bool contains(KeyType const &key) const {
    return this->find(key) != keys_.end();
  }

  template <class KeyType>
  constexpr std::pair<const_iterator, const_iterator> equal_range(KeyType const &key) const {
    auto const lower = lower_bound(key);
    if (lower == end())
      return {lower, lower};
    else
      return {lower, lower + 1};
  }

  template <class KeyType>
  constexpr const_iterator lower_bound(KeyType const &key) const {
    auto const where = bits::lower_bound<N>(keys_.begin(), key, value_comp());
    if ((where != end()) && !value_comp()(key, *where))
      return where;
    else
      return end();
  }

  template <class KeyType>
  constexpr const_iterator upper_bound(KeyType const &key) const {
    auto const where = bits::lower_bound<N>(keys_.begin(), key, value_comp());
    if ((where != end()) && !value_comp()(key, *where))
      return where + 1;
    else
      return end();
  }

  /* observers */
  constexpr const key_compare& key_comp() const { return value_comp(); }
  constexpr const key_compare& value_comp() const { return static_cast<const Compare&>(*this); }

  /* iterators */
  constexpr const_iterator begin() const { return keys_.begin(); }
  constexpr const_iterator cbegin() const { return keys_.begin(); }
  constexpr const_iterator end() const { return keys_.end(); }
  constexpr const_iterator cend() const { return keys_.end(); }

  constexpr const_reverse_iterator rbegin() const { return const_reverse_iterator{keys_.end()}; }
  constexpr const_reverse_iterator crbegin() const { return const_reverse_iterator{keys_.end()}; }
  constexpr const_reverse_iterator rend() const { return const_reverse_iterator{keys_.begin()}; }
  constexpr const_reverse_iterator crend() const { return const_reverse_iterator{keys_.begin()}; }

  /* comparison */
  constexpr bool operator==(set const& rhs) const { return bits::equal(begin(), end(), rhs.begin()); }
  constexpr bool operator!=(set const& rhs) const { return !(*this == rhs); }
  constexpr bool operator<(set const& rhs) const { return bits::lexicographical_compare(begin(), end(), rhs.begin(), rhs.end()); }
  constexpr bool operator<=(set const& rhs) const { return (*this < rhs) || (*this == rhs); }
  constexpr bool operator>(set const& rhs) const { return bits::lexicographical_compare(rhs.begin(), rhs.end(), begin(), end()); }
  constexpr bool operator>=(set const& rhs) const { return (*this > rhs) || (*this == rhs); }
};

template <class Key, class Compare> class set<Key, 0, Compare> : private Compare {
  using container_type = bits::carray<Key, 0>; // just for the type definitions

public:
  /* container typedefs*/
  using key_type = Key;
  using value_type = Key;
  using size_type = typename container_type::size_type;
  using difference_type = typename container_type::size_type;
  using key_compare = Compare;
  using value_compare = Compare;
  using reference = typename container_type::const_reference;
  using const_reference = reference;
  using pointer = typename container_type::const_pointer;
  using const_pointer = pointer;
  using iterator = pointer;
  using reverse_iterator = pointer;
  using const_iterator = const_pointer;
  using const_reverse_iterator = const_pointer;

public:
  /* constructors */
  constexpr set(const set &other) = default;
  constexpr set(bits::carray<Key, 0>, Compare const &) {}
  explicit constexpr set(bits::carray<Key, 0>) {}

  constexpr set(std::initializer_list<Key>, Compare const &comp)
      : Compare{comp} {}
  constexpr set(std::initializer_list<Key> keys) : set{keys, Compare{}} {}

  constexpr set& operator=(const set &other) = default;

  /* capacity */
  constexpr bool empty() const { return true; }
  constexpr size_type size() const { return 0; }
  constexpr size_type max_size() const { return 0; }

  /* lookup */
  template <class KeyType>
  constexpr std::size_t count(KeyType const &) const { return 0; }

  template <class KeyType>
  constexpr const_iterator find(KeyType const &) const { return end(); }

  template <class KeyType>
  constexpr std::pair<const_iterator, const_iterator>
  equal_range(KeyType const &) const { return {end(), end()}; }

  template <class KeyType>
  constexpr const_iterator lower_bound(KeyType const &) const { return end(); }

  template <class KeyType>
  constexpr const_iterator upper_bound(KeyType const &) const { return end(); }

  /* observers */
  constexpr const key_compare& key_comp() const { return value_comp(); }
  constexpr const key_compare& value_comp() const { return static_cast<Compare const&>(*this); }

  /* iterators */
  constexpr const_iterator begin() const { return nullptr; }
  constexpr const_iterator cbegin() const { return nullptr; }
  constexpr const_iterator end() const { return nullptr; }
  constexpr const_iterator cend() const { return nullptr; }

  constexpr const_reverse_iterator rbegin() const { return nullptr; }
  constexpr const_reverse_iterator crbegin() const { return nullptr; }
  constexpr const_reverse_iterator rend() const { return nullptr; }
  constexpr const_reverse_iterator crend() const { return nullptr; }
};

template <typename T>
constexpr auto make_set(bits::ignored_arg = {}/* for consistency with the initializer below for N = 0*/) {
  return set<T, 0>{};
}

template <typename T, std::size_t N>
constexpr auto make_set(const T (&args)[N]) {
  return set<T, N>(args);
}

template <typename T, std::size_t N>
constexpr auto make_set(std::array<T, N> const &args) {
  return set<T, N>(args);
}

template <typename T, typename Compare, std::size_t N>
constexpr auto make_set(const T (&args)[N], Compare const& compare = Compare{}) {
  return set<T, N, Compare>(args, compare);
}

template <typename T, typename Compare, std::size_t N>
constexpr auto make_set(std::array<T, N> const &args, Compare const& compare = Compare{}) {
  return set<T, N, Compare>(args, compare);
}

#ifdef FROZEN_LETITGO_HAS_DEDUCTION_GUIDES

template<class T, class... Args>
set(T, Args...) -> set<T, sizeof...(Args) + 1>;

#endif // FROZEN_LETITGO_HAS_DEDUCTION_GUIDES

} // namespace frozen

#endif

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/src/vendor`
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/ieee754_types.hpp`
```
// https://github.com/kkimdev/ieee754-types
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#ifndef IEEE754_TYPES_HPP_
#define IEEE754_TYPES_HPP_

// Based on IEEE 754-2008

#if __cplusplus < 201703L
#error This file requires C++17
#endif

#include <climits>
#include <limits>
#include <type_traits>

namespace IEEE_754 {
namespace detail {

template <typename T>
inline constexpr int get_storage_bits() {
  return sizeof(T) * CHAR_BIT;
}

template <typename T>
inline constexpr int get_exponent_bits() {
  int exponent_range = ::std::numeric_limits<T>::max_exponent -
                       ::std::numeric_limits<T>::min_exponent;
  int bits = 0;
  while ((exponent_range >> bits) > 0) ++bits;
  return bits;
}

template <typename T>
inline constexpr int get_mantissa_bits() {
  return ::std::numeric_limits<T>::digits - 1;
}

template <int storage_bits>
inline constexpr int standard_binary_interchange_format_exponent_bits() {
  constexpr bool is_valid_storage_bits =
      storage_bits == 16 ||   //
      storage_bits == 32 ||   //
      storage_bits == 64 ||   //
      storage_bits == 128 ||  //
      (storage_bits > 128 && storage_bits % 32 == 0);
  static_assert(
      is_valid_storage_bits,
      "IEEE 754-2008 standard binary interchange formats are only defined for "
      "the following storage width in bits: 16, 32, 64, 128, and any multiple "
      "of 32 of at least 128.");
  static_assert(!(is_valid_storage_bits && storage_bits > 128),
                "Not Implemented for storage bits larger than 128.");

  if (storage_bits == 16) return 5;
  if (storage_bits == 32) return 8;
  if (storage_bits == 64) return 11;
  if (storage_bits == 128) return 15;

  throw;
}

template <int storage_bits>
inline constexpr int standard_binary_interchange_format_mantissa_bits() {
  return storage_bits -
         standard_binary_interchange_format_exponent_bits<storage_bits>() - 1;
}

static_assert(standard_binary_interchange_format_exponent_bits<16>()  == 5,  "");
static_assert(standard_binary_interchange_format_exponent_bits<32>()  == 8,  "");
static_assert(standard_binary_interchange_format_exponent_bits<64>()  == 11, "");
static_assert(standard_binary_interchange_format_exponent_bits<128>() == 15, "");

static_assert(standard_binary_interchange_format_mantissa_bits<16>()  == 10, "");
static_assert(standard_binary_interchange_format_mantissa_bits<32>()  == 23, "");
static_assert(standard_binary_interchange_format_mantissa_bits<64>()  == 52, "");
static_assert(standard_binary_interchange_format_mantissa_bits<128>() == 112,"");

template <int storage_bits, int exponent_bits, int mantissa_bits>
struct Is_Ieee754_2008_Binary_Interchange_Format {
  // TODO: as of 2018-06-11 clang-format doesn't handle the following section
  //       well.
  // clang-format off
  template <typename T>
  static constexpr bool value =
      ::std::is_floating_point<T>()            &&
      ::std::numeric_limits<T>::is_iec559      &&
      ::std::numeric_limits<T>::radix == 2     &&
      get_storage_bits<T>() == storage_bits    &&
      get_exponent_bits<T>() == exponent_bits  &&
      get_mantissa_bits<T>() == mantissa_bits;
  // clang-format on
};

template <typename C, typename T, typename... Ts>
inline constexpr auto find_type() {
  throw;

  if constexpr (C::template value<T>) {
    return T();
  } else if constexpr (sizeof...(Ts) >= 1) {
    return find_type<C, Ts...>();
  } else {
    return void();
  }
}

template <int storage_bits,
          int exponent_bits =
              standard_binary_interchange_format_exponent_bits<storage_bits>(),
          int mantissa_bits =
              standard_binary_interchange_format_mantissa_bits<storage_bits>()>
using BinaryFloatOrVoid =
    decltype(find_type<                                                //
             Is_Ieee754_2008_Binary_Interchange_Format<storage_bits,   //
                                                       exponent_bits,  //
                                                       mantissa_bits>,
             float, double, long double>());

template <typename T>
struct AssertTypeFound {
  static_assert(
      !::std::is_same_v<T, void>,
      "No corresponding IEEE 754-2008 binary interchange format found.");
  using type = T;
};

}  // namespace detail

namespace _2008 {
template <int storage_bits>
using Binary = typename detail::AssertTypeFound<
    detail::BinaryFloatOrVoid<storage_bits>>::type;
}  // namespace _2008

// Testing
namespace detail {

template <int storage_bits, int exponent_bits, int mantissa_bits>
inline void test_if_type_exists() {
  throw;

  if constexpr (!::std::is_same_v<BinaryFloatOrVoid<storage_bits>, void>) {
    using T = ::IEEE_754::_2008::Binary<storage_bits>;
    static_assert(::std::is_floating_point<T>(), "");
    static_assert(::std::numeric_limits<T>::is_iec559, "");
    static_assert(::std::numeric_limits<T>::radix == 2, "");
    static_assert(get_storage_bits<T>() == storage_bits, "");
    static_assert(get_exponent_bits<T>() == exponent_bits, "");
    static_assert(get_mantissa_bits<T>() == mantissa_bits, "");
  }
}

inline void tests() {
  throw;

  test_if_type_exists<16, 5, 10>();
  test_if_type_exists<32, 8, 23>();
  test_if_type_exists<64, 11, 52>();
  test_if_type_exists<128, 15, 112>();
}

}  // namespace detail

}  // namespace IEEE_754

#endif  // IEEE754_TYPES_HPP_

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/ini.c`
```
/* inih -- simple .INI file parser

SPDX-License-Identifier: BSD-3-Clause

Copyright (C) 2009-2020, Ben Hoyt

inih is released under the New BSD license (see LICENSE.txt). Go to the project
home page for more info:

https://github.com/benhoyt/inih

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "ini.h"

#if !INI_USE_STACK
#if INI_CUSTOM_ALLOCATOR
#include <stddef.h>
void* ini_malloc(size_t size);
void ini_free(void* ptr);
void* ini_realloc(void* ptr, size_t size);
#else
#include <stdlib.h>
#define ini_malloc malloc
#define ini_free free
#define ini_realloc realloc
#endif
#endif

#define MAX_SECTION 50
#define MAX_NAME 50

/* Used by ini_parse_string() to keep track of string parsing state. */
typedef struct {
    const char* ptr;
    size_t num_left;
} ini_parse_string_ctx;

/* Strip whitespace chars off end of given string, in place. Return s. */
static char* ini_rstrip(char* s)
{
    char* p = s + strlen(s);
    while (p > s && isspace((unsigned char)(*--p)))
        *p = '\0';
    return s;
}

/* Return pointer to first non-whitespace char in given string. */
static char* ini_lskip(const char* s)
{
    while (*s && isspace((unsigned char)(*s)))
        s++;
    return (char*)s;
}

/* Return pointer to first char (of chars) or inline comment in given string,
   or pointer to NUL at end of string if neither found. Inline comment must
   be prefixed by a whitespace character to register as a comment. */
static char* ini_find_chars_or_comment(const char* s, const char* chars)
{
#if INI_ALLOW_INLINE_COMMENTS
    int was_space = 0;
    while (*s && (!chars || !strchr(chars, *s)) &&
           !(was_space && strchr(INI_INLINE_COMMENT_PREFIXES, *s))) {
        was_space = isspace((unsigned char)(*s));
        s++;
    }
#else
    while (*s && (!chars || !strchr(chars, *s))) {
        s++;
    }
#endif
    return (char*)s;
}

/* Similar to strncpy, but ensures dest (size bytes) is
   NUL-terminated, and doesn't pad with NULs. */
static char* ini_strncpy0(char* dest, const char* src, size_t size)
{
    /* Could use strncpy internally, but it causes gcc warnings (see issue #91) */
    size_t i;
    for (i = 0; i < size - 1 && src[i]; i++)
        dest[i] = src[i];
    dest[i] = '\0';
    return dest;
}

/* See documentation in header file. */
int ini_parse_stream(ini_reader reader, void* stream, ini_handler handler,
                     void* user)
{
    /* Uses a fair bit of stack (use heap instead if you need to) */
#if INI_USE_STACK
    char line[INI_MAX_LINE];
    size_t max_line = INI_MAX_LINE;
#else
    char* line;
    size_t max_line = INI_INITIAL_ALLOC;
#endif
#if INI_ALLOW_REALLOC && !INI_USE_STACK
    char* new_line;
#endif
    char section[MAX_SECTION] = "";
#if INI_ALLOW_MULTILINE
    char prev_name[MAX_NAME] = "";
#endif

    size_t offset;
    char* start;
    char* end;
    char* name;
    char* value;
    int lineno = 0;
    int error = 0;
    char abyss[16];  /* Used to consume input when a line is too long. */

#if !INI_USE_STACK
    line = (char*)ini_malloc(INI_INITIAL_ALLOC);
    if (!line) {
        return -2;
    }
#endif

#if INI_HANDLER_LINENO
#define HANDLER(u, s, n, v) handler(u, s, n, v, lineno)
#else
#define HANDLER(u, s, n, v) handler(u, s, n, v)
#endif

    /* Scan through stream line by line */
    while (reader(line, (int)max_line, stream) != NULL) {
        offset = strlen(line);

#if INI_ALLOW_REALLOC && !INI_USE_STACK
        while (offset == max_line - 1 && line[offset - 1] != '\n') {
            max_line *= 2;
            if (max_line > INI_MAX_LINE)
                max_line = INI_MAX_LINE;
            new_line = ini_realloc(line, max_line);
            if (!new_line) {
                ini_free(line);
                return -2;
            }
            line = new_line;
            if (reader(line + offset, (int)(max_line - offset), stream) == NULL)
                break;
            offset += strlen(line + offset);
            if (max_line >= INI_MAX_LINE)
                break;
        }
#endif

        lineno++;

        /* If line exceeded INI_MAX_LINE bytes, discard till end of line. */
        if (offset == max_line - 1 && line[offset - 1] != '\n') {
            while (reader(abyss, sizeof(abyss), stream) != NULL) {
                if (!error)
                    error = lineno;
                if (abyss[strlen(abyss) - 1] == '\n')
                    break;
            }
        }

        start = line;
#if INI_ALLOW_BOM
        if (lineno == 1 && (unsigned char)start[0] == 0xEF &&
                           (unsigned char)start[1] == 0xBB &&
                           (unsigned char)start[2] == 0xBF) {
            start += 3;
        }
#endif
        start = ini_rstrip(ini_lskip(start));

        if (strchr(INI_START_COMMENT_PREFIXES, *start)) {
            /* Start-of-line comment */
        }
#if INI_ALLOW_MULTILINE
        else if (*prev_name && *start && start > line) {
#if INI_ALLOW_INLINE_COMMENTS
            end = ini_find_chars_or_comment(start, NULL);
            if (*end)
                *end = '\0';
            ini_rstrip(start);
#endif
            /* Non-blank line with leading whitespace, treat as continuation
               of previous name's value (as per Python configparser). */
            if (!HANDLER(user, section, prev_name, start) && !error)
                error = lineno;
        }
#endif
        else if (*start == '[') {
            /* A "[section]" line */
            end = ini_find_chars_or_comment(start + 1, "]");
            if (*end == ']') {
                *end = '\0';
                ini_strncpy0(section, start + 1, sizeof(section));
#if INI_ALLOW_MULTILINE
                *prev_name = '\0';
#endif
#if INI_CALL_HANDLER_ON_NEW_SECTION
                if (!HANDLER(user, section, NULL, NULL) && !error)
                    error = lineno;
#endif
            }
            else if (!error) {
                /* No ']' found on section line */
                error = lineno;
            }
        }
        else if (*start) {
            /* Not a comment, must be a name[=:]value pair */
            end = ini_find_chars_or_comment(start, "=:");
            if (*end == '=' || *end == ':') {
                *end = '\0';
                name = ini_rstrip(start);
                value = end + 1;
#if INI_ALLOW_INLINE_COMMENTS
                end = ini_find_chars_or_comment(value, NULL);
                if (*end)
                    *end = '\0';
#endif
                value = ini_lskip(value);
                ini_rstrip(value);

#if INI_ALLOW_MULTILINE
                ini_strncpy0(prev_name, name, sizeof(prev_name));
#endif
                /* Valid name[=:]value pair found, call handler */
                if (!HANDLER(user, section, name, value) && !error)
                    error = lineno;
            }
            else if (!error) {
                /* No '=' or ':' found on name[=:]value line */
#if INI_ALLOW_NO_VALUE
                *end = '\0';
                name = ini_rstrip(start);
                if (!HANDLER(user, section, name, NULL) && !error)
                    error = lineno;
#else
                error = lineno;
#endif
            }
        }

#if INI_STOP_ON_FIRST_ERROR
        if (error)
            break;
#endif
    }

#if !INI_USE_STACK
    ini_free(line);
#endif

    return error;
}

/* See documentation in header file. */
int ini_parse_file(FILE* file, ini_handler handler, void* user)
{
    return ini_parse_stream((ini_reader)fgets, file, handler, user);
}

/* See documentation in header file. */
int ini_parse(const char* filename, ini_handler handler, void* user)
{
    FILE* file;
    int error;

    file = fopen(filename, "r");
    if (!file)
        return -1;
    error = ini_parse_file(file, handler, user);
    fclose(file);
    return error;
}

/* An ini_reader function to read the next line from a string buffer. This
   is the fgets() equivalent used by ini_parse_string(). */
static char* ini_reader_string(char* str, int num, void* stream) {
    ini_parse_string_ctx* ctx = (ini_parse_string_ctx*)stream;
    const char* ctx_ptr = ctx->ptr;
    size_t ctx_num_left = ctx->num_left;
    char* strp = str;
    char c;

    if (ctx_num_left == 0 || num < 2)
        return NULL;

    while (num > 1 && ctx_num_left != 0) {
        c = *ctx_ptr++;
        ctx_num_left--;
        *strp++ = c;
        if (c == '\n')
            break;
        num--;
    }

    *strp = '\0';
    ctx->ptr = ctx_ptr;
    ctx->num_left = ctx_num_left;
    return str;
}

/* See documentation in header file. */
int ini_parse_string(const char* string, ini_handler handler, void* user) {
    ini_parse_string_ctx ctx;

    ctx.ptr = string;
    ctx.num_left = strlen(string);
    return ini_parse_stream((ini_reader)ini_reader_string, &ctx, handler,
                            user);
}

```
#### File: `temp_terra-awg-main (9)/terra-awg-main/src/vendor/ini.h`
```
/* inih -- simple .INI file parser

SPDX-License-Identifier: BSD-3-Clause

Copyright (C) 2009-2020, Ben Hoyt

inih is released under the New BSD license (see LICENSE.txt). Go to the project
home page for more info:

https://github.com/benhoyt/inih

*/

#ifndef INI_H
#define INI_H

/* Make this header file easier to include in C++ code */
#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>

/* Nonzero if ini_handler callback should accept lineno parameter. */
#ifndef INI_HANDLER_LINENO
#define INI_HANDLER_LINENO 0
#endif

/* Visibility symbols, required for Windows DLLs */
#ifndef INI_API
#if defined _WIN32 || defined __CYGWIN__
#	ifdef INI_SHARED_LIB
#		ifdef INI_SHARED_LIB_BUILDING
#			define INI_API __declspec(dllexport)
#		else
#			define INI_API __declspec(dllimport)
#		endif
#	else
#		define INI_API
#	endif
#else
#	if defined(__GNUC__) && __GNUC__ >= 4
#		define INI_API __attribute__ ((visibility ("default")))
#	else
#		define INI_API
#	endif
#endif
#endif

/* Typedef for prototype of handler function.

   Note that even though the value parameter has type "const char*", the user
   may cast to "char*" and modify its content, as the value is not used again
   after the call to ini_handler. This is not true of section and name --
   those must not be modified.
*/
#if INI_HANDLER_LINENO
typedef int (*ini_handler)(void* user, const char* section,
                           const char* name, const char* value,
                           int lineno);
#else
typedef int (*ini_handler)(void* user, const char* section,
                           const char* name, const char* value);
#endif

/* Typedef for prototype of fgets-style reader function. */
typedef char* (*ini_reader)(char* str, int num, void* stream);

/* Parse given INI-style file. May have [section]s, name=value pairs
   (whitespace stripped), and comments starting with ';' (semicolon). Section
   is "" if name=value pair parsed before any section heading. name:value
   pairs are also supported as a concession to Python's configparser.

   For each name=value pair parsed, call handler function with given user
   pointer as well as section, name, and value (data only valid for duration
   of handler call). Handler should return nonzero on success, zero on error.

   Returns 0 on success, line number of first error on parse error (doesn't
   stop on first error), -1 on file open error, or -2 on memory allocation
   error (only when INI_USE_STACK is zero).
*/
INI_API int ini_parse(const char* filename, ini_handler handler, void* user);

/* Same as ini_parse(), but takes a FILE* instead of filename. This doesn't
   close the file when it's finished -- the caller must do that. */
INI_API int ini_parse_file(FILE* file, ini_handler handler, void* user);

/* Same as ini_parse(), but takes an ini_reader function pointer instead of
   filename. Used for implementing custom or string-based I/O (see also
   ini_parse_string). */
INI_API int ini_parse_stream(ini_reader reader, void* stream, ini_handler handler,
                     void* user);

/* Same as ini_parse(), but takes a zero-terminated string with the INI data
instead of a file. Useful for parsing INI data from a network socket or
already in memory. */
INI_API int ini_parse_string(const char* string, ini_handler handler, void* user);

/* Nonzero to allow multi-line value parsing, in the style of Python's
   configparser. If allowed, ini_parse() will call the handler with the same
   name for each subsequent line parsed. */
#ifndef INI_ALLOW_MULTILINE
#define INI_ALLOW_MULTILINE 1
#endif

/* Nonzero to allow a UTF-8 BOM sequence (0xEF 0xBB 0xBF) at the start of
   the file. See https://github.com/benhoyt/inih/issues/21 */
#ifndef INI_ALLOW_BOM
#define INI_ALLOW_BOM 1
#endif

/* Chars that begin a start-of-line comment. Per Python configparser, allow
   both ; and # comments at the start of a line by default. */
#ifndef INI_START_COMMENT_PREFIXES
#define INI_START_COMMENT_PREFIXES ";#"
#endif

/* Nonzero to allow inline comments (with valid inline comment characters
   specified by INI_INLINE_COMMENT_PREFIXES). Set to 0 to turn off and match
   Python 3.2+ configparser behaviour. */
#ifndef INI_ALLOW_INLINE_COMMENTS
#define INI_ALLOW_INLINE_COMMENTS 1
#endif
#ifndef INI_INLINE_COMMENT_PREFIXES
#define INI_INLINE_COMMENT_PREFIXES ";"
#endif

/* Nonzero to use stack for line buffer, zero to use heap (malloc/free). */
#ifndef INI_USE_STACK
#define INI_USE_STACK 1
#endif

/* Maximum line length for any line in INI file (stack or heap). Note that
   this must be 3 more than the longest line (due to '\r', '\n', and '\0'). */
#ifndef INI_MAX_LINE
#define INI_MAX_LINE 200
#endif

/* Nonzero to allow heap line buffer to grow via realloc(), zero for a
   fixed-size buffer of INI_MAX_LINE bytes. Only applies if INI_USE_STACK is
   zero. */
#ifndef INI_ALLOW_REALLOC
#define INI_ALLOW_REALLOC 0
#endif

/* Initial size in bytes for heap line buffer. Only applies if INI_USE_STACK
   is zero. */
#ifndef INI_INITIAL_ALLOC
#define INI_INITIAL_ALLOC 200
#endif

/* Stop parsing on first error (default is to keep parsing). */
#ifndef INI_STOP_ON_FIRST_ERROR
#define INI_STOP_ON_FIRST_ERROR 0
#endif

/* Nonzero to call the handler at the start of each new section (with
   name and value NULL). Default is to only call the handler on
   each name=value pair. */
#ifndef INI_CALL_HANDLER_ON_NEW_SECTION
#define INI_CALL_HANDLER_ON_NEW_SECTION 0
#endif

/* Nonzero to allow a name without a value (no '=' or ':' on the line) and
   call the handler with value NULL in this case. Default is to treat
   no-value lines as an error. */
#ifndef INI_ALLOW_NO_VALUE
#define INI_ALLOW_NO_VALUE 0
#endif

/* Nonzero to use custom ini_malloc, ini_free, and ini_realloc memory
   allocation functions (INI_USE_STACK must also be 0). These functions must
   have the same signatures as malloc/free/realloc and behave in a similar
   way. ini_realloc is only needed if INI_ALLOW_REALLOC is set. */
#ifndef INI_CUSTOM_ALLOCATOR
#define INI_CUSTOM_ALLOCATOR 0
#endif


#ifdef __cplusplus
}
#endif

#endif /* INI_H */

```
### Folder: `temp_terra-awg-main (9)/terra-awg-main/util`
#### File: `temp_terra-awg-main (9)/terra-awg-main/util/importStructure.py`
```
#!/usr/bin/env python3

import sys
import textwrap

try:
    from natsort import natsorted
except ModuleNotFoundError:
    natsorted = sorted

def readUint8(f):
    return int.from_bytes(f.read(1))

def readUint16(f):
    return int.from_bytes(f.read(2), byteorder='little')

def readUint32(f):
    return int.from_bytes(f.read(4), byteorder='little')

def readString(f):
    # LEB128 encoded length prefix.
    strLen = 0
    shift = 0
    while True:
        b = readUint8(f)
        strLen |= (b & 0x7f) << shift
        if (b & 0x80) == 0:
            break
        shift += 7
    return f.read(strLen).decode('utf-8')

def readBitVec(f):
    vecLen = readUint16(f)
    b = 0
    mask = 0x80
    bitVec = []
    for i in range(vecLen):
        if mask == 0x80:
            b = readUint8(f)
            mask = 0x01
        else:
            mask <<= 1
        bitVec.append((b & mask) == mask)
    return bitVec

def loadTiles(filename):
    with open(filename, mode='rb') as f:
        print('//', readString(f))
        version = readUint32(f)
        assert version == 10279, f'Unknown file version {version}'
        framedTiles = readBitVec(f)
        width = readUint32(f)
        height = readUint32(f)
        assert width < 0xff and height < 0xff, f'Structure too large {width}x{height}'
        tiles = [[{} for y in range(height)] for x in range(width)]
        for x in range(width):
            rle = 0
            for y in range(height):
                if rle > 0:
                    tiles[x][y] = tiles[x][y - 1]
                    rle -= 1
                else:
                    flags = [0, 0, 0, 0]
                    for i in range(len(flags)):
                        flags[i] = readUint8(f)
                        if flags[i] & 0x01 == 0:
                            break
                    if flags[0] & 0x02 == 0:
                        tiles[x][y]['blockID'] = -1
                    else:
                        if flags[0] & 0x20 == 0:
                            tiles[x][y]['blockID'] = readUint8(f)
                        else:
                            tiles[x][y]['blockID'] = readUint16(f)
                        if framedTiles[tiles[x][y]['blockID']]:
                            tiles[x][y]['frameX'] = readUint16(f)
                            tiles[x][y]['frameY'] = readUint16(f)
                        if flags[2] & 0x08 == 0x08:
                            tiles[x][y]['blockPaint'] = readUint8(f)
                        tiles[x][y]['slope'] = (flags[1] >> 4) & 0x07
                    if flags[0] & 0x04 == 0:
                        tiles[x][y]['wallID'] = 0
                    else:
                        tiles[x][y]['wallID'] = readUint8(f)
                        if flags[2] & 0x10 == 0x10:
                            tiles[x][y]['wallPaint'] = readUint8(f)
                    if flags[0] & 0x18 == 0x08:
                        if flags[2] & 0x80 == 0x80:
                            tiles[x][y]['liquid'] = 'shimmer'
                        else:
                            tiles[x][y]['liquid'] = 'water'
                    elif flags[0] & 0x18 == 0x10:
                        tiles[x][y]['liquid'] = 'lava'
                    elif flags[0] & 0x18 == 0x18:
                        tiles[x][y]['liquid'] = 'honey'
                    if 'liquid' in tiles[x][y]:
                        readUint8(f) # Liquid amount.
                    else:
                        tiles[x][y]['liquid'] = 'none'
                    if flags[2] & 0x40 == 0x40:
                        tiles[x][y]['wallID'] |= readUint8(f) << 8
                    tiles[x][y]['wireRed'] = flags[1] & 0x02 == 0x02
                    tiles[x][y]['wireBlue'] = flags[1] & 0x04 == 0x04
                    tiles[x][y]['wireGreen'] = flags[1] & 0x08 == 0x08
                    tiles[x][y]['wireYellow'] = flags[2] & 0x20 == 0x20
                    tiles[x][y]['actuator'] = flags[2] & 0x02 == 0x02
                    tiles[x][y]['actuated'] = flags[2] & 0x04 == 0x04
                    tiles[x][y]['echoCoatBlock'] = flags[3] & 0x02 == 0x02
                    tiles[x][y]['echoCoatWall'] = flags[3] & 0x04 == 0x04
                    tiles[x][y]['illuminantBlock'] = flags[3] & 0x08 == 0x08
                    tiles[x][y]['illuminantWall'] = flags[3] & 0x10 == 0x10
                    if flags[0] & 0x40 == 0x40:
                        rle = readUint8(f)
                    elif flags[0] & 0x80 == 0x80:
                        rle = readUint16(f)
        return (tiles, framedTiles)

# header(16)
# blockID(16) frameX(16) frameY(16) wallID(16)
# blockPaint(8) wallPaint(8) liquid(3) slope(3)
# wires,actuators,coating(10)
def serializeTile(tile, framedTiles):
    for key in ['slope', 'blockPaint', 'wallPaint']:
        if not key in tile:
            tile[key] = 0
    data = [0]
    if tile['blockID'] != -1:
        data[0] |= 0x1000
        data.append(tile['blockID'])
        if framedTiles[tile['blockID']]:
            data.append(tile['frameX'])
            data.append(tile['frameY'])
    if tile['wallID'] != 0:
        data[0] |= 0x2000
        data.append(tile['wallID'])
    if tile['blockPaint']  != 0 or tile['wallPaint'] != 0:
        data[0] |= 0x4000
        data.append(tile['blockPaint'] | (tile['wallPaint'] << 8))
    flags = {
        'none': 0,
        'water': 1,
        'lava': 2,
        'honey': 3,
        'shimmer': 4,
    }[tile['liquid']]
    flags |= tile['slope'] << 3
    flagDef = {
        'wireRed': 6,
        'wireBlue': 7,
        'wireGreen': 8,
        'wireYellow': 9,
        'actuator': 10,
        'actuated': 11,
        'echoCoatBlock': 12,
        'echoCoatWall': 13,
        'illuminantBlock': 14,
        'illuminantWall': 15,
    }
    for key, shift in flagDef.items():
        if tile[key]:
            flags |= 1 << shift
    if flags != 0:
        data[0] |= 0x8000
        data.append(flags)
    return data

for filename in natsorted(sys.argv[1:]):
    (tiles, framedTiles) = loadTiles(filename)
    data = [len(tiles) << 8 | len(tiles[0])]
    prevTile = []
    rleIndex = len(data)
    for column in tiles:
        for tile in column:
            curTile = serializeTile(tile, framedTiles)
            if prevTile == curTile:
                data[rleIndex] += 1
            else:
                rleIndex = len(data)
                data += curTile
                prevTile = curTile
    print('{')
    print('\n'.join(textwrap.wrap(
        ', '.join([str(val) for val in data]),
        width=79,
        initial_indent='    ',
        subsequent_indent='    '
    )))
    print('},')

```
