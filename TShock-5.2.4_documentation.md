# Project Documentation: TShock-5.2.4
## 1. README
```markdown
<p align="center">
  <img src="https://tshock.s3.us-west-001.backblazeb2.com/newlogo.png" alt="TShock for Terraria"><br />
  <a href="https://ci.appveyor.com/project/hakusaro/tshock">
    <img src="https://ci.appveyor.com/api/projects/status/chhe61q227lqdlg1?svg=true" alt="AppVeyor Build Status">
  </a>
  <a href="https://github.com/Pryaxis/TShock/actions">
    <img src="https://github.com/Pryaxis/TShock/actions/workflows/build.yml/badge.svg" alt="GitHub Actions Build Status">
  </a>
  <a title="Crowdin" target="_blank" href="https://crowdin.com/project/tshock"><img src="https://badges.crowdin.net/tshock/localized.svg"></a>
  <br/><br/>
  <a href="https://github.com/Pryaxis/TShock/blob/general-devel/README_cn.md">查看中文版</a>
</p>

TShock is a toolbox for Terraria servers and communities. That toolbox is jam packed with anti-cheat tools, server-side characters, groups, permissions, item bans, tons of commands, and limitless potential. It's one of a kind.

This is the readme for TShock developers and hackers. We're building out new [TShock documentation](https://ikebukuro.tshock.co/) for server operators and plugin developers, but this is a work-in-progress right now.

## Developing TShock

If you want to contribute to TShock by sending a pull request or customize it to suit your own sparkly desires, this is the best starting point. By the end of this, you'll be able to build TShock from source, start to finish. More than that, though, you'll know how to start on the path of becoming an expert TShock developer.

This guide works assuming that you have the [.NET 6 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/6.0) installed and that you're familiar with the command line. If that doesn't describe you, you should be able to accomplish the same thing using Visual Studio 2022 or Visual Studio Code.

1. Clone the repository: `git clone https://github.com/Pryaxis/TShock.git --recurse-submodules`
1. `cd TShock` to enter the repo.
1. `dotnet build`. No really, that will build things!

If you want to run the `TShockLauncher` (which runs a server), run:

1. `dotnet run --project TShockLauncher`

To produce a packaged release (suitable for distribution), run:

1. `cd TShockLauncher`
1. `dotnet publish -r win-x64 -f net6.0 -c Release -p:PublishSingleFile=true --self-contained false`

Note that in this example, you'd be building for `win-x64`. You can build for `win-x64`, `osx-x64`, `linux-x64`, `linux-arm64`, `linux-arm`. Your release will be in the `TShockLauncher/bin/Release/net6.0/` folder under the architecture you specified.

### Working with Terraria

Working with Terraria in TShock and in other Terraria Server API plugins is different from most other APIs. Due to the nature of how OTAPI works, you have direct access to all public fields in the `Terraria` namespace. This means that you can access Terraria member methods directly. TShock and other plugins do this quite often, mostly to modify the game world, send data, and receive data. Calls to `Main` are one such example of direct access to Terraria. This is the equivalent to `net.minecraft.server` (NMS) calls in CraftBukkit.

You might find yourself wondering where these fields are. Pryaxis provides the decompiled [Sources](https://github.com/pryaxis/Sources) to Terraria's server, updated with each release. These sources are made available to developers of TShock. If you have submitted a pull request to TShock, reach out on Discord to get access. In lieu of this, you can download `ILSpy` and decompile Terraria or the server itself.

Finally, you may be interested in developing other Terraria Server API plugins. The [TShockResources](https://github.com/TShockResources) organization has several plugins you can look at and build on. TShock is itself a plugin, and most plugins are open source. This gives you ample room to figure out where to go next.

Need help? Join us on [Discord](https://discord.gg/Cav9nYX).

## Code of Conduct

> By participating in the TShock for Terraria community, all members will adhere to maintaining decorum with respect to all humans, in and out of the community. Members will not engage in discussion that inappropriately disparages or marginalizes any group of people or any individual. Members will not attempt to further or advance an agenda to the point of being overbearing or close minded (such as through spreading FUD). Members will not abuse services provided to them and will follow the guidance of community leaders on a situational basis about what abuse consists of. Members will adhere to United States and international law. If members notice a violation of this code of conduct, they will not engage but will instead contact the leadership team on either the forums or Discord.

> Do not attempt to circumvent or bypass the code of conduct by using clever logic or reasoning (e.g., insulting Facepunch members, because they weren't directly mentioned here).
```
## 3. Project File Tree
```
temp_TShock-5.2.4
├── Dockerfile
├── README.md
├── SECURITY.md
├── TShock.sln
├── TShockAPI
│   ├── BackupManager.cs
│   ├── Bouncer.cs
│   ├── CLI
│   │   ├── CommandLineParser.cs
│   │   └── FlagSet.cs
│   ├── Commands.cs
│   ├── Configuration
│   │   ├── ConfigFile.cs
│   │   ├── IConfigFile.cs
│   │   ├── ServerSideConfig.cs
│   │   └── TShockConfig.cs
│   ├── DB
│   │   ├── BanManager.cs
│   │   ├── CharacterManager.cs
│   │   ├── GroupManager.cs
│   │   ├── IQueryBuilder.cs
│   │   ├── ItemManager.cs
│   │   ├── ProjectileManager.cs
│   │   ├── RegionManager.cs
│   │   ├── RememberedPosManager.cs
│   │   ├── ResearchDatastore.cs
│   │   ├── SqlColumn.cs
│   │   ├── SqlTable.cs
│   │   ├── SqlValue.cs
│   │   ├── TileManager.cs
│   │   ├── UserManager.cs
│   │   └── WarpsManager.cs
│   ├── Extensions
│   │   ├── DbExt.cs
│   │   ├── ExceptionExt.cs
│   │   ├── LinqExt.cs
│   │   ├── RandomExt.cs
│   │   └── StringExt.cs
│   ├── FileTools.cs
│   ├── GeoIPCountry.cs
│   ├── GetDataHandlers.cs
│   ├── Group.cs
│   ├── HandlerList.cs
│   ├── Handlers
│   │   ├── DisplayDollItemSyncHandler.cs
│   │   ├── EmojiHandler.cs
│   │   ├── IPacketHandler.cs
│   │   ├── IllegalPerSe
│   │   │   └── EmojiPlayerMismatch.cs
│   │   ├── LandGolfBallInCupHandler.cs
│   │   ├── NetModules
│   │   │   ├── AmbienceHandler.cs
│   │   │   ├── BestiaryHandler.cs
│   │   │   ├── CreativePowerHandler.cs
│   │   │   ├── CreativeUnlocksHandler.cs
│   │   │   ├── INetModuleHandler.cs
│   │   │   ├── LiquidHandler.cs
│   │   │   ├── NetModulePacketHandler.cs
│   │   │   └── PylonHandler.cs
│   │   ├── RequestTileEntityInteractionHandler.cs
│   │   ├── SendTileRectHandler.cs
│   │   └── SyncTilePickingHandler.cs
│   ├── Hooks
│   │   ├── AccountHooks.cs
│   │   ├── GeneralHooks.cs
│   │   ├── PlayerHooks.cs
│   │   └── RegionHooks.cs
│   ├── I18n.cs
│   ├── ILog.cs
│   ├── IPackable.cs
│   ├── ItemBans.cs
│   ├── Localization
│   │   └── EnglishLanguage.cs
│   ├── Models
│   │   ├── PlayerUpdate
│   │   │   ├── ControlSet.cs
│   │   │   ├── MiscDataSet1.cs
│   │   │   ├── MiscDataSet2.cs
│   │   │   └── MiscDataSet3.cs
│   │   └── Projectiles
│   │       └── NewProjectileData.cs
│   ├── Modules
│   │   ├── Module.cs
│   │   ├── ModuleManager.cs
│   │   └── ReduceConsoleSpam.cs
│   ├── Net
│   │   ├── BaseMsg.cs
│   │   ├── DisconnectMsg.cs
│   │   ├── NetTile.cs
│   │   ├── ProjectileRemoveMsg.cs
│   │   ├── SpawnMsg.cs
│   │   └── WorldInfoMsg.cs
│   ├── NetItem.cs
│   ├── PaginationTools.cs
│   ├── Permissions.cs
│   ├── PlayerData.cs
│   ├── RegionHandler.cs
│   ├── Rest
│   │   ├── Rest.cs
│   │   ├── RestCommand.cs
│   │   ├── RestManager.cs
│   │   ├── RestObject.cs
│   │   ├── RestPermissions.cs
│   │   ├── RestVerbs.cs
│   │   └── SecureRest.cs
│   ├── SaveManager.cs
│   ├── Sockets
│   │   └── LinuxTcpSocket.cs
│   ├── SqlLog.cs
│   ├── TSPlayer.cs
│   ├── TSServerPlayer.cs
│   ├── TShock.cs
│   ├── TShockAPI.csproj
│   ├── TShockAPI.licenseheader
│   ├── TextLog.cs
│   ├── UpdateManager.cs
│   └── Utils.cs
├── TShockInstaller
│   ├── Program.cs
│   └── TShockInstaller.csproj
├── TShockLauncher
│   ├── Program.cs
│   └── TShockLauncher.csproj
├── TShockLauncher.Tests
│   ├── ChatTests.cs
│   ├── GroupTests.cs
│   ├── ServerInitTests.cs
│   ├── TShockLauncher.Tests.csproj
│   └── TestSetup.cs
├── TShockPluginManager
│   ├── CLIHelpers.cs
│   ├── I18n.cs
│   ├── Nuget.cs
│   ├── NugetCLI.cs
│   └── TShockPluginManager.csproj
├── TerrariaServerAPI
├── appveyor.yml
├── crowdin.yml
├── docs
│   ├── CNAME
│   ├── README.md
│   ├── _sidebar.md
│   ├── changelog.md
│   ├── command-line-parameters.md
│   ├── config-file-descriptions.md
│   ├── docker.md
│   ├── i18n.md
│   ├── index.html
│   ├── lang.md
│   ├── motd.md
│   ├── packages-help.txt
│   ├── packages.md
│   ├── permission-descriptions.md
│   ├── rest-fields.md
│   ├── ssc-config.md
│   ├── ssc.md
│   └── tile-providers.md
├── i18n
│   ├── en_PT
│   │   └── TShockAPI.po
│   ├── es_ES
│   │   └── TShockAPI.po
│   └── template.pot
├── prebuilts
│   ├── GeoIP.dat
│   ├── HttpServer.dll
│   ├── HttpServer.pdb
│   └── HttpServer.xml
└── scripts
    ├── create_release.py
    ├── deploy_release.py
    ├── gpltext.py
    ├── ssh_private_key.enc
    └── test_release.py

29 directories, 146 files
```
## 4. Source Files
### Folder: `temp_TShock-5.2.4`
#### File: `temp_TShock-5.2.4/.all-contributorsrc`
```
{
  "files": [
    "README.md",
    "README_cn.md"
  ],
  "imageSize": 100,
  "commit": false,
  "contributors": [
    {
      "login": "AviKav",
      "name": "AviKav",
      "avatar_url": "https://avatars2.githubusercontent.com/u/18518861?v=4",
      "profile": "https://avikav.net",
      "contributions": [
        "bug",
        "test"
      ]
    },
    {
      "login": "AxisKriel",
      "name": "Rodrigo Rente",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3332657?v=4",
      "profile": "https://tshock.co",
      "contributions": [
        "code",
        "projectManagement",
        "test"
      ]
    },
    {
      "login": "sgkoishi",
      "name": "Stargazing Koishi",
      "avatar_url": "https://avatars2.githubusercontent.com/u/9637711?v=4",
      "profile": "https://sgkoi.dev",
      "contributions": [
        "code",
        "infra"
      ]
    },
    {
      "login": "AxeelAnder",
      "name": "Axeel",
      "avatar_url": "https://avatars2.githubusercontent.com/u/25691207?v=4",
      "profile": "https://github.com/AxeelAnder",
      "contributions": [
        "doc",
        "projectManagement"
      ]
    },
    {
      "login": "Patrikkk",
      "name": "Patrikkk",
      "avatar_url": "https://avatars0.githubusercontent.com/u/58985873?v=4",
      "profile": "https://aurora-gaming.org/",
      "contributions": [
        "code",
        "doc",
        "test"
      ]
    },
    {
      "login": "ndragon798",
      "name": "Nathan Easton",
      "avatar_url": "https://avatars2.githubusercontent.com/u/10368650?v=4",
      "profile": "http://www.nathaneaston.com/",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "Ristellise",
      "name": "Shinon",
      "avatar_url": "https://avatars2.githubusercontent.com/u/7894419?v=4",
      "profile": "https://github.com/Ristellise",
      "contributions": [
        "test",
        "code",
        "doc"
      ]
    },
    {
      "login": "Retrograde-i486",
      "name": "Retrograde-i486",
      "avatar_url": "https://avatars1.githubusercontent.com/u/65242258?v=4",
      "profile": "https://github.com/Retrograde-i486",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "ColinBohn",
      "name": "Colin Bohn",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1351268?v=4",
      "profile": "http://colinbohn.me",
      "contributions": [
        "code"
      ]
    },
    {
      "login": "mrshroomy",
      "name": "mrshroomy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/52048952?v=4",
      "profile": "https://github.com/mrshroomy",
      "contributions": [
        "test"
      ]
    },
    {
      "login": "agentsparrow",
      "name": "agentsparrow",
      "avatar_url": "https://avatars0.githubusercontent.com/u/16114336?v=4",
      "profile": "https://github.com/agentsparrow",
      "contributions": [
        "test"
      ]
    }
  ],
  "contributorsPerLine": 7,
  "projectName": "TShock",
  "projectOwner": "Pryaxis",
  "repoType": "github",
  "repoHost": "https://github.com",
  "skipCi": true
}

```
#### File: `temp_TShock-5.2.4/.dockerignore`
```
# Ignore all Git metadata and build output (in all directories).
**/.git*
**/bin/
**/obj/

# Ignore other specific files that aren't needed for the build itself.
/.all-contributorsrc
/.dockerignore
/.editorconfig
/.vscode
/appveyor.yml
/COPYING
/crowdin.yml
/Dockerfile
/docs
/README.md
/README_cn.md
/renovate.json
/scripts
/SECURITY.md

```
#### File: `temp_TShock-5.2.4/.editorconfig`
```
root = true

[*]
end_of_line = crlf
insert_final_newline = true

[*.cs]
indent_style = tab
trim_trailing_whitespace = true

```
#### File: `temp_TShock-5.2.4/.gitattributes`
```
* text=auto
*.cs text eol=crlf
*.sln text eol=crlf
*.csproj text eol=crlf
*.vsmdi text eol=crlf
CHANGELOG.md merge=union

```
#### File: `temp_TShock-5.2.4/.gitignore`
```
# Sublime Text #
*.sublime-*
releases/
# Compiled source #
###################
*.com
*.class
*.dll
*.exe
*.o
*.so
*/bin/*
*/obj/*
bin/*
obj/*

# Packages #
############
# it's better to unpack these files and commit the raw source
# git has its own built in compression methods
*.7z
*.dmg
*.gz
*.iso
*.jar
*.rar
*.tar
*.zip

# Logs and databases #
######################
*.log
*.sql
*.sqlite

# OS generated files #
######################
.DS_Store
ehthumbs.db
Icon?
Thumbs.db

# Visual Studio #
##################################
*.userprefs
*.suo
*.sdf
*.opensdf
*.cache
*.pdb
*.csproj.user
*/_ReSharper*/*
*.user
.vs/*

#Template Bat file#
###################
postbuild.bat
/TestResults

# JetBrains Crap #
##################
*.dotCover
_ReSharper.*

# GTFO NuGet stuff #
####################
packages/*

# Private key files #
scripts/ssh_private_key

```
#### File: `temp_TShock-5.2.4/.gitmodules`
```
[submodule "TerrariaServerAPI"]
	path = TerrariaServerAPI
	url = https://github.com/NyxStudios/TerrariaAPI-Server.git
	ignore = dirty
	branch = general-devel

```
#### File: `temp_TShock-5.2.4/Dockerfile`
```
# TARGETPLATFORM and BUILDPLATFORM are automatically filled in by Docker buildx.
# They should not be set in the global scope manually.

FROM --platform=${BUILDPLATFORM} mcr.microsoft.com/dotnet/sdk:6.0 AS builder

# Copy build context
WORKDIR /TShock
COPY . ./

# Build and package release based on target architecture
RUN dotnet build -v m
WORKDIR /TShock/TShockLauncher

# Make TARGETPLATFORM available to the container.
ARG TARGETPLATFORM

RUN \ 
  case "${TARGETPLATFORM}" in \
    "linux/amd64") export ARCH="linux-x64" \
    ;; \
    "linux/arm64") export ARCH="linux-arm64" \
    ;; \
    "linux/arm/v7") export ARCH="linux-arm" \
    ;; \
    "windows/amd64") export ARCH="win-x64" \
    ;; \
    *) echo "Error: Unsupported platform ${TARGETPLATFORM}" && exit 1 \
    ;; \
  esac && \
  dotnet publish -o output/ -r "${ARCH}" -v m -f net6.0 -c Release -p:PublishSingleFile=true --self-contained false

# Runtime image
FROM --platform=${TARGETPLATFORM} mcr.microsoft.com/dotnet/runtime:6.0 AS runner
WORKDIR /server
COPY --from=builder /TShock/TShockLauncher/output ./

VOLUME ["/tshock", "/worlds", "/plugins"]
EXPOSE 7777 7878

ENTRYPOINT [ \
  "./TShock.Server", \
  "-configpath", "/tshock", \
  "-logpath", "/tshock/logs", \
  "-crashdir", "/tshock/crashes", \
  "-worldselectpath", "/worlds", \
  "-additionalplugins", "/plugins" \
]

```
#### File: `temp_TShock-5.2.4/SECURITY.md`
```
# Security policy

TShock aims to improve Terraria's multiplayer security. Security issues
for us are a little different compared to other projects.

Our "most normal" response criteria for security reports involve TShock
itself. For security issues in TShock, TSAPI, or other Pryaxis
projects, all issues can be reported to us directly, and we'll issue
fixes as appropriate. Depending on the nature of the issue, we will
either issue an update and note the issue in the changelog, or
coordinate a case specific security response.

For example, in [GHSA-q776-cv3j-4q6m](https://github.com/Pryaxis/TShock/security/advisories/GHSA-q776-cv3j-4q6m),
we gave many server operators advanced warning about the issue,
provided server specific patch guidance, and announced the disclosure
in a predictable way. This is because the issue was primarily one
introduced by TShock. Since we attempted to fix a problem with Terraria
and left a gap, we considered it a higher priority to fix and disclose
than other issues we've had reported.

If you operate a server with a large player base, you can contact us for
advanced details about a security vulnerability when we're coordinating
the disclosure. The best way to learn about upcoming issues is to keep
an eye on the announcements category of discussions, and subscribe to
our Discord's announcements feed.

When issues are discovered in the Terraria protocol directly, we add
guards to TShock to prevent their abuse. Depending on the severity of
the issue, we may choose to release versions which account for protocol
defects differently. Because there are so many protocol defects,
running a TShock server (and by extension, a Terraria server) is
inherently risky. Therefore, we strongly advise updating to the latest
versions of TShock at all times.

Some types of issues may not be directly patched by TShock, after
reporting. For example, esoteric attack types may not be disclosed
because they're too difficult to protect against, represent a low risk,
or otherwise may adversely affect servers if disclosed. This is usually
the case with minor protocol defects in Terraria, where patching an
issue may start an "arm's race" or where the attack is theoretical, but
not occurring in practice, and poses minimal risk.

## Supported Terraria protocol versions

TShock maintains protocol patches and associated protection services for
the the most recent versions of Terraria. We may remove protection
mechanisms or update them in response to protocol changes.

| Version | Supported          |
| ------- | ------------------ |
| 1.4.2.1 | :white_check_mark: |
| 1.4.0.5 | :x:                |

It is important to remember that Terraria is a clientside game with
serverside networking "added on." If you're familiar with hosting
Minecraft or other primarily serverside games, please be aware that
integrity cannot be maintained with Terraria in the same way. The
network design has improved over the years, but is fundamentally
difficult to fully secure. Even in a fully patched, supported version
of TShock, protocol defects leading to client and server crashes, item
duplication, and denial of service still exist in some way or another.

When feasible, Pryaxis works with Re-Logic to address security issues.
However, due to the nature of these types of issues, we cannot always
disclose the status of certain issues which have been reported to
Re-Logic.

## Supported TShock versions

Beginning with TShock 4.5, versions with odd numbers are
considered "unstable" for the purposes of operating a public server,
and may contain issues with the Terraria protocol in terms of patching,
danger, or other similar things. Versions which are considered "stable"
are even numbered releases, which offer typical security measures.

When running unstable versions of TShock, make regular backups of your
worlds, characters, configurations, and databases. This is because the
Terraria protocol may be dangerous in this version, and data loss may
occur. More commonly, attackers may perform denial of service attacks,
cheat items into the game, or perform other types of griefing on
servers. You stand a better chance to defend against these protocol
issues by using updated versions of TShock that are stable, not
unstable releases.

## Bug bounties

Pryaxis may offer bug bounties for defects found in Terraria or TShock,
but this is evaluated on a case by case basis. Bounties should not be
expected, and are only awarded to those who do not ask for them.

## Reporting issues

To report issues, join Discord and mention a staff member, or post that
you have critical information in the #tshock channel. You can also
contact hakusaro (argo@hey.com) directly.

```
#### File: `temp_TShock-5.2.4/TShock.sln`
```
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31825.309
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{755F5B05-0924-47E9-9563-26EB20FE3F67}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		.gitignore = .gitignore
		appveyor.yml = appveyor.yml
		CHANGELOG.md = CHANGELOG.md
		.github\workflows\ci-otapi3-nuget.yml = .github\workflows\ci-otapi3-nuget.yml
		.github\workflows\ci-otapi3.yml = .github\workflows\ci-otapi3.yml
		COPYING = COPYING
		.github\workflows\danger.yml = .github\workflows\danger.yml
		README.md = README.md
		README_cn.md = README_cn.md
		SECURITY.md = SECURITY.md
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "TShockAPI", "TShockAPI\TShockAPI.csproj", "{49606449-072B-4CF5-8088-AA49DA586694}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "TerrariaServerAPI", "TerrariaServerAPI\TerrariaServerAPI\TerrariaServerAPI.csproj", "{6877506E-ADC6-4142-98A6-79E4FA02855A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "TShockLauncher", "TShockLauncher\TShockLauncher.csproj", "{2A312452-A43F-43E3-8AEB-E22F9A35C210}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "TShockLauncher.Tests", "TShockLauncher.Tests\TShockLauncher.Tests.csproj", "{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TShockInstaller", "TShockInstaller\TShockInstaller.csproj", "{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TShockPluginManager", "TShockPluginManager\TShockPluginManager.csproj", "{9FFABC7D-B042-4B58-98F5-7FA787B9A757}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|Mixed Platforms = Debug|Mixed Platforms
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|Mixed Platforms = Release|Mixed Platforms
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{49606449-072B-4CF5-8088-AA49DA586694}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Debug|x64.ActiveCfg = Debug|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Debug|x64.Build.0 = Debug|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Debug|x86.ActiveCfg = Debug|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Debug|x86.Build.0 = Debug|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Release|Any CPU.Build.0 = Release|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Release|x64.ActiveCfg = Release|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Release|x64.Build.0 = Release|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Release|x86.ActiveCfg = Release|Any CPU
		{49606449-072B-4CF5-8088-AA49DA586694}.Release|x86.Build.0 = Release|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Debug|x64.Build.0 = Debug|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Debug|x86.Build.0 = Debug|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Release|Any CPU.Build.0 = Release|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Release|x64.ActiveCfg = Release|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Release|x64.Build.0 = Release|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Release|x86.ActiveCfg = Release|Any CPU
		{6877506E-ADC6-4142-98A6-79E4FA02855A}.Release|x86.Build.0 = Release|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Debug|x64.ActiveCfg = Debug|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Debug|x64.Build.0 = Debug|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Debug|x86.ActiveCfg = Debug|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Debug|x86.Build.0 = Debug|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Release|Any CPU.Build.0 = Release|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Release|x64.ActiveCfg = Release|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Release|x64.Build.0 = Release|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Release|x86.ActiveCfg = Release|Any CPU
		{2A312452-A43F-43E3-8AEB-E22F9A35C210}.Release|x86.Build.0 = Release|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Debug|x64.Build.0 = Debug|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Debug|x86.Build.0 = Debug|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Release|Any CPU.Build.0 = Release|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Release|x64.ActiveCfg = Release|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Release|x64.Build.0 = Release|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Release|x86.ActiveCfg = Release|Any CPU
		{90AB47F3-8220-48FC-BDAB-D6E97BFDA51B}.Release|x86.Build.0 = Release|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Debug|x64.ActiveCfg = Debug|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Debug|x64.Build.0 = Debug|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Debug|x86.ActiveCfg = Debug|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Debug|x86.Build.0 = Debug|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Release|Any CPU.Build.0 = Release|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Release|x64.ActiveCfg = Release|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Release|x64.Build.0 = Release|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Release|x86.ActiveCfg = Release|Any CPU
		{17AC4DD0-8334-4B5C-ABED-77EAF52D75FA}.Release|x86.Build.0 = Release|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Debug|Mixed Platforms.ActiveCfg = Debug|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Debug|Mixed Platforms.Build.0 = Debug|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Debug|x64.ActiveCfg = Debug|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Debug|x64.Build.0 = Debug|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Debug|x86.ActiveCfg = Debug|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Debug|x86.Build.0 = Debug|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Release|Any CPU.Build.0 = Release|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Release|Mixed Platforms.ActiveCfg = Release|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Release|Mixed Platforms.Build.0 = Release|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Release|x64.ActiveCfg = Release|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Release|x64.Build.0 = Release|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Release|x86.ActiveCfg = Release|Any CPU
		{9FFABC7D-B042-4B58-98F5-7FA787B9A757}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B56F0765-BADD-48CF-8A19-436BD0EAD34A}
	EndGlobalSection
	GlobalSection(TestCaseManagementSettings) = postSolution
		CategoryFile = Terraria.vsmdi
	EndGlobalSection
EndGlobal

```
### Folder: `temp_TShock-5.2.4/TShockAPI`
#### File: `temp_TShock-5.2.4/TShockAPI/BackupManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.Threading;
using Terraria;

namespace TShockAPI
{
	public class BackupManager
	{
		public string BackupPath { get; set; }
		public int Interval { get; set; }
		public int KeepFor { get; set; }

		private DateTime lastbackup = DateTime.UtcNow;

		public BackupManager(string path)
		{
			BackupPath = path;
		}

		public bool IsBackupTime
		{
			get { return (Interval > 0) && ((DateTime.UtcNow - lastbackup).TotalMinutes >= Interval); }
		}

		public void Backup()
		{
			lastbackup = DateTime.UtcNow;
			Thread t = new Thread(() => {
				DoBackup(null);
				DeleteOld(null);
			});
			t.Name = GetString("Backup Thread");
			t.Start();

			// ThreadPool.QueueUserWorkItem(DoBackup);
			// ThreadPool.QueueUserWorkItem(DeleteOld);
		}

		private void DoBackup(object o)
		{
			try
			{
				string worldname = Main.worldPathName;
				string name = Path.GetFileName(worldname);

				Main.ActiveWorldFileData._path = Path.Combine(BackupPath, string.Format("{0}.{1:yyyy-MM-ddTHH.mm.ssZ}.bak", name, DateTime.UtcNow));

				string worldpath = Path.GetDirectoryName(Main.worldPathName);
				if (worldpath != null && !Directory.Exists(worldpath))
					Directory.CreateDirectory(worldpath);

				if (TShock.Config.Settings.ShowBackupAutosaveMessages)
				{
					TSPlayer.All.SendInfoMessage(GetString("Server map saving..."));
				}
				Console.WriteLine(GetString("Backing up world..."));

				SaveManager.Instance.SaveWorld();
				Console.WriteLine(GetString("World backed up."));
				Console.ForegroundColor = ConsoleColor.Gray;
				TShock.Log.Info(GetString("World backed up ({0}).", Main.worldPathName));

				Main.ActiveWorldFileData._path = worldname;
			}
			catch (Exception ex)
			{
				Console.ForegroundColor = ConsoleColor.Red;
				Console.WriteLine(GetString("Backup failed!"));
				Console.ForegroundColor = ConsoleColor.Gray;
				TShock.Log.Error(GetString("Backup failed!"));
				TShock.Log.Error(ex.ToString());
			}
		}

		private void DeleteOld(object o)
		{
			if (KeepFor <= 0)
				return;
			foreach (var fi in new DirectoryInfo(BackupPath).GetFiles("*.bak"))
			{
				if ((DateTime.UtcNow - fi.LastWriteTimeUtc).TotalMinutes > KeepFor)
				{
					fi.Delete();
				}
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Bouncer.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
using System;
using System.Collections.Generic;
using System.Linq;
using Terraria.ID;
using TShockAPI.Net;
using Terraria;
using Microsoft.Xna.Framework;
using TShockAPI.Localization;
using static TShockAPI.GetDataHandlers;
using Terraria.ObjectData;
using Terraria.DataStructures;
using Terraria.Localization;
using TShockAPI.Models.PlayerUpdate;
using System.Threading.Tasks;

namespace TShockAPI
{
	/// <summary>Bouncer is the TShock anti-hack and anti-cheat system.</summary>
	internal sealed class Bouncer
	{
		internal Handlers.SendTileRectHandler STSHandler { get; private set; }
		internal Handlers.NetModules.NetModulePacketHandler NetModuleHandler { get; private set; }
		internal Handlers.EmojiHandler EmojiHandler { get; private set; }
		internal Handlers.IllegalPerSe.EmojiPlayerMismatch EmojiPlayerMismatch { get; private set; }
		internal Handlers.DisplayDollItemSyncHandler DisplayDollItemSyncHandler { get; private set; }
		internal Handlers.RequestTileEntityInteractionHandler RequestTileEntityInteractionHandler { get; private set; }
		internal Handlers.LandGolfBallInCupHandler LandGolfBallInCupHandler { get; private set; }
		internal Handlers.SyncTilePickingHandler SyncTilePickingHandler { get; private set; }

		/// <summary>
		/// A class that represents the limits for a particular buff when a client applies it with PlayerAddBuff.
		/// </summary>
		internal class BuffLimit
		{
			/// <summary>
			/// How many ticks at the maximum a player can apply this to another player for.
			/// </summary>
			public int MaxTicks { get; set; }
			/// <summary>
			/// Can this buff be added without the receiver being hostile (PvP)
			/// </summary>
			public bool CanBeAddedWithoutHostile { get; set; }
			/// <summary>
			/// Can this buff only be applied to the sender?
			/// </summary>
			public bool CanOnlyBeAppliedToSender { get; set; }
		}

		internal static BuffLimit[] PlayerAddBuffWhitelist;

		/// <summary>
		/// Represents a place style corrector.
		/// </summary>
		/// <param name="player">The player placing the tile.</param>
		/// <param name="requestedPlaceStyle">The requested place style to be placed.</param>
		/// <param name="actualItemPlaceStyle">The actual place style that should be placed, based of the player's held item.</param>
		/// <returns>The correct place style in the current context.</returns>
		internal delegate int PlaceStyleCorrector(Player player, int requestedPlaceStyle, int actualItemPlaceStyle);

		/// <summary>
		/// Represents a dictionary of <see cref="PlaceStyleCorrector"/>s, the key is the tile ID and the value is the corrector.
		/// </summary>
		internal Dictionary<int, PlaceStyleCorrector> PlaceStyleCorrectors = new Dictionary<int, PlaceStyleCorrector>();

		/// <summary>Constructor call initializes Bouncer and related functionality.</summary>
		/// <returns>A new Bouncer.</returns>
		internal Bouncer()
		{
			STSHandler = new Handlers.SendTileRectHandler();
			GetDataHandlers.SendTileRect += STSHandler.OnReceive;

			NetModuleHandler = new Handlers.NetModules.NetModulePacketHandler();
			GetDataHandlers.ReadNetModule += NetModuleHandler.OnReceive;

			EmojiPlayerMismatch = new Handlers.IllegalPerSe.EmojiPlayerMismatch();
			GetDataHandlers.Emoji += EmojiPlayerMismatch.OnReceive;

			EmojiHandler = new Handlers.EmojiHandler();
			GetDataHandlers.Emoji += EmojiHandler.OnReceive;

			DisplayDollItemSyncHandler = new Handlers.DisplayDollItemSyncHandler();
			GetDataHandlers.DisplayDollItemSync += DisplayDollItemSyncHandler.OnReceive;

			RequestTileEntityInteractionHandler = new Handlers.RequestTileEntityInteractionHandler();
			GetDataHandlers.RequestTileEntityInteraction += RequestTileEntityInteractionHandler.OnReceive;

			LandGolfBallInCupHandler = new Handlers.LandGolfBallInCupHandler();
			GetDataHandlers.LandGolfBallInCup += LandGolfBallInCupHandler.OnReceive;

			SyncTilePickingHandler = new Handlers.SyncTilePickingHandler();
			GetDataHandlers.SyncTilePicking += SyncTilePickingHandler.OnReceive;

			// Setup hooks
			GetDataHandlers.GetSection += OnGetSection;
			GetDataHandlers.PlayerUpdate += OnPlayerUpdate;
			GetDataHandlers.TileEdit += OnTileEdit;
			GetDataHandlers.ItemDrop += OnItemDrop;
			GetDataHandlers.NewProjectile += OnNewProjectile;
			GetDataHandlers.NPCStrike += OnNPCStrike;
			GetDataHandlers.ProjectileKill += OnProjectileKill;
			GetDataHandlers.ChestItemChange += OnChestItemChange;
			GetDataHandlers.ChestOpen += OnChestOpen;
			GetDataHandlers.PlaceChest += OnPlaceChest;
			GetDataHandlers.PlayerZone += OnPlayerZone;
			GetDataHandlers.PlayerAnimation += OnPlayerAnimation;
			GetDataHandlers.LiquidSet += OnLiquidSet;
			GetDataHandlers.PlayerBuff += OnPlayerBuff;
			GetDataHandlers.NPCAddBuff += OnNPCAddBuff;
			GetDataHandlers.NPCHome += OnUpdateNPCHome;
			GetDataHandlers.HealOtherPlayer += OnHealOtherPlayer;
			GetDataHandlers.ReleaseNPC += OnReleaseNPC;
			GetDataHandlers.PlaceObject += OnPlaceObject;
			GetDataHandlers.PlaceTileEntity += OnPlaceTileEntity;
			GetDataHandlers.PlaceItemFrame += OnPlaceItemFrame;
			GetDataHandlers.PortalTeleport += OnPlayerPortalTeleport;
			GetDataHandlers.GemLockToggle += OnGemLockToggle;
			GetDataHandlers.MassWireOperation += OnMassWireOperation;
			GetDataHandlers.PlayerDamage += OnPlayerDamage;
			GetDataHandlers.KillMe += OnKillMe;
			GetDataHandlers.FishOutNPC += OnFishOutNPC;
			GetDataHandlers.FoodPlatterTryPlacing += OnFoodPlatterTryPlacing;


			// The following section is based off Player.PlaceThing_Tiles_PlaceIt and Player.PlaceThing_Tiles_PlaceIt_GetLegacyTileStyle.
			// Multi-block tiles are intentionally ignored because they don't pass through OnTileEdit.
			PlaceStyleCorrectors.Add(TileID.Torches,
				(player, requestedPlaceStyle, actualItemPlaceStyle) =>
				{
					// If the client is attempting to place a default torch, we need to check that the torch they are attempting to place is valid.
					// The place styles may mismatch if the player is placing a biome torch.
					// Biome torches can only be placed if the player has unlocked them (Torch God's Favor)
					// Therefore, the following conditions need to be true:
					// - The client's selected item will create a default torch(this should be true if this handler is running)
					// - The client's selected item's place style will be that of a default torch
					// - The client has unlocked biome torches
					if (actualItemPlaceStyle == TorchID.Torch && player.unlockedBiomeTorches)
					{
						// The server isn't notified when the player turns on biome torches.
						// So on the client it can be on, while on the server it's off.
						// BiomeTorchPlaceStyle returns placeStyle as-is if biome torches is off.
						// Because of the uncertainty, we:
						// 1. Ensure that UsingBiomeTorches is on, so we can get the correct
						// value from BiomeTorchPlaceStyle.
						// 2. Check if the torch is either 0 or the biome torch since we aren't
						// sure if the player has biome torches on
						var usingBiomeTorches = player.UsingBiomeTorches;
						player.UsingBiomeTorches = true;
						// BiomeTorchPlaceStyle returns the place style of the player's current biome's biome torch
						var biomeTorchPlaceStyle = player.BiomeTorchPlaceStyle(actualItemPlaceStyle);
						// Reset UsingBiomeTorches value
						player.UsingBiomeTorches = usingBiomeTorches;

						return biomeTorchPlaceStyle;
					}
					else
					{
						// If the player isn't holding the default torch, then biome torches don't apply and return item place style.
						// Or, they are holding the default torch but haven't unlocked biome torches yet, so return item place style.
						return actualItemPlaceStyle;
					}
				});
			PlaceStyleCorrectors.Add(TileID.Presents,
				(player, requestedPlaceStyle, actualItemPlaceStyle) =>
				{
					// RNG only generates placeStyles less than 7, so permit only <7
					// Note: there's an 8th present(blue, golden stripes) that's unplaceable.
					// https://terraria.fandom.com/wiki/Presents, last present of the 8 displayed
					if (requestedPlaceStyle < 7)
					{
						return requestedPlaceStyle;
					}
					else
					{
						// Return 0 for now, but ideally 0-7 should be returned.
						return 0;
					}
				});
			PlaceStyleCorrectors.Add(TileID.Explosives,
				(player, requestedPlaceStyle, actualItemPlaceStyle) =>
				{
					// RNG only generates placeStyles less than 2, so permit only <2
					if (requestedPlaceStyle < 2)
					{
						return requestedPlaceStyle;
					}
					else
					{
						// Return 0 for now, but ideally 0-1 should be returned.
						return 0;
					}
				});
			PlaceStyleCorrectors.Add(TileID.Crystals,
				(player, requestedPlaceStyle, actualItemPlaceStyle) =>
				{
					// RNG only generates placeStyles less than 18, so permit only <18.
					// Note: Gelatin Crystals(Queen Slime summon) share the same ID as Crystal Shards.
					// <18 includes all shards except Gelatin Crystals.
					if (requestedPlaceStyle < 18)
					{
						return requestedPlaceStyle;
					}
					else
					{
						// Return 0 for now, but ideally 0-17 should be returned.
						return 0;
					}
				});
			PlaceStyleCorrectors.Add(TileID.MinecartTrack,
				(player, requestedPlaceStyle, actualItemPlaceStyle) =>
				{
					// Booster tracks have 2 variations, but only 1 item.
					// The variation depends on the direction the player is facing.
					if (actualItemPlaceStyle == 2)
					{
						// Check the direction the player is facing.
						// 1 is right and -1 is left, these are the only possible values.
						if (player.direction == 1)
						{
							// Right-facing booster tracks
							return 3;
						}
						else if (player.direction == -1)
						{
							// Left-facing booster tracks
							return 2;
						}
						else
						{
							throw new InvalidOperationException(GetString("Unrecognized player direction"));
						}
					}
					else
					{
						// Not a booster track, return as-is.
						return actualItemPlaceStyle;
					}
				});

			#region PlayerAddBuff Whitelist

			PlayerAddBuffWhitelist = new BuffLimit[Terraria.ID.BuffID.Count];
			PlayerAddBuffWhitelist[BuffID.Poisoned] = new BuffLimit
			{
				MaxTicks = 60 * 60
			};
			PlayerAddBuffWhitelist[BuffID.OnFire] = new BuffLimit
			{
				MaxTicks = 60 * 20
			};
			PlayerAddBuffWhitelist[BuffID.Confused] = new BuffLimit
			{
				MaxTicks = 60 * 4
			};
			PlayerAddBuffWhitelist[BuffID.CursedInferno] = new BuffLimit
			{
				MaxTicks = 60 * 7
			};
			PlayerAddBuffWhitelist[BuffID.Wet] = new BuffLimit
			{
				MaxTicks = 60 * 30,
				// The Water Gun can be shot at other players and inflict Wet while not in PvP
				CanBeAddedWithoutHostile = true
			};
			PlayerAddBuffWhitelist[BuffID.Ichor] = new BuffLimit
			{
				MaxTicks = 60 * 20
			};
			PlayerAddBuffWhitelist[BuffID.Venom] = new BuffLimit
			{
				MaxTicks = 60 * 30
			};
			PlayerAddBuffWhitelist[BuffID.GelBalloonBuff] = new BuffLimit
			{
				MaxTicks = 60 * 30,
				// The Sparkle Slime Balloon inflicts this while not in PvP
				CanBeAddedWithoutHostile = true
			};
			PlayerAddBuffWhitelist[BuffID.Frostburn] = new BuffLimit
			{
				MaxTicks = 60 * 8
			};
			PlayerAddBuffWhitelist[BuffID.Campfire] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.Sunflower] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.WaterCandle] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.BeetleEndurance1] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.BeetleEndurance2] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.BeetleEndurance3] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.BeetleMight1] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.BeetleMight2] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.BeetleMight3] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true,
			};
			PlayerAddBuffWhitelist[BuffID.SolarShield1] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = false,
			};
			PlayerAddBuffWhitelist[BuffID.SolarShield2] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = false,
			};
			PlayerAddBuffWhitelist[BuffID.SolarShield3] = new BuffLimit
			{
				MaxTicks = 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = false,
			};
			PlayerAddBuffWhitelist[BuffID.MonsterBanner] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.HeartLamp] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.PeaceCandle] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.StarInBottle] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.CatBast] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.OnFire3] = new BuffLimit
			{
				MaxTicks = 60 * 6,
				CanBeAddedWithoutHostile = false,
				CanOnlyBeAppliedToSender = false
			};
			PlayerAddBuffWhitelist[BuffID.HeartyMeal] = new BuffLimit
			{
				MaxTicks = 60 * 7,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.Frostburn2] = new BuffLimit
			{
				MaxTicks = 60 * 7,
				CanBeAddedWithoutHostile = false,
				CanOnlyBeAppliedToSender = false
			};
			PlayerAddBuffWhitelist[BuffID.ShadowCandle] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.BrainOfConfusionBuff] = new BuffLimit
			{
				MaxTicks = 60 * 4,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.WindPushed] = new BuffLimit
			{
				MaxTicks = 2,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};
			PlayerAddBuffWhitelist[BuffID.ParryDamageBuff] = new BuffLimit
			{
				MaxTicks = 60 * 5,
				CanBeAddedWithoutHostile = true,
				CanOnlyBeAppliedToSender = true
			};

			#endregion Whitelist
		}

		internal void OnGetSection(object sender, GetDataHandlers.GetSectionEventArgs args)
		{
			if (args.Player.RequestedSection)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnGetSection rejected GetSection packet from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
			args.Player.RequestedSection = true;

			if (String.IsNullOrEmpty(args.Player.Name))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnGetSection rejected empty player name."));
				args.Player.Kick(GetString("Your client sent a blank character name."), true, true);
				args.Handled = true;
				return;
			}

			if (!args.Player.HasPermission(Permissions.ignorestackhackdetection))
			{
				args.Player.IsDisabledForStackDetection = args.Player.HasHackedItemStacks(shouldWarnPlayer: true);
			}
		}

		/// <summary>Handles disabling enforcement and minor anti-exploit stuff</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnPlayerUpdate(object sender, GetDataHandlers.PlayerUpdateEventArgs args)
		{
			byte plr = args.PlayerId;
			ControlSet control = args.Control;
			MiscDataSet1 miscData1 = args.MiscData1;
			byte item = args.SelectedItem;
			var pos = args.Position;
			var vel = args.Velocity;

			if (Single.IsInfinity(vel.X) || Single.IsInfinity(vel.Y))
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnPlayerUpdate force kicked (attempted to set velocity to infinity) from {0}", args.Player.Name));
				args.Player.Kick(GetString("Detected DOOM set to ON position."), true, true);
				args.Handled = true;
				return;
			}

			if (Single.IsNaN(vel.X) || Single.IsNaN(vel.Y))
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnPlayerUpdate force kicked (attempted to set velocity to NaN) from {0}", args.Player.Name));
				args.Player.Kick(GetString("Detected DOOM set to ON position."), true, true);
				args.Handled = true;
				return;
			}

			if (vel.X > 50000 || vel.Y > 50000 || vel.X < -50000 || vel.Y < -50000)
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnPlayerUpdate force kicked (attempted to set velocity +/- 50000) from {0}", args.Player.Name));
				args.Player.Kick(GetString("Detected DOOM set to ON position."), true, true);
				args.Handled = true;
				return;
			}

			if (!float.IsFinite(pos.X) || !float.IsFinite(pos.Y))
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnPlayerUpdate force kicked (attempted to set position to infinity or NaN) from {0}", args.Player.Name));
				args.Player.Kick(GetString("Detected DOOM set to ON position."), true, true);
				args.Handled = true;
				return;
			}

			if (pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerUpdate rejected from (position check) {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (item < 0 || item >= args.Player.TPlayer.inventory.Length)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerUpdate rejected from (inventory length) {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.LastNetPosition == Vector2.Zero)
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnPlayerUpdate *would have rejected* from (last network position zero) {0}", args.Player.Name));
				// args.Handled = true;
				// return;
			}

			if (!pos.Equals(args.Player.LastNetPosition))
			{
				float distance = Vector2.Distance(new Vector2(pos.X / 16f, pos.Y / 16f),
					new Vector2(args.Player.LastNetPosition.X / 16f, args.Player.LastNetPosition.Y / 16f));

				if (args.Player.IsBeingDisabled())
				{
					// If the player has moved outside the disabled zone...
					if (distance > TShock.Config.Settings.MaxRangeForDisabled)
					{
						// We need to tell them they were disabled and why, then revert the change.
						if (args.Player.IsDisabledForStackDetection)
						{
							args.Player.SendErrorMessage(GetString("Disabled. You went too far with hacked item stacks."));
						}
						else if (args.Player.IsDisabledForBannedWearable)
						{
							args.Player.SendErrorMessage(GetString("Disabled. You went too far with banned armor."));
						}
						else if (args.Player.IsDisabledForSSC)
						{
							args.Player.SendErrorMessage(GetString("Disabled. You need to {0}login to load your saved data.", TShock.Config.Settings.CommandSpecifier));
						}
						else if (TShock.Config.Settings.RequireLogin && !args.Player.IsLoggedIn)
						{
							args.Player.SendErrorMessage(GetString("Account needed! Please {0}register or {0}login to play!", TShock.Config.Settings.CommandSpecifier));
						}
						else if (args.Player.IsDisabledPendingTrashRemoval)
						{
							args.Player.SendErrorMessage(GetString("You need to rejoin to ensure your trash can is cleared!"));
						}

						// ??
						var lastTileX = args.Player.LastNetPosition.X;
						var lastTileY = args.Player.LastNetPosition.Y - 48;
						if (!args.Player.Teleport(lastTileX, lastTileY))
						{
							args.Player.Spawn(PlayerSpawnContext.RecallFromItem);
						}
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerUpdate rejected from (??) {0}", args.Player.Name));
						args.Handled = true;
						return;
					}
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerUpdate rejected from (below ??) {0}", args.Player.Name));
					args.Handled = true;
					return;
				}

				// Corpses don't move
				if (args.Player.Dead)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerUpdate rejected from (corpses don't move) {0}", args.Player.Name));
					args.Handled = true;
					return;
				}
			}

			args.Player.LastNetPosition = pos;
			return;
		}

		/// <summary>Bouncer's TileEdit hook is used to revert malicious tile changes.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnTileEdit(object sender, GetDataHandlers.TileEditEventArgs args)
		{
			// TODO: Add checks on the new edit actions. ReplaceTile, ReplaceWall, TryKillTile, Acutate, PokeLogicGate, SlopePoundTile
			EditAction action = args.Action;
			int tileX = args.X;
			int tileY = args.Y;
			short editData = args.EditData;
			EditType type = args.editDetail;

			// 'placeStyle' is a term used in Terraria land to determine which frame of a sprite is displayed when the sprite is placed. The placeStyle
			// determines the frameX and frameY offsets
			byte requestedPlaceStyle = args.Style;

			try
			{
				if (!TShock.Utils.TilePlacementValid(tileX, tileY))
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (tile placement valid) {0} {1} {2}", args.Player.Name, action, editData));
					args.Handled = true;
					return;
				}

				// I do not understand the ice tile check enough to be able to modify it, however I do know that it can be used to completely bypass region protection
				// This check ensures that build permission is always checked no matter what
				if (!args.Player.HasBuildPermission(tileX, tileY))
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from build from {0} {1} {2}", args.Player.Name, action, editData));

					GetRollbackRectSize(tileX, tileY, out byte width, out byte length, out int offsetY);
					args.Player.SendTileRect((short)(tileX - width), (short)(tileY + offsetY), (byte)(width * 2), (byte)(length + 1));
					args.Handled = true;
					return;
				}

				if (editData < 0 ||
					((action == EditAction.PlaceTile || action == EditAction.ReplaceTile) && editData >= Terraria.ID.TileID.Count) ||
					((action == EditAction.PlaceWall || action == EditAction.ReplaceWall) && editData >= Terraria.ID.WallID.Count))
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from editData out of bounds {0} {1} {2}", args.Player.Name, action, editData));
					args.Player.SendTileSquareCentered(tileX, tileY, 4);
					args.Handled = true;
					return;
				}

				if (action == EditAction.KillTile && Main.tile[tileX, tileY].type == TileID.MagicalIceBlock)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit super accepted from (ice block) {0} {1} {2}", args.Player.Name, action, editData));
					args.Handled = false;
					return;
				}

				if (args.Player.Dead && TShock.Config.Settings.PreventDeadModification)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (pdm) {0} {1} {2}", args.Player.Name, action, editData));
					args.Player.SendTileSquareCentered(tileX, tileY, 4);
					args.Handled = true;
					return;
				}

				Item selectedItem = args.Player.SelectedItem;
				int lastKilledProj = args.Player.LastKilledProjectile;
				ITile tile = Main.tile[tileX, tileY];

				if (action == EditAction.PlaceTile || action == EditAction.ReplaceTile)
				{
					if (TShock.TileBans.TileIsBanned(editData, args.Player))
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (tb) {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 1);
						args.Player.SendErrorMessage(GetString("You do not have permission to place this tile."));
						args.Handled = true;
						return;
					}

					// This is the actual tile ID we expect the selected item to create. If the tile ID from the packet and the tile ID from the item do not match
					// we need to inspect further to determine if Terraria is sending funny information (which it does sometimes) or if someone is being malicious
					var actualTileToBeCreated = selectedItem.createTile;
					// This is the actual place style we expect the selected item to create. Same as above - if it differs from what the client tells us,
					// we need to do some inspection to check if its valid
					var actualItemPlaceStyle = selectedItem.placeStyle;

					// The client has requested to place a style that does not match their held item's actual place style
					if (requestedPlaceStyle != actualItemPlaceStyle)
					{
						var tplayer = args.Player.TPlayer;
						// Search for an extraneous tile corrector
						// If none found then it can't be a false positive so deny the action
						if (!PlaceStyleCorrectors.TryGetValue(actualTileToBeCreated, out PlaceStyleCorrector corrector))
						{
							TShock.Log.ConsoleError(GetString("Bouncer / OnTileEdit rejected from (placestyle) {0} {1} {2} placeStyle: {3} expectedStyle: {4}",
								args.Player.Name, action, editData, requestedPlaceStyle, actualItemPlaceStyle));
							args.Player.SendTileSquareCentered(tileX, tileY, 1);
							args.Handled = true;
							return;
						}

						// See if the corrector's expected style matches
						var correctedPlaceStyle = corrector(tplayer, requestedPlaceStyle, actualItemPlaceStyle);
						if (requestedPlaceStyle != correctedPlaceStyle)
						{
							TShock.Log.ConsoleError(GetString("Bouncer / OnTileEdit rejected from (placestyle) {0} {1} {2} placeStyle: {3} expectedStyle: {4}",
								args.Player.Name, action, editData, requestedPlaceStyle, correctedPlaceStyle));
							args.Player.SendTileSquareCentered(tileX, tileY, 1);
							args.Handled = true;
							return;
						}
					}
				}

				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type) && args.Player.RecentFuse == 0)
				{
					// If the tile is an axe tile and they aren't selecting an axe, they're hacking.
					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != MountID.Drill && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID]))
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (axe) {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 4);
						args.Handled = true;
						return;
					}
					// If the tile is a hammer tile and they aren't selecting a hammer, they're hacking.
					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != MountID.Drill && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID]))
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (hammer) {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 4);
						args.Handled = true;
						return;
					}
					// If the tile is a pickaxe tile and they aren't selecting a pickaxe, they're hacking.
					// Item frames can be modified without pickaxe tile.
					// also add an exception for snake coils, they can be removed when the player places a new one or after x amount of time
					// If the tile is part of the breakable when placing set, it might be getting broken by a placement.
					else if (tile.type != TileID.ItemFrame && tile.type != TileID.MysticSnakeRope
														   && !ItemID.Sets.Explosives[selectedItem.netID]
														   && !TileID.Sets.BreakableWhenPlacing[tile.type]
														   && !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0
														   && selectedItem.pick == 0 && selectedItem.type != ItemID.GravediggerShovel
														   && args.Player.TPlayer.mount.Type != MountID.Drill
														   && args.Player.TPlayer.mount.Type != MountID.DiggingMoleMinecart)
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (pick) {0} {1} {2}", args.Player.Name, action,
							editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 4);
						args.Handled = true;
						return;
					}
				}
				else if (action == EditAction.KillWall)
				{
					// If they aren't selecting a hammer, they could be hacking.
					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (hammer2) {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 1);
						args.Handled = true;
						return;
					}
				}
				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))
				{
					args.Player.LastKilledProjectile = 0;
				}
				else if (CoilTileIds.Contains(editData))
				{
					// Handle placement if the user is placing rope that comes from a ropecoil,
					// but have not created the ropecoil projectile recently or the projectile was not at the correct coordinate, or the tile that the projectile places does not match the rope it is suposed to place
					// projectile should be the same X coordinate as all tile places (Note by @Olink)
					if (ropeCoilPlacements.ContainsKey(selectedItem.netID) &&
						!args.Player.RecentlyCreatedProjectiles.Any(p => GetDataHandlers.projectileCreatesTile.ContainsKey(p.Type) && GetDataHandlers.projectileCreatesTile[p.Type] == editData &&
						!p.Killed && Math.Abs((int)(Main.projectile[p.Index].position.X / 16f) - tileX) <= Math.Abs(Main.projectile[p.Index].velocity.X)))
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (inconceivable rope coil) {0} {1} {2} selectedItem:{3} itemCreateTile:{4}", args.Player.Name, action, editData, selectedItem.netID, selectedItem.createTile));
						args.Player.SendTileSquareCentered(tileX, tileY, 1);
						args.Handled = true;
						return;
					}
				}
				else if (action == EditAction.PlaceTile || action == EditAction.ReplaceTile || action == EditAction.PlaceWall || action == EditAction.ReplaceWall)
				{
					if ((action == EditAction.PlaceTile && TShock.Config.Settings.PreventInvalidPlaceStyle) &&
						requestedPlaceStyle > GetMaxPlaceStyle(editData))
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (ms1) {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 4);
						args.Handled = true;
						return;
					}

					/// Handle placement action if the player is using an Ice Rod but not placing the iceblock.
					if (selectedItem.netID == ItemID.IceRod && editData != TileID.MagicalIceBlock)
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from using ice rod but not placing ice block {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 4);
						args.Handled = true;
					}
					/// If they aren't selecting the item which creates the tile, they're hacking.
					if ((action == EditAction.PlaceTile || action == EditAction.ReplaceTile) && editData != selectedItem.createTile)
					{
						/// These would get caught up in the below check because Terraria does not set their createTile field.
						if (selectedItem.netID != ItemID.IceRod && selectedItem.netID != ItemID.DirtBomb && selectedItem.netID != ItemID.StickyBomb && (args.Player.TPlayer.mount.Type != MountID.DiggingMoleMinecart || editData != TileID.MinecartTrack))
						{
							TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from tile placement not matching selected item createTile {0} {1} {2} selectedItemID:{3} createTile:{4}", args.Player.Name, action, editData, selectedItem.netID, selectedItem.createTile));
							args.Player.SendTileSquareCentered(tileX, tileY, 4);
							args.Handled = true;
							return;
						}
					}
					/// If they aren't selecting the item which creates the wall, they're hacking.
					if ((action == EditAction.PlaceWall || action == EditAction.ReplaceWall) && editData != selectedItem.createWall)
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from wall placement not matching selected item createWall {0} {1} {2} selectedItemID:{3} createWall:{4}", args.Player.Name, action, editData, selectedItem.netID, selectedItem.createWall));
						args.Player.SendTileSquareCentered(tileX, tileY, 4);
						args.Handled = true;
						return;
					}
					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))
					{
						if (TShock.Utils.HasWorldReachedMaxChests())
						{
							TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from (chestcap) {0} {1} {2}", args.Player.Name, action, editData));
							args.Player.SendErrorMessage(GetString("The world's chest limit has been reached - unable to place more."));
							args.Player.SendTileSquareCentered(tileX, tileY, 3);
							args.Handled = true;
							return;
						}
					}
				}
				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)
				{
					// If they aren't selecting a wrench, they're hacking.
					// WireKite = The Grand Design
					if (selectedItem.type != ItemID.Wrench
						&& selectedItem.type != ItemID.BlueWrench
						&& selectedItem.type != ItemID.GreenWrench
						&& selectedItem.type != ItemID.YellowWrench
						&& selectedItem.type != ItemID.MulticolorWrench
						&& selectedItem.type != ItemID.WireKite)
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from place wire from {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 1);
						args.Handled = true;
						return;
					}
				}
				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||
					action == EditAction.KillWire2 || action == EditAction.KillWire3)
				{
					// If they aren't selecting the wire cutter, they're hacking.
					if (selectedItem.type != ItemID.WireCutter
						&& selectedItem.type != ItemID.WireKite
						&& selectedItem.type != ItemID.MulticolorWrench)
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from wire cutter from {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 1);
						args.Handled = true;
						return;
					}
				}
				else if (action == EditAction.PlaceActuator)
				{
					// If they aren't selecting the actuator and don't have the Presserator equipped, they're hacking.
					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from actuator/presserator from {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 1);
						args.Handled = true;
						return;
					}
				}
				if (TShock.Config.Settings.AllowCutTilesAndBreakables && Main.tileCut[tile.type])
				{
					if (action == EditAction.KillWall || action == EditAction.ReplaceWall)
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from sts allow cut from {0} {1} {2}", args.Player.Name, action, editData));
						args.Player.SendTileSquareCentered(tileX, tileY, 1);
						args.Handled = true;
						return;
					}
					args.Handled = false;
					return;
				}

				if (args.Player.IsBeingDisabled())
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from disable from {0} {1} {2}", args.Player.Name, action, editData));
					args.Player.SendTileSquareCentered(tileX, tileY, 4);
					args.Handled = true;
					return;
				}

				if (!args.Player.HasModifiedIceSuccessfully(tileX, tileY, editData, action)
					&& !args.Player.HasBuildPermission(tileX, tileY))
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from ice/build from {0} {1} {2}", args.Player.Name, action, editData));

					GetRollbackRectSize(tileX, tileY, out byte width, out byte length, out int offsetY);
					args.Player.SendTileRect((short)(tileX - width), (short)(tileY + offsetY), (byte)(width * 2), (byte)(length + 1));
					args.Handled = true;
					return;
				}

				//make sure it isnt a snake coil related edit so it doesnt spam debug logs with range check failures
				if (((action == EditAction.PlaceTile && editData != TileID.MysticSnakeRope) || (action == EditAction.KillTile && tile.type != TileID.MysticSnakeRope)) && !args.Player.IsInRange(tileX, tileY))
				{
					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope || editData == TileID.MysticSnakeRope))
					{
						args.Handled = false;
						return;
					}

					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)
					{
						args.Handled = false;
						return;
					}

					// Dirt bomb makes dirt everywhere
					if ((action == EditAction.PlaceTile || action == EditAction.SlopeTile) && editData == TileID.Dirt && args.Player.RecentFuse > 0)
					{
						args.Handled = false;
						return;
					}

					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from explosives/fuses from {0} {1} {2}", args.Player.Name, action, editData));
					args.Player.SendTileSquareCentered(tileX, tileY, 4);
					args.Handled = true;
					return;
				}

				if (args.Player.TileKillThreshold >= TShock.Config.Settings.TileKillThreshold)
				{
					if (TShock.Config.Settings.KickOnTileKillThresholdBroken)
					{
						args.Player.Kick(GetString("Tile kill threshold exceeded {0}.", TShock.Config.Settings.TileKillThreshold));
					}
					else
					{
						args.Player.Disable(GetString("Reached TileKill threshold."), DisableFlags.WriteToLogAndConsole);
						args.Player.SendTileSquareCentered(tileX, tileY, 4);
					}

					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from tile kill threshold from {0}, (value: {1})", args.Player.Name, args.Player.TileKillThreshold));
					TShock.Log.ConsoleDebug(GetString("If this player wasn't hacking, please report the tile kill threshold they were disabled for to TShock so we can improve this!"));
					args.Handled = true;
					return;
				}

				if (args.Player.TilePlaceThreshold >= TShock.Config.Settings.TilePlaceThreshold)
				{
					if (TShock.Config.Settings.KickOnTilePlaceThresholdBroken)
					{
						args.Player.Kick(GetString("Tile place threshold exceeded {0}.", TShock.Config.Settings.TilePlaceThreshold));
					}
					else
					{
						args.Player.Disable(GetString("Reached TilePlace threshold."), DisableFlags.WriteToLogAndConsole);
						args.Player.SendTileSquareCentered(tileX, tileY, 4);
					}

					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from tile place threshold from {0}, (value: {1})", args.Player.Name, args.Player.TilePlaceThreshold));
					TShock.Log.ConsoleDebug(GetString("If this player wasn't hacking, please report the tile place threshold they were disabled for to TShock so we can improve this!"));
					args.Handled = true;
					return;
				}

				if (args.Player.IsBouncerThrottled())
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from throttled from {0} {1} {2}", args.Player.Name, action, editData));
					args.Player.SendTileSquareCentered(tileX, tileY, 4);
					args.Handled = true;
					return;
				}

				//snake coil can allow massive amounts of tile edits so it gets an exception
				if (!((action == EditAction.PlaceTile && editData == TileID.MysticSnakeRope) || (action == EditAction.KillTile && tile.type == TileID.MysticSnakeRope)))
				{
					if ((action == EditAction.PlaceTile || action == EditAction.ReplaceTile || action == EditAction.PlaceWall || action == EditAction.ReplaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))
					{
						args.Player.TilePlaceThreshold++;
						var coords = new Vector2(tileX, tileY);
						lock (args.Player.TilesCreated)
							if (!args.Player.TilesCreated.ContainsKey(coords))
								args.Player.TilesCreated.Add(coords, Main.tile[tileX, tileY]);
					}

					if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.ReplaceTile || action == EditAction.KillWall || action == EditAction.ReplaceWall) && Main.tileSolid[Main.tile[tileX, tileY].type] &&
						!args.Player.HasPermission(Permissions.ignorekilltiledetection))
					{
						args.Player.TileKillThreshold++;
						var coords = new Vector2(tileX, tileY);
						lock (args.Player.TilesDestroyed)
							if (!args.Player.TilesDestroyed.ContainsKey(coords))
								args.Player.TilesDestroyed.Add(coords, Main.tile[tileX, tileY]);
					}
				}
				args.Handled = false;
				return;
			}
			catch
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnTileEdit rejected from weird confusing flow control from {0}", args.Player.Name));
				TShock.Log.ConsoleDebug(GetString("If you're seeing this message and you know what that player did, please report it to TShock for further investigation."));
				args.Player.SendTileSquareCentered(tileX, tileY, 4);
				args.Handled = true;
				return;
			}
		}

		/// <summary>
		/// Gets the size of the rectangle required to rollback all tiles impacted by a single tile.
		/// Eg, rolling back the destruction of a tile that had a Safe on top would require rolling back the safe as well as the
		/// tile that was destroyed
		/// </summary>
		/// <param name="tileX">X position of the initial tile</param>
		/// <param name="tileY">Y position of the initial tile</param>
		/// <param name="width">The calculated width of the rectangle</param>
		/// <param name="length">The calculated length of the rectangle</param>
		/// <param name="offsetY">The Y offset from the initial tile Y that the rectangle should begin at</param>
		private void GetRollbackRectSize(int tileX, int tileY, out byte width, out byte length, out int offsetY)
		{
			CheckForTileObjectsAbove(out byte topWidth, out byte topLength, out offsetY);
			CheckForTileObjectsBelow(out byte botWidth, out byte botLength);

			// If no tile object exists around the given tile, width will be 1. Else the width of the largest tile object will be used
			width = Math.Max((byte)1, Math.Max(topWidth, botWidth));
			// If no tile object exists around the given tile, length will be 1. Else the sum of all tile object lengths will be used
			length = Math.Max((byte)1, (byte)(topLength + botLength));

			// Checks for the presence of tile objects above the tile being checked
			void CheckForTileObjectsAbove(out byte objWidth, out byte objLength, out int yOffset)
			{
				objWidth = 0;
				objLength = 0;
				yOffset = 0;

				if (tileY <= 0)
				{
					return;
				}

				ITile above = Main.tile[tileX, tileY - 1];
				if (above.type < TileObjectData._data.Count && TileObjectData._data[above.type] != null)
				{
					TileObjectData data = TileObjectData._data[above.type];
					objWidth = (byte)data.Width;
					objLength = (byte)data.Height;
					yOffset = -data.Height; //y offset is the negative of the height of the tile object
				}
			}

			//Checks for the presence of tile objects below the tile being checked
			void CheckForTileObjectsBelow(out byte objWidth, out byte objLength)
			{
				objWidth = 0;
				objLength = 0;

				if (tileY == Main.maxTilesY)
				{
					return;
				}

				ITile below = Main.tile[tileX, tileY + 1];
				if (below.type < TileObjectData._data.Count && TileObjectData._data[below.type] != null)
				{
					TileObjectData data = TileObjectData._data[below.type];
					objWidth = (byte)data.Width;
					objLength = (byte)data.Height;
				}
			}
		}

		/// <summary>Registered when items fall to the ground to prevent cheating.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnItemDrop(object sender, GetDataHandlers.ItemDropEventArgs args)
		{
			short id = args.ID;
			Vector2 pos = args.Position;
			Vector2 vel = args.Velocity;
			short stacks = args.Stacks;
			short prefix = args.Prefix;
			bool noDelay = args.NoDelay;
			short type = args.Type;

			if (!float.IsFinite(pos.X) || !float.IsFinite(pos.Y))
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnItemDrop force kicked (attempted to set position to infinity or NaN) from {0}", args.Player.Name));
				args.Player.Kick(GetString("Detected DOOM set to ON position."), true, true);
				args.Handled = true;
				return;
			}

			if (!float.IsFinite(vel.X) || !float.IsFinite(vel.Y))
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnItemDrop force kicked (attempted to set velocity to infinity or NaN) from {0}", args.Player.Name));
				args.Player.Kick(GetString("Detected DOOM set to ON position."), true, true);
				args.Handled = true;
				return;
			}

			// player is attempting to crash clients
			if (type < -48 || type >= Terraria.ID.ItemID.Count)
			{
				// Causes item duplications. Will be re added later if necessary
				//args.Player.SendData(PacketTypes.ItemDrop, "", id);
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnItemDrop rejected from attempt crash from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			// make sure the prefix is a legit value
			// Note: Not checking if prefix is less than 1 because if it is, this check
			// will break item pickups on the client.
			if (prefix > PrefixID.Count)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnItemDrop rejected from prefix check from {0}", args.Player.Name));

				args.Player.SendData(PacketTypes.ItemDrop, "", id);
				args.Handled = true;
				return;
			}

			//Item removed, let client do this to prevent item duplication
			// client side (but only if it passed the range check) (i.e., return false)
			if (type == 0)
			{
				if (!args.Player.IsInRange((int)(Main.item[id].position.X / 16f), (int)(Main.item[id].position.Y / 16f)))
				{
					// Causes item duplications. Will be re added if necessary
					//args.Player.SendData(PacketTypes.ItemDrop, "", id);
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnItemDrop rejected from dupe range check from {0}", args.Player.Name));
					args.Handled = true;
					return;
				}

				args.Handled = false;
				return;
			}

			if (!args.Player.IsInRange((int)(pos.X / 16f), (int)(pos.Y / 16f)))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnItemDrop rejected from range check from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.ItemDrop, "", id);
				args.Handled = true;
				return;
			}

			// stop the client from changing the item type of a drop but
			// only if the client isn't picking up the item
			if (Main.item[id].active && Main.item[id].netID != type)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnItemDrop rejected from item drop/pickup check from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.ItemDrop, "", id);
				args.Handled = true;
				return;
			}

			Item item = new Item();
			item.netDefaults(type);
			if ((stacks > item.maxStack || stacks <= 0) || (TShock.ItemBans.DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type), args.Player) && !args.Player.HasPermission(Permissions.allowdroppingbanneditems)))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnItemDrop rejected from drop item ban check / max stack check / min stack check from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.ItemDrop, "", id);
				args.Handled = true;
				return;
			}

			// TODO: Remove item ban part of this check
			if ((Main.ServerSideCharacter) && (DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond - args.Player.LoginMS < TShock.ServerSideCharacterConfig.Settings.LogonDiscardThreshold))
			{
				//Player is probably trying to sneak items onto the server in their hands!!!
				TShock.Log.ConsoleInfo(GetString("Player {0} tried to sneak {1} onto the server!", args.Player.Name, item.Name));
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnItemDrop rejected from sneaky from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.ItemDrop, "", id);
				args.Handled = true;
				return;

			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnItemDrop rejected from disabled from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.ItemDrop, "", id);
				args.Handled = true;
				return;
			}
		}

		/// <summary>Bouncer's projectile trigger hook stops world damaging projectiles from destroying the world.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnNewProjectile(object sender, GetDataHandlers.NewProjectileEventArgs args)
		{
			short ident = args.Identity;
			Vector2 pos = args.Position;
			Vector2 vel = args.Velocity;
			float knockback = args.Knockback;
			short damage = args.Damage;
			byte owner = args.Owner;
			short type = args.Type;
			int index = args.Index;
			float[] ai = args.Ai;

			// Clients do send NaN values so we can't just kick them
			// See https://github.com/Pryaxis/TShock/issues/3076
			if (!float.IsFinite(pos.X) || !float.IsFinite(pos.Y))
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnNewProjectile rejected set position to infinity or NaN from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (!float.IsFinite(vel.X) || !float.IsFinite(vel.Y))
			{
				TShock.Log.ConsoleInfo(GetString("Bouncer / OnNewProjectile rejected set velocity to infinity or NaN from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (index > Main.maxProjectiles)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from above projectile limit from {0}", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			if (TShock.ProjectileBans.ProjectileIsBanned(type, args.Player))
			{
				args.Player.Disable(GetString("Player does not have permission to create projectile {0}.", type), DisableFlags.WriteToLogAndConsole);
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from permission check from {0} {1}", args.Player.Name, type));
				args.Player.SendErrorMessage(GetString("You do not have permission to create that projectile."));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			if (damage > TShock.Config.Settings.MaxProjDamage && !args.Player.HasPermission(Permissions.ignoredamagecap))
			{
				args.Player.Disable(GetString("Projectile damage is higher than {0}.", TShock.Config.Settings.MaxProjDamage), DisableFlags.WriteToLogAndConsole);
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from projectile damage limit from {0} {1}/{2}", args.Player.Name, damage, TShock.Config.Settings.MaxProjDamage));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from disabled from {0}", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			/// If the projectile is a directional projectile, check if the player is holding their respected item to validate the projectile creation.
			if (directionalProjectiles.ContainsKey(type))
			{
				if (directionalProjectiles[type] == args.Player.TPlayer.HeldItem.type)
				{
					args.Handled = false;
					return;
				}
			}

			/// If the created projectile is a golf club, check if the player is holding one of the golf club items to validate the projectile creation.
			if (type == ProjectileID.GolfClubHelper && Handlers.LandGolfBallInCupHandler.GolfClubItemIDs.Contains(args.Player.TPlayer.HeldItem.type))
			{
				args.Handled = false;
				return;
			}

			/// If the created projectile is a golf ball and the player is not holding a golf club item and neither a golf ball item and neither they have had a golf club projectile created recently.
			if (Handlers.LandGolfBallInCupHandler.GolfBallProjectileIDs.Contains(type) &&
				!Handlers.LandGolfBallInCupHandler.GolfClubItemIDs.Contains(args.Player.TPlayer.HeldItem.type) &&
				!Handlers.LandGolfBallInCupHandler.GolfBallItemIDs.Contains(args.Player.TPlayer.HeldItem.type) &&
				!args.Player.RecentlyCreatedProjectiles.Any(p => p.Type == ProjectileID.GolfClubHelper))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile please report to tshock about this! normally this is a reject from {0} {1} (golf)", args.Player.Name, type));
			}

			// Main.projHostile contains projectiles that can harm players
			// without PvP enabled and belong to enemy mobs, so they shouldn't be
			// possible for players to create. (Source: Ijwu, QuiCM)
			if (Main.projHostile[type])
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from hostile projectile from {0}", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			// Tombstones should never be permitted by players
			// This check means like, invalid or hacked tombstones (sent from hacked clients)
			// Death does not create a tombstone projectile by default
			if (type == ProjectileID.Tombstone)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from tombstones from {0}", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			if (!TShock.Config.Settings.IgnoreProjUpdate && !args.Player.HasPermission(Permissions.ignoreprojectiledetection))
			{
				if (type == ProjectileID.BlowupSmokeMoonlord
					|| type == ProjectileID.PhantasmalEye
					|| type == ProjectileID.CultistBossIceMist
					|| (type >= ProjectileID.MoonlordBullet && type <= ProjectileID.MoonlordTurretLaser)
					|| type == ProjectileID.DeathLaser || type == ProjectileID.Landmine
					|| type == ProjectileID.BulletDeadeye || type == ProjectileID.BoulderStaffOfEarth
					|| (type > ProjectileID.ConfettiMelee && type < ProjectileID.SpiritHeal)
					|| (type >= ProjectileID.FlamingWood && type <= ProjectileID.GreekFire3)
					|| (type >= ProjectileID.PineNeedleHostile && type <= ProjectileID.Spike)
					|| (type >= ProjectileID.MartianTurretBolt && type <= ProjectileID.RayGunnerLaser)
					|| type == ProjectileID.CultistBossLightningOrb)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from weird check from {0} {1}", args.Player.Name, type));
					TShock.Log.Debug(GetString("Certain projectiles have been ignored for cheat detection."));
				}
				else
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile please report to tshock about this! normally this is a reject from {0} {1}", args.Player.Name, type));
					// args.Player.Disable(String.Format("Does not have projectile permission to update projectile. ({0})", type), DisableFlags.WriteToLogAndConsole);
					// args.Player.RemoveProjectile(ident, owner);
				}
				// args.Handled = false;
				// return;
			}

			if (args.Player.ProjectileThreshold >= TShock.Config.Settings.ProjectileThreshold)
			{
				if (TShock.Config.Settings.KickOnProjectileThresholdBroken)
				{
					args.Player.Kick(GetString("Projectile create threshold exceeded {0}.", TShock.Config.Settings.ProjectileThreshold));
				}
				else
				{
					args.Player.Disable(GetString("Reached projectile create threshold."), DisableFlags.WriteToLogAndConsole);
					args.Player.RemoveProjectile(ident, owner);
				}

				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from projectile create threshold from {0} {1}/{2}", args.Player.Name, args.Player.ProjectileThreshold, TShock.Config.Settings.ProjectileThreshold));
				TShock.Log.ConsoleDebug(GetString("If this player wasn't hacking, please report the projectile create threshold they were disabled for to TShock so we can improve this!"));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from bouncer throttle from {0}", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			if (
				(Projectile_MaxValuesAI.ContainsKey(type) &&
					(Projectile_MaxValuesAI[type] < ai[0] || Projectile_MinValuesAI[type] > ai[0])) ||
				(Projectile_MaxValuesAI2.ContainsKey(type) &&
					(Projectile_MaxValuesAI2[type] < ai[1] || Projectile_MinValuesAI2[type] > ai[1]))
			)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from bouncer modified AI from {0}.", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			/*
			 * ai - Arguments that Projectile.AI uses for easier projectile control.
			 *	ai[0] - Distance from player (Doesn't affect the result very much)
			 *	ai[1] - The identifier of the object that will fly.
			 *
			 * FinalFractalHelper._fractalProfiles - A list of items that must be used in Zenith. (And also their colors)
			 *	If you add an item to this collection, it will also fly in the Zenith. (not active from server)
			*/
			if (TShock.Config.Settings.DisableModifiedZenith && type == ProjectileID.FinalFractal && (ai[0] < -100 || ai[0] > 101) && !Terraria.Graphics.FinalFractalHelper._fractalProfiles.ContainsKey((int)ai[1]))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNewProjectile rejected from bouncer modified Zenith projectile from {0}.", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				args.Handled = true;
				return;
			}

			if (!args.Player.HasPermission(Permissions.ignoreprojectiledetection))
			{
				if (type == ProjectileID.CrystalShard && TShock.Config.Settings.ProjIgnoreShrapnel) // Ignore crystal shards
				{
					TShock.Log.Debug(GetString("Ignoring shrapnel per config.."));
				}
				else if (!Main.projectile[index].active)
				{
					args.Player.ProjectileThreshold++; // Creating new projectile
				}
			}

			if ((type == ProjectileID.Bomb
				|| type == ProjectileID.Dynamite
				|| type == ProjectileID.StickyBomb
				|| type == ProjectileID.StickyDynamite
				|| type == ProjectileID.BombFish
				|| type == ProjectileID.ScarabBomb
				|| type == ProjectileID.DirtBomb))
			{
				//  Denotes that the player has recently set a fuse - used for cheat detection.
				args.Player.RecentFuse = 10;
			}
		}

		/// <summary>Handles the NPC Strike event for Bouncer.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnNPCStrike(object sender, GetDataHandlers.NPCStrikeEventArgs args)
		{
			short id = args.ID;
			byte direction = args.Direction;
			short damage = args.Damage;
			float knockback = args.Knockback;
			byte crit = args.Critical;

			if (Main.npc[id] == null)
			{
				args.Handled = true;
				return;
			}

			if (damage >= TShock.Config.Settings.MaxDamage && !args.Player.HasPermission(Permissions.ignoredamagecap))
			{
				if (TShock.Config.Settings.KickOnDamageThresholdBroken)
				{
					args.Player.Kick(GetString("NPC damage exceeded {0}.", TShock.Config.Settings.MaxDamage));
				}
				else
				{
					args.Player.Disable(GetString("NPC damage exceeded {0}.", TShock.Config.Settings.MaxDamage), DisableFlags.WriteToLogAndConsole);
					args.Player.SendData(PacketTypes.NpcUpdate, "", id);
				}

				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNPCStrike rejected from damage threshold from {0} {1}/{2}", args.Player.Name, damage, TShock.Config.Settings.MaxDamage));
				TShock.Log.ConsoleDebug(GetString("If this player wasn't hacking, please report the damage threshold they were disabled for to TShock so we can improve this!"));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNPCStrike rejected from disabled from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.NpcUpdate, "", id);
				args.Handled = true;
				return;
			}

			if (TShock.Config.Settings.RangeChecks &&
				!args.Player.IsInRange((int)(Main.npc[id].position.X / 16f), (int)(Main.npc[id].position.Y / 16f), 128))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNPCStrike rejected from range checks from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.NpcUpdate, "", id);
				args.Handled = true;
				return;
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNPCStrike rejected from bouncer throttle from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.NpcUpdate, "", id);
				args.Handled = true;
				return;
			}
		}

		/// <summary>Handles ProjectileKill events for throttling and out of bounds projectiles.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnProjectileKill(object sender, GetDataHandlers.ProjectileKillEventArgs args)
		{
			if (args.ProjectileIndex < 0)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnProjectileKill rejected from negative projectile index from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnProjectileKill rejected from disabled from {0}", args.Player.Name));
				args.Player.RemoveProjectile(args.ProjectileIdentity, args.ProjectileOwner);
				args.Handled = true;
				return;
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnProjectileKill rejected from bouncer throttle from {0}", args.Player.Name));
				args.Player.RemoveProjectile(args.ProjectileIdentity, args.ProjectileOwner);
				args.Handled = true;
				return;
			}
		}

		/// <summary>Handles when a chest item is changed.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnChestItemChange(object sender, GetDataHandlers.ChestItemEventArgs args)
		{
			short id = args.ID;
			byte slot = args.Slot;
			short stacks = args.Stacks;
			byte prefix = args.Prefix;
			short type = args.Type;

			if (args.Player.TPlayer.chest != id)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnChestItemChange rejected from chest mismatch from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnChestItemChange rejected from disable from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.ChestItem, "", id, slot);
				args.Handled = true;
				return;
			}

			if (!args.Player.HasBuildPermission(Main.chest[id].x, Main.chest[id].y) && TShock.Config.Settings.RegionProtectChests)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnChestItemChange rejected from region protection? from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (!args.Player.IsInRange(Main.chest[id].x, Main.chest[id].y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnChestItemChange rejected from range check from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
		}

		/// <summary>The Bouncer handler for when chests are opened.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnChestOpen(object sender, GetDataHandlers.ChestOpenEventArgs args)
		{
			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnChestOpen rejected from disabled from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (!args.Player.IsInRange(args.X, args.Y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnChestOpen rejected from range check from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (!args.Player.HasBuildPermission(args.X, args.Y) && TShock.Config.Settings.RegionProtectChests)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnChestOpen rejected from region check from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			int id = Chest.FindChest(args.X, args.Y);
			args.Player.ActiveChest = id;
		}

		/// <summary>The place chest event that Bouncer hooks to prevent accidental damage.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnPlaceChest(object sender, GetDataHandlers.PlaceChestEventArgs args)
		{
			int tileX = args.TileX;
			int tileY = args.TileY;
			int flag = args.Flag;
			short style = args.Style;

			if (!TShock.Utils.TilePlacementValid(tileX, tileY) || (args.Player.Dead && TShock.Config.Settings.PreventDeadModification))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceChest rejected from invalid check from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceChest rejected from disabled from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 3);
				args.Handled = true;
				return;
			}

			if (args.Player.SelectedItem.placeStyle != style)
			{
				TShock.Log.ConsoleError(GetString("Bouncer / OnPlaceChest / rejected from invalid place style from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 3);
				args.Handled = true;
				return;
			}

			if (flag != 0 && flag != 4 // if no container or container2 placement
				&& Main.tile[tileX, tileY].type != TileID.Containers
				&& Main.tile[tileX, tileY].type != TileID.Dressers
				&& Main.tile[tileX, tileY].type != TileID.Containers2
				&& (!TShock.Utils.HasWorldReachedMaxChests() && Main.tile[tileX, tileY].type != TileID.Dirt)) //Chest
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceChest rejected from weird check from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 3);
				args.Handled = true;
				return;
			}

			if (flag == 2) //place dresser
			{
				if ((TShock.Utils.TilePlacementValid(tileX, tileY + 1) && Main.tile[tileX, tileY + 1].type == TileID.Teleporter) ||
					(TShock.Utils.TilePlacementValid(tileX + 1, tileY + 1) && Main.tile[tileX + 1, tileY + 1].type == TileID.Teleporter))
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceChest rejected from weird placement check from {0}", args.Player.Name));
					//Prevent a dresser from being placed on a teleporter, as this can cause client and server crashes.
					args.Player.SendTileSquareCentered(tileX, tileY, 3);
					args.Handled = true;
					return;
				}
			}

			if (!args.Player.HasBuildPermission(tileX, tileY))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceChest rejected from invalid permission from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 3);
				args.Handled = true;
				return;
			}

			if (!args.Player.IsInRange(tileX, tileY))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceChest rejected from range check from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 3);
				args.Handled = true;
				return;
			}
		}

		/// <summary>Handles PlayerZone events for preventing spawning NPC maliciously.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnPlayerZone(object sender, GetDataHandlers.PlayerZoneEventArgs args)
		{
			if (args.Zone2[1] || args.Zone2[2] || args.Zone2[3] || args.Zone2[4])
			{
				bool hasSolarTower = false;
				bool hasVortexTower = false;
				bool hasNebulaTower = false;
				bool hasStardustTower = false;

				foreach (var npc in Main.npc)
				{
					if (npc.netID == NPCID.LunarTowerSolar)
						hasSolarTower = true;
					else if (npc.netID == NPCID.LunarTowerVortex)
						hasVortexTower = true;
					else if (npc.netID == NPCID.LunarTowerNebula)
						hasNebulaTower = true;
					else if (npc.netID == NPCID.LunarTowerStardust)
						hasStardustTower = true;
				}

				if ((args.Zone2[1] && !hasSolarTower)
					|| (args.Zone2[2] && !hasVortexTower)
					|| (args.Zone2[3] && !hasNebulaTower)
					|| (args.Zone2[4] && !hasStardustTower)
					)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerZone rejected from {0}", args.Player.Name));
					args.Handled = true;
					return;
				}
			}
		}

		/// <summary>Handles basic animation throttling for disabled players.</summary>
		/// <param name="sender">sender</param>
		/// <param name="args">args</param>
		internal void OnPlayerAnimation(object sender, GetDataHandlers.PlayerAnimationEventArgs args)
		{
			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerAnimation rejected from disabled from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PlayerAnimation, "", args.Player.Index);
				args.Handled = true;
				return;
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerAnimation rejected from throttle from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PlayerAnimation, "", args.Player.Index);
				args.Handled = true;
				return;
			}
		}

		/// <summary>Handles Bouncer's liquid set anti-cheat.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnLiquidSet(object sender, GetDataHandlers.LiquidSetEventArgs args)
		{
			int tileX = args.TileX;
			int tileY = args.TileY;
			byte amount = args.Amount;
			LiquidType type = args.Type;

			if (!TShock.Utils.TilePlacementValid(tileX, tileY) || (args.Player.Dead && TShock.Config.Settings.PreventDeadModification))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnLiquidSet rejected invalid check from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnLiquidSet rejected disabled from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 1);
				args.Handled = true;
				return;
			}

			if (args.Player.TileLiquidThreshold >= TShock.Config.Settings.TileLiquidThreshold)
			{
				if (TShock.Config.Settings.KickOnTileLiquidThresholdBroken)
				{
					args.Player.Kick(GetString("Reached TileLiquid threshold {0}.", TShock.Config.Settings.TileLiquidThreshold));
				}
				else
				{
					args.Player.Disable(GetString("Reached TileLiquid threshold."), DisableFlags.WriteToLogAndConsole);
					args.Player.SendTileSquareCentered(tileX, tileY, 1);
				}

				TShock.Log.ConsoleDebug(GetString("Bouncer / OnLiquidSet rejected from liquid threshold from {0} {1}/{2}", args.Player.Name, args.Player.TileLiquidThreshold, TShock.Config.Settings.TileLiquidThreshold));
				TShock.Log.ConsoleDebug(GetString("If this player wasn't hacking, please report the tile liquid threshold they were disabled for to TShock so we can improve this!"));
				args.Handled = true;
				return;
			}

			if (!args.Player.HasPermission(Permissions.ignoreliquidsetdetection))
			{
				args.Player.TileLiquidThreshold++;
			}

			bool wasThereABombNearby = false;
			lock (args.Player.RecentlyCreatedProjectiles)
			{
				IEnumerable<int> projectileTypesThatPerformThisOperation;
				if (amount > 0) //handle the projectiles that create fluid.
				{
					projectileTypesThatPerformThisOperation = projectileCreatesLiquid.Where(k => k.Value == type).Select(k => k.Key);
				}
				else //handle the scenario where we are removing liquid
				{
					projectileTypesThatPerformThisOperation = projectileCreatesLiquid.Where(k => k.Value == LiquidType.Removal).Select(k => k.Key);
				}

				var recentBombs = args.Player.RecentlyCreatedProjectiles.Where(p => projectileTypesThatPerformThisOperation.Contains(Main.projectile[p.Index].type));
				wasThereABombNearby = recentBombs.Any(r => Math.Abs(args.TileX - (Main.projectile[r.Index].position.X / 16.0f)) < TShock.Config.Settings.BombExplosionRadius
														&& Math.Abs(args.TileY - (Main.projectile[r.Index].position.Y / 16.0f)) < TShock.Config.Settings.BombExplosionRadius);
			}

			// Liquid anti-cheat
			// Arguably the banned buckets bit should be in the item bans system
			if (amount != 0 && !wasThereABombNearby)
			{
				int selectedItemType = args.Player.TPlayer.inventory[args.Player.TPlayer.selectedItem].type;

				void Reject(string reason)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnLiquidSet rejected liquid type {0} from {1} holding {2}", type, args.Player.Name, selectedItemType));
					args.Player.SendErrorMessage(GetString("You do not have permission to perform this action."));
					args.Player.Disable(reason, DisableFlags.WriteToLogAndConsole);
					args.Player.SendTileSquareCentered(tileX, tileY, 1);
					args.Handled = true;
				}

				if (TShock.ItemBans.DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItemType), args.Player))
				{
					Reject(GetString("Using banned {0} to manipulate liquid", Lang.GetItemNameValue(selectedItemType)));
					return;
				}

				switch (type)
				{
					case LiquidType.Water:
						if (TShock.ItemBans.DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(ItemID.WaterBucket), args.Player))
						{
							Reject(GetString("Using banned water bucket without permissions"));
							return;
						}
						break;
					case LiquidType.Lava:
						if (TShock.ItemBans.DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(ItemID.LavaBucket), args.Player))
						{
							Reject(GetString("Using banned lava bucket without permissions"));
							return;
						}
						break;
					case LiquidType.Honey:
						if (TShock.ItemBans.DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(ItemID.HoneyBucket), args.Player))
						{
							Reject(GetString("Using banned honey bucket without permissions"));
							return;
						}
						break;
					case LiquidType.Shimmer:
						if (TShock.ItemBans.DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(ItemID.BottomlessShimmerBucket), args.Player))
						{
							Reject(GetString("Using banned shimmering water bucket without permissions"));
							return;
						}
						break;
					default:
						Reject(GetString("Manipulating unknown liquid type"));
						return;
				}

				switch (selectedItemType)
				{
					case ItemID.WaterBucket:
					case ItemID.BottomlessBucket:
						if (type != LiquidType.Water)
						{
							Reject(GetString("Using {0} on non-water", Lang.GetItemNameValue(selectedItemType)));
							return;
						}
						break;
					case ItemID.HoneyBucket:
					case ItemID.HoneyAbsorbantSponge:
					case ItemID.BottomlessHoneyBucket:
						if (type != LiquidType.Honey)
						{
							Reject(GetString("Using {0} on non-honey", Lang.GetItemNameValue(selectedItemType)));
							return;
						}
						break;
					case ItemID.LavaAbsorbantSponge:
					case ItemID.BottomlessLavaBucket:
					case ItemID.LavaBucket:
						if (type != LiquidType.Lava)
						{
							Reject(GetString("Using {0} on non-lava", Lang.GetItemNameValue(selectedItemType)));
							return;
						}
						break;
					case ItemID.BottomlessShimmerBucket:
						if (type != LiquidType.Shimmer)
						{
							Reject(GetString("Using {0} on non-shimmer", Lang.GetItemNameValue(selectedItemType)));
							return;
						}
						break;
					case ItemID.SuperAbsorbantSponge:
						if (type != LiquidType.Water && type != LiquidType.Shimmer)
						{
							Reject(GetString("Using {0} on non-water or shimmer", Lang.GetItemNameValue(selectedItemType)));
							return;
						}
						break;
					case ItemID.EmptyBucket:
					case ItemID.UltraAbsorbantSponge:
						break;
					default:
						Reject(GetString("Using {0} to manipulate unknown liquid {1}", Lang.GetItemNameValue(selectedItemType), type));
						return;
				}
			}

			if (!args.Player.HasBuildPermission(tileX, tileY))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnLiquidSet rejected build permission from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 1);
				args.Handled = true;
				return;
			}

			if (!wasThereABombNearby && !args.Player.IsInRange(tileX, tileY, 16))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnLiquidSet rejected range checks from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 1);
				args.Handled = true;
				return;
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnLiquidSet rejected throttle from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(tileX, tileY, 1);
				args.Handled = true;
				return;
			}
		}

		/// <summary>Handles Buff events.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnPlayerBuff(object sender, GetDataHandlers.PlayerBuffEventArgs args)
		{
			byte id = args.ID;
			int type = args.Type;
			int time = args.Time;

			void Reject(bool shouldResync = true)
			{
				args.Handled = true;

				if (shouldResync)
					args.Player.SendData(PacketTypes.PlayerBuff, number: id);
			}

			if (id >= Main.maxPlayers)
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: target ID out of bounds",
					args.Player.Name, args.Player.Index, type, id, time));
				Reject(false);
				return;
			}

			if (TShock.Players[id] == null || !TShock.Players[id].Active)
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: target is null", args.Player.Name,
					args.Player.Index, type, id, time));
				Reject(false);
				return;
			}

			if (type >= Terraria.ID.BuffID.Count)
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: invalid buff type", args.Player.Name,
					args.Player.Index, type, id, time));
				Reject(false);
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is being disabled",
					args.Player.Name, args.Player.Index, type, id, time));
				Reject();
				return;
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is being throttled",
					args.Player.Name, args.Player.Index, type, id, time));
				Reject();

				return;
			}

			var targetPlayer = TShock.Players[id];
			var buffLimit = PlayerAddBuffWhitelist[type];

			if (!args.Player.IsInRange(targetPlayer.TileX, targetPlayer.TileY, 50))
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is not in range of target",
					args.Player.Name, args.Player.Index, type, id, time));
				Reject();
				return;
			}

			if (buffLimit == null)
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff is not whitelisted",
					args.Player.Name, args.Player.Index, type, id, time));
				Reject();
				return;
			}

			if (buffLimit.CanOnlyBeAppliedToSender && id != args.Player.Index)
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied to non-senders",
					args.Player.Name, args.Player.Index, type, id, time));
				Reject();
				return;
			}

			if (!buffLimit.CanBeAddedWithoutHostile && !targetPlayer.TPlayer.hostile)
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied without pvp",
					args.Player.Name, args.Player.Index, type, id, time));
				Reject();
				return;
			}

			if (time <= 0 || time > buffLimit.MaxTicks)
			{
				TShock.Log.ConsoleDebug(GetString(
					"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied for that long",
					args.Player.Name, args.Player.Index, type, id, time));
				Reject();
				return;
			}
		}

		/// <summary>Handles NPCAddBuff events.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnNPCAddBuff(object sender, GetDataHandlers.NPCAddBuffEventArgs args)
		{
			short id = args.ID;
			int type = args.Type;
			short time = args.Time;

			if (id >= Main.npc.Length)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNPCAddBuff rejected out of bounds NPC update from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			NPC npc = Main.npc[id];

			if (npc == null)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNPCAddBuff rejected null npc from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnNPCAddBuff rejected disabled from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (!args.Player.HasPermission(Permissions.ignorenpcbuffdetection))
			{
				bool detectedNPCBuffTimeCheat = false;

				if (NPCAddBuffTimeMax.ContainsKey(type))
				{
					if (time > NPCAddBuffTimeMax[type])
					{
						detectedNPCBuffTimeCheat = true;
					}

					if (npc.townNPC)
					{
						if (type != BuffID.Poisoned
							&& type != BuffID.OnFire
							&& type != BuffID.Confused
							&& type != BuffID.CursedInferno
							&& type != BuffID.Ichor
							&& type != BuffID.Venom
							&& type != BuffID.Midas
							&& type != BuffID.Wet
							&& type != BuffID.Lovestruck
							&& type != BuffID.Stinky
							&& type != BuffID.Slimed
							&& type != BuffID.DryadsWard
							&& type != BuffID.GelBalloonBuff
							&& type != BuffID.OnFire3
							&& type != BuffID.Frostburn2
							&& type != BuffID.Shimmer)
						{
							detectedNPCBuffTimeCheat = true;
						}
					}
				}
				else
				{
					detectedNPCBuffTimeCheat = true;
				}

				if (detectedNPCBuffTimeCheat)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnNPCAddBuff rejected abnormal buff ({0}, last for {4}) added to {1} ({2}) from {3}.", type, npc.TypeName, npc.netID, args.Player.Name, time));
					args.Player.Kick(GetString($"Added buff to {npc.TypeName} NPC abnormally."), true);
					args.Handled = true;
				}
			}
		}

		/// <summary>The Bouncer handler for when an NPC is rehomed.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnUpdateNPCHome(object sender, GetDataHandlers.NPCHomeChangeEventArgs args)
		{
			int id = args.ID;
			short x = args.X;
			short y = args.Y;

			if (!args.Player.HasBuildPermission(x, y))
			{
				args.Player.SendData(PacketTypes.UpdateNPCHome, "", id, Main.npc[id].homeTileX, Main.npc[id].homeTileY,
									 Convert.ToByte(Main.npc[id].homeless));
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnUpdateNPCHome rejected npc home build permission from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			// When kicking out an npc, x and y in args are 0, we shouldn't check range at this case
			if (args.HouseholdStatus != HouseholdStatus.Homeless && !args.Player.IsInRange(x, y))
			{
				args.Player.SendData(PacketTypes.UpdateNPCHome, "", id, Main.npc[id].homeTileX, Main.npc[id].homeTileY,
									 Convert.ToByte(Main.npc[id].homeless));
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnUpdateNPCHome rejected range checks from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
		}

		/// <summary>Bouncer's HealOther handler prevents gross misuse of HealOther packets by hackers.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnHealOtherPlayer(object sender, GetDataHandlers.HealOtherPlayerEventArgs args)
		{
			short amount = args.Amount;
			byte plr = args.TargetPlayerIndex;

			if (amount <= 0 || TShock.Players[plr] == null || !TShock.Players[plr].Active)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnHealOtherPlayer rejected null checks"));
				args.Handled = true;
				return;
			}

			// Why 0.2?
			// @bartico6: Because heal other player only happens when you are using the spectre armor with the hood,
			// and the healing you can do with that is 20% of your damage.
			if (amount >= TShock.Config.Settings.MaxDamage * 0.2 && !args.Player.HasPermission(Permissions.ignoredamagecap))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnHealOtherPlayer 0.2 check from {0}", args.Player.Name));
				args.Player.Disable(GetString("HealOtherPlayer cheat attempt!"), DisableFlags.WriteToLogAndConsole);
				args.Handled = true;
				return;
			}

			if (args.Player.HealOtherThreshold >= TShock.Config.Settings.HealOtherThreshold)
			{
				if (TShock.Config.Settings.KickOnHealOtherThresholdBroken)
				{
					args.Player.Kick(GetString("HealOtherPlayer threshold exceeded {0}.", TShock.Config.Settings.HealOtherThreshold));
				}
				else
				{
					args.Player.Disable(GetString("Reached HealOtherPlayer threshold."), DisableFlags.WriteToLogAndConsole);
				}
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnHealOtherPlayer rejected heal other threshold from {0} {1}/{2}", args.Player.Name, args.Player.HealOtherThreshold, TShock.Config.Settings.HealOtherThreshold));
				TShock.Log.ConsoleDebug(GetString("If this player wasn't hacking, please report the HealOtherPlayer threshold they were disabled for to TShock so we can improve this!"));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled() || args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnHealOtherPlayer rejected disabled/throttled from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			args.Player.HealOtherThreshold++;
			args.Handled = false;
			return;
		}

		/// <summary>
		/// A bouncer for checking NPC released by player
		/// </summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnReleaseNPC(object sender, GetDataHandlers.ReleaseNpcEventArgs args)
		{
			int x = args.X;
			int y = args.Y;
			short type = args.Type;
			byte style = args.Style;

			// if npc released outside allowed tile
			if (x >= Main.maxTilesX * 16 - 16 || x < 0 || y >= Main.maxTilesY * 16 - 16 || y < 0)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnReleaseNPC rejected out of bounds from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			// if player disabled
			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnReleaseNPC rejected npc release from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			void rejectForCritterNotReleasedFromItem()
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnReleaseNPC released different critter from {0}", args.Player.Name));
				args.Player.Kick(GetString("Released critter was not from its item."), true);
				args.Handled = true;
			}

			// if released npc not from its item (from crafted packet)
			// e.g. using bunny item to release golden bunny
			if (args.Player.TPlayer.lastVisualizedSelectedItem.makeNPC != type || args.Player.TPlayer.lastVisualizedSelectedItem.placeStyle != style)
			{
				// If the critter is an Explosive Bunny, check if we've recently created an Explosive Bunny projectile.
				// If we have, check if the critter we are trying to create is within range of the projectile
				// If we have at least one of those, then this wasn't a crafted packet, but simply a delayed critter release from an
				// Explosive Bunny projectile.
				if (type == NPCID.ExplosiveBunny)
				{
					bool areAnyBunnyProjectilesInRange;

					lock (args.Player.RecentlyCreatedProjectiles)
					{
						areAnyBunnyProjectilesInRange = args.Player.RecentlyCreatedProjectiles.Any(projectile =>
						{
							if (projectile.Type != ProjectileID.ExplosiveBunny)
								return false;

							var projectileInstance = Main.projectile[projectile.Index];
							return projectileInstance.active && projectileInstance.WithinRange(new Vector2(args.X, args.Y), 32.0f);
						});
					}

					if (!areAnyBunnyProjectilesInRange)
					{
						rejectForCritterNotReleasedFromItem();
						return;
					}
				}
				else
				{
					rejectForCritterNotReleasedFromItem();
					return;
				}
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnReleaseNPC rejected throttle from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
		}

		/// <summary>Bouncer's PlaceObject hook reverts malicious tile placement.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnPlaceObject(object sender, GetDataHandlers.PlaceObjectEventArgs args)
		{
			short x = args.X;
			short y = args.Y;
			short type = args.Type;
			short style = args.Style;

			if (!TShock.Utils.TilePlacementValid(x, y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected valid placements from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (type < 0 || type >= Terraria.ID.TileID.Count)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected out of bounds tile from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (x < 0 || x >= Main.maxTilesX)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected out of bounds tile x from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (y < 0 || y >= Main.maxTilesY)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected out of bounds tile y from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			//style 52 and 53 are used by ItemID.Fake_newchest1 and ItemID.Fake_newchest2
			//These two items cause localised lag and rendering issues
			if (type == TileID.FakeContainers && (style == 52 || style == 53))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected fake containers from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(x, y, 4);
				args.Handled = true;
				return;
			}

			// TODO: REMOVE. This does NOT look like Bouncer code.
			if (TShock.TileBans.TileIsBanned(type, args.Player))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected banned tiles from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(x, y, 1);
				args.Player.SendErrorMessage(GetString("You do not have permission to place this tile."));
				args.Handled = true;
				return;
			}

			if (args.Player.Dead && TShock.Config.Settings.PreventDeadModification)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected dead people don't do things from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(x, y, 4);
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected disabled from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(x, y, 4);
				args.Handled = true;
				return;
			}

			if (args.Player.SelectedItem.type is ItemID.RubblemakerSmall or ItemID.RubblemakerMedium or ItemID.RubblemakerLarge)
			{
				if (type != TileID.LargePilesEcho && type != TileID.LargePiles2Echo && type != TileID.SmallPiles2x1Echo &&
					type != TileID.SmallPiles1x1Echo && type != TileID.PlantDetritus3x2Echo && type != TileID.PlantDetritus2x2Echo)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected rubblemaker I can't believe it's not rubble! from {0}",
						args.Player.Name));
					args.Player.SendTileSquareCentered(x, y, 4);
					args.Handled = true;
					return;
				}
			}
			else if (args.Player.SelectedItem.type == ItemID.AcornAxe)
			{
				if (type != TileID.Saplings)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected Axe of Regrowth only places saplings {0}", args.Player.Name));
					args.Player.SendTileSquareCentered(x, y, 4);
					args.Handled = true;
					return;
				}
			}
			else
			{
				// This is necessary to check in order to prevent special tiles such as
				// queen bee larva, paintings etc that use this packet from being placed
				// without selecting the right item.
				if (type != args.Player.TPlayer.inventory[args.Player.TPlayer.selectedItem].createTile)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected awkward tile creation/selection from {0}", args.Player.Name));
					args.Player.SendTileSquareCentered(x, y, 4);
					args.Handled = true;
					return;
				}

				if (args.Player.SelectedItem.placeStyle != style)
				{
					var validTorch = args.Player.SelectedItem.createTile == TileID.Torches && args.Player.TPlayer.BiomeTorchPlaceStyle(args.Player.SelectedItem.placeStyle) == style;
					var validCampfire = args.Player.SelectedItem.createTile == TileID.Campfire && args.Player.TPlayer.BiomeCampfirePlaceStyle(args.Player.SelectedItem.placeStyle) == style;
					if (!args.Player.TPlayer.unlockedBiomeTorches || (!validTorch && !validCampfire))
					{
						TShock.Log.ConsoleError(GetString("Bouncer / OnPlaceObject rejected object placement with invalid style {1} (expected {2}) from {0}", args.Player.Name, style, args.Player.SelectedItem.placeStyle));
						args.Player.SendTileSquareCentered(x, y, 4);
						args.Handled = true;
						return;
					}
				}
			}

			TileObjectData tileData = TileObjectData.GetTileData(type, style, 0);
			if (tileData == null)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected null tile data from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			x -= tileData.Origin.X;
			y -= tileData.Origin.Y;

			for (int i = x; i < x + tileData.Width; i++)
			{
				for (int j = y; j < y + tileData.Height; j++)
				{
					if (!args.Player.HasModifiedIceSuccessfully(i, j, type, EditAction.PlaceTile)
						&& !args.Player.HasBuildPermission(i, j))
					{
						TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected mad loop from {0}", args.Player.Name));
						args.Player.SendTileSquareCentered(i, j, 4);
						args.Handled = true;
						return;
					}
				}
			}

			// Ignore rope placement range
			if ((type != TileID.Rope
					|| type != TileID.SilkRope
					|| type != TileID.VineRope
					|| type != TileID.WebRope
					|| type != TileID.MysticSnakeRope)
					&& !args.Player.IsInRange(x, y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected range checks from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(x, y, 4);
				args.Handled = true;
				return;
			}

			if (args.Player.TilePlaceThreshold >= TShock.Config.Settings.TilePlaceThreshold)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceObject rejected tile place threshold from {0} {1}/{2}", args.Player.Name, args.Player.TilePlaceThreshold, TShock.Config.Settings.TilePlaceThreshold));
				args.Player.Disable(GetString("Reached TilePlace threshold."), DisableFlags.WriteToLogAndConsole);
				args.Player.SendTileSquareCentered(x, y, 4);
				args.Handled = true;
				return;
			}

			if (!args.Player.HasPermission(Permissions.ignoreplacetiledetection))
			{
				args.Player.TilePlaceThreshold++;
				var coords = new Vector2(x, y);
				lock (args.Player.TilesCreated)
					if (!args.Player.TilesCreated.ContainsKey(coords))
						args.Player.TilesCreated.Add(coords, Main.tile[x, y]);
			}
		}

		/// <summary>Fired when a PlaceTileEntity occurs for basic anti-cheat on perms and range.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnPlaceTileEntity(object sender, GetDataHandlers.PlaceTileEntityEventArgs args)
		{
			if (!TShock.Utils.TilePlacementValid(args.X, args.Y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceTileEntity rejected tile placement valid from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceTileEntity rejected disabled from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (!args.Player.HasBuildPermission(args.X, args.Y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceTileEntity rejected permissions from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (!args.Player.IsInRange(args.X, args.Y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceTileEntity rejected range checks from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
		}

		/// <summary>Fired when an item frame is placed for anti-cheat detection.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnPlaceItemFrame(object sender, GetDataHandlers.PlaceItemFrameEventArgs args)
		{
			if (!TShock.Utils.TilePlacementValid(args.X, args.Y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceItemFrame rejected tile placement valid from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceItemFrame rejected disabled from {0}", args.Player.Name));
				NetMessage.SendData((int)PacketTypes.UpdateTileEntity, -1, -1, NetworkText.Empty, args.ItemFrame.ID, 0, 1);
				args.Handled = true;
				return;
			}

			if (!args.Player.HasBuildPermission(args.X, args.Y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceItemFrame rejected permissions from {0}", args.Player.Name));
				NetMessage.SendData((int)PacketTypes.UpdateTileEntity, -1, -1, NetworkText.Empty, args.ItemFrame.ID, 0, 1);
				args.Handled = true;
				return;
			}

			if (!args.Player.IsInRange(args.X, args.Y))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlaceItemFrame rejected range checks from {0}", args.Player.Name));
				NetMessage.SendData((int)PacketTypes.UpdateTileEntity, -1, -1, NetworkText.Empty, args.ItemFrame.ID, 0, 1);
				args.Handled = true;
				return;
			}
		}

		internal void OnPlayerPortalTeleport(object sender, GetDataHandlers.TeleportThroughPortalEventArgs args)
		{
			//Packet 96 (player teleport through portal) has no validation on whether or not the player id provided
			//belongs to the player who sent the packet.
			if (args.Player.Index != args.TargetPlayerIndex)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerPortalTeleport rejected untargetable teleport from {0}", args.Player.Name));
				//If the player who sent the packet is not the player being teleported, cancel this packet
				args.Player.Disable(GetString("Malicious portal attempt."), DisableFlags.WriteToLogAndConsole); //Todo: this message is not particularly clear - suggestions wanted
				args.Handled = true;
				return;
			}

			//Generic bounds checking, though I'm not sure if anyone would willingly hack themselves outside the map?
			if (args.NewPosition.X > Main.maxTilesX || args.NewPosition.X < 0
				|| args.NewPosition.Y > Main.maxTilesY || args.NewPosition.Y < 0)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerPortalTeleport rejected teleport out of bounds from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			//May as well reject teleport attempts if the player is being throttled
			if (args.Player.IsBeingDisabled() || args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerPortalTeleport rejected disabled/throttled from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
		}

		/// <summary>Handles the anti-cheat components of gem lock toggles.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnGemLockToggle(object sender, GetDataHandlers.GemLockToggleEventArgs args)
		{
			if (args.X < 0 || args.Y < 0 || args.X >= Main.maxTilesX || args.Y >= Main.maxTilesY)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnGemLockToggle rejected boundaries check from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (!TShock.Utils.TilePlacementValid(args.X, args.Y) || (args.Player.Dead && TShock.Config.Settings.PreventDeadModification))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnGemLockToggle invalid placement/deadmod from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnGemLockToggle rejected disabled from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if (TShock.Config.Settings.RegionProtectGemLocks)
			{
				if (!args.Player.HasBuildPermission(args.X, args.Y))
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnGemLockToggle rejected permissions check from {0}", args.Player.Name));
					args.Handled = true;
					return;
				}
			}
		}

		/// <summary>Handles validation of of basic anti-cheat on mass wire operations.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnMassWireOperation(object sender, GetDataHandlers.MassWireOperationEventArgs args)
		{
			short startX = args.StartX;
			short startY = args.StartY;
			short endX = args.EndX;
			short endY = args.EndY;

			List<Point> points = Utils.Instance.GetMassWireOperationRange(
				new Point(startX, startY),
				new Point(endX, endY),
				args.Player.TPlayer.direction == 1);

			int x;
			int y;
			foreach (Point p in points)
			{
				/* Perform similar checks to TileKill
				 * The server-side nature of this packet removes the need to use SendTileSquare
				 * Range checks are currently ignored here as the items that send this seem to have infinite range */

				x = p.X;
				y = p.Y;

				if (!TShock.Utils.TilePlacementValid(x, y) || (args.Player.Dead && TShock.Config.Settings.PreventDeadModification))
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnMassWireOperation rejected valid placement from {0}", args.Player.Name));
					args.Handled = true;
					return;
				}

				if (args.Player.IsBeingDisabled())
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnMassWireOperation rejected disabled from {0}", args.Player.Name));
					args.Handled = true;
					return;
				}

				if (!args.Player.HasBuildPermission(x, y))
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnMassWireOperation rejected build perms from {0}", args.Player.Name));
					args.Handled = true;
					return;
				}
			}
		}

		/// <summary>Called when a player is damaged.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnPlayerDamage(object sender, GetDataHandlers.PlayerDamageEventArgs args)
		{
			byte id = args.ID;
			short damage = args.Damage;
			bool pvp = args.PVP;
			bool crit = args.Critical;
			byte direction = args.Direction;
			PlayerDeathReason reason = args.PlayerDeathReason;

			if (id >= Main.maxPlayers || TShock.Players[id] == null || !TShock.Players[id].Active)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerDamage rejected null check"));
				args.Handled = true;
				return;
			}

			if (damage > TShock.Config.Settings.MaxDamage && !args.Player.HasPermission(Permissions.ignoredamagecap) && id != args.Player.Index)
			{
				if (TShock.Config.Settings.KickOnDamageThresholdBroken)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerDamage rejected damage threshold from {0} {1}/{2}", args.Player.Name, damage, TShock.Config.Settings.MaxDamage));
					args.Player.Kick(GetString("Player damage exceeded {0}.", TShock.Config.Settings.MaxDamage));
					args.Handled = true;
					return;
				}
				else
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerDamage rejected damage threshold2 from {0} {1}/{2}", args.Player.Name, damage, TShock.Config.Settings.MaxDamage));
					args.Player.Disable(GetString("Player damage exceeded {0}.", TShock.Config.Settings.MaxDamage), DisableFlags.WriteToLogAndConsole);
				}
				args.Player.SendData(PacketTypes.PlayerHp, "", id);
				args.Player.SendData(PacketTypes.PlayerUpdate, "", id);
				args.Handled = true;
				return;
			}

			if (!TShock.Players[id].TPlayer.hostile && pvp && id != args.Player.Index)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerDamage rejected hostile from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PlayerHp, "", id);
				args.Player.SendData(PacketTypes.PlayerUpdate, "", id);
				args.Handled = true;
				return;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerDamage rejected disabled from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PlayerHp, "", id);
				args.Player.SendData(PacketTypes.PlayerUpdate, "", id);
				args.Handled = true;
				return;
			}

			if (!args.Player.IsInRange(TShock.Players[id].TileX, TShock.Players[id].TileY, 100))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerDamage rejected range checks from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PlayerHp, "", id);
				args.Player.SendData(PacketTypes.PlayerUpdate, "", id);
				args.Handled = true;
				return;
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerDamage rejected throttled from {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PlayerHp, "", id);
				args.Player.SendData(PacketTypes.PlayerUpdate, "", id);
				args.Handled = true;
				return;
			}

			/*
			 * PlayerDeathReason does not initially contain any information, so all fields have values -1 or null.
			 * We can use this to determine the real cause of death.
			 *
			 * If the player was not specified, that is, the player index is -1, then it is definitely a custom cause, as you can only deal damage with a projectile or another player.
			 * This is how everything else works. If an NPC is specified, its value is not -1, which is a custom cause.
			 *
			 * An exception to this is damage dealt by the Inferno potion to other players -- it is only identified by the other index value of 16,
			 * even lacking a source player index.
			 *
			 * Checking whether this damage came from the player is necessary, because the damage from the player can come even when it is hit by a NPC
			*/
			if (TShock.Config.Settings.DisableCustomDeathMessages && id != args.Player.Index && reason._sourceOtherIndex != 16 &&
				(reason._sourcePlayerIndex == -1 || reason._sourceNPCIndex != -1 || reason._sourceOtherIndex != -1 || reason._sourceCustomReason != null))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnPlayerDamage rejected custom death message from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
		}

		/// <summary>Bouncer's KillMe hook stops crash exploits from out of bounds values.</summary>
		/// <param name="sender">The object that triggered the event.</param>
		/// <param name="args">The packet arguments that the event has.</param>
		internal void OnKillMe(object sender, GetDataHandlers.KillMeEventArgs args)
		{
			short damage = args.Damage;
			short id = args.PlayerId;
			PlayerDeathReason playerDeathReason = args.PlayerDeathReason;

			if (damage > 42000) //Abnormal values have the potential to cause infinite loops in the server.
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnKillMe rejected high damage from {0} {1}", args.Player.Name, damage));
				args.Player.Kick(GetString("Failed to shade polygon normals."), true, true);
				TShock.Log.ConsoleError(GetString("Death Exploit Attempt: Damage {0}", damage));
				args.Handled = true;
				return;
			}

			if (id >= Main.maxPlayers)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnKillMe rejected index check from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			// This was formerly marked as a crash check; does not actually crash on this specific packet.
			if (playerDeathReason != null)
			{
				if (playerDeathReason.GetDeathText(TShock.Players[id].Name).ToString().Length > 500)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnKillMe rejected bad length death text from {0}", args.Player.Name));
					TShock.Players[id].Kick(GetString("Death reason outside of normal bounds."), true);
					args.Handled = true;
					return;
				}
				if (TShock.Config.Settings.DisableCustomDeathMessages && playerDeathReason._sourceCustomReason != null)
				{
					TShock.Log.ConsoleDebug(GetString("Bouncer / OnKillMe rejected custom death message from {0}", args.Player.Name));
					args.Handled = true;
					return;
				}
			}
		}

		/// <summary>
		/// Called when the player fishes out an NPC.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		internal void OnFishOutNPC(object sender, GetDataHandlers.FishOutNPCEventArgs args)
		{
			/// Getting recent projectiles of the player and selecting the first that is a bobber.
			var projectile = args.Player.RecentlyCreatedProjectiles.FirstOrDefault(p => Main.projectile[p.Index].bobber);

			if (!FishingRodItemIDs.Contains(args.Player.SelectedItem.type))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFishOutNPC rejected for not using a fishing rod! - From {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
			if (projectile.Type == 0 || projectile.Killed) /// The bobber projectile is never killed when the NPC spawns. Type can only be 0 if no recent projectile is found that is named Bobber.
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFishOutNPC rejected for not finding active bobber projectile! - From {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
			if (!FishableNpcIDs.Contains(args.NpcID))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFishOutNPC rejected for the NPC not being on the fishable NPCs list! - From {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
			if (args.NpcID == NPCID.DukeFishron && !args.Player.HasPermission(Permissions.summonboss))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFishOutNPC rejected summon boss permissions from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}
			if (!args.Player.IsInRange(args.TileX, args.TileY, 55))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFishOutNPC rejected range checks from {0}", args.Player.Name));
				args.Handled = true;
			}
		}

		/// <summary>
		/// Called when a player is trying to place an item into a food plate.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		internal void OnFoodPlatterTryPlacing(object sender, GetDataHandlers.FoodPlatterTryPlacingEventArgs args)
		{
			if (!TShock.Utils.TilePlacementValid(args.TileX, args.TileY))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFoodPlatterTryPlacing rejected tile placement valid from {0}", args.Player.Name));
				args.Handled = true;
				return;
			}

			if ((args.Player.SelectedItem.type != args.ItemID && args.Player.ItemInHand.type != args.ItemID))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFoodPlatterTryPlacing rejected item not placed by hand from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(args.TileX, args.TileY, 1);
				args.Handled = true;
				return;
			}
			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFoodPlatterTryPlacing rejected disabled from {0}", args.Player.Name));
				Item item = new Item();
				item.netDefaults(args.ItemID);
				args.Player.GiveItemCheck(args.ItemID, item.Name, args.Stack, args.Prefix);
				args.Player.SendTileSquareCentered(args.TileX, args.TileY, 1);
				args.Handled = true;
				return;
			}

			if (!args.Player.HasBuildPermission(args.TileX, args.TileY))
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFoodPlatterTryPlacing rejected permissions from {0}", args.Player.Name));
				Item item = new Item();
				item.netDefaults(args.ItemID);
				args.Player.GiveItemCheck(args.ItemID, item.Name, args.Stack, args.Prefix);
				args.Player.SendTileSquareCentered(args.TileX, args.TileY, 1);
				args.Handled = true;
				return;
			}

			if (!args.Player.IsInRange(args.TileX, args.TileY, range: 13)) // To my knowledge, max legit tile reach with accessories.
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / OnFoodPlatterTryPlacing rejected range checks from {0}", args.Player.Name));
				args.Player.SendTileSquareCentered(args.TileX, args.TileY, 1);
				args.Handled = true;
				return;
			}
		}

		internal void OnSecondUpdate()
		{
			Task.Run(() =>
			{
				foreach (var player in TShock.Players)
				{
					if (player != null && player.TPlayer.whoAmI >= 0)
					{
						var threshold = DateTime.Now.AddSeconds(-5);
						lock (player.RecentlyCreatedProjectiles)
						{
							player.RecentlyCreatedProjectiles = player.RecentlyCreatedProjectiles.Where(s => s.CreatedAt > threshold).ToList();
						}
					}
				}
			});
		}

		/// <summary>
		/// Returns the max <see cref="Item.placeStyle"/> associated with the given <paramref name="tileID"/>. Or -1 if there's no association
		/// </summary>
		/// <param name="tileID">Tile ID to query for</param>
		/// <returns>The max <see cref="Item.placeStyle"/>, otherwise -1 if there's no association</returns>
		internal static int GetMaxPlaceStyle(int tileID)
		{
			int result;
			if (ExtraneousPlaceStyles.TryGetValue(tileID, out result)
				|| MaxPlaceStyles.TryGetValue(tileID, out result))
			{
				return result;
			}
			else
			{
				return -1;
			}
		}

		// These time values are references from Projectile.cs, at npc.AddBuff() calls.
		// Moved to Projectile.StatusNPC(int i).
		private static Dictionary<int, short> NPCAddBuffTimeMax = new Dictionary<int, short>()
		{
			{ BuffID.Poisoned, 3600 },              // BuffID: 20
			{ BuffID.OnFire, 1200 },                // BuffID: 24
			{ BuffID.Confused, short.MaxValue },    // BuffID: 31 Brain of Confusion Internal Item ID: 3223
			{ BuffID.CursedInferno, 600 },          // BuffID: 39
			{ BuffID.Frostburn, 900 },              // BuffID: 44
			{ BuffID.Ichor, 1200 },                 // BuffID: 69
			{ BuffID.Venom, 1800 },                 // BuffID: 70
			{ BuffID.Midas, 120 },                  // BuffID: 72
			{ BuffID.Wet, 1500 },                   // BuffID: 103
			{ BuffID.Lovestruck, 1800 },            // BuffID: 119
			{ BuffID.Stinky, 1800 },                // BuffID: 120
			{ BuffID.Slimed, 1500 },                // BuffID: 137
			{ BuffID.SoulDrain, 30 },               // BuffID: 151
			{ BuffID.ShadowFlame, 660 },            // BuffID: 153
			{ BuffID.DryadsWard, 120 },             // BuffID: 165
			{ BuffID.BoneJavelin, 900 },            // BuffID: 169
			{ BuffID.StardustMinionBleed, 900 },    // BuffID: 183
			{ BuffID.DryadsWardDebuff, 120 },       // BuffID: 186
			{ BuffID.Daybreak, 300 },               // BuffID: 189 Solar Eruption Item ID: 3473, Daybreak Item ID: 3543
			{ BuffID.BetsysCurse, 600 },            // BuffID: 203
			{ BuffID.Oiled, 540 },                  // BuffID: 204
			{ BuffID.BlandWhipEnemyDebuff, 240  },  // BuffID: 307
			{ BuffID.SwordWhipNPCDebuff, 240  },    // BuffID: 309
			{ BuffID.ScytheWhipEnemyDebuff, 240  }, // BuffID: 310
			{ BuffID.FlameWhipEnemyDebuff, 240  },  // BuffID: 313
			{ BuffID.ThornWhipNPCDebuff, 240  },    // BuffID: 315
			{ BuffID.RainbowWhipNPCDebuff, 240  },  // BuffID: 316
			{ BuffID.MaceWhipNPCDebuff, 240  },     // BuffID: 319
			{ BuffID.GelBalloonBuff, 1800  },       // BuffID: 320
			{ BuffID.OnFire3, 1200 },               // BuffID: 323
			{ BuffID.Frostburn2, 1200 },            // BuffID: 324
			{ BuffID.BoneWhipNPCDebuff, 240 },      // BuffID: 326
			{ BuffID.TentacleSpike, 540 },          // BuffID: 337
			{ BuffID.CoolWhipNPCDebuff, 240 },      // BuffID: 340
			{ BuffID.BloodButcherer, 540 },         // BuffID: 344
			{ BuffID.Shimmer, 100 },		        // BuffID: 353
		};

		/// <summary>
		/// Tile IDs that can be oriented:
		/// Cannon,
		/// Chairs,
		/// Beds,
		/// Bathtubs,
		/// Statues,
		/// Mannequin,
		/// Traps,
		/// MusicBoxes,
		/// ChristmasTree,
		/// WaterFountain,
		/// Womannequin,
		/// MinecartTrack,
		/// WeaponsRack,
		/// LunarMonolith,
		/// TargetDummy,
		/// Campfire
		/// </summary>
		private static int[] orientableTiles = new int[]
		{
			TileID.Cannon,
			TileID.Chairs,
			TileID.Beds,
			TileID.Bathtubs,
			TileID.Statues,
			TileID.Mannequin,
			TileID.Traps,
			TileID.MusicBoxes,
			TileID.ChristmasTree,
			TileID.WaterFountain,
			TileID.Womannequin,
			TileID.MinecartTrack,
			TileID.WeaponsRack,
			TileID.ItemFrame,
			TileID.LunarMonolith,
			TileID.TargetDummy,
			TileID.Campfire
		};

		/// <summary>
		/// These projectiles have been added or modified with Terraria 1.4.
		/// They come from normal items, but to have the directional functionality, they must be projectiles.
		/// </summary>
		private static Dictionary<int, int> directionalProjectiles = new Dictionary<int, int>()
		{
			///Spears
			{ ProjectileID.DarkLance, ItemID.DarkLance},
			{ ProjectileID.Trident, ItemID.Trident},
			{ ProjectileID.Spear, ItemID.Spear},
			{ ProjectileID.MythrilHalberd, ItemID.MythrilHalberd},
			{ ProjectileID.AdamantiteGlaive, ItemID.AdamantiteGlaive},
			{ ProjectileID.CobaltNaginata, ItemID.CobaltNaginata},
			{ ProjectileID.Gungnir, ItemID.Gungnir},
			{ ProjectileID.MushroomSpear, ItemID.MushroomSpear},
			{ ProjectileID.TheRottedFork, ItemID.TheRottedFork},
			{ ProjectileID.PalladiumPike, ItemID.PalladiumPike},
			{ ProjectileID.OrichalcumHalberd, ItemID.OrichalcumHalberd},
			{ ProjectileID.TitaniumTrident, ItemID.TitaniumTrident},
			{ ProjectileID.ChlorophytePartisan, ItemID.ChlorophytePartisan},
			{ ProjectileID.NorthPoleWeapon, ItemID.NorthPole},
			{ ProjectileID.ObsidianSwordfish, ItemID.ObsidianSwordfish},
			{ ProjectileID.Swordfish, ItemID.Swordfish},
			{ ProjectileID.MonkStaffT2, ItemID.MonkStaffT2},
			{ ProjectileID.ThunderSpear, ItemID.ThunderSpear},
			{ ProjectileID.GladiusStab, ItemID.Gladius},
			/// ShortSwords
			{ ProjectileID.RulerStab, ItemID.Ruler },
			{ ProjectileID.CopperShortswordStab, ItemID.CopperShortsword },
			{ ProjectileID.TinShortswordStab, ItemID.TinShortsword },
			{ ProjectileID.IronShortswordStab, ItemID.IronShortsword },
			{ ProjectileID.LeadShortswordStab, ItemID.LeadShortsword },
			{ ProjectileID.SilverShortswordStab, ItemID.SilverShortsword },
			{ ProjectileID.TungstenShortswordStab, ItemID.TungstenShortsword },
			{ ProjectileID.GoldShortswordStab, ItemID.GoldShortsword },
			{ ProjectileID.PlatinumShortswordStab, ItemID.PlatinumShortsword }
		};

		private Dictionary<short, float> Projectile_MinValuesAI = new Dictionary<short, float> {
			{ 611, -1 },

			{ 950, 0 }
		};
		private Dictionary<short, float> Projectile_MaxValuesAI = new Dictionary<short, float> {
			{ 611, 1 },

			{ 950, 0 }
		};

		private Dictionary<short, float> Projectile_MinValuesAI2 = new Dictionary<short, float> {
			{ 405, 0f },
			{ 410, 0f },

			{ 424, 0.5f },
			{ 425, 0.5f },
			{ 426, 0.5f },

			{ 612, 0.4f },
			{ 953, 0.85f },

			{ 756, 0.5f },
			{ 522, 0 }
		};
		private Dictionary<short, float> Projectile_MaxValuesAI2 = new Dictionary<short, float> {
			{ 405, 1.2f },
			{ 410, 1.2f },

			{ 424, 0.8f },
			{ 425, 0.8f },
			{ 426, 0.8f },

			{ 612, 0.7f },
			{ 953, 2 },

			{ 756, 1 },
			{ 522, 40f }
		};
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/CLI`
#### File: `temp_TShock-5.2.4/TShockAPI/CLI/CommandLineParser.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;

namespace TShockAPI.CLI
{
	/// <summary>
	/// A simple command-line parser for retrieving basic information from a command-line. Array types are not supported
	/// </summary>
	public class CommandLineParser
	{
		private List<FlagSet> _flags = new List<FlagSet>();
		private Dictionary<FlagSet, object> _results = new Dictionary<FlagSet, object>();
		private string[] _source;

		/// <summary>
		/// Resets the CommandLineParser, removing any results and flags, and clearing the source
		/// </summary>
		/// <returns></returns>
		public CommandLineParser Reset()
		{
			_flags.Clear();
			_results.Clear();
			_source = null;

			return this;
		}

		/// <summary>
		/// Adds a flag to be parsed
		/// </summary>
		/// <param name="flag">The flag to be added</param>
		/// <param name="noArgs">Whether or not the flag is followed by an argument</param>
		public CommandLineParser AddFlag(string flag, bool noArgs = false)
		{
			FlagSet flags = new FlagSet(flag) { NoArgs = noArgs };
			return AddFlags(flags);
		}

		/// <summary>
		/// Adds a flag to be parsed, with the given callback being invoked with the flag's argument when it is found.
		/// The callback's parameter is the argument passed to the flag
		/// </summary>
		/// <param name="flag"></param>
		/// <param name="callback"></param>
		/// <returns></returns>
		public CommandLineParser AddFlag(string flag, Action<string> callback)
		{
			FlagSet flags = new FlagSet(flag) { callback = callback };
			return AddFlags(flags);
		}

		/// <summary>
		/// Adds a flag to be parsed, with the given callback being invoked when the flag is found.
		/// This method assumes the flag has no arguments
		/// </summary>
		/// <param name="flag"></param>
		/// <param name="callback"></param>
		/// <returns></returns>
		public CommandLineParser AddFlag(string flag, Action callback)
		{
			FlagSet flags = new FlagSet(flag) { NoArgs = true, callback = callback };
			return AddFlags(flags);
		}

		/// <summary>
		/// Adds a range of flags to be parsed
		/// </summary>
		/// <param name="flags">The FlagSet to be added</param>
		/// <returns></returns>
		public CommandLineParser AddFlags(FlagSet flags)
		{
			if (_flags.Contains(flags))
			{
				return this;
			}

			_flags.Add(flags);

			return this;
		}

		/// <summary>
		/// Adds a range of flags to be parsed, with the given callback being invoked with the flag's argument when it is found.
		/// The callback's parameter is the argument passed to the flag
		/// </summary>
		/// <param name="flags">The FlagSet to be added</param>
		/// <param name="callback">An Action with a single string parameter. This parameter is the value passed to the flag</param>
		/// <returns></returns>
		public CommandLineParser AddFlags(FlagSet flags, Action<string> callback)
		{
			flags.callback = callback;
			return AddFlags(flags);
		}

		/// <summary>
		/// Adds a range of flags to be parsed, with the given callback being invoked when the flag's argument is found.
		/// This method assumes the flag has no arguments
		/// </summary>
		/// <param name="flags">The FlagSet to be added</param>
		/// <param name="callback">An Action with no parameters.</param>
		/// <returns></returns>
		public CommandLineParser AddFlags(FlagSet flags, Action callback)
		{
			flags.callback = callback;
			flags.NoArgs = true;
			return AddFlags(flags);
		}

		/// <summary>
		/// Adds a callback after a flag's parsing has been completed.
		/// This method automatically attaches the callback to the last added flag
		/// </summary>
		/// <param name="callback">An Action with no parameters.</param>
		/// <returns></returns>
		public CommandLineParser After(Action callback)
		{
			FlagSet flags = _flags.Last();
			flags.continuation = callback;
			return this;
		}

		/// <summary>
		/// Gets the result of a FlagSet, cast to the given type parameter. Array types are not supported
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="flags"></param>
		/// <returns></returns>
		public T Get<T>(FlagSet flags)
		{
			if (!_results.ContainsKey(flags))
			{
				return default(T);
			}

			object result = _results[flags];
			Type t = typeof(T);

			if (t == typeof(string))
			{
				if (result == null)
				{
					return (T)(object)string.Empty;
				}

				return (T)result;
			}

			if (t.IsValueType)
			{
				TypeConverter tc = TypeDescriptor.GetConverter(t);
				return (T)tc.ConvertFromString(result.ToString());
			}

			return (T)Activator.CreateInstance(t, result);
		}

		/// <summary>
		/// Parses the given source for flags registered with the parser
		/// </summary>
		/// <param name="source"></param>
		/// <returns></returns>
		public CommandLineParser ParseFromSource(string[] source)
		{
			_source = source;

			for (int i = 0; i < (source.Length - 1 == 0 ? 1 : source.Length); i++)
			{
				string flag = source[i].ToLowerInvariant();
				string argument = null;

				if (string.IsNullOrWhiteSpace(flag))
				{
					continue;
				}

				if (i + 1 < source.Length)
				{
					argument = source[i + 1];
				}

				FlagSet flags = _flags.FirstOrDefault(f => f.Contains(flag));
				if (flags == null)
				{
					continue;
				}

				if (flags.NoArgs)
				{
					if (flags.callback != null)
					{
						((Action)flags.callback).Invoke();
					}
					else
					{
						_results.Add(flags, true);
					}
				}
				else
				{
					if (flags.callback != null)
					{
						((Action<string>)flags.callback).Invoke(argument);
					}
					else
					{
						_results.Add(flags, argument);
					}
				}
				flags.continuation?.Invoke();
			}

			return this;
		}

		/// <summary>
		/// Gets the result of a flag, cast to the given type parameter. Array types are not supported
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="flag"></param>
		/// <returns></returns>
		public T Get<T>(string flag)
		{
			FlagSet flags = _flags.FirstOrDefault(f => f.Contains(flag));
			if (flags == null)
			{
				return default(T);
			}

			return Get<T>(flags);
		}

		/// <summary>
		/// Attempts to get the result of a flag, cast to the given type parameter. Array types are not supported
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="flag"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public bool TryGet<T>(string flag, out T value)
		{
			FlagSet flags = _flags.FirstOrDefault(f => f.Contains(flag));
			if (flags == null)
			{
				value = default(T);
				return false;
			}

			return TryGet(flags, out value);
		}

		/// <summary>
		/// Attempts to get the result of a FlagSet, cast to the given type parameter. Array types are not supported
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="flags"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public bool TryGet<T>(FlagSet flags, out T value)
		{
			object result = _results[flags];

			if (result == null)
			{
				//Null result shouldn't happen, but return false if it does
				value = default(T);
				return false; 
			}

			Type t = typeof(T);

			//Strings get special handling because the result object is a string
			if (t == typeof(string))
			{
				if (result == null)
				{
					//Null strings shouldn't happen, but return false if it does
					value = default(T);
					return false;
				}

				value = (T)result;
				return true;
			}

			//Value types get converted with a TypeConverter
			if (t.IsValueType)
			{
				try
				{
					TypeConverter tc = TypeDescriptor.GetConverter(t);
					value = (T)tc.ConvertFrom(result);
					return true;
				}
				catch
				{
					value = default(T);
					return false;
				}
			}

			try
			{
				//Reference types get created with an Activator
				value = (T)Activator.CreateInstance(t, result);
				return true;
			}
			catch
			{
				value = default(T);
				return false;
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/CLI/FlagSet.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace TShockAPI.CLI
{
	/// <summary>
	/// Describes a set of flags that are responsible for one CL argument
	/// </summary>
	public class FlagSet : IEquatable<FlagSet>
	{
		private IEnumerable<string> _flags;

		internal object callback;
		internal Action continuation;

		/// <summary>
		/// Whether or not the set of flags represented by this FlagSet is followed by an argument
		/// </summary>
		public bool NoArgs { get; set; }

		/// <summary>
		/// Creates a new <see cref="FlagSet"/> with the given flags
		/// </summary>
		/// <param name="flags">Flags represented by this FlagSet</param>
		public FlagSet(params string[] flags)
		{
			if (flags == null)
			{
				throw new ArgumentNullException(nameof(flags));
			}

			_flags = flags.Select(f => f.ToLowerInvariant());
		}

		/// <summary>
		/// Creates a new <see cref="FlagSet"/> with the given flags and arguments option
		/// </summary>
		/// <param name="flags">Flags represented by this FlagSet</param>
		/// <param name="noArgs">Whether or not the flags specified will be followed by an argument</param>
		public FlagSet(string[] flags, bool noArgs) : this(flags)
		{
			NoArgs = noArgs;
		}

		/// <summary>
		/// Determines whether or not this flag set contains the given flag
		/// </summary>
		/// <param name="flag"></param>
		/// <returns></returns>
		public bool Contains(string flag)
		{
			return _flags.Contains(flag);
		}

		/// <summary>
		/// Determines whether or not this flag set is equatable to another
		/// </summary>
		/// <param name="other"></param>
		/// <returns></returns>
		public bool Equals(FlagSet other)
		{
			if (other == null)
			{
				return false;
			}

			return other._flags == _flags;
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI`
#### File: `temp_TShock-5.2.4/TShockAPI/Commands.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using TShockAPI.DB;
using TerrariaApi.Server;
using TShockAPI.Hooks;
using Terraria.GameContent.Events;
using Microsoft.Xna.Framework;
using TShockAPI.Localization;
using System.Text.RegularExpressions;
using Terraria.DataStructures;
using Terraria.GameContent.Creative;

namespace TShockAPI
{
	public delegate void CommandDelegate(CommandArgs args);

	public class CommandArgs : EventArgs
	{
		public string Message { get; private set; }
		public TSPlayer Player { get; private set; }
		public bool Silent { get; private set; }

		/// <summary>
		/// Parameters passed to the argument. Does not include the command name.
		/// IE '/kick "jerk face"' will only have 1 argument
		/// </summary>
		public List<string> Parameters { get; private set; }

		public Player TPlayer
		{
			get { return Player.TPlayer; }
		}

		public CommandArgs(string message, TSPlayer ply, List<string> args)
		{
			Message = message;
			Player = ply;
			Parameters = args;
			Silent = false;
		}

		public CommandArgs(string message, bool silent, TSPlayer ply, List<string> args)
		{
			Message = message;
			Player = ply;
			Parameters = args;
			Silent = silent;
		}
	}

	public class Command
	{
		/// <summary>
		/// Gets or sets whether to allow non-players to use this command.
		/// </summary>
		public bool AllowServer { get; set; }
		/// <summary>
		/// Gets or sets whether to do logging of this command.
		/// </summary>
		public bool DoLog { get; set; }
		/// <summary>
		/// Gets or sets the help text of this command.
		/// </summary>
		public string HelpText { get; set; }
		/// <summary>
		/// Gets or sets an extended description of this command.
		/// </summary>
		public string[] HelpDesc { get; set; }
		/// <summary>
		/// Gets the name of the command.
		/// </summary>
		public string Name { get { return Names[0]; } }
		/// <summary>
		/// Gets the names of the command.
		/// </summary>
		public List<string> Names { get; protected set; }
		/// <summary>
		/// Gets the permissions of the command.
		/// </summary>
		public List<string> Permissions { get; protected set; }

		private CommandDelegate commandDelegate;
		public CommandDelegate CommandDelegate
		{
			get { return commandDelegate; }
			set
			{
				if (value == null)
					throw new ArgumentNullException();

				commandDelegate = value;
			}
		}

		public Command(List<string> permissions, CommandDelegate cmd, params string[] names)
			: this(cmd, names)
		{
			Permissions = permissions;
		}

		public Command(string permissions, CommandDelegate cmd, params string[] names)
			: this(cmd, names)
		{
			Permissions = new List<string> { permissions };
		}

		public Command(CommandDelegate cmd, params string[] names)
		{
			if (cmd == null)
				throw new ArgumentNullException("cmd");
			if (names == null || names.Length < 1)
				throw new ArgumentException("names");

			AllowServer = true;
			CommandDelegate = cmd;
			DoLog = true;
			HelpText = GetString("No help available.");
			HelpDesc = null;
			Names = new List<string>(names);
			Permissions = new List<string>();
		}

		public bool Run(CommandArgs args)
		{
			if (!CanRun(args.Player))
				return false;

			try
			{
				CommandDelegate(args);
			}
			catch (Exception e)
			{
				args.Player.SendErrorMessage(GetString("Command failed, check logs for more details."));
				TShock.Log.Error(e.ToString());
			}

			return true;
		}

		public bool Run(string msg, bool silent, TSPlayer ply, List<string> parms)
		{
			return Run(new CommandArgs(msg, silent, ply, parms));
		}

		public bool Run(string msg, TSPlayer ply, List<string> parms)
		{
			return Run(msg, false, ply, parms);
		}

		public bool HasAlias(string name)
		{
			return Names.Contains(name);
		}

		public bool CanRun(TSPlayer ply)
		{
			if (Permissions == null || Permissions.Count < 1)
				return true;
			foreach (var Permission in Permissions)
			{
				if (ply.HasPermission(Permission))
					return true;
			}
			return false;
		}
	}

	public static class Commands
	{
		public static List<Command> ChatCommands = new List<Command>();
		public static ReadOnlyCollection<Command> TShockCommands = new ReadOnlyCollection<Command>(new List<Command>());

		/// <summary>
		/// The command specifier, defaults to "/"
		/// </summary>
		public static string Specifier
		{
			get { return string.IsNullOrWhiteSpace(TShock.Config.Settings.CommandSpecifier) ? "/" : TShock.Config.Settings.CommandSpecifier; }
		}

		/// <summary>
		/// The silent command specifier, defaults to "."
		/// </summary>
		public static string SilentSpecifier
		{
			get { return string.IsNullOrWhiteSpace(TShock.Config.Settings.CommandSilentSpecifier) ? "." : TShock.Config.Settings.CommandSilentSpecifier; }
		}

		private delegate void AddChatCommand(string permission, CommandDelegate command, params string[] names);

		public static void InitCommands()
		{
			List<Command> tshockCommands = new List<Command>(100);
			Action<Command> add = (cmd) =>
			{
				tshockCommands.Add(cmd);
				ChatCommands.Add(cmd);
			};

			add(new Command(SetupToken, "setup")
			{
				AllowServer = false,
				HelpText = GetString("Used to authenticate as superadmin when first setting up TShock.")
			});
			add(new Command(Permissions.user, ManageUsers, "user")
			{
				DoLog = false,
				HelpText = GetString("Manages user accounts.")
			});

			#region Account Commands
			add(new Command(Permissions.canlogin, AttemptLogin, "login")
			{
				AllowServer = false,
				DoLog = false,
				HelpText = GetString("Logs you into an account.")
			});
			add(new Command(Permissions.canlogout, Logout, "logout")
			{
				AllowServer = false,
				DoLog = false,
				HelpText = GetString("Logs you out of your current account.")
			});
			add(new Command(Permissions.canchangepassword, PasswordUser, "password")
			{
				AllowServer = false,
				DoLog = false,
				HelpText = GetString("Changes your account's password.")
			});
			add(new Command(Permissions.canregister, RegisterUser, "register")
			{
				AllowServer = false,
				DoLog = false,
				HelpText = GetString("Registers you an account.")
			});
			add(new Command(Permissions.checkaccountinfo, ViewAccountInfo, "accountinfo", "ai")
			{
				HelpText = GetString("Shows information about a user.")
			});
			#endregion
			#region Admin Commands
			add(new Command(Permissions.ban, Ban, "ban")
			{
				HelpText = GetString("Manages player bans.")
			});
			add(new Command(Permissions.broadcast, Broadcast, "broadcast", "bc", "say")
			{
				HelpText = GetString("Broadcasts a message to everyone on the server.")
			});
			add(new Command(Permissions.logs, DisplayLogs, "displaylogs")
			{
				HelpText = GetString("Toggles whether you receive server logs.")
			});
			add(new Command(Permissions.managegroup, Group, "group")
			{
				HelpText = GetString("Manages groups.")
			});
			add(new Command(Permissions.manageitem, ItemBan, "itemban")
			{
				HelpText = GetString("Manages item bans.")
			});
			add(new Command(Permissions.manageprojectile, ProjectileBan, "projban")
			{
				HelpText = GetString("Manages projectile bans.")
			});
			add(new Command(Permissions.managetile, TileBan, "tileban")
			{
				HelpText = GetString("Manages tile bans.")
			});
			add(new Command(Permissions.manageregion, Region, "region")
			{
				HelpText = GetString("Manages regions.")
			});
			add(new Command(Permissions.kick, Kick, "kick")
			{
				HelpText = GetString("Removes a player from the server.")
			});
			add(new Command(Permissions.mute, Mute, "mute", "unmute")
			{
				HelpText = GetString("Prevents a player from talking.")
			});
			add(new Command(Permissions.savessc, OverrideSSC, "overridessc", "ossc")
			{
				HelpText = GetString("Overrides serverside characters for a player, temporarily.")
			});
			add(new Command(Permissions.savessc, SaveSSC, "savessc")
			{
				HelpText = GetString("Saves all serverside characters.")
			});
			add(new Command(Permissions.uploaddata, UploadJoinData, "uploadssc")
			{
				HelpText = GetString("Upload the account information when you joined the server as your Server Side Character data.")
			});
			add(new Command(Permissions.settempgroup, TempGroup, "tempgroup")
			{
				HelpText = GetString("Temporarily sets another player's group.")
			});
			add(new Command(Permissions.su, SubstituteUser, "su")
			{
				HelpText = GetString("Temporarily elevates you to Super Admin.")
			});
			add(new Command(Permissions.su, SubstituteUserDo, "sudo")
			{
				HelpText = GetString("Executes a command as the super admin.")
			});
			add(new Command(Permissions.userinfo, GrabUserUserInfo, "userinfo", "ui")
			{
				HelpText = GetString("Shows information about a player.")
			});
			#endregion
			#region Annoy Commands
			add(new Command(Permissions.annoy, Annoy, "annoy")
			{
				HelpText = GetString("Annoys a player for an amount of time.")
			});
			add(new Command(Permissions.annoy, Rocket, "rocket")
			{
				HelpText = GetString("Rockets a player upwards. Requires SSC.")
			});
			add(new Command(Permissions.annoy, FireWork, "firework")
			{
				HelpText = GetString("Spawns fireworks at a player.")
			});
			#endregion
			#region Configuration Commands
			add(new Command(Permissions.maintenance, CheckUpdates, "checkupdates")
			{
				HelpText = GetString("Checks for TShock updates.")
			});
			add(new Command(Permissions.maintenance, Off, "off", "exit", "stop")
			{
				HelpText = GetString("Shuts down the server while saving.")
			});
			add(new Command(Permissions.maintenance, OffNoSave, "off-nosave", "exit-nosave", "stop-nosave")
			{
				HelpText = GetString("Shuts down the server without saving.")
			});
			add(new Command(Permissions.cfgreload, Reload, "reload")
			{
				HelpText = GetString("Reloads the server configuration file.")
			});
			add(new Command(Permissions.cfgpassword, ServerPassword, "serverpassword")
			{
				HelpText = GetString("Changes the server password.")
			});
			add(new Command(Permissions.maintenance, GetVersion, "version")
			{
				HelpText = GetString("Shows the TShock version.")
			});
			add(new Command(Permissions.whitelist, Whitelist, "whitelist")
			{
				HelpText = GetString("Manages the server whitelist.")
			});
			#endregion
			#region Item Commands
			add(new Command(Permissions.give, Give, "give", "g")
			{
				HelpText = GetString("Gives another player an item.")
			});
			add(new Command(Permissions.item, Item, "item", "i")
			{
				AllowServer = false,
				HelpText = GetString("Gives yourself an item.")
			});
			#endregion
			#region NPC Commands
			add(new Command(Permissions.butcher, Butcher, "butcher")
			{
				HelpText = GetString("Kills hostile NPCs or NPCs of a certain type.")
			});
			add(new Command(Permissions.renamenpc, RenameNPC, "renamenpc")
			{
				HelpText = GetString("Renames an NPC.")
			});
			add(new Command(Permissions.maxspawns, MaxSpawns, "maxspawns")
			{
				HelpText = GetString("Sets the maximum number of NPCs.")
			});
			add(new Command(Permissions.spawnboss, SpawnBoss, "spawnboss", "sb")
			{
				AllowServer = false,
				HelpText = GetString("Spawns a number of bosses around you.")
			});
			add(new Command(Permissions.spawnmob, SpawnMob, "spawnmob", "sm")
			{
				AllowServer = false,
				HelpText = GetString("Spawns a number of mobs around you.")
			});
			add(new Command(Permissions.spawnrate, SpawnRate, "spawnrate")
			{
				HelpText = GetString("Sets the spawn rate of NPCs.")
			});
			add(new Command(Permissions.clearangler, ClearAnglerQuests, "clearangler")
			{
				HelpText = GetString("Resets the list of users who have completed an angler quest that day.")
			});
			#endregion
			#region TP Commands
			add(new Command(Permissions.home, Home, "home")
			{
				AllowServer = false,
				HelpText = GetString("Sends you to your spawn point.")
			});
			add(new Command(Permissions.spawn, Spawn, "spawn")
			{
				AllowServer = false,
				HelpText = GetString("Sends you to the world's spawn point.")
			});
			add(new Command(Permissions.tp, TP, "tp")
			{
				AllowServer = false,
				HelpText = GetString("Teleports a player to another player.")
			});
			add(new Command(Permissions.tpothers, TPHere, "tphere")
			{
				AllowServer = false,
				HelpText = GetString("Teleports a player to yourself.")
			});
			add(new Command(Permissions.tpnpc, TPNpc, "tpnpc")
			{
				AllowServer = false,
				HelpText = GetString("Teleports you to an npc.")
			});
			add(new Command(Permissions.tppos, TPPos, "tppos")
			{
				AllowServer = false,
				HelpText = GetString("Teleports you to tile coordinates.")
			});
			add(new Command(Permissions.getpos, GetPos, "pos")
			{
				AllowServer = false,
				HelpText = GetString("Returns the user's or specified user's current position.")
			});
			add(new Command(Permissions.tpallow, TPAllow, "tpallow")
			{
				AllowServer = false,
				HelpText = GetString("Toggles whether other people can teleport you.")
			});
			#endregion
			#region World Commands
			add(new Command(Permissions.toggleexpert, ChangeWorldMode, "worldmode", "gamemode")
			{
				HelpText = GetString("Changes the world mode.")
			});
			add(new Command(Permissions.antibuild, ToggleAntiBuild, "antibuild")
			{
				HelpText = GetString("Toggles build protection.")
			});
			add(new Command(Permissions.grow, Grow, "grow")
			{
				AllowServer = false,
				HelpText = GetString("Grows plants at your location.")
			});
			add(new Command(Permissions.halloween, ForceHalloween, "forcehalloween")
			{
				HelpText = GetString("Toggles halloween mode (goodie bags, pumpkins, etc).")
			});
			add(new Command(Permissions.xmas, ForceXmas, "forcexmas")
			{
				HelpText = GetString("Toggles christmas mode (present spawning, santa, etc).")
			});
			add(new Command(Permissions.manageevents, ManageWorldEvent, "worldevent")
			{
				HelpText = GetString("Enables starting and stopping various world events.")
			});
			add(new Command(Permissions.hardmode, Hardmode, "hardmode")
			{
				HelpText = GetString("Toggles the world's hardmode status.")
			});
			add(new Command(Permissions.editspawn, ProtectSpawn, "protectspawn")
			{
				HelpText = GetString("Toggles spawn protection.")
			});
			add(new Command(Permissions.worldsave, Save, "save")
			{
				HelpText = GetString("Saves the world file.")
			});
			add(new Command(Permissions.worldspawn, SetSpawn, "setspawn")
			{
				AllowServer = false,
				HelpText = GetString("Sets the world's spawn point to your location.")
			});
			add(new Command(Permissions.dungeonposition, SetDungeon, "setdungeon")
			{
				AllowServer = false,
				HelpText = GetString("Sets the dungeon's position to your location.")
			});
			add(new Command(Permissions.worldsettle, Settle, "settle")
			{
				HelpText = GetString("Forces all liquids to update immediately.")
			});
			add(new Command(Permissions.time, Time, "time")
			{
				HelpText = GetString("Sets the world time.")
			});
			add(new Command(Permissions.wind, Wind, "wind")
			{
				HelpText = GetString("Changes the wind speed.")
			});
			add(new Command(Permissions.worldinfo, WorldInfo, "worldinfo")
			{
				HelpText = GetString("Shows information about the current world.")
			});
			#endregion
			#region Other Commands
			add(new Command(Permissions.buff, Buff, "buff")
			{
				AllowServer = false,
				HelpText = GetString("Gives yourself a buff or debuff for an amount of time. Putting -1 for time will set it to 415 days.")
			});
			add(new Command(Permissions.clear, Clear, "clear")
			{
				HelpText = GetString("Clears item drops or projectiles.")
			});
			add(new Command(Permissions.buffplayer, GBuff, "gbuff", "buffplayer")
			{
				HelpText = GetString("Gives another player a buff or debuff for an amount of time. Putting -1 for time will set it to 415 days.")
			});
			add(new Command(Permissions.godmode, ToggleGodMode, "godmode", "god")
			{
				HelpText = GetString("Toggles godmode on a player.")
			});
			add(new Command(Permissions.heal, Heal, "heal")
			{
				HelpText = GetString("Heals a player in HP and MP.")
			});
			add(new Command(Permissions.kill, Kill, "kill", "slay")
			{
				HelpText = GetString("Kills another player.")
			});
			add(new Command(Permissions.cantalkinthird, ThirdPerson, "me")
			{
				HelpText = GetString("Sends an action message to everyone.")
			});
			add(new Command(Permissions.canpartychat, PartyChat, "party", "p")
			{
				AllowServer = false,
				HelpText = GetString("Sends a message to everyone on your team.")
			});
			add(new Command(Permissions.whisper, Reply, "reply", "r")
			{
				HelpText = GetString("Replies to a PM sent to you.")
			});
			add(new Command(Rests.RestPermissions.restmanage, ManageRest, "rest")
			{
				HelpText = GetString("Manages the REST API.")
			});
			add(new Command(Permissions.slap, Slap, "slap")
			{
				HelpText = GetString("Slaps a player, dealing damage.")
			});
			add(new Command(Permissions.serverinfo, ServerInfo, "serverinfo")
			{
				HelpText = GetString("Shows the server information.")
			});
			add(new Command(Permissions.warp, Warp, "warp")
			{
				HelpText = GetString("Teleports you to a warp point or manages warps.")
			});
			add(new Command(Permissions.whisper, Whisper, "whisper", "w", "tell", "pm", "dm")
			{
				HelpText = GetString("Sends a PM to a player.")
			});
			add(new Command(Permissions.whisper, Wallow, "wallow", "wa")
			{
				AllowServer = false,
				HelpText = GetString("Toggles to either ignore or recieve whispers from other players.")
			});
			add(new Command(Permissions.createdumps, CreateDumps, "dump-reference-data")
			{
				HelpText = GetString("Creates a reference tables for Terraria data types and the TShock permission system in the server folder.")
			});
			add(new Command(Permissions.synclocalarea, SyncLocalArea, "sync")
			{
				HelpText = GetString("Sends all tiles from the server to the player to resync the client with the actual world state.")
			});
			add(new Command(Permissions.respawn, Respawn, "respawn")
			{
				HelpText = GetString("Respawn yourself or another player.")
			});
			#endregion

			add(new Command(Aliases, "aliases")
			{
				HelpText = GetString("Shows a command's aliases.")
			});
			add(new Command(Help, "help")
			{
				HelpText = GetString("Lists commands or gives help on them.")
			});
			add(new Command(Motd, "motd")
			{
				HelpText = GetString("Shows the message of the day.")
			});
			add(new Command(ListConnectedPlayers, "playing", "online", "who")
			{
				HelpText = GetString("Shows the currently connected players.")
			});
			add(new Command(Rules, "rules")
			{
				HelpText = GetString("Shows the server's rules.")
			});

			TShockCommands = new ReadOnlyCollection<Command>(tshockCommands);
		}

		public static bool HandleCommand(TSPlayer player, string text)
		{
			string cmdText = text.Remove(0, 1);
			string cmdPrefix = text[0].ToString();
			bool silent = false;

			if (cmdPrefix == SilentSpecifier)
				silent = true;

			int index = -1;
			for (int i = 0; i < cmdText.Length; i++)
			{
				if (IsWhiteSpace(cmdText[i]))
				{
					index = i;
					break;
				}
			}
			string cmdName;
			if (index == 0) // Space after the command specifier should not be supported
			{
				player.SendErrorMessage(GetString("You entered a space after {0} instead of a command. Type {0}help for a list of valid commands.", Specifier));
				return true;
			}
			else if (index < 0)
				cmdName = cmdText.ToLower();
			else
				cmdName = cmdText.Substring(0, index).ToLower();

			List<string> args;
			if (index < 0)
				args = new List<string>();
			else
				args = ParseParameters(cmdText.Substring(index));

			IEnumerable<Command> cmds = ChatCommands.FindAll(c => c.HasAlias(cmdName));

			if (Hooks.PlayerHooks.OnPlayerCommand(player, cmdName, cmdText, args, ref cmds, cmdPrefix))
				return true;

			if (cmds.Count() == 0)
			{
				if (player.AwaitingResponse.ContainsKey(cmdName))
				{
					Action<CommandArgs> call = player.AwaitingResponse[cmdName];
					player.AwaitingResponse.Remove(cmdName);
					call(new CommandArgs(cmdText, player, args));
					return true;
				}
				player.SendErrorMessage(GetString("Invalid command entered. Type {0}help for a list of valid commands.", Specifier));
				return true;
			}
			foreach (Command cmd in cmds)
			{
				if (!cmd.CanRun(player))
				{
					if (cmd.DoLog)
						TShock.Utils.SendLogs(GetString("{0} tried to execute {1}{2}.", player.Name, Specifier, cmdText), Color.PaleVioletRed, player);
					else
						TShock.Utils.SendLogs(GetString("{0} tried to execute (args omitted) {1}{2}.", player.Name, Specifier, cmdName), Color.PaleVioletRed, player);
					player.SendErrorMessage(GetString("You do not have access to this command."));
					if (player.HasPermission(Permissions.su))
					{
						player.SendInfoMessage(GetString("You can use '{0}sudo {0}{1}' to override this check.", Specifier, cmdText));
					}
				}
				else if (!cmd.AllowServer && !player.RealPlayer)
				{
					player.SendErrorMessage(GetString("You must use this command in-game."));
				}
				else
				{
					if (cmd.DoLog)
						TShock.Utils.SendLogs(GetString("{0} executed: {1}{2}.", player.Name, silent ? SilentSpecifier : Specifier, cmdText), Color.PaleVioletRed, player);
					else
						TShock.Utils.SendLogs(GetString("{0} executed (args omitted): {1}{2}.", player.Name, silent ? SilentSpecifier : Specifier, cmdName), Color.PaleVioletRed, player);

					CommandArgs arguments = new CommandArgs(cmdText, silent, player, args);
					bool handled = PlayerHooks.OnPrePlayerCommand(cmd, ref arguments);
					if (!handled)
						cmd.Run(arguments);
					PlayerHooks.OnPostPlayerCommand(cmd, arguments, handled);
				}
			}
			return true;
		}

		/// <summary>
		/// Parses a string of parameters into a list. Handles quotes.
		/// </summary>
		/// <param name="str"></param>
		/// <returns></returns>
		private static List<String> ParseParameters(string str)
		{
			var ret = new List<string>();
			var sb = new StringBuilder();
			bool instr = false;
			for (int i = 0; i < str.Length; i++)
			{
				char c = str[i];

				if (c == '\\' && ++i < str.Length)
				{
					if (str[i] != '"' && str[i] != ' ' && str[i] != '\\')
						sb.Append('\\');
					sb.Append(str[i]);
				}
				else if (c == '"')
				{
					instr = !instr;
					if (!instr)
					{
						ret.Add(sb.ToString());
						sb.Clear();
					}
					else if (sb.Length > 0)
					{
						ret.Add(sb.ToString());
						sb.Clear();
					}
				}
				else if (IsWhiteSpace(c) && !instr)
				{
					if (sb.Length > 0)
					{
						ret.Add(sb.ToString());
						sb.Clear();
					}
				}
				else
					sb.Append(c);
			}
			if (sb.Length > 0)
				ret.Add(sb.ToString());

			return ret;
		}

		private static bool IsWhiteSpace(char c)
		{
			return c == ' ' || c == '\t' || c == '\n';
		}

		#region Account commands

		private static void AttemptLogin(CommandArgs args)
		{
			if (args.Player.LoginAttempts > TShock.Config.Settings.MaximumLoginAttempts && (TShock.Config.Settings.MaximumLoginAttempts != -1))
			{
				TShock.Log.Warn(GetString("{0} ({1}) had {2} or more invalid login attempts and was kicked automatically.",
					args.Player.IP, args.Player.Name, TShock.Config.Settings.MaximumLoginAttempts));
				args.Player.Kick(GetString("Too many invalid login attempts."));
				return;
			}

			if (args.Player.IsLoggedIn)
			{
				args.Player.SendErrorMessage(GetString("You are already logged in, and cannot login again."));
				return;
			}

			// We need to emulate the checks done in Player.TrySwitchingLoadout, because otherwise the server is not allowed to sync the
			// loadout index to the player, causing catastrophic desync.
			// The player must not be dead, using an item, or CC'd to switch loadouts.

			// Note that we only check for CC'd players when SSC is enabled, as that is only where it can cause issues,
			// and the RequireLogin config option (without SSC) will disable player's until they login, creating a vicious cycle.

			// FIXME: There is always the chance that in-between the time we check these requirements on the server, and the loadout sync
			//		  packet reaches the client, that the client state has changed, causing the loadout sync to be rejected, even though
			//		  we expected it to succeed.

			if (args.TPlayer.dead)
			{
				args.Player.SendErrorMessage(GetString("You cannot login whilst dead."));
				return;
			}

			// FIXME: This check is not correct -- even though we reject PlayerAnimation whilst disabled, we don't re-sync it to the client,
			//		  meaning these will still be set on the client, and they WILL reject the loadout sync.
			if (args.TPlayer.itemTime > 0 || args.TPlayer.itemAnimation > 0)
			{
				args.Player.SendErrorMessage(GetString("You cannot login whilst using an item."));
				return;
			}

			if (args.TPlayer.CCed && Main.ServerSideCharacter)
			{
				args.Player.SendErrorMessage(GetString("You cannot login whilst crowd controlled."));
				return;
			}

			UserAccount account = TShock.UserAccounts.GetUserAccountByName(args.Player.Name);
			string password = "";
			bool usingUUID = false;
			if (args.Parameters.Count == 0 && !TShock.Config.Settings.DisableUUIDLogin)
			{
				if (PlayerHooks.OnPlayerPreLogin(args.Player, args.Player.Name, ""))
					return;
				usingUUID = true;
			}
			else if (args.Parameters.Count == 1)
			{
				if (PlayerHooks.OnPlayerPreLogin(args.Player, args.Player.Name, args.Parameters[0]))
					return;
				password = args.Parameters[0];
			}
			else if (args.Parameters.Count == 2 && TShock.Config.Settings.AllowLoginAnyUsername)
			{
				if (String.IsNullOrEmpty(args.Parameters[0]))
				{
					args.Player.SendErrorMessage(GetString("Bad login attempt."));
					return;
				}

				if (PlayerHooks.OnPlayerPreLogin(args.Player, args.Parameters[0], args.Parameters[1]))
					return;

				account = TShock.UserAccounts.GetUserAccountByName(args.Parameters[0]);
				password = args.Parameters[1];
			}
			else
			{
				if (!TShock.Config.Settings.DisableUUIDLogin)
					args.Player.SendMessage(GetString($"{Specifier}login - Authenticates you using your UUID and character name."), Color.White);

				if (TShock.Config.Settings.AllowLoginAnyUsername)
					args.Player.SendMessage(GetString($"{Specifier}login <username> <password> - Authenticates you using your username and password."), Color.White);
				else
					args.Player.SendMessage(GetString($"{Specifier}login <password> - Authenticates you using your password and character name."), Color.White);

				args.Player.SendWarningMessage(GetString("If you forgot your password, contact the administrator for help."));
				return;
			}
			try
			{
				if (account == null)
				{
					args.Player.SendErrorMessage(GetString("A user account by that name does not exist."));
				}
				else if (account.VerifyPassword(password) ||
						(usingUUID && account.UUID == args.Player.UUID && !TShock.Config.Settings.DisableUUIDLogin &&
						!String.IsNullOrWhiteSpace(args.Player.UUID)))
				{
					var group = TShock.Groups.GetGroupByName(account.Group);

					if (!TShock.Groups.AssertGroupValid(args.Player, group, false))
					{
						args.Player.SendErrorMessage(GetString("Login attempt failed - see the message above."));
						return;
					}

					args.Player.PlayerData = TShock.CharacterDB.GetPlayerData(args.Player, account.ID);

					args.Player.Group = group;
					args.Player.tempGroup = null;
					args.Player.Account = account;
					args.Player.IsLoggedIn = true;
					args.Player.IsDisabledForSSC = false;

					if (Main.ServerSideCharacter)
					{
						if (args.Player.HasPermission(Permissions.bypassssc))
						{
							args.Player.PlayerData.CopyCharacter(args.Player);
							TShock.CharacterDB.InsertPlayerData(args.Player);
						}
						args.Player.PlayerData.RestoreCharacter(args.Player);
					}
					args.Player.LoginFailsBySsi = false;

					if (args.Player.HasPermission(Permissions.ignorestackhackdetection))
						args.Player.IsDisabledForStackDetection = false;

					if (args.Player.HasPermission(Permissions.usebanneditem))
						args.Player.IsDisabledForBannedWearable = false;

					args.Player.SendSuccessMessage(GetString("Authenticated as {0} successfully.", account.Name));

					TShock.Log.ConsoleInfo(GetString("{0} authenticated successfully as user: {1}.", args.Player.Name, account.Name));
					if ((args.Player.LoginHarassed) && (TShock.Config.Settings.RememberLeavePos))
					{
						if (TShock.RememberedPos.GetLeavePos(args.Player.Name, args.Player.IP) != Vector2.Zero)
						{
							Vector2 pos = TShock.RememberedPos.GetLeavePos(args.Player.Name, args.Player.IP);
							args.Player.Teleport((int)pos.X * 16, (int)pos.Y * 16);
						}
						args.Player.LoginHarassed = false;

					}
					TShock.UserAccounts.SetUserAccountUUID(account, args.Player.UUID);

					Hooks.PlayerHooks.OnPlayerPostLogin(args.Player);
				}
				else
				{
					if (usingUUID && !TShock.Config.Settings.DisableUUIDLogin)
					{
						args.Player.SendErrorMessage(GetString("UUID does not match this character."));
					}
					else
					{
						args.Player.SendErrorMessage(GetString("Invalid password."));
					}
					TShock.Log.Warn(GetString("{0} failed to authenticate as user: {1}.", args.Player.IP, account.Name));
					args.Player.LoginAttempts++;
				}
			}
			catch (Exception ex)
			{
				args.Player.SendErrorMessage(GetString("There was an error processing your login or authentication related request."));
				TShock.Log.Error(ex.ToString());
			}
		}

		private static void Logout(CommandArgs args)
		{
			if (!args.Player.IsLoggedIn)
			{
				args.Player.SendErrorMessage(GetString("You are not logged-in. Therefore, you cannot logout."));
				return;
			}

			if (args.Player.TPlayer.talkNPC != -1)
			{
				args.Player.SendErrorMessage(GetString("Please close NPC windows before logging out."));
				return;
			}

			args.Player.Logout();
			args.Player.SendSuccessMessage(GetString("You have been successfully logged out of your account."));
			if (Main.ServerSideCharacter)
			{
				args.Player.SendWarningMessage(GetString("Server side characters are enabled. You need to be logged-in to play."));
			}
		}

		private static void PasswordUser(CommandArgs args)
		{
			try
			{
				if (args.Player.IsLoggedIn && args.Parameters.Count == 2)
				{
					string password = args.Parameters[0];
					if (args.Player.Account.VerifyPassword(password))
					{
						try
						{
							args.Player.SendSuccessMessage(GetString("You have successfully changed your password."));
							TShock.UserAccounts.SetUserAccountPassword(args.Player.Account, args.Parameters[1]); // SetUserPassword will hash it for you.
							TShock.Log.ConsoleInfo(GetString("{0} ({1}) changed the password for account {2}.", args.Player.IP, args.Player.Name, args.Player.Account.Name));
						}
						catch (ArgumentOutOfRangeException)
						{
							args.Player.SendErrorMessage(GetString("Password must be greater than or equal to {0} characters.", TShock.Config.Settings.MinimumPasswordLength));
						}
					}
					else
					{
						args.Player.SendErrorMessage(GetString("You failed to change your password."));
						TShock.Log.ConsoleInfo(GetString("{0} ({1}) failed to change the password for account {2}.", args.Player.IP, args.Player.Name, args.Player.Account.Name));
					}
				}
				else
				{
					args.Player.SendErrorMessage(GetString("Not logged in or Invalid syntax. Proper syntax: {0}password <oldpassword> <newpassword>.", Specifier));
				}
			}
			catch (UserAccountManagerException ex)
			{
				args.Player.SendErrorMessage(GetString("Sorry, an error occurred: {0}.", ex.Message));
				TShock.Log.ConsoleError(GetString("PasswordUser returned an error: {0}.", ex));
			}
		}

		private static void RegisterUser(CommandArgs args)
		{
			try
			{
				var account = new UserAccount();
				string echoPassword = "";
				if (args.Parameters.Count == 1)
				{
					account.Name = args.Player.Name;
					echoPassword = args.Parameters[0];
					try
					{
						account.CreateBCryptHash(args.Parameters[0]);
					}
					catch (ArgumentOutOfRangeException)
					{
						args.Player.SendErrorMessage(GetString("Password must be greater than or equal to {0} characters.", TShock.Config.Settings.MinimumPasswordLength));
						return;
					}
				}
				else if (args.Parameters.Count == 2 && TShock.Config.Settings.AllowRegisterAnyUsername)
				{
					account.Name = args.Parameters[0];
					echoPassword = args.Parameters[1];
					try
					{
						account.CreateBCryptHash(args.Parameters[1]);
					}
					catch (ArgumentOutOfRangeException)
					{
						args.Player.SendErrorMessage(GetString("Password must be greater than or equal to {0} characters.", TShock.Config.Settings.MinimumPasswordLength));
						return;
					}
				}
				else
				{
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}register <password>.", Specifier));
					return;
				}

				account.Group = TShock.Config.Settings.DefaultRegistrationGroupName; // FIXME -- we should get this from the DB. --Why?
				account.UUID = args.Player.UUID;

				if (TShock.UserAccounts.GetUserAccountByName(account.Name) == null && account.Name != TSServerPlayer.AccountName) // Cheap way of checking for existance of a user
				{
					args.Player.SendSuccessMessage(GetString("Your account, \"{0}\", has been registered.", account.Name));
					args.Player.SendSuccessMessage(GetString("Your password is {0}.", echoPassword));

					if (!TShock.Config.Settings.DisableUUIDLogin)
						args.Player.SendMessage(GetString($"Type {Specifier}login to log-in to your account using your UUID."), Color.White);

					if (TShock.Config.Settings.AllowLoginAnyUsername)
						args.Player.SendMessage(GetString($"Type {Specifier}login \"{account.Name.Color(Utils.GreenHighlight)}\" {echoPassword.Color(Utils.BoldHighlight)} to log-in to your account."), Color.White);
					else
						args.Player.SendMessage(GetString($"Type {Specifier}login {echoPassword.Color(Utils.BoldHighlight)} to log-in to your account."), Color.White);

					TShock.UserAccounts.AddUserAccount(account);
					TShock.Log.ConsoleInfo(GetString("{0} registered an account: \"{1}\".", args.Player.Name, account.Name));
				}
				else
				{
					args.Player.SendErrorMessage(GetString("Sorry, {0} was already taken by another person.", account.Name));
					args.Player.SendErrorMessage(GetString("Please try a different username."));
					TShock.Log.ConsoleInfo(GetString("{0} attempted to register for the account {1} but it was already taken.", args.Player.Name, account.Name));
				}
			}
			catch (UserAccountManagerException ex)
			{
				args.Player.SendErrorMessage(GetString("Sorry, an error occurred: {0}.", ex.Message));
				TShock.Log.ConsoleError(GetString("RegisterUser returned an error: {0}.", ex));
			}
		}

		private static void ManageUsers(CommandArgs args)
		{
			// This guy needs to be here so that people don't get exceptions when they type /user
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid user syntax. Try {0}user help.", Specifier));
				return;
			}

			string subcmd = args.Parameters[0];

			// Add requires a username, password, and a group specified.
			if (subcmd == "add" && args.Parameters.Count == 4)
			{
				var account = new UserAccount();

				account.Name = args.Parameters[1];
				try
				{
					account.CreateBCryptHash(args.Parameters[2]);
				}
				catch (ArgumentOutOfRangeException)
				{
					args.Player.SendErrorMessage(GetString("Password must be greater than or equal to {0} characters.", TShock.Config.Settings.MinimumPasswordLength));
					return;
				}
				account.Group = args.Parameters[3];

				try
				{
					TShock.UserAccounts.AddUserAccount(account);
					args.Player.SendSuccessMessage(GetString("Account {0} has been added to group {1}.", account.Name, account.Group));
					TShock.Log.ConsoleInfo(GetString("{0} added account {1} to group {2}.", args.Player.Name, account.Name, account.Group));
				}
				catch (GroupNotExistsException)
				{
					args.Player.SendErrorMessage(GetString("Group {0} does not exist.", account.Group));
				}
				catch (UserAccountExistsException)
				{
					args.Player.SendErrorMessage(GetString("User {0} already exists.", account.Name));
				}
				catch (UserAccountManagerException e)
				{
					args.Player.SendErrorMessage(GetString("User {0} could not be added, check console for details.", account.Name));
					TShock.Log.ConsoleError(e.ToString());
				}
			}
			// User deletion requires a username
			else if (subcmd == "del" && args.Parameters.Count == 2)
			{
				var account = new UserAccount();
				account.Name = args.Parameters[1];

				try
				{
					TShock.UserAccounts.RemoveUserAccount(account);
					args.Player.SendSuccessMessage(GetString("Account removed successfully."));
					TShock.Log.ConsoleInfo(GetString("{0} successfully deleted account: {1}.", args.Player.Name, args.Parameters[1]));
				}
				catch (UserAccountNotExistException)
				{
					args.Player.SendErrorMessage(GetString("The user {0} does not exist! Therefore, the account was not deleted.", account.Name));
				}
				catch (UserAccountManagerException ex)
				{
					args.Player.SendErrorMessage(ex.Message);
					TShock.Log.ConsoleError(ex.ToString());
				}
			}

			// Password changing requires a username, and a new password to set
			else if (subcmd == "password" && args.Parameters.Count == 3)
			{
				var account = new UserAccount();
				account.Name = args.Parameters[1];

				try
				{
					TShock.UserAccounts.SetUserAccountPassword(account, args.Parameters[2]);
					TShock.Log.ConsoleInfo(GetString("{0} changed the password for account {1}", args.Player.Name, account.Name));
					args.Player.SendSuccessMessage(GetString("Password change succeeded for {0}.", account.Name));
				}
				catch (UserAccountNotExistException)
				{
					args.Player.SendErrorMessage(GetString("Account {0} does not exist! Therefore, the password cannot be changed.", account.Name));
				}
				catch (UserAccountManagerException e)
				{
					args.Player.SendErrorMessage(GetString("Password change attempt for {0} failed for an unknown reason. Check the server console for more details.", account.Name));
					TShock.Log.ConsoleError(e.ToString());
				}
				catch (ArgumentOutOfRangeException)
				{
					args.Player.SendErrorMessage(GetString("Password must be greater than or equal to {0} characters.", TShock.Config.Settings.MinimumPasswordLength));
				}
			}
			// Group changing requires a username or IP address, and a new group to set
			else if (subcmd == "group" && args.Parameters.Count == 3)
			{
				var account = new UserAccount();
				account.Name = args.Parameters[1];

				try
				{
					TShock.UserAccounts.SetUserGroup(args.Player, account, args.Parameters[2]);
					TShock.Log.ConsoleInfo(GetString("{0} changed account {1} to group {2}.", args.Player.Name, account.Name, args.Parameters[2]));
					args.Player.SendSuccessMessage(GetString("Account {0} has been changed to group {1}.", account.Name, args.Parameters[2]));

					//send message to player with matching account name
					var player = TShock.Players.FirstOrDefault(p => p != null && p.Account?.Name == account.Name);
					if (player != null && !args.Silent)
						player.SendSuccessMessage(GetString($"{args.Player.Name} has changed your group to {args.Parameters[2]}."));
				}
				catch (GroupNotExistsException)
				{
					args.Player.SendErrorMessage(GetString("That group does not exist."));
				}
				catch (UserAccountNotExistException)
				{
					args.Player.SendErrorMessage(GetString($"User {account.Name} does not exist."));
				}
				catch (UserGroupUpdateLockedException)
				{
					args.Player.SendErrorMessage(GetString("Hook blocked the attempt to change the user group."));
				}
				catch (UserAccountManagerException e)
				{
					args.Player.SendErrorMessage(GetString($"User {account.Name} could not be added. Check console for details."));
					TShock.Log.ConsoleError(e.ToString());
				}
			}
			else if (subcmd == "help")
			{
				args.Player.SendInfoMessage(GetString("User management command help:"));
				args.Player.SendInfoMessage(GetString("{0}user add username password group   -- Adds a specified user", Specifier));
				args.Player.SendInfoMessage(GetString("{0}user del username                  -- Removes a specified user", Specifier));
				args.Player.SendInfoMessage(GetString("{0}user password username newpassword -- Changes a user's password", Specifier));
				args.Player.SendInfoMessage(GetString("{0}user group username newgroup       -- Changes a user's group", Specifier));
			}
			else
			{
				args.Player.SendErrorMessage(GetString("Invalid user syntax. Try {0}user help.", Specifier));
			}
		}

		#endregion

		#region Stupid commands

		private static void ServerInfo(CommandArgs args)
		{
			args.Player.SendInfoMessage(GetString($"Memory usage: {Process.GetCurrentProcess().WorkingSet64}"));
			args.Player.SendInfoMessage(GetString($"Allocated memory: {Process.GetCurrentProcess().VirtualMemorySize64}"));
			args.Player.SendInfoMessage(GetString($"Total processor time: {Process.GetCurrentProcess().TotalProcessorTime}"));
			args.Player.SendInfoMessage(GetString($"Operating system: {Environment.OSVersion}"));
			args.Player.SendInfoMessage(GetString($"Proc count: {Environment.ProcessorCount}"));
			args.Player.SendInfoMessage(GetString($"Machine name: {Environment.MachineName}"));
		}

		private static void WorldInfo(CommandArgs args)
		{
			args.Player.SendInfoMessage(GetString("Information about the currently running world"));
			args.Player.SendInfoMessage(GetString($"Name: {(TShock.Config.Settings.UseServerName ? TShock.Config.Settings.ServerName : Main.worldName)}"));
			args.Player.SendInfoMessage(GetString("Size: {0}x{1}", Main.maxTilesX, Main.maxTilesY));
			args.Player.SendInfoMessage(GetString($"ID: {Main.worldID}"));
			args.Player.SendInfoMessage(GetString($"Seed: {WorldGen.currentWorldSeed}"));
			args.Player.SendInfoMessage(GetString($"Mode: {Main.GameMode}"));
			args.Player.SendInfoMessage(GetString($"Path: {Main.worldPathName}"));
		}

		#endregion

		#region Player Management Commands

		private static void GrabUserUserInfo(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}userinfo <player>.", Specifier));
				return;
			}

			var players = TSPlayer.FindByNameOrID(args.Parameters[0]);
			if (players.Count < 1)
				args.Player.SendErrorMessage(GetString("Invalid player."));
			else if (players.Count > 1)
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			else
			{
				args.Player.SendSuccessMessage(GetString($"IP Address: {players[0].IP}."));
				if (players[0].Account != null && players[0].IsLoggedIn)
					args.Player.SendSuccessMessage(GetString($" -> Logged-in as: {players[0].Account.Name}; in group {players[0].Group.Name}."));
			}
		}

		private static void ViewAccountInfo(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}accountinfo <username>.", Specifier));
				return;
			}

			string username = String.Join(" ", args.Parameters);
			if (!string.IsNullOrWhiteSpace(username))
			{
				var account = TShock.UserAccounts.GetUserAccountByName(username);
				if (account != null)
				{
					DateTime LastSeen;
					string Timezone = TimeZone.CurrentTimeZone.GetUtcOffset(DateTime.Now).Hours.ToString("+#;-#");

					if (DateTime.TryParse(account.LastAccessed, out LastSeen))
					{
						LastSeen = DateTime.Parse(account.LastAccessed).ToLocalTime();
						args.Player.SendSuccessMessage(GetString("{0}'s last login occurred {1} {2} UTC{3}.", account.Name, LastSeen.ToShortDateString(),
							LastSeen.ToShortTimeString(), Timezone));
					}

					if (args.Player.Group.HasPermission(Permissions.advaccountinfo))
					{
						List<string> KnownIps = JsonConvert.DeserializeObject<List<string>>(account.KnownIps?.ToString() ?? string.Empty);
						string ip = KnownIps?[KnownIps.Count - 1] ?? GetString("N/A");
						DateTime Registered = DateTime.Parse(account.Registered).ToLocalTime();

						args.Player.SendSuccessMessage(GetString("{0}'s group is {1}.", account.Name, account.Group));
						args.Player.SendSuccessMessage(GetString("{0}'s last known IP is {1}.", account.Name, ip));
						args.Player.SendSuccessMessage(GetString("{0}'s register date is {1} {2} UTC{3}.", account.Name, Registered.ToShortDateString(), Registered.ToShortTimeString(), Timezone));
					}
				}
				else
					args.Player.SendErrorMessage(GetString("User {0} does not exist.", username));
			}
			else args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}accountinfo <username>.", Specifier));
		}

		private static void Kick(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}kick <player> [reason].", Specifier));
				return;
			}
			if (args.Parameters[0].Length == 0)
			{
				args.Player.SendErrorMessage(GetString("A player name must be provided to kick a player. Please provide one."));
				return;
			}

			string plStr = args.Parameters[0];
			var players = TSPlayer.FindByNameOrID(plStr);
			if (players.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Player not found. Unable to kick the player."));
			}
			else if (players.Count > 1)
			{
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			}
			else
			{
				string reason = args.Parameters.Count > 1
									? String.Join(" ", args.Parameters.GetRange(1, args.Parameters.Count - 1))
									: GetString("Misbehaviour.");
				if (!players[0].Kick(reason, !args.Player.RealPlayer, false, args.Player.Name))
				{
					args.Player.SendErrorMessage(GetString("You can't kick another admin."));
				}
			}
		}

		private static void Ban(CommandArgs args)
		{
			//Ban syntax:
			// ban add <target> [reason] [duration] [flags (default: -a -u -ip)]
			//						Duration is in the format 0d0h0m0s. Any part can be ignored. E.g., 1s is a valid ban time, as is 1d1s, etc. If no duration is specified, ban is permanent
			//						Valid flags: -a (ban account name), -u (ban UUID), -n (ban character name), -ip (ban IP address), -e (exact, ban the identifier provided as 'target')
			//						Unless -e is passed to the command, <target> is assumed to be a player or player index.
			// ban del <ban ID>
			//						Target is expected to be a ban Unique ID
			// ban list [page]
			//						Displays a paginated list of bans
			// ban details <ban ID>
			//						Target is expected to be a ban Unique ID
			//ban help [command]
			//						Provides extended help on specific ban commands

			void Help()
			{
				if (args.Parameters.Count > 1)
				{
					MoreHelp(args.Parameters[1].ToLower());
					return;
				}

				//TODO: Translate. The string interpolation here will break the text extractor.
				args.Player.SendMessage(GetString("TShock Ban Help"), Color.White);
				args.Player.SendMessage(GetString("Available Ban commands:"), Color.White);
				args.Player.SendMessage(GetString($"ban {"add".Color(Utils.RedHighlight)} <Target> [Flags]"), Color.White);
				args.Player.SendMessage(GetString($"ban {"del".Color(Utils.RedHighlight)} <Ban ID>"), Color.White);
				args.Player.SendMessage(GetString($"ban {"list".Color(Utils.RedHighlight)}"), Color.White);
				args.Player.SendMessage(GetString($"ban {"details".Color(Utils.RedHighlight)} <Ban ID>"), Color.White);
				args.Player.SendMessage(GetString($"Quick usage: {"ban add".Color(Utils.BoldHighlight)} {args.Player.Name.Color(Utils.RedHighlight)} \"Griefing\""), Color.White);
				args.Player.SendMessage(GetString($"For more info, use {"ban help".Color(Utils.BoldHighlight)} {"command".Color(Utils.RedHighlight)} or {"ban help".Color(Utils.BoldHighlight)} {"examples".Color(Utils.RedHighlight)}"), Color.White);
			}

			void MoreHelp(string cmd)
			{
				switch (cmd)
				{
					case "add":
						args.Player.SendMessage(GetString(""), Color.White);
						args.Player.SendMessage(GetString("Ban Add Syntax"), Color.White);
						args.Player.SendMessage(GetString($"{"ban add".Color(Utils.BoldHighlight)} <{"Target".Color(Utils.RedHighlight)}> [{"Reason".Color(Utils.BoldHighlight)}] [{"Duration".Color(Utils.PinkHighlight)}] [{"Flags".Color(Utils.GreenHighlight)}]"), Color.White);
						args.Player.SendMessage(GetString($"- {"Duration".Color(Utils.PinkHighlight)}: uses the format {"0d0m0s".Color(Utils.PinkHighlight)} to determine the length of the ban."), Color.White);
						args.Player.SendMessage(GetString($"   Eg a value of {"10d30m0s".Color(Utils.PinkHighlight)} would represent 10 days, 30 minutes, 0 seconds."), Color.White);
						args.Player.SendMessage(GetString($"   If no duration is provided, the ban will be permanent."), Color.White);
						args.Player.SendMessage(GetString($"- {"Flags".Color(Utils.GreenHighlight)}: -a (account name), -u (UUID), -n (character name), -ip (IP address), -e (exact, {"Target".Color(Utils.RedHighlight)} will be treated as identifier)"), Color.White);
						args.Player.SendMessage(GetString($"   Unless {"-e".Color(Utils.GreenHighlight)} is passed to the command, {"Target".Color(Utils.RedHighlight)} is assumed to be a player or player index"), Color.White);
						args.Player.SendMessage(GetString($"   If no {"Flags".Color(Utils.GreenHighlight)} are specified, the command uses {"-a -u -ip".Color(Utils.GreenHighlight)} by default."), Color.White);
						args.Player.SendMessage(GetString($"Example usage: {"ban add".Color(Utils.BoldHighlight)} {args.Player.Name.Color(Utils.RedHighlight)} {"\"Cheating\"".Color(Utils.BoldHighlight)} {"10d30m0s".Color(Utils.PinkHighlight)} {"-a -u -ip".Color(Utils.GreenHighlight)}"), Color.White);
						break;

					case "del":
						args.Player.SendMessage(GetString(""), Color.White);
						args.Player.SendMessage(GetString("Ban Del Syntax"), Color.White);
						args.Player.SendMessage(GetString($"{"ban del".Color(Utils.BoldHighlight)} <{"Ticket Number".Color(Utils.RedHighlight)}>"), Color.White);
						args.Player.SendMessage(GetString($"- {"Ticket Numbers".Color(Utils.RedHighlight)} are provided when you add a ban, and can also be viewed with the {"ban list".Color(Utils.BoldHighlight)} command."), Color.White);
						args.Player.SendMessage(GetString($"Example usage: {"ban del".Color(Utils.BoldHighlight)} {"12345".Color(Utils.RedHighlight)}"), Color.White);
						break;

					case "list":
						args.Player.SendMessage(GetString(""), Color.White);
						args.Player.SendMessage(GetString("Ban List Syntax"), Color.White);
						args.Player.SendMessage(GetString($"{"ban list".Color(Utils.BoldHighlight)} [{"Page".Color(Utils.PinkHighlight)}]"), Color.White);
						args.Player.SendMessage(GetString("- Lists active bans. Color trends towards green as the ban approaches expiration"), Color.White);
						args.Player.SendMessage(GetString($"Example usage: {"ban list".Color(Utils.BoldHighlight)}"), Color.White);
						break;

					case "details":
						args.Player.SendMessage(GetString(""), Color.White);
						args.Player.SendMessage(GetString("Ban Details Syntax"), Color.White);
						args.Player.SendMessage(GetString($"{"ban details".Color(Utils.BoldHighlight)} <{"Ticket Number".Color(Utils.RedHighlight)}>"), Color.White);
						args.Player.SendMessage(GetString($"- {"Ticket Numbers".Color(Utils.RedHighlight)} are provided when you add a ban, and can be found with the {"ban list".Color(Utils.BoldHighlight)} command."), Color.White);
						args.Player.SendMessage(GetString($"Example usage: {"ban details".Color(Utils.BoldHighlight)} {"12345".Color(Utils.RedHighlight)}"), Color.White);
						break;

					case "identifiers":
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 2, args.Player, out int pageNumber))
						{
							args.Player.SendMessage(GetString($"Invalid page number. Page number must be numeric."), Color.White);
							return;
						}

						var idents = from ident in Identifier.Available
									 select $"{ident.Color(Utils.RedHighlight)} - {ident.Description}";

						args.Player.SendMessage(GetString(""), Color.White);
						PaginationTools.SendPage(args.Player, pageNumber, idents.ToList(),
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Available identifiers ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}ban help identifiers {{0}} for more.", Specifier),
								NothingToDisplayString = GetString("There are currently no available identifiers."),
								HeaderTextColor = Color.White,
								LineTextColor = Color.White
							});
						break;

					case "examples":
						args.Player.SendMessage(GetString(""), Color.White);
						args.Player.SendMessage(GetString("Ban Usage Examples"), Color.White);
						args.Player.SendMessage(GetString("- Ban an offline player by account name"), Color.White);
						args.Player.SendMessage(GetString($"   {Specifier}{"ban add".Color(Utils.BoldHighlight)} \"{"acc:".Color(Utils.RedHighlight)}{args.Player.Account.Color(Utils.RedHighlight)}\" {"\"Multiple accounts are not allowed\"".Color(Utils.BoldHighlight)} {"-e".Color(Utils.GreenHighlight)} (Permanently bans this account name)"), Color.White);
						args.Player.SendMessage(GetString("- Ban an offline player by IP address"), Color.White);
						args.Player.SendMessage(GetString($"   {Specifier}{"ai".Color(Utils.BoldHighlight)} \"{args.Player.Account.Color(Utils.RedHighlight)}\" (Find the IP associated with the offline target's account)"), Color.White);
						args.Player.SendMessage(GetString($"   {Specifier}{"ban add".Color(Utils.BoldHighlight)} {"ip:".Color(Utils.RedHighlight)}{args.Player.IP.Color(Utils.RedHighlight)} {"\"Griefing\"".Color(Utils.BoldHighlight)} {"-e".Color(Utils.GreenHighlight)} (Permanently bans this IP address)"), Color.White);
						args.Player.SendMessage(GetString($"- Ban an online player by index (Useful for hard to type names)"), Color.White);
						args.Player.SendMessage(GetString($"   {Specifier}{"who".Color(Utils.BoldHighlight)} {"-i".Color(Utils.GreenHighlight)} (Find the player index for the target)"), Color.White);
						args.Player.SendMessage(GetString($"   {Specifier}{"ban add".Color(Utils.BoldHighlight)} {"tsi:".Color(Utils.RedHighlight)}{args.Player.Index.Color(Utils.RedHighlight)} {"\"Trolling\"".Color(Utils.BoldHighlight)} {"-a -u -ip".Color(Utils.GreenHighlight)} (Permanently bans the online player by Account, UUID, and IP)"), Color.White);
						// Ban by account ID when?
						break;

					default:
						args.Player.SendMessage(GetString($"Unknown ban command. Try {"ban help".Color(Utils.BoldHighlight)} {"add".Color(Utils.RedHighlight)}, {"del".Color(Utils.RedHighlight)}, {"list".Color(Utils.RedHighlight)}, {"details".Color(Utils.RedHighlight)}, {"identifiers".Color(Utils.RedHighlight)}, or {"examples".Color(Utils.RedHighlight)}."), Color.White); break;
				}
			}

			void DisplayBanDetails(Ban ban)
			{
				args.Player.SendMessage(GetString($"{"Ban Details".Color(Utils.BoldHighlight)} - Ticket Number: {ban.TicketNumber.Color(Utils.GreenHighlight)}"), Color.White);
				args.Player.SendMessage(GetString($"{"Identifier:".Color(Utils.BoldHighlight)} {ban.Identifier}"), Color.White);
				args.Player.SendMessage(GetString($"{"Reason:".Color(Utils.BoldHighlight)} {ban.Reason}"), Color.White);
				args.Player.SendMessage(GetString($"{"Banned by:".Color(Utils.BoldHighlight)} {ban.BanningUser.Color(Utils.GreenHighlight)} on {ban.BanDateTime.ToString("yyyy/MM/dd").Color(Utils.RedHighlight)} ({ban.GetPrettyTimeSinceBanString().Color(Utils.YellowHighlight)} ago)"), Color.White);
				if (ban.ExpirationDateTime < DateTime.UtcNow)
				{
					args.Player.SendMessage(GetString($"{"Ban expired:".Color(Utils.BoldHighlight)} {ban.ExpirationDateTime.ToString("yyyy/MM/dd").Color(Utils.RedHighlight)} ({ban.GetPrettyExpirationString().Color(Utils.YellowHighlight)} ago)"), Color.White);
				}
				else
				{
					string remaining;
					if (ban.ExpirationDateTime == DateTime.MaxValue)
					{
						remaining = GetString("Never.").Color(Utils.YellowHighlight);
					}
					else
					{
						remaining = GetString($"{ban.GetPrettyExpirationString().Color(Utils.YellowHighlight)} remaining.");
					}

					args.Player.SendMessage(GetString($"{"Ban expires:".Color(Utils.BoldHighlight)} {ban.ExpirationDateTime.ToString("yyyy/MM/dd").Color(Utils.RedHighlight)} ({remaining})"), Color.White);
				}
			}

			AddBanResult DoBan(string ident, string reason, DateTime expiration)
			{
				AddBanResult banResult = TShock.Bans.InsertBan(ident, reason, args.Player.Account.Name, DateTime.UtcNow, expiration);
				if (banResult.Ban != null)
				{
					args.Player.SendSuccessMessage(GetString($"Ban added. Ticket Number {banResult.Ban.TicketNumber.Color(Utils.GreenHighlight)} was created for identifier {ident.Color(Utils.WhiteHighlight)}."));
				}
				else
				{
					args.Player.SendWarningMessage(GetString($"Failed to add ban for identifier: {ident.Color(Utils.WhiteHighlight)}."));
					args.Player.SendWarningMessage(GetString($"Reason: {banResult.Message}."));
				}

				return banResult;
			}

			void AddBan()
			{
				if (!args.Parameters.TryGetValue(1, out string target))
				{
					args.Player.SendMessage(GetString($"Invalid Ban Add syntax. Refer to {"ban help add".Color(Utils.BoldHighlight)} for details on how to use the {"ban add".Color(Utils.BoldHighlight)} command"), Color.White);
					return;
				}

				bool exactTarget = args.Parameters.Any(p => p == "-e");
				bool banAccount = args.Parameters.Any(p => p == "-a");
				bool banUuid = args.Parameters.Any(p => p == "-u");
				bool banName = args.Parameters.Any(p => p == "-n");
				bool banIp = args.Parameters.Any(p => p == "-ip");

				List<string> flags = new List<string>() { "-e", "-a", "-u", "-n", "-ip" };

				string reason = GetString("Banned.");
				string duration = null;
				DateTime expiration = DateTime.MaxValue;

				//This is hacky. We want flag values to be independent of order so we must force the consecutive ordering of the 'reason' and 'duration' parameters,
				//while still allowing them to be placed arbitrarily in the parameter list.
				//As an example, the following parameter lists (and more) should all be acceptable:
				//-u "reason" -a duration -ip
				//"reason" duration -u -a -ip
				//-u -a -ip "reason" duration
				//-u -a -ip
				for (int i = 2; i < args.Parameters.Count; i++)
				{
					var param = args.Parameters[i];
					if (!flags.Contains(param))
					{
						reason = param;
						break;
					}
				}
				for (int i = 3; i < args.Parameters.Count; i++)
				{
					var param = args.Parameters[i];
					if (!flags.Contains(param))
					{
						duration = param;
						break;
					}
				}

				if (TShock.Utils.TryParseTime(duration, out ulong seconds))
				{
					expiration = DateTime.UtcNow.AddSeconds(seconds);
				}

				//If no flags were specified, default to account, uuid, and IP
				if (!exactTarget && !banAccount && !banUuid && !banName && !banIp)
				{
					banAccount = banUuid = banIp = true;

					if (TShock.Config.Settings.DisableDefaultIPBan)
					{
						banIp = false;
					}
				}

				reason = reason ?? "Banned";

				if (exactTarget)
				{
					DoBan(target, reason, expiration);
					return;
				}

				var players = TSPlayer.FindByNameOrID(target);

				if (players.Count > 1)
				{
					args.Player.SendMultipleMatchError(players.Select(p => p.Name));
					return;
				}

				if (players.Count < 1)
				{
					args.Player.SendErrorMessage(GetString("Could not find the target specified. Check that you have the correct spelling."));
					return;
				}

				var player = players[0];
				AddBanResult banResult = null;

				if (banAccount)
				{
					if (player.Account != null)
					{
						banResult = DoBan($"{Identifier.Account}{player.Account.Name}", reason, expiration);
					}
				}

				if (banUuid && player.UUID.Length > 0)
				{
					banResult = DoBan($"{Identifier.UUID}{player.UUID}", reason, expiration);
				}

				if (banName)
				{
					banResult = DoBan($"{Identifier.Name}{player.Name}", reason, expiration);
				}

				if (banIp)
				{
					banResult = DoBan($"{Identifier.IP}{player.IP}", reason, expiration);
				}

				if (banResult?.Ban != null)
				{
					player.Disconnect(GetString($"#{banResult.Ban.TicketNumber} - You have been banned: {banResult.Ban.Reason}."));
				}
			}

			void DelBan()
			{
				if (!args.Parameters.TryGetValue(1, out string target))
				{
					args.Player.SendMessage(GetString($"Invalid Ban Del syntax. Refer to {"ban help del".Color(Utils.BoldHighlight)} for details on how to use the {"ban del".Color(Utils.BoldHighlight)} command"), Color.White);
					return;
				}

				if (!int.TryParse(target, out int banId))
				{
					args.Player.SendMessage(GetString($"Invalid Ticket Number. Refer to {"ban help del".Color(Utils.BoldHighlight)} for details on how to use the {"ban del".Color(Utils.BoldHighlight)} command"), Color.White);
					return;
				}

				if (TShock.Bans.RemoveBan(banId))
				{
					TShock.Log.ConsoleInfo(GetString($"Ban {banId} has been revoked by {args.Player.Account.Name}."));
					args.Player.SendSuccessMessage(GetString($"Ban {banId.Color(Utils.GreenHighlight)} has now been marked as expired."));
				}
				else
				{
					args.Player.SendErrorMessage(GetString("Failed to remove ban."));
				}
			}

			void ListBans()
			{
				string PickColorForBan(Ban ban)
				{
					double hoursRemaining = (ban.ExpirationDateTime - DateTime.UtcNow).TotalHours;
					double hoursTotal = (ban.ExpirationDateTime - ban.BanDateTime).TotalHours;
					double percentRemaining = TShock.Utils.Clamp(hoursRemaining / hoursTotal, 100, 0);

					int red = TShock.Utils.Clamp((int)(255 * 2.0f * percentRemaining), 255, 0);
					int green = TShock.Utils.Clamp((int)(255 * (2.0f * (1 - percentRemaining))), 255, 0);

					return $"{red:X2}{green:X2}{0:X2}";
				}

				if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out int pageNumber))
				{
					args.Player.SendMessage(GetString($"Invalid Ban List syntax. Refer to {"ban help list".Color(Utils.BoldHighlight)} for details on how to use the {"ban list".Color(Utils.BoldHighlight)} command"), Color.White);
					return;
				}

				var bans = from ban in TShock.Bans.Bans
						   where ban.Value.ExpirationDateTime > DateTime.UtcNow
						   orderby ban.Value.ExpirationDateTime ascending
						   select $"[{ban.Key.Color(Utils.GreenHighlight)}] {ban.Value.Identifier.Color(PickColorForBan(ban.Value))}";

				PaginationTools.SendPage(args.Player, pageNumber, bans.ToList(),
					new PaginationTools.Settings
					{
						HeaderFormat = GetString("Bans ({{0}}/{{1}}):"),
						FooterFormat = GetString("Type {0}ban list {{0}} for more.", Specifier),
						NothingToDisplayString = GetString("There are currently no active bans.")
					});
			}

			void BanDetails()
			{
				if (!args.Parameters.TryGetValue(1, out string target))
				{
					args.Player.SendMessage(GetString($"Invalid Ban Details syntax. Refer to {"ban help details".Color(Utils.BoldHighlight)} for details on how to use the {"ban details".Color(Utils.BoldHighlight)} command"), Color.White);
					return;
				}

				if (!int.TryParse(target, out int banId))
				{
					args.Player.SendMessage(GetString($"Invalid Ticket Number. Refer to {"ban help details".Color(Utils.BoldHighlight)} for details on how to use the {"ban details".Color(Utils.BoldHighlight)} command"), Color.White);
					return;
				}

				Ban ban = TShock.Bans.GetBanById(banId);

				if (ban == null)
				{
					args.Player.SendErrorMessage(GetString("No bans found matching the provided ticket number."));
					return;
				}

				DisplayBanDetails(ban);
			}

			string subcmd = args.Parameters.Count == 0 ? "help" : args.Parameters[0].ToLower();
			switch (subcmd)
			{
				case "help":
					Help();
					break;

				case "add":
					AddBan();
					break;

				case "del":
					DelBan();
					break;

				case "list":
					ListBans();
					break;

				case "details":
					BanDetails();
					break;

				default:
					break;
			}
		}

		private static void Whitelist(CommandArgs args)
		{
			if (args.Parameters.Count == 1)
			{
				using (var tw = new StreamWriter(FileTools.WhitelistPath, true))
				{
					tw.WriteLine(args.Parameters[0]);
				}
				args.Player.SendSuccessMessage(GetString($"Added {args.Parameters[0]} to the whitelist."));
			}
		}

		private static void DisplayLogs(CommandArgs args)
		{
			args.Player.DisplayLogs = (!args.Player.DisplayLogs);
			if (args.Player.DisplayLogs)
			{
				args.Player.SendSuccessMessage(GetString("Log display enabled."));
			}
			else
			{
				args.Player.SendSuccessMessage(GetString("Log display disabled."));
			}
		}

		private static void SaveSSC(CommandArgs args)
		{
			if (Main.ServerSideCharacter)
			{
				args.Player.SendSuccessMessage(GetString("Your server-side character data has been saved."));
				foreach (TSPlayer player in TShock.Players)
				{
					if (player != null && player.IsLoggedIn && !player.IsDisabledPendingTrashRemoval)
					{
						TShock.CharacterDB.InsertPlayerData(player, true);
					}
				}
			}
		}

		private static void OverrideSSC(CommandArgs args)
		{
			if (!Main.ServerSideCharacter)
			{
				args.Player.SendErrorMessage(GetString("Server-side characters is disabled."));
				return;
			}
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Correct usage: {0}overridessc|{0}ossc <player name>", Specifier));
				return;
			}

			string playerNameToMatch = string.Join(" ", args.Parameters);
			var matchedPlayers = TSPlayer.FindByNameOrID(playerNameToMatch);
			if (matchedPlayers.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("No players matched \"{0}\".", playerNameToMatch));
				return;
			}
			else if (matchedPlayers.Count > 1)
			{
				args.Player.SendMultipleMatchError(matchedPlayers.Select(p => p.Name));
				return;
			}

			TSPlayer matchedPlayer = matchedPlayers[0];
			if (matchedPlayer.IsLoggedIn)
			{
				args.Player.SendErrorMessage(GetString("Player \"{0}\" is already logged in.", matchedPlayer.Name));
				return;
			}
			if (!matchedPlayer.LoginFailsBySsi)
			{
				args.Player.SendErrorMessage(GetString("Player \"{0}\" has to perform a /login attempt first.", matchedPlayer.Name));
				return;
			}
			if (matchedPlayer.IsDisabledPendingTrashRemoval)
			{
				args.Player.SendErrorMessage(GetString("Player \"{0}\" has to reconnect first, because they need to delete their trash.", matchedPlayer.Name));
				return;
			}

			TShock.CharacterDB.InsertPlayerData(matchedPlayer);
			args.Player.SendSuccessMessage(GetString("Server-side character data from \"{0}\" has been replaced by their current local data.", matchedPlayer.Name));
		}

		private static void UploadJoinData(CommandArgs args)
		{
			TSPlayer targetPlayer = args.Player;
			if (args.Parameters.Count == 1 && args.Player.HasPermission(Permissions.uploadothersdata))
			{
				List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[0]);
				if (players.Count > 1)
				{
					args.Player.SendMultipleMatchError(players.Select(p => p.Name));
					return;
				}
				else if (players.Count == 0)
				{
					args.Player.SendErrorMessage(GetString("No player was found matching '{0}'.", args.Parameters[0]));
					return;
				}
				else
				{
					targetPlayer = players[0];
				}
			}
			else if (args.Parameters.Count == 1)
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to upload another player's character join-state server-side-character data."));
				return;
			}
			else if (args.Parameters.Count > 0)
			{
				args.Player.SendErrorMessage(GetString("Usage: /uploadssc [playername]."));
				return;
			}
			else if (args.Parameters.Count == 0 && args.Player is TSServerPlayer)
			{
				args.Player.SendErrorMessage(GetString("The targeted user cannot have their data uploaded, because they are not a player."));
				args.Player.SendErrorMessage(GetString("Usage: /uploadssc [playername]."));
				return;
			}

			if (targetPlayer.IsLoggedIn)
			{
				if (TShock.CharacterDB.InsertSpecificPlayerData(targetPlayer, targetPlayer.DataWhenJoined))
				{
					targetPlayer.DataWhenJoined.RestoreCharacter(targetPlayer);
					targetPlayer.SendSuccessMessage(GetString("Your local character data, from your initial connection, has been uploaded to the server."));
					args.Player.SendSuccessMessage(GetString("The player's character data was successfully uploaded from their initial connection."));
				}
				else
				{
					args.Player.SendErrorMessage(GetString("Failed to upload your character data to the server. Are you logged-in to an account?"));
				}
			}
			else
			{
				args.Player.SendErrorMessage(GetString("The target player has not logged in yet."));
			}
		}

		private static void ForceHalloween(CommandArgs args)
		{
			TShock.Config.Settings.ForceHalloween = !TShock.Config.Settings.ForceHalloween;
			Main.checkHalloween();
			if (args.Silent)
				if (TShock.Config.Settings.ForceHalloween)
					args.Player.SendInfoMessage(GetString("Enabled halloween mode."));
				else
					args.Player.SendInfoMessage(GetString("Disabled halloween mode."));
			else
			{
				if (TShock.Config.Settings.ForceHalloween)
					TSPlayer.All.SendInfoMessage(GetString("{0} enabled halloween mode.", args.Player.Name));
				else
					TSPlayer.All.SendInfoMessage(GetString("{0} disabled halloween mode.", args.Player.Name));
			}
		}

		private static void ForceXmas(CommandArgs args)
		{
			TShock.Config.Settings.ForceXmas = !TShock.Config.Settings.ForceXmas;
			Main.checkXMas();
			if (args.Silent)
			{
				if (TShock.Config.Settings.ForceXmas)
					args.Player.SendInfoMessage(GetString("Enabled xmas mode."));
				else
					args.Player.SendInfoMessage(GetString("Disabled xmas mode."));
			}
			else
			{
				if (TShock.Config.Settings.ForceXmas)
					TSPlayer.All.SendInfoMessage(GetString("{0} enabled xmas mode.", args.Player.Name));
				else
					TSPlayer.All.SendInfoMessage(GetString("{0} disabled xmas mode.", args.Player.Name));
			}
		}

		private static void TempGroup(CommandArgs args)
		{
			if (args.Parameters.Count < 2)
			{
				args.Player.SendInfoMessage(GetString("Invalid syntax."));
				args.Player.SendInfoMessage(GetString("Usage: {0}tempgroup <username> <new group> [time]", Specifier));
				return;
			}

			List<TSPlayer> ply = TSPlayer.FindByNameOrID(args.Parameters[0]);
			if (ply.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Could not find player {0}.", args.Parameters[0]));
				return;
			}

			if (ply.Count > 1)
			{
				args.Player.SendMultipleMatchError(ply.Select(p => p.Account.Name));
			}

			if (!TShock.Groups.GroupExists(args.Parameters[1]))
			{
				args.Player.SendErrorMessage(GetString("Could not find group {0}", args.Parameters[1]));
				return;
			}

			if (args.Parameters.Count > 2)
			{
				ulong time;
				if (!TShock.Utils.TryParseTime(args.Parameters[2], out time))
				{
					args.Player.SendErrorMessage(GetString("Invalid time string! Proper format: _d_h_m_s, with at least one time specifier."));
					args.Player.SendErrorMessage(GetString("For example, 1d and 10h-30m+2m are both valid time strings, but 2 is not."));
					return;
				}

				ply[0].tempGroupTimer = new System.Timers.Timer(time * 1000d);
				ply[0].tempGroupTimer.Elapsed += ply[0].TempGroupTimerElapsed;
				ply[0].tempGroupTimer.Start();
			}

			Group g = TShock.Groups.GetGroupByName(args.Parameters[1]);

			ply[0].tempGroup = g;

			if (args.Parameters.Count < 3)
			{
				args.Player.SendSuccessMessage(GetString("You have changed {0}'s group to {1}", ply[0].Name, g.Name));
				ply[0].SendSuccessMessage(GetString("Your group has temporarily been changed to {0}", g.Name));
			}
			else
			{
				args.Player.SendSuccessMessage(GetString("You have changed {0}'s group to {1} for {2}",
					ply[0].Name, g.Name, args.Parameters[2]));
				ply[0].SendSuccessMessage(GetString("Your group has been changed to {0} for {1}",
					g.Name, args.Parameters[2]));
			}
		}

		private static void SubstituteUser(CommandArgs args)
		{

			if (args.Player.tempGroup != null)
			{
				args.Player.tempGroup = null;
				args.Player.tempGroupTimer.Stop();
				args.Player.SendSuccessMessage(GetString("Your previous permission set has been restored."));
				return;
			}
			else
			{
				args.Player.tempGroup = new SuperAdminGroup();
				args.Player.tempGroupTimer = new System.Timers.Timer(600 * 1000);
				args.Player.tempGroupTimer.Elapsed += args.Player.TempGroupTimerElapsed;
				args.Player.tempGroupTimer.Start();
				args.Player.SendSuccessMessage(GetString("Your account has been elevated to superadmin for 10 minutes."));
				return;
			}
		}

		#endregion Player Management Commands

		#region Server Maintenence Commands

		// Executes a command as a superuser if you have sudo rights.
		private static void SubstituteUserDo(CommandArgs args)
		{
			if (args.Parameters.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Usage: /sudo [command]."));
				args.Player.SendErrorMessage(GetString("Example: /sudo /ban add particles 2d Hacking."));
				return;
			}

			string replacementCommand = String.Join(" ", args.Parameters.Select(p => p.Contains(" ") ? $"\"{p}\"" : p));
			args.Player.tempGroup = new SuperAdminGroup();
			HandleCommand(args.Player, replacementCommand);
			args.Player.tempGroup = null;
			return;
		}

		private static void Broadcast(CommandArgs args)
		{
			if (args.Parameters.Count > 0)
			{
				string message = string.Join(" ", args.Parameters);

				TShock.Utils.Broadcast(
					GetString("(Server Broadcast) ") + message,
					Convert.ToByte(TShock.Config.Settings.BroadcastRGB[0]), Convert.ToByte(TShock.Config.Settings.BroadcastRGB[1]),
					Convert.ToByte(TShock.Config.Settings.BroadcastRGB[2]));
			}
		}

		private static void Off(CommandArgs args)
		{

			if (Main.ServerSideCharacter)
			{
				foreach (TSPlayer player in TShock.Players)
				{
					if (player != null && player.IsLoggedIn && !player.IsDisabledPendingTrashRemoval)
					{
						player.SaveServerCharacter();
					}
				}
			}

			string reason = ((args.Parameters.Count > 0) ? GetString("Server shutting down: ") + String.Join(" ", args.Parameters) : GetString("Server shutting down!"));
			TShock.Utils.StopServer(true, reason);
		}

		private static void OffNoSave(CommandArgs args)
		{
			string reason = ((args.Parameters.Count > 0) ? GetString("Server shutting down: ") + String.Join(" ", args.Parameters) : GetString("Server shutting down."));
			Netplay.SaveOnServerExit = false;
			TShock.Utils.StopServer(false, reason);
		}

		private static void CheckUpdates(CommandArgs args)
		{
			args.Player.SendInfoMessage(GetString("An update check has been queued. If an update is available, you will be notified shortly."));
			try
			{
				TShock.UpdateManager.UpdateCheckAsync(null);
			}
			catch (Exception)
			{
				//swallow the exception
				return;
			}
		}

		private static void ManageRest(CommandArgs args)
		{
			string subCommand = "help";
			if (args.Parameters.Count > 0)
				subCommand = args.Parameters[0];

			switch (subCommand.ToLower())
			{
				case "listusers":
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;

						Dictionary<string, int> restUsersTokens = new Dictionary<string, int>();
						foreach (Rests.SecureRest.TokenData tokenData in TShock.RestApi.Tokens.Values)
						{
							if (restUsersTokens.ContainsKey(tokenData.Username))
								restUsersTokens[tokenData.Username]++;
							else
								restUsersTokens.Add(tokenData.Username, 1);
						}

						List<string> restUsers = new List<string>(
							restUsersTokens.Select(ut => GetString("{0} ({1} tokens)", ut.Key, ut.Value)));

						PaginationTools.SendPage(
							args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(restUsers), new PaginationTools.Settings
							{
								NothingToDisplayString = GetString("There are currently no active REST users."),
								HeaderFormat = GetString("Active REST Users ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}rest listusers {{0}} for more.", Specifier)
							}
						);

						break;
					}
				case "destroytokens":
					{
						TShock.RestApi.Tokens.Clear();
						args.Player.SendSuccessMessage(GetString("All REST tokens have been destroyed."));
						break;
					}
				default:
					{
						args.Player.SendInfoMessage(GetString("Available REST Sub-Commands:"));
						args.Player.SendMessage(GetString("listusers - Lists all REST users and their current active tokens."), Color.White);
						args.Player.SendMessage(GetString("destroytokens - Destroys all current REST tokens."), Color.White);
						break;
					}
			}
		}

		#endregion Server Maintenence Commands

		#region Cause Events and Spawn Monsters Commands

		static readonly List<string> _validEvents = new List<string>()
		{
			"meteor",
			"fullmoon",
			"bloodmoon",
			"eclipse",
			"invasion",
			"sandstorm",
			"rain",
			"lanternsnight"
		};
		static readonly List<string> _validInvasions = new List<string>()
		{
			"goblins",
			"snowmen",
			"pirates",
			"pumpkinmoon",
			"frostmoon",
			"martians"
		};

		private static void ManageWorldEvent(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}worldevent <event type>.", Specifier));
				args.Player.SendErrorMessage(GetString("Valid event types: {0}.", String.Join(", ", _validEvents)));
				args.Player.SendErrorMessage(GetString("Valid invasion types if spawning an invasion: {0}.", String.Join(", ", _validInvasions)));
				return;
			}

			var eventType = args.Parameters[0].ToLowerInvariant();

			void FailedPermissionCheck()
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to start the {0} event.", eventType));
				return;
			}

			switch (eventType)
			{
				case "meteor":
					if (!args.Player.HasPermission(Permissions.dropmeteor) && !args.Player.HasPermission(Permissions.managemeteorevent))
					{
						FailedPermissionCheck();
						return;
					}

					DropMeteor(args);
					return;

				case "fullmoon":
				case "full moon":
					if (!args.Player.HasPermission(Permissions.fullmoon) && !args.Player.HasPermission(Permissions.managefullmoonevent))
					{
						FailedPermissionCheck();
						return;
					}
					Fullmoon(args);
					return;

				case "bloodmoon":
				case "blood moon":
					if (!args.Player.HasPermission(Permissions.bloodmoon) && !args.Player.HasPermission(Permissions.managebloodmoonevent))
					{
						FailedPermissionCheck();
						return;
					}
					Bloodmoon(args);
					return;

				case "eclipse":
					if (!args.Player.HasPermission(Permissions.eclipse) && !args.Player.HasPermission(Permissions.manageeclipseevent))
					{
						FailedPermissionCheck();
						return;
					}
					Eclipse(args);
					return;

				case "invade":
				case "invasion":
					if (!args.Player.HasPermission(Permissions.invade) && !args.Player.HasPermission(Permissions.manageinvasionevent))
					{
						FailedPermissionCheck();
						return;
					}
					Invade(args);
					return;

				case "sandstorm":
					if (!args.Player.HasPermission(Permissions.sandstorm) && !args.Player.HasPermission(Permissions.managesandstormevent))
					{
						FailedPermissionCheck();
						return;
					}
					Sandstorm(args);
					return;

				case "rain":
					if (!args.Player.HasPermission(Permissions.rain) && !args.Player.HasPermission(Permissions.managerainevent))
					{
						FailedPermissionCheck();
						return;
					}
					Rain(args);
					return;

				case "lanternsnight":
				case "lanterns":
					if (!args.Player.HasPermission(Permissions.managelanternsnightevent))
					{
						FailedPermissionCheck();
						return;
					}
					LanternsNight(args);
					return;

				default:
					args.Player.SendErrorMessage(GetString("Invalid event type. Valid event types: {0}.", String.Join(", ", _validEvents)));
					return;
			}
		}

		private static void DropMeteor(CommandArgs args)
		{
			WorldGen.spawnMeteor = false;
			WorldGen.dropMeteor();
			if (args.Silent)
			{
				args.Player.SendInfoMessage(GetString("A meteor has been triggered."));
			}
			else
			{
				TSPlayer.All.SendInfoMessage(GetString("{0} triggered a meteor.", args.Player.Name));
			}
		}

		private static void Fullmoon(CommandArgs args)
		{
			TSPlayer.Server.SetFullMoon();
			if (args.Silent)
			{
				args.Player.SendInfoMessage(GetString("Started a full moon event."));
			}
			else
			{
				TSPlayer.All.SendInfoMessage(GetString("{0} started a full moon event.", args.Player.Name));
			}
		}

		private static void Bloodmoon(CommandArgs args)
		{
			TSPlayer.Server.SetBloodMoon(!Main.bloodMoon);
			if (args.Silent)
			{
				if (Main.bloodMoon)
				{
					args.Player.SendInfoMessage(GetString("Started a blood moon event."));
				}
				else
				{
					args.Player.SendInfoMessage(GetString("Stopped the current blood moon event."));
				}
			}
			else
			{
				if (Main.bloodMoon)
				{
					TSPlayer.All.SendInfoMessage(GetString("{0} started a blood moon event.", args.Player.Name));
				}
				else
				{
					TSPlayer.All.SendInfoMessage(GetString("{0} stopped the current blood moon.", args.Player.Name));
				}
			}
		}

		private static void Eclipse(CommandArgs args)
		{
			TSPlayer.Server.SetEclipse(!Main.eclipse);
			if (args.Silent)
			{
				if (Main.eclipse)
				{
					args.Player.SendInfoMessage(GetString("Started an eclipse."));
				}
				else
				{
					args.Player.SendInfoMessage(GetString("Stopped an eclipse."));
				}
			}
			else
			{
				if (Main.eclipse)
				{
					TSPlayer.All.SendInfoMessage(GetString("{0} started an eclipse.", args.Player.Name));
				}
				else
				{
					TSPlayer.All.SendInfoMessage(GetString("{0} stopped an eclipse.", args.Player.Name));
				}
			}
		}

		private static void Invade(CommandArgs args)
		{
			if (Main.invasionSize <= 0)
			{
				if (args.Parameters.Count < 2)
				{
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax:  {0}worldevent invasion [invasion type] [invasion wave].", Specifier));
					args.Player.SendErrorMessage(GetString("Valid invasion types: {0}.", String.Join(", ", _validInvasions)));
					return;
				}

				int wave = 1;
				switch (args.Parameters[1].ToLowerInvariant())
				{
					case "goblin":
					case "goblins":
						TSPlayer.All.SendInfoMessage(GetString("{0} has started a goblin army invasion.", args.Player.Name));
						TShock.Utils.StartInvasion(1);
						break;

					case "snowman":
					case "snowmen":
						TSPlayer.All.SendInfoMessage(GetString("{0} has started a snow legion invasion.", args.Player.Name));
						TShock.Utils.StartInvasion(2);
						break;

					case "pirate":
					case "pirates":
						TSPlayer.All.SendInfoMessage(GetString("{0} has started a pirate invasion.", args.Player.Name));
						TShock.Utils.StartInvasion(3);
						break;

					case "pumpkin":
					case "pumpkinmoon":
						if (args.Parameters.Count > 2)
						{
							if (!int.TryParse(args.Parameters[2], out wave) || wave <= 0)
							{
								args.Player.SendErrorMessage(GetString("Invalid pumpkin moon event wave."));
								break;
							}
						}

						TSPlayer.Server.SetPumpkinMoon(true);
						Main.bloodMoon = false;
						NPC.waveKills = 0f;
						NPC.waveNumber = wave;
						TSPlayer.All.SendInfoMessage(GetString("{0} started the pumpkin moon at wave {1}!", args.Player.Name, wave));
						break;

					case "frost":
					case "frostmoon":
						if (args.Parameters.Count > 2)
						{
							if (!int.TryParse(args.Parameters[2], out wave) || wave <= 0)
							{
								args.Player.SendErrorMessage(GetString("Invalid frost moon event wave."));
								return;
							}
						}

						TSPlayer.Server.SetFrostMoon(true);
						Main.bloodMoon = false;
						NPC.waveKills = 0f;
						NPC.waveNumber = wave;
						TSPlayer.All.SendInfoMessage(GetString("{0} started the frost moon at wave {1}!", args.Player.Name, wave));
						break;

					case "martian":
					case "martians":
						TSPlayer.All.SendInfoMessage(GetString("{0} has started a martian invasion.", args.Player.Name));
						TShock.Utils.StartInvasion(4);
						break;

					default:
						args.Player.SendErrorMessage(GetString("Invalid invasion type. Valid invasion types: {0}.", String.Join(", ", _validInvasions)));
						break;
				}
			}
			else if (DD2Event.Ongoing)
			{
				DD2Event.StopInvasion();
				TSPlayer.All.SendInfoMessage(GetString("{0} has ended the Old One's Army event.", args.Player.Name));
			}
			else
			{
				TSPlayer.All.SendInfoMessage(GetString("{0} has ended the current invasion event.", args.Player.Name));
				Main.invasionSize = 0;
			}
		}

		private static void Sandstorm(CommandArgs args)
		{
			if (Terraria.GameContent.Events.Sandstorm.Happening)
			{
				Terraria.GameContent.Events.Sandstorm.StopSandstorm();
				TSPlayer.All.SendInfoMessage(GetString("{0} stopped the current sandstorm event.", args.Player.Name));
			}
			else
			{
				Terraria.GameContent.Events.Sandstorm.StartSandstorm();
				TSPlayer.All.SendInfoMessage(GetString("{0} started a sandstorm event.", args.Player.Name));
			}
		}

		private static void Rain(CommandArgs args)
		{
			bool slime = false;
			if (args.Parameters.Count > 1 && args.Parameters[1].ToLowerInvariant() == "slime")
			{
				slime = true;
			}

			if (!slime)
			{
				args.Player.SendInfoMessage(GetString("Use \"{0}worldevent rain slime\" to start slime rain!", Specifier));
			}

			if (slime && Main.raining) //Slime rain cannot be activated during normal rain
			{
				args.Player.SendErrorMessage(GetString("Slime rain cannot be activated during normal rain. Stop the normal rainstorm and try again."));
				return;
			}

			if (slime && Main.slimeRain) //Toggle slime rain off
			{
				Main.StopSlimeRain(false);
				TSPlayer.All.SendData(PacketTypes.WorldInfo);
				TSPlayer.All.SendInfoMessage(GetString("{0} ended the slime rain.", args.Player.Name));
				return;
			}

			if (slime && !Main.slimeRain) //Toggle slime rain on
			{
				Main.StartSlimeRain(false);
				TSPlayer.All.SendData(PacketTypes.WorldInfo);
				TSPlayer.All.SendInfoMessage(GetString("{0} caused it to rain slime.", args.Player.Name));
			}

			if (Main.raining && !slime) //Toggle rain off
			{
				Main.StopRain();
				TSPlayer.All.SendData(PacketTypes.WorldInfo);
				TSPlayer.All.SendInfoMessage(GetString("{0} ended the rain.", args.Player.Name));
				return;
			}

			if (!Main.raining && !slime) //Toggle rain on
			{
				Main.StartRain();
				TSPlayer.All.SendData(PacketTypes.WorldInfo);
				TSPlayer.All.SendInfoMessage(GetString("{0} caused it to rain.", args.Player.Name));
				return;
			}
		}

		private static void LanternsNight(CommandArgs args)
		{
			LanternNight.ToggleManualLanterns();
			if (args.Silent)
			{
				if (LanternNight.LanternsUp)
				{
					args.Player.SendSuccessMessage(GetString("Lanterns are now up."));
				}
				else
				{
					args.Player.SendSuccessMessage(GetString("Lanterns are now down."));
				}
			}
			else
			{
				if (LanternNight.LanternsUp)
				{
					TSPlayer.All.SendInfoMessage(GetString("{0} started a lantern night.", args.Player.Name));
				}
				else
				{
					TSPlayer.All.SendInfoMessage(GetString("{0} stopped the lantern night.", args.Player.Name));
				}
			}
		}

		private static void ClearAnglerQuests(CommandArgs args)
		{
			if (args.Parameters.Count > 0)
			{
				var result = Main.anglerWhoFinishedToday.RemoveAll(s => s.ToLower().Equals(args.Parameters[0].ToLower()));
				if (result > 0)
				{
					foreach (TSPlayer ply in TShock.Players.Where(p => p != null && p.Active && p.TPlayer.name.ToLower().Equals(args.Parameters[0].ToLower())))
					{
						//this will always tell the client that they have not done the quest today.
						ply.SendData(PacketTypes.AnglerQuest, "");
					}
					args.Player.SendSuccessMessage(GetString("Removed {0} players from the angler quest completion list for today.", result));
				}
				else
					args.Player.SendErrorMessage(GetString("Failed to find any users by that name on the list."));

			}
			else
			{
				Main.anglerWhoFinishedToday.Clear();
				NetMessage.SendAnglerQuest(-1);
				args.Player.SendSuccessMessage(GetString("Cleared all users from the angler quest completion list for today."));
			}
		}

		static Dictionary<string, int> _worldModes = new Dictionary<string, int>
		{
			{ "normal",    0 },
			{ "expert",    1 },
			{ "master",    2 },
			{ "journey",   3 },
			{ "creative",  3 }
		};

		private static void ChangeWorldMode(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}worldmode <mode>.", Specifier));
				args.Player.SendErrorMessage(GetString("Valid world modes: {0}", String.Join(", ", _worldModes.Keys)));
				return;
			}

			int mode;

			if (int.TryParse(args.Parameters[0], out mode))
			{
				if (mode < 0 || mode > 3)
				{
					args.Player.SendErrorMessage(GetString("Invalid world mode. Valid world modes: {0}", String.Join(", ", _worldModes.Keys)));
					return;
				}
			}
			else if (_worldModes.ContainsKey(args.Parameters[0].ToLowerInvariant()))
			{
				mode = _worldModes[args.Parameters[0].ToLowerInvariant()];
			}
			else
			{
				args.Player.SendErrorMessage(GetString("Invalid mode world mode. Valid modes: {0}", String.Join(", ", _worldModes.Keys)));
				return;
			}

			Main.GameMode = mode;
			args.Player.SendSuccessMessage(GetString("World mode set to {0}.", _worldModes.Keys.ElementAt(mode)));
			TSPlayer.All.SendData(PacketTypes.WorldInfo);
		}

		private static void Hardmode(CommandArgs args)
		{
			if (Main.hardMode)
			{
				Main.hardMode = false;
				TSPlayer.All.SendData(PacketTypes.WorldInfo);
				args.Player.SendSuccessMessage(GetString("Hardmode is now off."));
			}
			else if (!TShock.Config.Settings.DisableHardmode)
			{
				WorldGen.StartHardmode();
				args.Player.SendSuccessMessage(GetString("Hardmode is now on."));
			}
			else
			{
				args.Player.SendErrorMessage(GetString("Hardmode is disabled in the server configuration file."));
			}
		}

		private static void SpawnBoss(CommandArgs args)
		{
			if (args.Parameters.Count < 1 || args.Parameters.Count > 2)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}spawnboss <boss type> [amount].", Specifier));
				return;
			}

			int amount = 1;
			if (args.Parameters.Count == 2 && (!int.TryParse(args.Parameters[1], out amount) || amount <= 0))
			{
				args.Player.SendErrorMessage(GetString("Invalid boss amount."));
				return;
			}


			string spawnName;
			NPC npc = new NPC();
			switch (args.Parameters[0].ToLower())
			{
				case "*":
				case "all":
					int[] npcIds = { 4, 13, 35, 50, 125, 126, 127, 134, 222, 245, 262, 266, 370, 398, 439, 636, 657 };
					TSPlayer.Server.SetTime(false, 0.0);
					foreach (int i in npcIds)
					{
						npc.SetDefaults(i);
						TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					}
					spawnName = GetString("all bosses");
					break;

				case "brain":
				case "brain of cthulhu":
				case "boc":
					npc.SetDefaults(266);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Brain of Cthulhu");
					break;

				case "destroyer":
					npc.SetDefaults(134);
					TSPlayer.Server.SetTime(false, 0.0);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Destroyer");
					break;
				case "duke":
				case "duke fishron":
				case "fishron":
					npc.SetDefaults(370);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("Duke Fishron");
					break;
				case "eater":
				case "eater of worlds":
				case "eow":
					npc.SetDefaults(13);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Eater of Worlds");
					break;
				case "eye":
				case "eye of cthulhu":
				case "eoc":
					npc.SetDefaults(4);
					TSPlayer.Server.SetTime(false, 0.0);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Eye of Cthulhu");
					break;
				case "golem":
					npc.SetDefaults(245);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Golem");
					break;
				case "king":
				case "king slime":
				case "ks":
					npc.SetDefaults(50);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the King Slime");
					break;
				case "plantera":
					npc.SetDefaults(262);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("Plantera");
					break;
				case "prime":
				case "skeletron prime":
					npc.SetDefaults(127);
					TSPlayer.Server.SetTime(false, 0.0);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("Skeletron Prime");
					break;
				case "queen bee":
				case "qb":
					npc.SetDefaults(222);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Queen Bee");
					break;
				case "skeletron":
					npc.SetDefaults(35);
					TSPlayer.Server.SetTime(false, 0.0);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("Skeletron");
					break;
				case "twins":
					TSPlayer.Server.SetTime(false, 0.0);
					npc.SetDefaults(125);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					npc.SetDefaults(126);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Twins");
					break;
				case "wof":
				case "wall of flesh":
					if (Main.wofNPCIndex != -1)
					{
						args.Player.SendErrorMessage(GetString("There is already a Wall of Flesh."));
						return;
					}
					if (args.Player.Y / 16f < Main.maxTilesY - 205)
					{
						args.Player.SendErrorMessage(GetString("You must spawn the Wall of Flesh in hell."));
						return;
					}
					NPC.SpawnWOF(new Vector2(args.Player.X, args.Player.Y));
					spawnName = GetString("the Wall of Flesh");
					break;
				case "moon":
				case "moon lord":
				case "ml":
					npc.SetDefaults(398);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Moon Lord");
					break;
				case "empress":
				case "empress of light":
				case "eol":
					npc.SetDefaults(636);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Empress of Light");
					break;
				case "queen slime":
				case "qs":
					npc.SetDefaults(657);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Queen Slime");
					break;
				case "lunatic":
				case "lunatic cultist":
				case "cultist":
				case "lc":
					npc.SetDefaults(439);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Lunatic Cultist");
					break;
				case "betsy":
					npc.SetDefaults(551);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("Betsy");
					break;
				case "flying dutchman":
				case "flying":
				case "dutchman":
					npc.SetDefaults(491);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Flying Dutchman");
					break;
				case "mourning wood":
					npc.SetDefaults(325);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("Mourning Wood");
					break;
				case "pumpking":
					npc.SetDefaults(327);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Pumpking");
					break;
				case "everscream":
					npc.SetDefaults(344);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("Everscream");
					break;
				case "santa-nk1":
				case "santa":
					npc.SetDefaults(346);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("Santa-NK1");
					break;
				case "ice queen":
					npc.SetDefaults(345);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("the Ice Queen");
					break;
				case "martian saucer":
					npc.SetDefaults(392);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("a Martian Saucer");
					break;
				case "solar pillar":
					npc.SetDefaults(517);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("a Solar Pillar");
					break;
				case "nebula pillar":
					npc.SetDefaults(507);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("a Nebula Pillar");
					break;
				case "vortex pillar":
					npc.SetDefaults(422);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("a Vortex Pillar");
					break;
				case "stardust pillar":
					npc.SetDefaults(493);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("a Stardust Pillar");
					break;
				case "deerclops":
					npc.SetDefaults(668);
					TSPlayer.Server.SpawnNPC(npc.type, npc.FullName, amount, args.Player.TileX, args.Player.TileY);
					spawnName = GetString("a Deerclops");
					break;
				default:
					args.Player.SendErrorMessage(GetString("Invalid boss type!"));
					return;
			}

			if (args.Silent)
			{
				args.Player.SendSuccessMessage(GetPluralString("You spawned {0} {1} time.", "You spawned {0} {1} times.", amount, spawnName, amount));
			}
			else
			{
				TSPlayer.All.SendSuccessMessage(GetPluralString("{0} spawned {1} {2} time.", "{0} spawned {1} {2} times.", amount, args.Player.Name, spawnName, amount));
			}
		}

		private static void SpawnMob(CommandArgs args)
		{
			if (args.Parameters.Count < 1 || args.Parameters.Count > 2)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}spawnmob <mob type> [amount].", Specifier));
				return;
			}
			if (args.Parameters[0].Length == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid mob type."));
				return;
			}

			int amount = 1;
			if (args.Parameters.Count == 2 && !int.TryParse(args.Parameters[1], out amount))
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}spawnmob <mob type> [amount].", Specifier));
				return;
			}

			amount = Math.Min(amount, Main.maxNPCs);

			var npcs = TShock.Utils.GetNPCByIdOrName(args.Parameters[0]);
			if (npcs.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid mob type!"));
			}
			else if (npcs.Count > 1)
			{
				args.Player.SendMultipleMatchError(npcs.Select(n => $"{n.FullName}({n.type})"));
			}
			else
			{
				var npc = npcs[0];
				if (npc.type >= 1 && npc.type < Terraria.ID.NPCID.Count && npc.type != 113)
				{
					TSPlayer.Server.SpawnNPC(npc.netID, npc.FullName, amount, args.Player.TileX, args.Player.TileY, 50, 20);
					if (args.Silent)
					{
						args.Player.SendSuccessMessage(GetPluralString("Spawned {0} {1} time.", "Spawned {0} {1} times.", amount, npc.FullName, amount));
					}
					else
					{
						TSPlayer.All.SendSuccessMessage(GetPluralString("{0} has spawned {1} {2} time.", "{0} has spawned {1} {2} times.", amount, args.Player.Name, npc.FullName, amount));
					}
				}
				else if (npc.type == 113)
				{
					if (Main.wofNPCIndex != -1 || (args.Player.Y / 16f < (Main.maxTilesY - 205)))
					{
						args.Player.SendErrorMessage(GetString("Unable to spawn a Wall of Flesh based on its current state or your current location."));
						return;
					}
					NPC.SpawnWOF(new Vector2(args.Player.X, args.Player.Y));
					if (args.Silent)
					{
						args.Player.SendSuccessMessage(GetString("Spawned a Wall of Flesh."));
					}
					else
					{
						TSPlayer.All.SendSuccessMessage(GetString("{0} has spawned a Wall of Flesh.", args.Player.Name));
					}
				}
				else
				{
					args.Player.SendErrorMessage(GetString("Invalid mob type."));
				}
			}
		}

		#endregion Cause Events and Spawn Monsters Commands

		#region Teleport Commands

		private static void Home(CommandArgs args)
		{
			if (args.Player.Dead)
			{
				args.Player.SendErrorMessage(GetString("You are dead. Dead players can't go home."));
				return;
			}
			args.Player.Spawn(PlayerSpawnContext.RecallFromItem);
			args.Player.SendSuccessMessage(GetString("Teleported to your spawn point (home)."));
		}

		private static void Spawn(CommandArgs args)
		{
			if (args.Player.Teleport(Main.spawnTileX * 16, (Main.spawnTileY * 16) - 48))
				args.Player.SendSuccessMessage(GetString("Teleported to the map's spawn point."));
		}

		private static void TP(CommandArgs args)
		{
			if (args.Parameters.Count != 1 && args.Parameters.Count != 2)
			{
				if (args.Player.HasPermission(Permissions.tpothers))
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tp <player> [player 2].", Specifier));
				else
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tp <player>.", Specifier));
				return;
			}

			if (args.Parameters.Count == 1)
			{
				var players = TSPlayer.FindByNameOrID(args.Parameters[0]);
				if (players.Count == 0)
					args.Player.SendErrorMessage(GetString("Invalid destination player."));
				else if (players.Count > 1)
					args.Player.SendMultipleMatchError(players.Select(p => p.Name));
				else
				{
					var target = players[0];
					if (!target.TPAllow && !args.Player.HasPermission(Permissions.tpoverride))
					{
						args.Player.SendErrorMessage(GetString("{0} has disabled incoming teleports.", target.Name));
						return;
					}
					if (args.Player.Teleport(target.TPlayer.position.X, target.TPlayer.position.Y))
					{
						args.Player.SendSuccessMessage(GetString("Teleported to {0}.", target.Name));
						if (!args.Player.HasPermission(Permissions.tpsilent))
							target.SendInfoMessage(GetString("{0} teleported to you.", args.Player.Name));
					}
				}
			}
			else
			{
				if (!args.Player.HasPermission(Permissions.tpothers))
				{
					args.Player.SendErrorMessage(GetString("You do not have permission to teleport other players."));
					return;
				}

				var players1 = TSPlayer.FindByNameOrID(args.Parameters[0]);
				var players2 = TSPlayer.FindByNameOrID(args.Parameters[1]);

				if (players2.Count == 0)
					args.Player.SendErrorMessage(GetString("Invalid destination player."));
				else if (players2.Count > 1)
					args.Player.SendMultipleMatchError(players2.Select(p => p.Name));
				else if (players1.Count == 0)
				{
					if (args.Parameters[0] == "*")
					{
						if (!args.Player.HasPermission(Permissions.tpallothers))
						{
							args.Player.SendErrorMessage(GetString("You do not have permission to teleport all players."));
							return;
						}

						var target = players2[0];
						foreach (var source in TShock.Players.Where(p => p != null && p != args.Player))
						{
							if (!target.TPAllow && !args.Player.HasPermission(Permissions.tpoverride))
								continue;
							if (source.Teleport(target.TPlayer.position.X, target.TPlayer.position.Y))
							{
								if (args.Player != source)
								{
									if (args.Player.HasPermission(Permissions.tpsilent))
										source.SendSuccessMessage(GetString("You were teleported to {0}.", target.Name));
									else
										source.SendSuccessMessage(GetString("{0} teleported you to {1}.", args.Player.Name, target.Name));
								}
								if (args.Player != target)
								{
									if (args.Player.HasPermission(Permissions.tpsilent))
										target.SendInfoMessage(GetString("{0} was teleported to you.", source.Name));
									if (!args.Player.HasPermission(Permissions.tpsilent))
										target.SendInfoMessage(GetString("{0} teleported {1} to you.", args.Player.Name, source.Name));
								}
							}
						}
						args.Player.SendSuccessMessage(GetString("Teleported everyone to {0}.", target.Name));
					}
					else
						args.Player.SendErrorMessage(GetString("Invalid destination player."));
				}
				else if (players1.Count > 1)
					args.Player.SendMultipleMatchError(players1.Select(p => p.Name));
				else
				{
					var source = players1[0];
					if (!source.TPAllow && !args.Player.HasPermission(Permissions.tpoverride))
					{
						args.Player.SendErrorMessage(GetString("{0} has disabled incoming teleports.", source.Name));
						return;
					}
					var target = players2[0];
					if (!target.TPAllow && !args.Player.HasPermission(Permissions.tpoverride))
					{
						args.Player.SendErrorMessage(GetString("{0} has disabled incoming teleports.", target.Name));
						return;
					}
					args.Player.SendSuccessMessage(GetString("Teleported {0} to {1}.", source.Name, target.Name));
					if (source.Teleport(target.TPlayer.position.X, target.TPlayer.position.Y))
					{
						if (args.Player != source)
						{
							if (args.Player.HasPermission(Permissions.tpsilent))
								source.SendSuccessMessage(GetString("You were teleported to {0}.", target.Name));
							else
								source.SendSuccessMessage(GetString("{0} teleported you to {1}.", args.Player.Name, target.Name));
						}
						if (args.Player != target)
						{
							if (args.Player.HasPermission(Permissions.tpsilent))
								target.SendInfoMessage(GetString("{0} was teleported to you.", source.Name));
							if (!args.Player.HasPermission(Permissions.tpsilent))
								target.SendInfoMessage(GetString("{0} teleported {1} to you.", args.Player.Name, source.Name));
						}
					}
				}
			}
		}

		private static void TPHere(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				if (args.Player.HasPermission(Permissions.tpallothers))
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tphere <player|*>.", Specifier));
				else
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tphere <player>.", Specifier));
				return;
			}

			string playerName = String.Join(" ", args.Parameters);
			var players = TSPlayer.FindByNameOrID(playerName);
			if (players.Count == 0)
			{
				if (playerName == "*")
				{
					if (!args.Player.HasPermission(Permissions.tpallothers))
					{
						args.Player.SendErrorMessage(GetString("You do not have permission to teleport all other players."));
						return;
					}
					foreach (var player in TShock.Players)
					{
						if (player != null && player.Active && player.Index != args.Player.Index)
						{
							if (player.Teleport(args.TPlayer.position.X, args.TPlayer.position.Y))
								player.SendSuccessMessage(GetString("You were teleported to {0}.", args.Player.Name));
						}
					}
					args.Player.SendSuccessMessage(GetString("Teleported everyone to yourself."));
				}
				else
					args.Player.SendErrorMessage(GetString("Invalid destination player."));
			}
			else if (players.Count > 1)
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			else
			{
				var plr = players[0];
				if (plr.Teleport(args.TPlayer.position.X, args.TPlayer.position.Y))
				{
					plr.SendInfoMessage(GetString("You were teleported to {0}.", args.Player.Name));
					args.Player.SendSuccessMessage(GetString("Teleported {0} to yourself.", plr.Name));
				}
			}
		}

		private static void TPNpc(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tpnpc <NPC>.", Specifier));
				return;
			}

			var npcStr = string.Join(" ", args.Parameters);
			var matches = new List<NPC>();
			foreach (var npc in Main.npc.Where(npc => npc.active))
			{
				var englishName = EnglishLanguage.GetNpcNameById(npc.netID);

				if (string.Equals(npc.FullName, npcStr, StringComparison.InvariantCultureIgnoreCase) ||
					string.Equals(englishName, npcStr, StringComparison.InvariantCultureIgnoreCase))
				{
					matches = new List<NPC> { npc };
					break;
				}
				if (npc.FullName.ToLowerInvariant().StartsWith(npcStr.ToLowerInvariant()) ||
					englishName?.StartsWith(npcStr, StringComparison.InvariantCultureIgnoreCase) == true)
					matches.Add(npc);
			}

			if (matches.Count > 1)
			{
				args.Player.SendMultipleMatchError(matches.Select(n => $"{n.FullName}({n.whoAmI})"));
				return;
			}
			if (matches.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid destination NPC."));
				return;
			}

			var target = matches[0];
			args.Player.Teleport(target.position.X, target.position.Y);
			args.Player.SendSuccessMessage(GetString("Teleported to the '{0}'.", target.FullName));
		}

		private static void GetPos(CommandArgs args)
		{
			var player = args.Player.Name;
			if (args.Parameters.Count > 0)
			{
				player = String.Join(" ", args.Parameters);
			}

			var players = TSPlayer.FindByNameOrID(player);
			if (players.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid target player."));
			}
			else if (players.Count > 1)
			{
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			}
			else
			{
				args.Player.SendSuccessMessage(GetString("Location of {0} is ({1}, {2}).", players[0].Name, players[0].TileX, players[0].TileY));
			}
		}

		private static void TPPos(CommandArgs args)
		{
			if (args.Parameters.Count != 2)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tppos <tile x> <tile y>.", Specifier));
				return;
			}

			int x, y;
			if (!int.TryParse(args.Parameters[0], out x) || !int.TryParse(args.Parameters[1], out y))
			{
				args.Player.SendErrorMessage(GetString("The destination coordinates provided don't look like valid numbers."));
				return;
			}
			x = Math.Max(0, x);
			y = Math.Max(0, y);
			x = Math.Min(x, Main.maxTilesX - 1);
			y = Math.Min(y, Main.maxTilesY - 1);

			args.Player.Teleport(16 * x, 16 * y);
			args.Player.SendSuccessMessage(GetString("Teleported to {0}, {1}.", x, y));
		}

		private static void TPAllow(CommandArgs args)
		{
			if (!args.Player.TPAllow)
				args.Player.SendSuccessMessage(GetString("Incoming teleports are now allowed."));
			if (args.Player.TPAllow)
				args.Player.SendSuccessMessage(GetString("Incoming teleports are now disabled."));
			args.Player.TPAllow = !args.Player.TPAllow;
		}

		private static void Warp(CommandArgs args)
		{
			bool hasManageWarpPermission = args.Player.HasPermission(Permissions.managewarp);
			if (args.Parameters.Count < 1)
			{
				if (hasManageWarpPermission)
				{
					args.Player.SendInfoMessage(GetString("Invalid syntax. Proper syntax: {0}warp [command] [arguments].", Specifier));
					args.Player.SendInfoMessage(GetString("Commands: add, del, hide, list, send, [warpname]."));
					args.Player.SendInfoMessage(GetString("Arguments: add [warp name], del [warp name], list [page]."));
					args.Player.SendInfoMessage(GetString("Arguments: send [player] [warp name], hide [warp name] [Enable(true/false)]."));
					args.Player.SendInfoMessage(GetString("Examples: {0}warp add foobar, {0}warp hide foobar true, {0}warp foobar.", Specifier));
					return;
				}
				else
				{
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}warp [name] or {0}warp list <page>.", Specifier));
					return;
				}
			}

			if (args.Parameters[0].Equals("list"))
			{
				#region List warps
				int pageNumber;
				if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
					return;
				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps
												where !warp.IsPrivate
												select warp.Name;
				PaginationTools.SendPage(args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(warpNames),
					new PaginationTools.Settings
					{
						HeaderFormat = GetString("Warps ({{0}}/{{1}}):"),
						FooterFormat = GetString("Type {0}warp list {{0}} for more.", Specifier),
						NothingToDisplayString = GetString("There are currently no warps defined.")
					});
				#endregion
			}
			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)
			{
				#region Add warp
				if (args.Parameters.Count == 2)
				{
					string warpName = args.Parameters[1];
					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")
					{
						args.Player.SendErrorMessage(GetString("Invalid warp name. The names 'list', 'hide', 'del' and 'add' are reserved for commands."));
					}
					else if (TShock.Warps.Add(args.Player.TileX, args.Player.TileY, warpName))
					{
						args.Player.SendSuccessMessage(GetString($"Warp added: {warpName}."));
					}
					else
					{
						args.Player.SendErrorMessage(GetString($"Warp {warpName} already exists."));
					}
				}
				else
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}warp add [name].", Specifier));
				#endregion
			}
			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)
			{
				#region Del warp
				if (args.Parameters.Count == 2)
				{
					string warpName = args.Parameters[1];
					if (TShock.Warps.Remove(warpName))
					{
						args.Player.SendSuccessMessage(GetString($"Warp deleted: {warpName}"));
					}
					else
						args.Player.SendErrorMessage(GetString($"Could not find a warp named {warpName} to remove."));
				}
				else
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}warp del [name].", Specifier));
				#endregion
			}
			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)
			{
				#region Hide warp
				if (args.Parameters.Count == 3)
				{
					string warpName = args.Parameters[1];
					bool state = false;
					if (Boolean.TryParse(args.Parameters[2], out state))
					{
						if (TShock.Warps.Hide(args.Parameters[1], state))
						{
							if (state)
								args.Player.SendSuccessMessage(GetString("Warp {0} is now private.", warpName));
							else
								args.Player.SendSuccessMessage(GetString("Warp {0} is now public.", warpName));
						}
						else
							args.Player.SendErrorMessage(GetString("Could not find specified warp."));
					}
					else
						args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}warp hide [name] <true/false>.", Specifier));
				}
				else
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}warp hide [name] <true/false>.", Specifier));
				#endregion
			}
			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))
			{
				#region Warp send
				if (args.Parameters.Count < 3)
				{
					args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}warp send [player] [warpname].", Specifier));
					return;
				}

				var foundplr = TSPlayer.FindByNameOrID(args.Parameters[1]);
				if (foundplr.Count == 0)
				{
					args.Player.SendErrorMessage(GetString("Invalid target player."));
					return;
				}
				else if (foundplr.Count > 1)
				{
					args.Player.SendMultipleMatchError(foundplr.Select(p => p.Name));
					return;
				}

				string warpName = args.Parameters[2];
				var warp = TShock.Warps.Find(warpName);
				var plr = foundplr[0];
				if (warp != null)
				{
					if (plr.Teleport(warp.Position.X * 16, warp.Position.Y * 16))
					{
						plr.SendSuccessMessage(GetString("{0} warped you to {1}.", args.Player.Name, warpName));
						args.Player.SendSuccessMessage(GetString("You warped {0} to {1}.", plr.Name, warpName));
					}
				}
				else
				{
					args.Player.SendErrorMessage(GetString($"The destination warp, {warpName}, was not found."));
				}
				#endregion
			}
			else
			{
				string warpName = String.Join(" ", args.Parameters);
				var warp = TShock.Warps.Find(warpName);
				if (warp != null)
				{
					if (args.Player.Teleport(warp.Position.X * 16, warp.Position.Y * 16))
						args.Player.SendSuccessMessage(GetString($"Warped to {warpName}."));
				}
				else
				{
					args.Player.SendErrorMessage(GetString($"The destination warp, {warpName}, was not found."));
				}
			}
		}

		#endregion Teleport Commands

		#region Group Management

		private static void Group(CommandArgs args)
		{
			string subCmd = args.Parameters.Count == 0 ? "help" : args.Parameters[0].ToLower();

			switch (subCmd)
			{
				case "add":
					#region Add group
					{
						if (args.Parameters.Count < 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group add <group name> [permissions].", Specifier));
							return;
						}

						string groupName = args.Parameters[1];
						args.Parameters.RemoveRange(0, 2);
						string permissions = String.Join(",", args.Parameters);

						try
						{
							TShock.Groups.AddGroup(groupName, null, permissions, TShockAPI.Group.defaultChatColor);
							args.Player.SendSuccessMessage(GetString($"Group {groupName} was added successfully."));
						}
						catch (GroupExistsException)
						{
							args.Player.SendErrorMessage(GetString("A group with the same name already exists."));
						}
						catch (GroupManagerException ex)
						{
							args.Player.SendErrorMessage(ex.ToString());
						}
					}
					#endregion
					return;
				case "addperm":
					#region Add permissions
					{
						if (args.Parameters.Count < 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group addperm <group name> <permissions...>.", Specifier));
							return;
						}

						string groupName = args.Parameters[1];
						args.Parameters.RemoveRange(0, 2);
						if (groupName == "*")
						{
							foreach (Group g in TShock.Groups)
							{
								TShock.Groups.AddPermissions(g.Name, args.Parameters);
							}
							args.Player.SendSuccessMessage(GetString("The permissions have been added to all of the groups in the system."));
							return;
						}
						try
						{
							string response = TShock.Groups.AddPermissions(groupName, args.Parameters);
							if (response.Length > 0)
							{
								args.Player.SendSuccessMessage(response);
							}
							return;
						}
						catch (GroupManagerException ex)
						{
							args.Player.SendErrorMessage(ex.ToString());
						}
					}
					#endregion
					return;
				case "help":
					#region Help
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;

						var lines = new List<string>
						{
							GetString("add <name> <permissions...> - Adds a new group."),
							GetString("addperm <group> <permissions...> - Adds permissions to a group."),
							GetString("color <group> <rrr,ggg,bbb> - Changes a group's chat color."),
							GetString("rename <group> <new name> - Changes a group's name."),
							GetString("del <group> - Deletes a group."),
							GetString("delperm <group> <permissions...> - Removes permissions from a group."),
							GetString("list [page] - Lists groups."),
							GetString("listperm <group> [page] - Lists a group's permissions."),
							GetString("parent <group> <parent group> - Changes a group's parent group."),
							GetString("prefix <group> <prefix> - Changes a group's prefix."),
							GetString("suffix <group> <suffix> - Changes a group's suffix.")
						};

						PaginationTools.SendPage(args.Player, pageNumber, lines,
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Group Sub-Commands ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}group help {{0}} for more sub-commands.", Specifier)
							}
						);
					}
					#endregion
					return;
				case "parent":
					#region Parent
					{
						if (args.Parameters.Count < 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group parent <group name> [new parent group name].", Specifier));
							return;
						}

						string groupName = args.Parameters[1];
						Group group = TShock.Groups.GetGroupByName(groupName);
						if (group == null)
						{
							args.Player.SendErrorMessage(GetString("No such group \"{0}\".", groupName));
							return;
						}

						if (args.Parameters.Count > 2)
						{
							string newParentGroupName = string.Join(" ", args.Parameters.Skip(2));
							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))
							{
								args.Player.SendErrorMessage(GetString("No such group \"{0}\".", newParentGroupName));
								return;
							}

							try
							{
								TShock.Groups.UpdateGroup(groupName, newParentGroupName, group.Permissions, group.ChatColor, group.Suffix, group.Prefix);

								if (!string.IsNullOrWhiteSpace(newParentGroupName))
									args.Player.SendSuccessMessage(GetString("Parent of group \"{0}\" set to \"{1}\".", groupName, newParentGroupName));
								else
									args.Player.SendSuccessMessage(GetString("Removed parent of group \"{0}\".", groupName));
							}
							catch (GroupManagerException ex)
							{
								args.Player.SendErrorMessage(ex.Message);
							}
						}
						else
						{
							if (group.Parent != null)
								args.Player.SendSuccessMessage(GetString("Parent of \"{0}\" is \"{1}\".", group.Name, group.Parent.Name));
							else
								args.Player.SendSuccessMessage(GetString("Group \"{0}\" has no parent.", group.Name));
						}
					}
					#endregion
					return;
				case "suffix":
					#region Suffix
					{
						if (args.Parameters.Count < 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group suffix <group name> [new suffix].", Specifier));
							return;
						}

						string groupName = args.Parameters[1];
						Group group = TShock.Groups.GetGroupByName(groupName);
						if (group == null)
						{
							args.Player.SendErrorMessage(GetString("No such group \"{0}\".", groupName));
							return;
						}

						if (args.Parameters.Count > 2)
						{
							string newSuffix = string.Join(" ", args.Parameters.Skip(2));

							try
							{
								TShock.Groups.UpdateGroup(groupName, group.ParentName, group.Permissions, group.ChatColor, newSuffix, group.Prefix);

								if (!string.IsNullOrWhiteSpace(newSuffix))
									args.Player.SendSuccessMessage(GetString("Suffix of group \"{0}\" set to \"{1}\".", groupName, newSuffix));
								else
									args.Player.SendSuccessMessage(GetString("Removed suffix of group \"{0}\".", groupName));
							}
							catch (GroupManagerException ex)
							{
								args.Player.SendErrorMessage(ex.Message);
							}
						}
						else
						{
							if (!string.IsNullOrWhiteSpace(group.Suffix))
								args.Player.SendSuccessMessage(GetString("Suffix of \"{0}\" is \"{1}\".", group.Name, group.Suffix));
							else
								args.Player.SendSuccessMessage(GetString("Group \"{0}\" has no suffix.", group.Name));
						}
					}
					#endregion
					return;
				case "prefix":
					#region Prefix
					{
						if (args.Parameters.Count < 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group prefix <group name> [new prefix].", Specifier));
							return;
						}

						string groupName = args.Parameters[1];
						Group group = TShock.Groups.GetGroupByName(groupName);
						if (group == null)
						{
							args.Player.SendErrorMessage(GetString("No such group \"{0}\".", groupName));
							return;
						}

						if (args.Parameters.Count > 2)
						{
							string newPrefix = string.Join(" ", args.Parameters.Skip(2));

							try
							{
								TShock.Groups.UpdateGroup(groupName, group.ParentName, group.Permissions, group.ChatColor, group.Suffix, newPrefix);

								if (!string.IsNullOrWhiteSpace(newPrefix))
									args.Player.SendSuccessMessage(GetString("Prefix of group \"{0}\" set to \"{1}\".", groupName, newPrefix));
								else
									args.Player.SendSuccessMessage(GetString("Removed prefix of group \"{0}\".", groupName));
							}
							catch (GroupManagerException ex)
							{
								args.Player.SendErrorMessage(ex.Message);
							}
						}
						else
						{
							if (!string.IsNullOrWhiteSpace(group.Prefix))
								args.Player.SendSuccessMessage(GetString("Prefix of \"{0}\" is \"{1}\".", group.Name, group.Prefix));
							else
								args.Player.SendSuccessMessage(GetString("Group \"{0}\" has no prefix.", group.Name));
						}
					}
					#endregion
					return;
				case "color":
					#region Color
					{
						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group color <group name> [new color(000,000,000)].", Specifier));
							return;
						}

						string groupName = args.Parameters[1];
						Group group = TShock.Groups.GetGroupByName(groupName);
						if (group == null)
						{
							args.Player.SendErrorMessage(GetString("No such group \"{0}\".", groupName));
							return;
						}

						if (args.Parameters.Count == 3)
						{
							string newColor = args.Parameters[2];

							String[] parts = newColor.Split(',');
							byte r;
							byte g;
							byte b;
							if (parts.Length == 3 && byte.TryParse(parts[0], out r) && byte.TryParse(parts[1], out g) && byte.TryParse(parts[2], out b))
							{
								try
								{
									TShock.Groups.UpdateGroup(groupName, group.ParentName, group.Permissions, newColor, group.Suffix, group.Prefix);

									args.Player.SendSuccessMessage(GetString("Chat color for group \"{0}\" set to \"{1}\".", groupName, newColor));
								}
								catch (GroupManagerException ex)
								{
									args.Player.SendErrorMessage(ex.Message);
								}
							}
							else
							{
								args.Player.SendErrorMessage(GetString("Invalid syntax for color, expected \"rrr,ggg,bbb\"."));
							}
						}
						else
						{
							args.Player.SendSuccessMessage(GetString("Chat color for \"{0}\" is \"{1}\".", group.Name, group.ChatColor));
						}
					}
					#endregion
					return;
				case "rename":
					#region Rename group
					{
						if (args.Parameters.Count != 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group rename <group> <new name>.", Specifier));
							return;
						}

						string group = args.Parameters[1];
						string newName = args.Parameters[2];
						try
						{
							string response = TShock.Groups.RenameGroup(group, newName);
							args.Player.SendSuccessMessage(response);
						}
						catch (GroupManagerException ex)
						{
							args.Player.SendErrorMessage(ex.Message);
						}
					}
					#endregion
					return;
				case "del":
					#region Delete group
					{
						if (args.Parameters.Count != 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group del <group name>.", Specifier));
							return;
						}

						try
						{
							string response = TShock.Groups.DeleteGroup(args.Parameters[1], true);
							if (response.Length > 0)
							{
								args.Player.SendSuccessMessage(response);
							}
						}
						catch (GroupManagerException ex)
						{
							args.Player.SendErrorMessage(ex.Message);
						}
					}
					#endregion
					return;
				case "delperm":
					#region Delete permissions
					{
						if (args.Parameters.Count < 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group delperm <group name> <permissions...>.", Specifier));
							return;
						}

						string groupName = args.Parameters[1];
						args.Parameters.RemoveRange(0, 2);
						if (groupName == "*")
						{
							foreach (Group g in TShock.Groups)
							{
								TShock.Groups.DeletePermissions(g.Name, args.Parameters);
							}
							args.Player.SendSuccessMessage(GetString("The permissions have been removed from all of the groups in the system."));
							return;
						}
						try
						{
							string response = TShock.Groups.DeletePermissions(groupName, args.Parameters);
							if (response.Length > 0)
							{
								args.Player.SendSuccessMessage(response);
							}
							return;
						}
						catch (GroupManagerException ex)
						{
							args.Player.SendErrorMessage(ex.Message);
						}
					}
					#endregion
					return;
				case "list":
					#region List groups
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;
						var groupNames = from grp in TShock.Groups.groups
										 select grp.Name;
						PaginationTools.SendPage(args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(groupNames),
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Groups ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}group list {{0}} for more.", Specifier)
							});
					}
					#endregion
					return;
				case "listperm":
					#region List permissions
					{
						if (args.Parameters.Count == 1)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}group listperm <group name> [page].", Specifier));
							return;
						}
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 2, args.Player, out pageNumber))
							return;

						if (!TShock.Groups.GroupExists(args.Parameters[1]))
						{
							args.Player.SendErrorMessage(GetString("Invalid group."));
							return;
						}
						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);
						List<string> permissions = grp.TotalPermissions;

						PaginationTools.SendPage(args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(permissions),
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Permissions for {0} ({{0}}/{{1}}):", grp.Name),
								FooterFormat = GetString("Type {0}group listperm {1} {{0}} for more.", Specifier, grp.Name),
								NothingToDisplayString = GetString($"There are currently no permissions for {grp.Name}.")
							});
					}
					#endregion
					return;
				default:
					args.Player.SendErrorMessage(GetString("Invalid subcommand! Type {0}group help for more information on valid commands.", Specifier));
					return;
			}
		}
		#endregion Group Management

		#region Item Management

		private static void ItemBan(CommandArgs args)
		{
			string subCmd = args.Parameters.Count == 0 ? "help" : args.Parameters[0].ToLower();
			switch (subCmd)
			{
				case "add":
					#region Add item
					{
						if (args.Parameters.Count != 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}itemban add <item name>.", Specifier));
							return;
						}

						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);
						if (items.Count == 0)
						{
							args.Player.SendErrorMessage(GetString("Invalid item."));
						}
						else if (items.Count > 1)
						{
							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));
						}
						else
						{
							// Yes this is required because of localization
							// User may have passed in localized name but itembans works on English names
							string englishNameForStorage = EnglishLanguage.GetItemNameById(items[0].type);
							TShock.ItemBans.DataModel.AddNewBan(englishNameForStorage);

							// It was decided in Telegram that we would continue to ban
							// projectiles based on whether or not their associated item was
							// banned. However, it was also decided that we'd change the way
							// this worked: in particular, we'd make it so that the item ban
							// system just adds things to the projectile ban system at the
							// command layer instead of inferring the state of projectile
							// bans based on the state of the item ban system.

							if (items[0].type == ItemID.DirtRod)
							{
								TShock.ProjectileBans.AddNewBan(ProjectileID.DirtBall);
							}

							if (items[0].type == ItemID.Sandgun)
							{
								TShock.ProjectileBans.AddNewBan(ProjectileID.SandBallGun);
								TShock.ProjectileBans.AddNewBan(ProjectileID.EbonsandBallGun);
								TShock.ProjectileBans.AddNewBan(ProjectileID.PearlSandBallGun);
							}

							// This returns the localized name to the player, not the item as it was stored.
							args.Player.SendSuccessMessage(GetString($"Banned {items[0].Name}."));
						}
					}
					#endregion
					return;
				case "allow":
					#region Allow group to item
					{
						if (args.Parameters.Count != 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}itemban allow <item name> <group name>.", Specifier));
							return;
						}

						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);
						if (items.Count == 0)
						{
							args.Player.SendErrorMessage(GetString("Invalid item."));
						}
						else if (items.Count > 1)
						{
							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));
						}
						else
						{
							if (!TShock.Groups.GroupExists(args.Parameters[2]))
							{
								args.Player.SendErrorMessage(GetString("Invalid group."));
								return;
							}

							ItemBan ban = TShock.ItemBans.DataModel.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));
							if (ban == null)
							{
								args.Player.SendErrorMessage(GetString("{0} is not banned.", items[0].Name));
								return;
							}
							if (!ban.AllowedGroups.Contains(args.Parameters[2]))
							{
								TShock.ItemBans.DataModel.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type), args.Parameters[2]);
								args.Player.SendSuccessMessage(GetString("{0} has been allowed to use {1}.", args.Parameters[2], items[0].Name));
							}
							else
							{
								args.Player.SendWarningMessage(GetString("{0} is already allowed to use {1}.", args.Parameters[2], items[0].Name));
							}
						}
					}
					#endregion
					return;
				case "del":
					#region Delete item
					{
						if (args.Parameters.Count != 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}itemban del <item name>.", Specifier));
							return;
						}

						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);
						if (items.Count == 0)
						{
							args.Player.SendErrorMessage(GetString("Invalid item."));
						}
						else if (items.Count > 1)
						{
							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));
						}
						else
						{
							TShock.ItemBans.DataModel.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));
							args.Player.SendSuccessMessage(GetString($"Unbanned {items[0].Name}."));
						}
					}
					#endregion
					return;
				case "disallow":
					#region Disllow group from item
					{
						if (args.Parameters.Count != 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}itemban disallow <item name> <group name>.", Specifier));
							return;
						}

						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);
						if (items.Count == 0)
						{
							args.Player.SendErrorMessage(GetString("Invalid item."));
						}
						else if (items.Count > 1)
						{
							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));
						}
						else
						{
							if (!TShock.Groups.GroupExists(args.Parameters[2]))
							{
								args.Player.SendErrorMessage(GetString("Invalid group."));
								return;
							}

							ItemBan ban = TShock.ItemBans.DataModel.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));
							if (ban == null)
							{
								args.Player.SendErrorMessage(GetString("{0} is not banned.", items[0].Name));
								return;
							}
							if (ban.AllowedGroups.Contains(args.Parameters[2]))
							{
								TShock.ItemBans.DataModel.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type), args.Parameters[2]);
								args.Player.SendSuccessMessage(GetString("{0} has been disallowed to use {1}.", args.Parameters[2], items[0].Name));
							}
							else
							{
								args.Player.SendWarningMessage(GetString("{0} is already disallowed to use {1}.", args.Parameters[2], items[0].Name));
							}
						}
					}
					#endregion
					return;
				case "help":
					#region Help
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;

						var lines = new List<string>
						{
							GetString("add <item> - Adds an item ban."),
							GetString("allow <item> <group> - Allows a group to use an item."),
							GetString("del <item> - Deletes an item ban."),
							GetString("disallow <item> <group> - Disallows a group from using an item."),
							GetString("list [page] - Lists all item bans.")
						};

						PaginationTools.SendPage(args.Player, pageNumber, lines,
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Item Ban Sub-Commands ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}itemban help {{0}} for more sub-commands.", Specifier)
							}
						);
					}
					#endregion
					return;
				case "list":
					#region List items
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;
						IEnumerable<string> itemNames = from itemBan in TShock.ItemBans.DataModel.ItemBans
														select itemBan.Name;
						PaginationTools.SendPage(args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(itemNames),
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Item bans ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}itemban list {{0}} for more.", Specifier),
								NothingToDisplayString = GetString("There are currently no banned items.")
							});
					}
					#endregion
					return;
				default:
					#region Default
					{
						args.Player.SendErrorMessage(GetString("Invalid subcommand. Type {0}itemban help for more information on valid subcommands.", Specifier));
					}
					#endregion
					return;

			}
		}
		#endregion Item Management

		#region Projectile Management

		private static void ProjectileBan(CommandArgs args)
		{
			string subCmd = args.Parameters.Count == 0 ? "help" : args.Parameters[0].ToLower();
			switch (subCmd)
			{
				case "add":
					#region Add projectile
					{
						if (args.Parameters.Count != 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}projban add <proj id>", Specifier));
							return;
						}
						short id;
						if (Int16.TryParse(args.Parameters[1], out id) && id > 0 && id < Terraria.ID.ProjectileID.Count)
						{
							TShock.ProjectileBans.AddNewBan(id);
							args.Player.SendSuccessMessage(GetString("Banned projectile {0}.", id));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid projectile ID!"));
					}
					#endregion
					return;
				case "allow":
					#region Allow group to projectile
					{
						if (args.Parameters.Count != 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}projban allow <id> <group>.", Specifier));
							return;
						}

						short id;
						if (Int16.TryParse(args.Parameters[1], out id) && id > 0 && id < Terraria.ID.ProjectileID.Count)
						{
							if (!TShock.Groups.GroupExists(args.Parameters[2]))
							{
								args.Player.SendErrorMessage(GetString("Invalid group."));
								return;
							}

							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);
							if (ban == null)
							{
								args.Player.SendErrorMessage(GetString("Projectile {0} is not banned.", id));
								return;
							}
							if (!ban.AllowedGroups.Contains(args.Parameters[2]))
							{
								TShock.ProjectileBans.AllowGroup(id, args.Parameters[2]);
								args.Player.SendSuccessMessage(GetString("{0} has been allowed to use projectile {1}.", args.Parameters[2], id));
							}
							else
								args.Player.SendWarningMessage(GetString("{0} is already allowed to use projectile {1}.", args.Parameters[2], id));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid projectile ID."));
					}
					#endregion
					return;
				case "del":
					#region Delete projectile
					{
						if (args.Parameters.Count != 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}projban del <id>.", Specifier));
							return;
						}

						short id;
						if (Int16.TryParse(args.Parameters[1], out id) && id > 0 && id < Terraria.ID.ProjectileID.Count)
						{
							TShock.ProjectileBans.RemoveBan(id);
							args.Player.SendSuccessMessage(GetString("Unbanned projectile {0}.", id));
							return;
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid projectile ID."));
					}
					#endregion
					return;
				case "disallow":
					#region Disallow group from projectile
					{
						if (args.Parameters.Count != 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}projban disallow <id> <group name>.", Specifier));
							return;
						}

						short id;
						if (Int16.TryParse(args.Parameters[1], out id) && id > 0 && id < Terraria.ID.ProjectileID.Count)
						{
							if (!TShock.Groups.GroupExists(args.Parameters[2]))
							{
								args.Player.SendErrorMessage(GetString("Invalid group."));
								return;
							}

							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);
							if (ban == null)
							{
								args.Player.SendErrorMessage(GetString("Projectile {0} is not banned.", id));
								return;
							}
							if (ban.AllowedGroups.Contains(args.Parameters[2]))
							{
								TShock.ProjectileBans.RemoveGroup(id, args.Parameters[2]);
								args.Player.SendSuccessMessage(GetString("{0} has been disallowed from using projectile {1}.", args.Parameters[2], id));
								return;
							}
							else
								args.Player.SendWarningMessage(GetString("{0} is already prevented from using projectile {1}.", args.Parameters[2], id));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid projectile ID."));
					}
					#endregion
					return;
				case "help":
					#region Help
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;

						var lines = new List<string>
						{
							GetString("add <projectile ID> - Adds a projectile ban."),
							GetString("allow <projectile ID> <group> - Allows a group to use a projectile."),
							GetString("del <projectile ID> - Deletes an projectile ban."),
							GetString("disallow <projectile ID> <group> - Disallows a group from using a projectile."),
							GetString("list [page] - Lists all projectile bans.")
						};

						PaginationTools.SendPage(args.Player, pageNumber, lines,
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Projectile Ban Sub-Commands ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}projban help {{0}} for more sub-commands.", Specifier)
							}
						);
					}
					#endregion
					return;
				case "list":
					#region List projectiles
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;
						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans
														   select projectileBan.ID;
						PaginationTools.SendPage(args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(projectileIds),
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Projectile bans ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}projban list {{0}} for more.", Specifier),
								NothingToDisplayString = GetString("There are currently no banned projectiles.")
							});
					}
					#endregion
					return;
				default:
					#region Default
					{
						args.Player.SendErrorMessage(GetString("Invalid subcommand. Type {0}projban help for more information on valid subcommands.", Specifier));
					}
					#endregion
					return;
			}
		}
		#endregion Projectile Management

		#region Tile Management
		private static void TileBan(CommandArgs args)
		{
			string subCmd = args.Parameters.Count == 0 ? "help" : args.Parameters[0].ToLower();
			switch (subCmd)
			{
				case "add":
					#region Add tile
					{
						if (args.Parameters.Count != 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tileban add <tile id>.", Specifier));
							return;
						}
						short id;
						if (Int16.TryParse(args.Parameters[1], out id) && id >= 0 && id < Terraria.ID.TileID.Count)
						{
							TShock.TileBans.AddNewBan(id);
							args.Player.SendSuccessMessage(GetString("Banned tile {0}.", id));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid tile ID."));
					}
					#endregion
					return;
				case "allow":
					#region Allow group to place tile
					{
						if (args.Parameters.Count != 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tileban allow <id> <group>.", Specifier));
							return;
						}

						short id;
						if (Int16.TryParse(args.Parameters[1], out id) && id >= 0 && id < Terraria.ID.TileID.Count)
						{
							if (!TShock.Groups.GroupExists(args.Parameters[2]))
							{
								args.Player.SendErrorMessage(GetString("Invalid group."));
								return;
							}

							TileBan ban = TShock.TileBans.GetBanById(id);
							if (ban == null)
							{
								args.Player.SendErrorMessage(GetString("Tile {0} is not banned.", id));
								return;
							}
							if (!ban.AllowedGroups.Contains(args.Parameters[2]))
							{
								TShock.TileBans.AllowGroup(id, args.Parameters[2]);
								args.Player.SendSuccessMessage(GetString("{0} has been allowed to place tile {1}.", args.Parameters[2], id));
							}
							else
								args.Player.SendWarningMessage(GetString("{0} is already allowed to place tile {1}.", args.Parameters[2], id));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid tile ID."));
					}
					#endregion
					return;
				case "del":
					#region Delete tile ban
					{
						if (args.Parameters.Count != 2)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tileban del <id>.", Specifier));
							return;
						}

						short id;
						if (Int16.TryParse(args.Parameters[1], out id) && id >= 0 && id < Terraria.ID.TileID.Count)
						{
							TShock.TileBans.RemoveBan(id);
							args.Player.SendSuccessMessage(GetString("Unbanned tile {0}.", id));
							return;
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid tile ID."));
					}
					#endregion
					return;
				case "disallow":
					#region Disallow group from placing tile
					{
						if (args.Parameters.Count != 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}tileban disallow <id> <group name>.", Specifier));
							return;
						}

						short id;
						if (Int16.TryParse(args.Parameters[1], out id) && id >= 0 && id < Terraria.ID.TileID.Count)
						{
							if (!TShock.Groups.GroupExists(args.Parameters[2]))
							{
								args.Player.SendErrorMessage(GetString("Invalid group."));
								return;
							}

							TileBan ban = TShock.TileBans.GetBanById(id);
							if (ban == null)
							{
								args.Player.SendErrorMessage(GetString("Tile {0} is not banned.", id));
								return;
							}
							if (ban.AllowedGroups.Contains(args.Parameters[2]))
							{
								TShock.TileBans.RemoveGroup(id, args.Parameters[2]);
								args.Player.SendSuccessMessage(GetString("{0} has been disallowed from placing tile {1}.", args.Parameters[2], id));
								return;
							}
							else
								args.Player.SendWarningMessage(GetString("{0} is already prevented from placing tile {1}.", args.Parameters[2], id));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid tile ID."));
					}
					#endregion
					return;
				case "help":
					#region Help
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;

						var lines = new List<string>
						{
							GetString("add <tile ID> - Adds a tile ban."),
							GetString("allow <tile ID> <group> - Allows a group to place a tile."),
							GetString("del <tile ID> - Deletes a tile ban."),
							GetString("disallow <tile ID> <group> - Disallows a group from place a tile."),
							GetString("list [page] - Lists all tile bans.")
						};

						PaginationTools.SendPage(args.Player, pageNumber, lines,
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Tile Ban Sub-Commands ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}tileban help {{0}} for more sub-commands.", Specifier)
							}
						);
					}
					#endregion
					return;
				case "list":
					#region List tile bans
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;
						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans
													 select tileBan.ID;
						PaginationTools.SendPage(args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(tileIds),
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Tile bans ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}tileban list {{0}} for more.", Specifier),
								NothingToDisplayString = GetString("There are currently no banned tiles.")
							});
					}
					#endregion
					return;
				default:
					#region Default
					{
						args.Player.SendErrorMessage(GetString("Invalid subcommand. Type {0}tileban help for more information on valid subcommands.", Specifier));
					}
					#endregion
					return;
			}
		}
		#endregion Tile Management

		#region Server Config Commands

		private static void SetSpawn(CommandArgs args)
		{
			Main.spawnTileX = args.Player.TileX + 1;
			Main.spawnTileY = args.Player.TileY + 3;
			SaveManager.Instance.SaveWorld(false);
			args.Player.SendSuccessMessage(GetString("Spawn has now been set at your location."));
		}

		private static void SetDungeon(CommandArgs args)
		{
			Main.dungeonX = args.Player.TileX + 1;
			Main.dungeonY = args.Player.TileY + 3;
			SaveManager.Instance.SaveWorld(false);
			args.Player.SendSuccessMessage(GetString("The dungeon's position has now been set at your location."));
		}

		private static void Reload(CommandArgs args)
		{
			TShock.Utils.Reload();
			Hooks.GeneralHooks.OnReloadEvent(args.Player);

			args.Player.SendSuccessMessage(
				GetString("Configuration, permissions, and regions reload complete. Some changes may require a server restart."));
		}

		private static void ServerPassword(CommandArgs args)
		{
			if (args.Parameters.Count != 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}serverpassword \"<new password>\".", Specifier));
				return;
			}
			string passwd = args.Parameters[0];
			TShock.Config.Settings.ServerPassword = passwd;
			args.Player.SendSuccessMessage(GetString("Server password has been changed to: {0}.", passwd));
		}

		private static void Save(CommandArgs args)
		{
			SaveManager.Instance.SaveWorld(false);
			foreach (TSPlayer tsply in TShock.Players.Where(tsply => tsply != null))
			{
				tsply.SaveServerCharacter();
			}
		}

		private static void Settle(CommandArgs args)
		{
			if (Liquid.panicMode)
			{
				args.Player.SendWarningMessage(GetString("Liquids are already settling."));
				return;
			}
			Liquid.StartPanic();
			args.Player.SendInfoMessage(GetString("Settling liquids."));
		}

		private static void MaxSpawns(CommandArgs args)
		{
			if (args.Parameters.Count == 0)
			{
				args.Player.SendInfoMessage(GetString("Current maximum spawns: {0}.", TShock.Config.Settings.DefaultMaximumSpawns));
				return;
			}

			if (String.Equals(args.Parameters[0], "default", StringComparison.CurrentCultureIgnoreCase))
			{
				TShock.Config.Settings.DefaultMaximumSpawns = NPC.defaultMaxSpawns = 5;
				if (args.Silent)
				{
					args.Player.SendInfoMessage(GetString("Changed the maximum spawns to 5."));
				}
				else
				{
					TSPlayer.All.SendInfoMessage(GetString("{0} changed the maximum spawns to 5.", args.Player.Name));
				}
				return;
			}

			int maxSpawns = -1;
			if (!int.TryParse(args.Parameters[0], out maxSpawns) || maxSpawns < 0 || maxSpawns > Main.maxNPCs)
			{
				args.Player.SendWarningMessage(GetString("Invalid maximum spawns.  Acceptable range is {0} to {1}.", 0, Main.maxNPCs));
				return;
			}

			TShock.Config.Settings.DefaultMaximumSpawns = NPC.defaultMaxSpawns = maxSpawns;
			if (args.Silent)
			{
				args.Player.SendInfoMessage(GetString("Changed the maximum spawns to {0}.", maxSpawns));
			}
			else
			{
				TSPlayer.All.SendInfoMessage(GetString("{0} changed the maximum spawns to {1}.", args.Player.Name, maxSpawns));
			}
		}

		private static void SpawnRate(CommandArgs args)
		{
			if (args.Parameters.Count == 0)
			{
				args.Player.SendInfoMessage(GetString("Current spawn rate: {0}.", TShock.Config.Settings.DefaultSpawnRate));
				return;
			}

			if (String.Equals(args.Parameters[0], "default", StringComparison.CurrentCultureIgnoreCase))
			{
				TShock.Config.Settings.DefaultSpawnRate = NPC.defaultSpawnRate = 600;
				if (args.Silent)
				{
					args.Player.SendInfoMessage(GetString("Changed the spawn rate to 600."));
				}
				else
				{
					TSPlayer.All.SendInfoMessage(GetString("{0} changed the spawn rate to 600.", args.Player.Name));
				}
				return;
			}

			int spawnRate = -1;
			if (!int.TryParse(args.Parameters[0], out spawnRate) || spawnRate < 0)
			{
				args.Player.SendWarningMessage(GetString("The spawn rate you provided is out-of-range or not a number."));
				return;
			}
			TShock.Config.Settings.DefaultSpawnRate = NPC.defaultSpawnRate = spawnRate;
			if (args.Silent)
			{
				args.Player.SendInfoMessage(GetString("Changed the spawn rate to {0}.", spawnRate));
			}
			else
			{
				TSPlayer.All.SendInfoMessage(GetString("{0} changed the spawn rate to {1}.", args.Player.Name, spawnRate));
			}
		}

		#endregion Server Config Commands

		#region Time/PvpFun Commands

		private static void Time(CommandArgs args)
		{
			if (args.Parameters.Count == 0)
			{
				double time = Main.time / 3600.0;
				time += 4.5;
				if (!Main.dayTime)
					time += 15.0;
				time = time % 24.0;
				args.Player.SendInfoMessage(GetString("The current time is {0}:{1:D2}.", (int)Math.Floor(time), (int)Math.Floor((time % 1.0) * 60.0)));
				return;
			}

			switch (args.Parameters[0].ToLower())
			{
				case "day":
					TSPlayer.Server.SetTime(true, 0.0);
					TSPlayer.All.SendInfoMessage(GetString("{0} set the time to 04:30.", args.Player.Name));
					break;
				case "night":
					TSPlayer.Server.SetTime(false, 0.0);
					TSPlayer.All.SendInfoMessage(GetString("{0} set the time to 19:30.", args.Player.Name));
					break;
				case "noon":
					TSPlayer.Server.SetTime(true, 27000.0);
					TSPlayer.All.SendInfoMessage(GetString("{0} set the time to 12:00.", args.Player.Name));
					break;
				case "midnight":
					TSPlayer.Server.SetTime(false, 16200.0);
					TSPlayer.All.SendInfoMessage(GetString("{0} set the time to 00:00.", args.Player.Name));
					break;
				default:
					string[] array = args.Parameters[0].Split(':');
					if (array.Length != 2)
					{
						args.Player.SendErrorMessage(GetString("Invalid time string. Proper format: hh:mm, in 24-hour time."));
						return;
					}

					int hours;
					int minutes;
					if (!int.TryParse(array[0], out hours) || hours < 0 || hours > 23
						|| !int.TryParse(array[1], out minutes) || minutes < 0 || minutes > 59)
					{
						args.Player.SendErrorMessage(GetString("Invalid time string. Proper format: hh:mm, in 24-hour time."));
						return;
					}

					decimal time = hours + (minutes / 60.0m);
					time -= 4.50m;
					if (time < 0.00m)
						time += 24.00m;

					if (time >= 15.00m)
					{
						TSPlayer.Server.SetTime(false, (double)((time - 15.00m) * 3600.0m));
					}
					else
					{
						TSPlayer.Server.SetTime(true, (double)(time * 3600.0m));
					}
					TSPlayer.All.SendInfoMessage(GetString("{0} set the time to {1}:{2:D2}.", args.Player.Name, hours, minutes));
					break;
			}
		}

		private static void Slap(CommandArgs args)
		{
			if (args.Parameters.Count < 1 || args.Parameters.Count > 2)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}slap <player> [damage].", Specifier));
				return;
			}

			if (args.Parameters[0].Length == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid target player."));
				return;
			}

			string plStr = args.Parameters[0];
			var players = TSPlayer.FindByNameOrID(plStr);
			if (players.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid target player."));
			}
			else if (players.Count > 1)
			{
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			}
			else
			{
				var plr = players[0];
				int damage = 5;
				if (args.Parameters.Count == 2)
				{
					int.TryParse(args.Parameters[1], out damage);
				}
				if (!args.Player.HasPermission(Permissions.kill))
				{
					damage = TShock.Utils.Clamp(damage, 15, 0);
				}
				plr.DamagePlayer(damage);
				TSPlayer.All.SendInfoMessage(GetString("{0} slapped {1} for {2} damage.", args.Player.Name, plr.Name, damage));
				TShock.Log.Info(GetString("{0} slapped {1} for {2} damage.", args.Player.Name, plr.Name, damage));
			}
		}

		private static void Wind(CommandArgs args)
		{
			if (args.Parameters.Count != 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}wind <speed in mph>.", Specifier));
				return;
			}

			float mph;
			if (!float.TryParse(args.Parameters[0], out mph) || mph is < -40f or > 40f)
			{
				args.Player.SendErrorMessage(GetString("Invalid wind speed (must be between -40 and 40)."));
				return;
			}

			float speed = mph / 50f; // -40 to 40 mph -> -0.8 to 0.8
			Main.windSpeedCurrent = speed;
			Main.windSpeedTarget = speed;
			TSPlayer.All.SendData(PacketTypes.WorldInfo);
			TSPlayer.All.SendInfoMessage(GetString("{0} changed the wind speed to {1}mph.", args.Player.Name, mph));
		}

		#endregion Time/PvpFun Commands

		#region Region Commands

		private static void Region(CommandArgs args)
		{
			string cmd = "help";
			if (args.Parameters.Count > 0)
			{
				cmd = args.Parameters[0].ToLower();
			}
			switch (cmd)
			{
				case "name":
					{
						{
							args.Player.SendInfoMessage(GetString("Hit a block to get the name of the region."));
							args.Player.AwaitingName = true;
							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();
						}
						break;
					}
				case "set":
					{
						int choice = 0;
						if (args.Parameters.Count == 2 &&
							int.TryParse(args.Parameters[1], out choice) &&
							choice >= 1 && choice <= 2)
						{
							args.Player.SendInfoMessage(GetString("Hit a block to set point {0}.", choice));
							args.Player.AwaitingTempPoint = choice;
						}
						else
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: /region set <1/2>."));
						}
						break;
					}
				case "define":
					{
						if (args.Parameters.Count > 1)
						{
							if (!args.Player.TempPoints.Any(p => p == Point.Zero))
							{
								string regionName = String.Join(" ", args.Parameters.GetRange(1, args.Parameters.Count - 1));
								var x = Math.Min(args.Player.TempPoints[0].X, args.Player.TempPoints[1].X);
								var y = Math.Min(args.Player.TempPoints[0].Y, args.Player.TempPoints[1].Y);
								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);
								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);

								if (TShock.Regions.AddRegion(x, y, width, height, regionName, args.Player.Account.Name,
															 Main.worldID.ToString()))
								{
									args.Player.TempPoints[0] = Point.Zero;
									args.Player.TempPoints[1] = Point.Zero;
									args.Player.SendInfoMessage(GetString("Set region {0}.", regionName));
								}
								else
								{
									args.Player.SendErrorMessage(GetString($"Region {regionName} already exists."));
								}
							}
							else
							{
								args.Player.SendErrorMessage(GetString("Region points need to be defined first. Use /region set 1 and /region set 2."));
							}
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region define <name>.", Specifier));
						break;
					}
				case "protect":
					{
						if (args.Parameters.Count == 3)
						{
							string regionName = args.Parameters[1];
							if (args.Parameters[2].ToLower() == "true")
							{
								if (TShock.Regions.SetRegionState(regionName, true))
									args.Player.SendInfoMessage(GetString("Marked region {0} as protected.", regionName));
								else
									args.Player.SendErrorMessage(GetString($"Could not find the region {regionName}."));
							}
							else if (args.Parameters[2].ToLower() == "false")
							{
								if (TShock.Regions.SetRegionState(regionName, false))
									args.Player.SendInfoMessage(GetString("Marked region {0} as unprotected.", regionName));
								else
									args.Player.SendErrorMessage(GetString($"Could not find the region {regionName}."));
							}
							else
								args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region protect <name> <true/false>.", Specifier));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: /region protect <name> <true/false>.", Specifier));
						break;
					}
				case "delete":
					{
						if (args.Parameters.Count > 1)
						{
							string regionName = String.Join(" ", args.Parameters.GetRange(1, args.Parameters.Count - 1));
							if (TShock.Regions.DeleteRegion(regionName))
							{
								args.Player.SendInfoMessage(GetString("Deleted region \"{0}\".", regionName));
							}
							else
								args.Player.SendErrorMessage(GetString($"Could not find the region {regionName}."));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region delete <name>.", Specifier));
						break;
					}
				case "clear":
					{
						args.Player.TempPoints[0] = Point.Zero;
						args.Player.TempPoints[1] = Point.Zero;
						args.Player.SendInfoMessage(GetString("Temporary region set points have been removed."));
						args.Player.AwaitingTempPoint = 0;
						break;
					}
				case "allow":
					{
						if (args.Parameters.Count > 2)
						{
							string playerName = args.Parameters[1];
							string regionName = "";

							for (int i = 2; i < args.Parameters.Count; i++)
							{
								if (regionName == "")
								{
									regionName = args.Parameters[2];
								}
								else
								{
									regionName = regionName + " " + args.Parameters[i];
								}
							}
							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)
							{
								if (TShock.Regions.AddNewUser(regionName, playerName))
								{
									args.Player.SendInfoMessage(GetString($"Added user {playerName} to {regionName}."));
								}
								else
									args.Player.SendErrorMessage(GetString($"Could not find the region {regionName}."));
							}
							else
							{
								args.Player.SendErrorMessage(GetString($"Player {playerName} not found."));
							}
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region allow <name> <region>.", Specifier));
						break;
					}
				case "remove":
					if (args.Parameters.Count > 2)
					{
						string playerName = args.Parameters[1];
						string regionName = "";

						for (int i = 2; i < args.Parameters.Count; i++)
						{
							if (regionName == "")
							{
								regionName = args.Parameters[2];
							}
							else
							{
								regionName = regionName + " " + args.Parameters[i];
							}
						}
						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)
						{
							if (TShock.Regions.RemoveUser(regionName, playerName))
							{
								args.Player.SendInfoMessage(GetString($"Removed user {playerName} from {regionName}."));
							}
							else
								args.Player.SendErrorMessage(GetString($"Could not find the region {regionName}."));
						}
						else
						{
							args.Player.SendErrorMessage(GetString($"Player {playerName} not found."));
						}
					}
					else
						args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region remove <name> <region>.", Specifier));
					break;
				case "allowg":
					{
						if (args.Parameters.Count > 2)
						{
							string group = args.Parameters[1];
							string regionName = "";

							for (int i = 2; i < args.Parameters.Count; i++)
							{
								if (regionName == "")
								{
									regionName = args.Parameters[2];
								}
								else
								{
									regionName = regionName + " " + args.Parameters[i];
								}
							}
							if (TShock.Groups.GroupExists(group))
							{
								if (TShock.Regions.AllowGroup(regionName, group))
								{
									args.Player.SendInfoMessage(GetString($"Added group {group} to {regionName}."));
								}
								else
									args.Player.SendErrorMessage(GetString($"Could not find the region {regionName}."));
							}
							else
							{
								args.Player.SendErrorMessage(GetString($"Group {group} not found."));
							}
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region allowg <group> <region>.", Specifier));
						break;
					}
				case "removeg":
					if (args.Parameters.Count > 2)
					{
						string group = args.Parameters[1];
						string regionName = "";

						for (int i = 2; i < args.Parameters.Count; i++)
						{
							if (regionName == "")
							{
								regionName = args.Parameters[2];
							}
							else
							{
								regionName = regionName + " " + args.Parameters[i];
							}
						}
						if (TShock.Groups.GroupExists(group))
						{
							if (TShock.Regions.RemoveGroup(regionName, group))
							{
								args.Player.SendInfoMessage(GetString("Removed group {0} from {1}", group, regionName));
							}
							else
								args.Player.SendErrorMessage(GetString($"Could not find the region {regionName}."));
						}
						else
						{
							args.Player.SendErrorMessage(GetString($"Group {group} not found."));
						}
					}
					else
						args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region removeg <group> <region>.", Specifier));
					break;
				case "list":
					{
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out pageNumber))
							return;

						IEnumerable<string> regionNames = from region in TShock.Regions.Regions
														  where region.WorldID == Main.worldID.ToString()
														  select region.Name;
						PaginationTools.SendPage(args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(regionNames),
							new PaginationTools.Settings
							{
								HeaderFormat = GetString("Regions ({{0}}/{{1}}):"),
								FooterFormat = GetString("Type {0}region list {{0}} for more.", Specifier),
								NothingToDisplayString = GetString("There are currently no regions defined.")
							});
						break;
					}
				case "info":
					{
						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region info <region> [-d] [page].", Specifier));
							break;
						}

						string regionName = args.Parameters[1];
						bool displayBoundaries = args.Parameters.Skip(2).Any(
							p => p.Equals("-d", StringComparison.InvariantCultureIgnoreCase)
						);

						Region region = TShock.Regions.GetRegionByName(regionName);
						if (region == null)
						{
							args.Player.SendErrorMessage(GetString($"Could not find the region {regionName}."));
							break;
						}

						int pageNumberIndex = displayBoundaries ? 3 : 2;
						int pageNumber;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, pageNumberIndex, args.Player, out pageNumber))
							break;

						List<string> lines = new List<string>
						{
							GetString("X: {0}; Y: {1}; W: {2}; H: {3}, Z: {4}", region.Area.X, region.Area.Y, region.Area.Width, region.Area.Height, region.Z),
							GetString($"Region owner: {region.Owner}."),
							GetString($"Protected: {region.DisableBuild.ToString()}."),
						};

						if (region.AllowedIDs.Count > 0)
						{
							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>
							{
								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);
								if (account != null)
									return account.Name;

								return string.Concat("{ID: ", userId, "}");
							});
							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());
							extraLines[0] = GetString("Shared with: ") + extraLines[0];
							lines.AddRange(extraLines);
						}
						else
						{
							lines.Add(GetString("Region is not shared with any users."));
						}

						if (region.AllowedGroups.Count > 0)
						{
							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());
							extraLines[0] = GetString("Shared with groups: ") + extraLines[0];
							lines.AddRange(extraLines);
						}
						else
						{
							lines.Add(GetString("Region is not shared with any groups."));
						}

						PaginationTools.SendPage(
							args.Player, pageNumber, lines, new PaginationTools.Settings
							{
								HeaderFormat = GetString("Information About Region \"{0}\" ({{0}}/{{1}}):", region.Name),
								FooterFormat = GetString("Type {0}region info {1} {{0}} for more information.", Specifier, regionName)
							}
						);

						if (displayBoundaries)
						{
							Rectangle regionArea = region.Area;
							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))
							{
								// Preferring dotted lines as those should easily be distinguishable from actual wires.
								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)
								{
									// Could be improved by sending raw tile data to the client instead but not really
									// worth the effort as chances are very low that overwriting the wire for a few
									// nanoseconds will cause much trouble.
									ITile tile = Main.tile[boundaryPoint.X, boundaryPoint.Y];
									bool oldWireState = tile.wire();
									tile.wire(true);

									try
									{
										args.Player.SendTileSquareCentered(boundaryPoint.X, boundaryPoint.Y, 1);
									}
									finally
									{
										tile.wire(oldWireState);
									}
								}
							}

							Timer boundaryHideTimer = null;
							boundaryHideTimer = new Timer((state) =>
							{
								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))
									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)
										args.Player.SendTileSquareCentered(boundaryPoint.X, boundaryPoint.Y, 1);

								Debug.Assert(boundaryHideTimer != null);
								boundaryHideTimer.Dispose();
							},
								null, 5000, Timeout.Infinite
							);
						}

						break;
					}
				case "z":
					{
						if (args.Parameters.Count == 3)
						{
							string regionName = args.Parameters[1];
							int z = 0;
							if (int.TryParse(args.Parameters[2], out z))
							{
								if (TShock.Regions.SetZ(regionName, z))
									args.Player.SendInfoMessage(GetString("Region's z is now {0}", z));
								else
									args.Player.SendErrorMessage(GetString("Could not find specified region"));
							}
							else
								args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region z <name> <#>", Specifier));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region z <name> <#>", Specifier));
						break;
					}
				case "resize":
				case "expand":
					{
						if (args.Parameters.Count == 4)
						{
							int direction;
							switch (args.Parameters[2])
							{
								case "u":
								case "up":
									{
										direction = 0;
										break;
									}
								case "r":
								case "right":
									{
										direction = 1;
										break;
									}
								case "d":
								case "down":
									{
										direction = 2;
										break;
									}
								case "l":
								case "left":
									{
										direction = 3;
										break;
									}
								default:
									{
										direction = -1;
										break;
									}
							}
							int addAmount;
							int.TryParse(args.Parameters[3], out addAmount);
							if (TShock.Regions.ResizeRegion(args.Parameters[1], addAmount, direction))
							{
								args.Player.SendInfoMessage(GetString("Region Resized Successfully!"));
								TShock.Regions.Reload();
							}
							else
								args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region resize <region> <u/d/l/r> <amount>", Specifier));
						}
						else
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region resize <region> <u/d/l/r> <amount>", Specifier));
						break;
					}
				case "rename":
					{
						if (args.Parameters.Count != 3)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region rename <region> <new name>", Specifier));
							break;
						}
						else
						{
							string oldName = args.Parameters[1];
							string newName = args.Parameters[2];

							if (oldName == newName)
							{
								args.Player.SendErrorMessage(GetString("Error: both names are the same."));
								break;
							}

							Region oldRegion = TShock.Regions.GetRegionByName(oldName);

							if (oldRegion == null)
							{
								args.Player.SendErrorMessage(GetString("Invalid region \"{0}\".", oldName));
								break;
							}

							Region newRegion = TShock.Regions.GetRegionByName(newName);

							if (newRegion != null)
							{
								args.Player.SendErrorMessage(GetString("Region \"{0}\" already exists.", newName));
								break;
							}

							if (TShock.Regions.RenameRegion(oldName, newName))
							{
								args.Player.SendInfoMessage(GetString("Region renamed successfully!"));
							}
							else
							{
								args.Player.SendErrorMessage(GetString("Failed to rename the region."));
							}
						}
						break;
					}
				case "tp":
					{
						if (!args.Player.HasPermission(Permissions.tp))
						{
							args.Player.SendErrorMessage(GetString("You do not have permission to teleport."));
							break;
						}
						if (args.Parameters.Count <= 1)
						{
							args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}region tp <region>.", Specifier));
							break;
						}

						string regionName = string.Join(" ", args.Parameters.Skip(1));
						Region region = TShock.Regions.GetRegionByName(regionName);
						if (region == null)
						{
							args.Player.SendErrorMessage(GetString("Region \"{0}\" does not exist.", regionName));
							break;
						}

						args.Player.Teleport(region.Area.Center.X * 16, region.Area.Center.Y * 16);
						break;
					}
				case "help":
				default:
					{
						int pageNumber;
						int pageParamIndex = 0;
						if (args.Parameters.Count > 1)
							pageParamIndex = 1;
						if (!PaginationTools.TryParsePageNumber(args.Parameters, pageParamIndex, args.Player, out pageNumber))
							return;

						List<string> lines = new List<string> {
						  GetString("set <1/2> - Sets the temporary region points."),
						  GetString("clear - Clears the temporary region points."),
						  GetString("define <name> - Defines the region with the given name."),
						  GetString("delete <name> - Deletes the given region."),
						  GetString("name [-u][-z][-p] - Shows the name of the region at the given point."),
						  GetString("rename <region> <new name> - Renames the given region."),
						  GetString("list - Lists all regions."),
						  GetString("resize <region> <u/d/l/r> <amount> - Resizes a region."),
						  GetString("allow <user> <region> - Allows a user to a region."),
						  GetString("remove <user> <region> - Removes a user from a region."),
						  GetString("allowg <group> <region> - Allows a user group to a region."),
						  GetString("removeg <group> <region> - Removes a user group from a region."),
						  GetString("info <region> [-d] - Displays several information about the given region."),
						  GetString("protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."),
						  GetString("z <name> <#> - Sets the z-order of the region."),
						};
						if (args.Player.HasPermission(Permissions.tp))
							lines.Add(GetString("tp <region> - Teleports you to the given region's center."));

						PaginationTools.SendPage(
						  args.Player, pageNumber, lines,
						  new PaginationTools.Settings
						  {
							  HeaderFormat = GetString("Available Region Sub-Commands ({{0}}/{{1}}):"),
							  FooterFormat = GetString("Type {0}region {{0}} for more sub-commands.", Specifier)
						  }
						);
						break;
					}
			}
		}

		#endregion Region Commands

		#region World Protection Commands

		private static void ToggleAntiBuild(CommandArgs args)
		{
			TShock.Config.Settings.DisableBuild = !TShock.Config.Settings.DisableBuild;
			TSPlayer.All.SendSuccessMessage(TShock.Config.Settings.DisableBuild ? GetString("Anti-build is now on.") : GetString("Anti-build is now off."));
		}

		private static void ProtectSpawn(CommandArgs args)
		{
			TShock.Config.Settings.SpawnProtection = !TShock.Config.Settings.SpawnProtection;
			TSPlayer.All.SendSuccessMessage(TShock.Config.Settings.SpawnProtection ? GetString("Spawn is now protected.") : GetString("Spawn is now open."));
		}

		#endregion World Protection Commands

		#region General Commands

		private static void Help(CommandArgs args)
		{
			if (args.Parameters.Count > 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}help <command/page>", Specifier));
				return;
			}

			int pageNumber;
			if (args.Parameters.Count == 0 || int.TryParse(args.Parameters[0], out pageNumber))
			{
				if (!PaginationTools.TryParsePageNumber(args.Parameters, 0, args.Player, out pageNumber))
				{
					return;
				}

				IEnumerable<string> cmdNames = from cmd in ChatCommands
											   where cmd.CanRun(args.Player) && (cmd.Name != "setup" || TShock.SetupToken != 0)
											   select Specifier + cmd.Name;

				PaginationTools.SendPage(args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(cmdNames),
					new PaginationTools.Settings
					{
						HeaderFormat = GetString("Commands ({{0}}/{{1}}):"),
						FooterFormat = GetString("Type {0}help {{0}} for more.", Specifier)
					});
			}
			else
			{
				string commandName = args.Parameters[0].ToLower();
				if (commandName.StartsWith(Specifier))
				{
					commandName = commandName.Substring(1);
				}

				Command command = ChatCommands.Find(c => c.Names.Contains(commandName));
				if (command == null)
				{
					args.Player.SendErrorMessage(GetString("Invalid command."));
					return;
				}
				if (!command.CanRun(args.Player))
				{
					args.Player.SendErrorMessage(GetString("You do not have access to this command."));
					return;
				}

				args.Player.SendSuccessMessage(GetString("{0}{1} help: ", Specifier, command.Name));
				if (command.HelpDesc == null)
				{
					args.Player.SendInfoMessage(command.HelpText);
					return;
				}
				foreach (string line in command.HelpDesc)
				{
					args.Player.SendInfoMessage(line);
				}
			}
		}

		private static void GetVersion(CommandArgs args)
		{
			args.Player.SendMessage(GetString($"TShock: {TShock.VersionNum.Color(Utils.BoldHighlight)} {TShock.VersionCodename.Color(Utils.RedHighlight)}."), Color.White);
		}

		private static void ListConnectedPlayers(CommandArgs args)
		{
			bool invalidUsage = (args.Parameters.Count > 2);

			bool displayIdsRequested = false;
			int pageNumber = 1;
			if (!invalidUsage)
			{
				foreach (string parameter in args.Parameters)
				{
					if (parameter.Equals("-i", StringComparison.InvariantCultureIgnoreCase))
					{
						displayIdsRequested = true;
						continue;
					}

					if (!int.TryParse(parameter, out pageNumber))
					{
						invalidUsage = true;
						break;
					}
				}
			}
			if (invalidUsage)
			{
				args.Player.SendMessage(GetString($"List Online Players Syntax"), Color.White);
				args.Player.SendMessage(GetString($"{"playing".Color(Utils.BoldHighlight)} {"[-i]".Color(Utils.RedHighlight)} {"[page]".Color(Utils.GreenHighlight)}"), Color.White);
				args.Player.SendMessage(GetString($"Command aliases: {"playing".Color(Utils.GreenHighlight)}, {"online".Color(Utils.GreenHighlight)}, {"who".Color(Utils.GreenHighlight)}"), Color.White);
				args.Player.SendMessage(GetString($"Example usage: {"who".Color(Utils.BoldHighlight)} {"-i".Color(Utils.RedHighlight)}"), Color.White);
				return;
			}
			if (displayIdsRequested && !args.Player.HasPermission(Permissions.seeids))
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to see player IDs."));
				return;
			}

			if (TShock.Utils.GetActivePlayerCount() == 0)
			{
				args.Player.SendMessage(GetString("There are currently no players online."), Color.White);
				return;
			}
			args.Player.SendMessage(GetString($"Online Players ({TShock.Utils.GetActivePlayerCount().Color(Utils.GreenHighlight)}/{TShock.Config.Settings.MaxSlots})"), Color.White);

			var players = new List<string>();

			foreach (TSPlayer ply in TShock.Players)
			{
				if (ply != null && ply.Active && ply.FinishedHandshake)
				{
					if (displayIdsRequested)
						if (ply.Account != null)
							players.Add(GetString($"{ply.Name} (Index: {ply.Index}, Account ID: {ply.Account.ID})"));
						else
							players.Add(GetString($"{ply.Name} (Index: {ply.Index})"));
					else
						players.Add(ply.Name);
				}
			}

			PaginationTools.SendPage(
				args.Player, pageNumber, PaginationTools.BuildLinesFromTerms(players),
				new PaginationTools.Settings
				{
					IncludeHeader = false,
					FooterFormat = GetString($"Type {Specifier}who {(displayIdsRequested ? "-i" : string.Empty)} for more.")
				}
			);
		}

		private static void SetupToken(CommandArgs args)
		{
			if (TShock.SetupToken == 0)
			{
				args.Player.SendWarningMessage(GetString("The initial setup system is disabled. This incident has been logged."));
				args.Player.SendWarningMessage(GetString("If you are locked out of all admin accounts, ask for help on https://tshock.co/"));
				TShock.Log.Warn("{0} attempted to use the initial setup system even though it's disabled.", args.Player.IP);
				return;
			}

			// If the user account is already logged in, turn off the setup system
			if (args.Player.IsLoggedIn && args.Player.tempGroup == null)
			{
				args.Player.SendSuccessMessage(GetString("Your new account has been verified, and the {0}setup system has been turned off.", Specifier));
				args.Player.SendSuccessMessage(GetString("Share your server, talk with admins, and chill on GitHub & Discord. -- https://tshock.co/"));
				args.Player.SendSuccessMessage(GetString("Thank you for using TShock for Terraria!"));
				FileTools.CreateFile(Path.Combine(TShock.SavePath, "setup.lock"));
				File.Delete(Path.Combine(TShock.SavePath, "setup-code.txt"));
				TShock.SetupToken = 0;
				return;
			}

			if (args.Parameters.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("You must provide a setup code!"));
				return;
			}

			int givenCode;
			if (!Int32.TryParse(args.Parameters[0], out givenCode) || givenCode != TShock.SetupToken)
			{
				args.Player.SendErrorMessage(GetString("Incorrect setup code. This incident has been logged."));
				TShock.Log.Warn(args.Player.IP + " attempted to use an incorrect setup code.");
				return;
			}

			if (args.Player.Group.Name != "superadmin")
				args.Player.tempGroup = new SuperAdminGroup();

			args.Player.SendInfoMessage(GetString("Temporary system access has been given to you, so you can run one command."));
			args.Player.SendWarningMessage(GetString("Please use the following to create a permanent account for you."));
			args.Player.SendWarningMessage(GetString("{0}user add <username> <password> owner", Specifier));
			args.Player.SendInfoMessage(GetString("Creates: <username> with the password <password> as part of the owner group."));
			args.Player.SendInfoMessage(GetString("Please use {0}login <username> <password> after this process.", Specifier));
			args.Player.SendWarningMessage(GetString("If you understand, please {0}login <username> <password> now, and then type {0}setup.", Specifier));
			return;
		}

		private static void ThirdPerson(CommandArgs args)
		{
			if (args.Parameters.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}me <text>", Specifier));
				return;
			}
			if (args.Player.mute)
				args.Player.SendErrorMessage(GetString("You are muted."));
			else
				TSPlayer.All.SendMessage(GetString("*{0} {1}", args.Player.Name, String.Join(" ", args.Parameters)), 205, 133, 63);
		}

		private static void PartyChat(CommandArgs args)
		{
			if (args.Parameters.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}p <team chat text>", Specifier));
				return;
			}
			int playerTeam = args.Player.Team;

			if (args.Player.mute)
				args.Player.SendErrorMessage(GetString("You are muted."));
			else if (playerTeam != 0)
			{
				string msg = GetString("<{0}> {1}", args.Player.Name, String.Join(" ", args.Parameters));
				foreach (TSPlayer player in TShock.Players)
				{
					if (player != null && player.Active && player.Team == playerTeam)
						player.SendMessage(msg, Main.teamColor[playerTeam].R, Main.teamColor[playerTeam].G, Main.teamColor[playerTeam].B);
				}
			}
			else
				args.Player.SendErrorMessage(GetString("You are not in a party!"));
		}

		private static void Mute(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendMessage(GetString("Mute Syntax"), Color.White);
				args.Player.SendMessage(GetString($"{"mute".Color(Utils.BoldHighlight)} <{"player".Color(Utils.RedHighlight)}> [{"reason".Color(Utils.GreenHighlight)}]"), Color.White);
				args.Player.SendMessage(GetString($"Example usage: {"mute".Color(Utils.BoldHighlight)} \"{args.Player.Name.Color(Utils.RedHighlight)}\" \"{"No swearing on my Christian server".Color(Utils.GreenHighlight)}\""), Color.White);
				args.Player.SendMessage(GetString($"To mute a player without broadcasting to chat, use the command with {SilentSpecifier.Color(Utils.GreenHighlight)} instead of {Specifier.Color(Utils.RedHighlight)}"), Color.White);
				return;
			}

			var players = TSPlayer.FindByNameOrID(args.Parameters[0]);
			if (players.Count == 0)
			{
				args.Player.SendErrorMessage(GetString($"Could not find any players named \"{args.Parameters[0]}\""));
			}
			else if (players.Count > 1)
			{
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			}
			else if (players[0].HasPermission(Permissions.mute))
			{
				args.Player.SendErrorMessage(GetString($"You do not have permission to mute {players[0].Name}"));
			}
			else if (players[0].mute)
			{
				var plr = players[0];
				plr.mute = false;
				if (args.Silent)
					args.Player.SendSuccessMessage(GetString($"You have unmuted {plr.Name}."));
				else
					TSPlayer.All.SendInfoMessage(GetString($"{args.Player.Name} has unmuted {plr.Name}."));
			}
			else
			{
				string reason = GetString("No reason specified.");
				if (args.Parameters.Count > 1)
					reason = String.Join(" ", args.Parameters.ToArray(), 1, args.Parameters.Count - 1);
				var plr = players[0];
				plr.mute = true;
				if (args.Silent)
					args.Player.SendSuccessMessage(GetString($"You have muted {plr.Name} for {reason}"));
				else
					TSPlayer.All.SendInfoMessage(GetString($"{args.Player.Name} has muted {plr.Name} for {reason}."));
			}
		}

		private static void Motd(CommandArgs args)
		{
			args.Player.SendFileTextAsMessage(FileTools.MotdPath);
		}

		private static void Rules(CommandArgs args)
		{
			args.Player.SendFileTextAsMessage(FileTools.RulesPath);
		}

		public static void Whisper(CommandArgs args)
		{
			if (args.Parameters.Count < 2)
			{
				args.Player.SendMessage(GetString("Whisper Syntax"), Color.White);
				args.Player.SendMessage(GetString($"{"whisper".Color(Utils.BoldHighlight)} <{"player".Color(Utils.RedHighlight)}> <{"message".Color(Utils.PinkHighlight)}>"), Color.White);
				args.Player.SendMessage(GetString($"Example usage: {"w".Color(Utils.BoldHighlight)} {args.Player.Name.Color(Utils.RedHighlight)} {"We're no strangers to love, you know the rules, and so do I.".Color(Utils.PinkHighlight)}"), Color.White);
				return;
			}
			var players = TSPlayer.FindByNameOrID(args.Parameters[0]);
			if (players.Count == 0)
			{
				args.Player.SendErrorMessage(GetString($"Could not find any player named \"{args.Parameters[0]}\""));
			}
			else if (players.Count > 1)
			{
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			}
			else if (args.Player.mute)
			{
				args.Player.SendErrorMessage(GetString("You are muted."));
			}
			else
			{
				var plr = players[0];
				if (plr == args.Player)
				{
					args.Player.SendErrorMessage(GetString("You cannot whisper to yourself."));
					return;
				}
				if (!plr.AcceptingWhispers)
				{
					args.Player.SendErrorMessage(GetString($"{plr.Name} is not accepting whispers."));
					return;
				}
				var msg = string.Join(" ", args.Parameters.ToArray(), 1, args.Parameters.Count - 1);
				plr.SendMessage(GetString($"<From {args.Player.Name}> {msg}"), Color.MediumPurple);
				args.Player.SendMessage(GetString($"<To {plr.Name}> {msg}"), Color.MediumPurple);
				plr.LastWhisper = args.Player;
				args.Player.LastWhisper = plr;
			}
		}

		private static void Wallow(CommandArgs args)
		{
			args.Player.AcceptingWhispers = !args.Player.AcceptingWhispers;
			if (args.Player.AcceptingWhispers)
				args.Player.SendInfoMessage(GetString("You may now receive whispers from other players."));
			else
				args.Player.SendInfoMessage(GetString("You will no longer receive whispers from other players."));
			args.Player.SendMessage(GetString($"You can use {Specifier.Color(Utils.GreenHighlight)}{"wa".Color(Utils.GreenHighlight)} to toggle this setting."), Color.White);
		}

		private static void Reply(CommandArgs args)
		{
			if (args.Player.mute)
			{
				args.Player.SendErrorMessage(GetString("You are muted."));
			}
			else if (args.Player.LastWhisper != null && args.Player.LastWhisper.Active)
			{
				if (!args.Player.LastWhisper.AcceptingWhispers)
				{
					args.Player.SendErrorMessage(GetString($"{args.Player.LastWhisper.Name} is not accepting whispers."));
					return;
				}
				var msg = string.Join(" ", args.Parameters);
				args.Player.LastWhisper.SendMessage(GetString($"<From {args.Player.Name}> {msg}"), Color.MediumPurple);
				args.Player.SendMessage(GetString($"<To {args.Player.LastWhisper.Name}> {msg}"), Color.MediumPurple);
			}
			else if (args.Player.LastWhisper != null)
			{
				args.Player.SendErrorMessage(GetString($"{args.Player.LastWhisper.Name} is offline and cannot receive your reply."));
			}
			else
			{
				args.Player.SendErrorMessage(GetString("You haven't previously received any whispers."));
				args.Player.SendMessage(GetString($"You can use {Specifier.Color(Utils.GreenHighlight)}{"w".Color(Utils.GreenHighlight)} to whisper to other players."), Color.White);
			}
		}

		private static void Annoy(CommandArgs args)
		{
			if (args.Parameters.Count != 2)
			{
				args.Player.SendMessage(GetString("Annoy Syntax"), Color.White);
				args.Player.SendMessage(GetString($"{"annoy".Color(Utils.BoldHighlight)} <{"player".Color(Utils.RedHighlight)}> <{"seconds".Color(Utils.PinkHighlight)}>"), Color.White);
				args.Player.SendMessage(GetString($"Example usage: {"annoy".Color(Utils.BoldHighlight)} <{args.Player.Name.Color(Utils.RedHighlight)}> <{"10".Color(Utils.PinkHighlight)}>"), Color.White);
				args.Player.SendMessage(GetString($"You can use {SilentSpecifier.Color(Utils.GreenHighlight)} instead of {Specifier.Color(Utils.RedHighlight)} to annoy a player silently."), Color.White);
				return;
			}
			int annoy = 5;
			int.TryParse(args.Parameters[1], out annoy);

			var players = TSPlayer.FindByNameOrID(args.Parameters[0]);
			if (players.Count == 0)
				args.Player.SendErrorMessage(GetString($"Could not find any player named \"{args.Parameters[0]}\""));
			else if (players.Count > 1)
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			else
			{
				var ply = players[0];
				args.Player.SendSuccessMessage(GetString($"Annoying {ply.Name} for {annoy} seconds."));
				if (!args.Silent)
					ply.SendMessage(GetString("You are now being annoyed."), Color.LightGoldenrodYellow);
				new Thread(ply.Whoopie).Start(annoy);
			}
		}

		private static void Rocket(CommandArgs args)
		{
			if (args.Parameters.Count != 1)
			{
				args.Player.SendMessage(GetString("Rocket Syntax"), Color.White);
				args.Player.SendMessage(GetString($"{"rocket".Color(Utils.BoldHighlight)} <{"player".Color(Utils.RedHighlight)}>"), Color.White);
				args.Player.SendMessage(GetString($"Example usage: {"rocket".Color(Utils.BoldHighlight)} {args.Player.Name.Color(Utils.RedHighlight)}"), Color.White);
				args.Player.SendMessage(GetString($"You can use {SilentSpecifier.Color(Utils.GreenHighlight)} instead of {Specifier.Color(Utils.RedHighlight)} to rocket a player silently."), Color.White);
				return;
			}
			var players = TSPlayer.FindByNameOrID(args.Parameters[0]);
			if (players.Count == 0)
				args.Player.SendErrorMessage(GetString($"Could not find any player named \"{args.Parameters[0]}\""));
			else if (players.Count > 1)
				args.Player.SendMultipleMatchError(players.Select(p => p.Name));
			else
			{
				var target = players[0];

				if (target.IsLoggedIn && Main.ServerSideCharacter)
				{
					target.TPlayer.velocity.Y = -50;
					TSPlayer.All.SendData(PacketTypes.PlayerUpdate, "", target.Index);

					if (!args.Silent)
					{
						if (target == args.Player)
							if (args.Player.TPlayer.Male)
								TSPlayer.All.SendInfoMessage(GetString($"{args.Player.Name} has launched himself into space."));
							else
								TSPlayer.All.SendInfoMessage(GetString($"{args.Player.Name} has launched herself into space."));
						else
							TSPlayer.All.SendInfoMessage(GetString($"{args.Player.Name} has launched {target.Name} into space."));
						return;
					}

					if (target == args.Player)
						args.Player.SendSuccessMessage(GetString("You have launched yourself into space."));
					else
						args.Player.SendSuccessMessage(GetString($"You have launched {target.Name} into space."));
				}
				else
				{
					if (!Main.ServerSideCharacter)
						args.Player.SendErrorMessage(GetString("SSC must be enabled to use this command."));
					else
						if (target.TPlayer.Male)
						args.Player.SendErrorMessage(GetString($"Unable to launch {target.Name} because he is not logged in."));
					else
						args.Player.SendErrorMessage(GetString($"Unable to launch {target.Name} because she is not logged in."));
				}
			}
		}

		private static void FireWork(CommandArgs args)
		{
			var user = args.Player;
			if (args.Parameters.Count < 1)
			{
				// firework <player> [R|G|B|Y]
				user.SendMessage(GetString("Firework Syntax"), Color.White);
				user.SendMessage(GetString($"{"firework".Color(Utils.CyanHighlight)} <{"player".Color(Utils.PinkHighlight)}> [{"R".Color(Utils.RedHighlight)}|{"G".Color(Utils.GreenHighlight)}|{"B".Color(Utils.BoldHighlight)}|{"Y".Color(Utils.YellowHighlight)}]"), Color.White);
				user.SendMessage(GetString($"Example usage: {"firework".Color(Utils.CyanHighlight)} {user.Name.Color(Utils.PinkHighlight)} {"R".Color(Utils.RedHighlight)}"), Color.White);
				user.SendMessage(GetString($"You can use {SilentSpecifier.Color(Utils.GreenHighlight)} instead of {Specifier.Color(Utils.RedHighlight)} to launch a firework silently."), Color.White);
				return;
			}
			var players = TSPlayer.FindByNameOrID(args.Parameters[0]);
			if (players.Count == 0)
				user.SendErrorMessage(GetString($"Could not find any player named \"{args.Parameters[0]}\""));
			else if (players.Count > 1)
				user.SendMultipleMatchError(players.Select(p => p.Name));
			else
			{
				int type = ProjectileID.RocketFireworkRed;
				if (args.Parameters.Count > 1)
				{
					switch (args.Parameters[1].ToLower())
					{
						case "red":
						case "r":
							type = ProjectileID.RocketFireworkRed;
							break;
						case "green":
						case "g":
							type = ProjectileID.RocketFireworkGreen;
							break;
						case "blue":
						case "b":
							type = ProjectileID.RocketFireworkBlue;
							break;
						case "yellow":
						case "y":
							type = ProjectileID.RocketFireworkYellow;
							break;
						case "r2":
						case "star":
							type = ProjectileID.RocketFireworksBoxRed;
							break;
						case "g2":
						case "spiral":
							type = ProjectileID.RocketFireworksBoxGreen;
							break;
						case "b2":
						case "rings":
							type = ProjectileID.RocketFireworksBoxBlue;
							break;
						case "y2":
						case "flower":
							type = ProjectileID.RocketFireworksBoxYellow;
							break;
						default:
							type = ProjectileID.RocketFireworkRed;
							break;
					}
				}
				var target = players[0];
				int p = Projectile.NewProjectile(Projectile.GetNoneSource(), target.TPlayer.position.X, target.TPlayer.position.Y - 64f, 0f, -8f, type, 0, 0);
				Main.projectile[p].Kill();
				if (target == user)
					args.Player.SendSuccessMessage(GetString("You launched fireworks on yourself."));
				else
					args.Player.SendSuccessMessage(GetString($"You launched fireworks on {target.Name}."));
				if (!args.Silent && target != user)
					target.SendSuccessMessage(GetString($"{user.Name} launched fireworks on you."));
			}
		}

		private static void Aliases(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}aliases <command or alias>", Specifier));
				return;
			}

			string givenCommandName = string.Join(" ", args.Parameters);
			if (string.IsNullOrWhiteSpace(givenCommandName))
			{
				args.Player.SendErrorMessage(GetString("Please enter a proper command name or alias."));
				return;
			}

			string commandName;
			if (givenCommandName[0] == Specifier[0])
				commandName = givenCommandName.Substring(1);
			else
				commandName = givenCommandName;

			bool didMatch = false;
			foreach (Command matchingCommand in ChatCommands.Where(cmd => cmd.Names.IndexOf(commandName) != -1))
			{
				if (matchingCommand.Names.Count > 1)
					args.Player.SendInfoMessage(
						GetString("Aliases of {0}{1}: {0}{2}", Specifier, matchingCommand.Name, string.Join($", {Specifier}", matchingCommand.Names.Skip(1))));
				else
					args.Player.SendInfoMessage(GetString("{0}{1} defines no aliases.", Specifier, matchingCommand.Name));

				didMatch = true;
			}

			if (!didMatch)
				args.Player.SendErrorMessage(GetString("No command or command alias matching \"{0}\" found.", givenCommandName));
		}

		private static void CreateDumps(CommandArgs args)
		{
			TShock.Utils.DumpPermissionMatrix("PermissionMatrix.txt");
			TShock.Utils.Dump(false);
			args.Player.SendSuccessMessage(GetString("Your reference dumps have been created in the server folder."));
			return;
		}

		private static void SyncLocalArea(CommandArgs args)
		{
			args.Player.SendTileSquareCentered(args.Player.TileX, args.Player.TileY, 32);
			args.Player.SendWarningMessage(GetString("Sync'd!"));
			return;
		}

		#endregion General Commands

		#region Game Commands

		private static void Clear(CommandArgs args)
		{
			var user = args.Player;
			var everyone = TSPlayer.All;
			int radius = 50;

			if (args.Parameters.Count != 1 && args.Parameters.Count != 2)
			{
				user.SendMessage(GetString("Clear Syntax"), Color.White);
				user.SendMessage(GetString($"{"clear".Color(Utils.BoldHighlight)} <{"item".Color(Utils.GreenHighlight)}|{"npc".Color(Utils.RedHighlight)}|{"projectile".Color(Utils.YellowHighlight)}> [{"radius".Color(Utils.PinkHighlight)}]"), Color.White);
				user.SendMessage(GetString($"Example usage: {"clear".Color(Utils.BoldHighlight)} {"i".Color(Utils.RedHighlight)} {"10000".Color(Utils.GreenHighlight)}"), Color.White); user.SendMessage(GetString($"Example usage: {"clear".Color(Utils.BoldHighlight)} {"item".Color(Utils.RedHighlight)} {"10000".Color(Utils.GreenHighlight)}"), Color.White);
				user.SendMessage(GetString($"If you do not specify a radius, it will use a default radius of {radius} around your character."), Color.White);
				user.SendMessage(GetString($"You can use {SilentSpecifier.Color(Utils.GreenHighlight)} instead of {Specifier.Color(Utils.RedHighlight)} to execute this command silently."), Color.White);
				return;
			}

			if (args.Parameters.Count == 2)
			{
				if (!int.TryParse(args.Parameters[1], out radius) || radius <= 0)
				{
					user.SendErrorMessage(GetString($"\"{args.Parameters[1]}\" is not a valid radius."));
					return;
				}
			}

			switch (args.Parameters[0].ToLower())
			{
				case "item":
				case "items":
				case "i":
					{
						int cleared = 0;
						for (int i = 0; i < Main.maxItems; i++)
						{
							float dX = Main.item[i].position.X - user.X;
							float dY = Main.item[i].position.Y - user.Y;

							if (Main.item[i].active && dX * dX + dY * dY <= radius * radius * 256f)
							{
								Main.item[i].active = false;
								everyone.SendData(PacketTypes.ItemDrop, "", i);
								cleared++;
							}
						}
						if (args.Silent)
							user.SendSuccessMessage(GetPluralString("You deleted {0} item within a radius of {1}.", "You deleted {0} items within a radius of {1}.", cleared, cleared, radius));
						else
							everyone.SendInfoMessage(GetPluralString("{0} deleted {1} item within a radius of {2}.", "{0} deleted {1} items within a radius of {2}.", cleared, user.Name, cleared, radius));
					}
					break;
				case "npc":
				case "npcs":
				case "n":
					{
						int cleared = 0;
						for (int i = 0; i < Main.maxNPCs; i++)
						{
							float dX = Main.npc[i].position.X - user.X;
							float dY = Main.npc[i].position.Y - user.Y;

							if (Main.npc[i].active && dX * dX + dY * dY <= radius * radius * 256f)
							{
								Main.npc[i].active = false;
								Main.npc[i].type = 0;
								everyone.SendData(PacketTypes.NpcUpdate, "", i);
								cleared++;
							}
						}
						if (args.Silent)
							user.SendSuccessMessage(GetPluralString("You deleted {0} NPC within a radius of {1}.", "You deleted {0} NPCs within a radius of {1}.", cleared, cleared, radius));
						else
							everyone.SendInfoMessage(GetPluralString("{0} deleted {1} NPC within a radius of {2}.", "{0} deleted {1} NPCs within a radius of {2}.", cleared, user.Name, cleared, radius));
					}
					break;
				case "proj":
				case "projectile":
				case "projectiles":
				case "p":
					{
						int cleared = 0;
						for (int i = 0; i < Main.maxProjectiles; i++)
						{
							float dX = Main.projectile[i].position.X - user.X;
							float dY = Main.projectile[i].position.Y - user.Y;

							if (Main.projectile[i].active && dX * dX + dY * dY <= radius * radius * 256f)
							{
								Main.projectile[i].active = false;
								Main.projectile[i].type = 0;
								everyone.SendData(PacketTypes.ProjectileNew, "", i);
								cleared++;
							}
						}
						if (args.Silent)
							user.SendSuccessMessage(GetPluralString("You deleted {0} projectile within a radius of {1}.", "You deleted {0} projectiles within a radius of {1}.", cleared, cleared, radius));
						else
							everyone.SendInfoMessage(GetPluralString("{0} deleted {1} projectile within a radius of {2}.", "{0} deleted {1} projectiles within a radius of {2}.", cleared, user.Name, cleared, radius));
					}
					break;
				default:
					user.SendErrorMessage(GetString($"\"{args.Parameters[0]}\" is not a valid clear option."));
					break;
			}
		}

		private static void Kill(CommandArgs args)
		{
			// To-Do: separate kill self and kill other player into two permissions
			var user = args.Player;
			if (args.Parameters.Count < 1)
			{
				user.SendMessage(GetString("Kill syntax and example"), Color.White);
				user.SendMessage(GetString($"{"kill".Color(Utils.BoldHighlight)} <{"player".Color(Utils.RedHighlight)}>"), Color.White);
				user.SendMessage(GetString($"Example usage: {"kill".Color(Utils.BoldHighlight)} {user.Name.Color(Utils.RedHighlight)}"), Color.White);
				user.SendMessage(GetString($"You can use {SilentSpecifier.Color(Utils.GreenHighlight)} instead of {Specifier.Color(Utils.RedHighlight)} to execute this command silently."), Color.White);
				return;
			}

			string targetName = String.Join(" ", args.Parameters);
			var players = TSPlayer.FindByNameOrID(targetName);

			if (players.Count == 0)
				user.SendErrorMessage(GetString($"Could not find any player named \"{targetName}\"."));
			else if (players.Count > 1)
				user.SendMultipleMatchError(players.Select(p => p.Name));
			else
			{
				var target = players[0];

				if (target.Dead)
				{
					if (target == user)
						user.SendErrorMessage(GetString("You are already dead!"));
					else
						user.SendErrorMessage(GetString($"{target.Name} is already dead!"));
					return;
				}
				target.KillPlayer();
				if (target == user)
					user.SendSuccessMessage(GetString("You just killed yourself!"));
				else
					user.SendSuccessMessage(GetString($"You just killed {target.Name}!"));
				if (!args.Silent && target != user)
					target.SendErrorMessage(GetString($"{user.Name} just killed you!"));
			}
		}

		private static void Respawn(CommandArgs args)
		{
			if (!args.Player.RealPlayer && args.Parameters.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("You can't respawn the server console!"));
				return;
			}
			TSPlayer playerToRespawn;
			if (args.Parameters.Count > 0)
			{
				if (!args.Player.HasPermission(Permissions.respawnother))
				{
					args.Player.SendErrorMessage(GetString("You do not have permission to respawn another player."));
					return;
				}
				string plStr = String.Join(" ", args.Parameters);
				var players = TSPlayer.FindByNameOrID(plStr);
				if (players.Count == 0)
				{
					args.Player.SendErrorMessage(GetString($"Could not find any player named \"{plStr}\""));
					return;
				}
				if (players.Count > 1)
				{
					args.Player.SendMultipleMatchError(players.Select(p => p.Name));
					return;
				}
				playerToRespawn = players[0];
			}
			else
				playerToRespawn = args.Player;

			if (!playerToRespawn.Dead)
			{
				if (playerToRespawn == args.Player)
					args.Player.SendErrorMessage(GetString("You are not dead!"));
				else
					args.Player.SendErrorMessage(GetString($"{playerToRespawn.Name} is not dead!"));
				return;
			}
			playerToRespawn.Spawn(PlayerSpawnContext.ReviveFromDeath);

			if (playerToRespawn != args.Player)
			{
				args.Player.SendSuccessMessage(GetString($"You have respawned {playerToRespawn.Name}"));
				if (!args.Silent)
					playerToRespawn.SendSuccessMessage(GetString($"{args.Player.Name} has respawned you."));
			}
			else
				playerToRespawn.SendSuccessMessage(GetString("You have respawned yourself."));
		}

		private static void Butcher(CommandArgs args)
		{
			var user = args.Player;
			if (args.Parameters.Count > 1)
			{
				user.SendMessage(GetString("Butcher Syntax and Example"), Color.White);
				user.SendMessage(GetString($"{"butcher".Color(Utils.BoldHighlight)} [{"NPC name".Color(Utils.RedHighlight)}|{"ID".Color(Utils.RedHighlight)}]"), Color.White);
				user.SendMessage(GetString($"Example usage: {"butcher".Color(Utils.BoldHighlight)} {"pigron".Color(Utils.RedHighlight)}"), Color.White);
				user.SendMessage(GetString("All alive NPCs (excluding town NPCs) on the server will be killed if you do not input a name or ID."), Color.White);
				user.SendMessage(GetString($"To get rid of NPCs without making them drop items, use the {"clear".Color(Utils.BoldHighlight)} command instead."), Color.White);
				user.SendMessage(GetString($"To execute this command silently, use {SilentSpecifier.Color(Utils.GreenHighlight)} instead of {Specifier.Color(Utils.RedHighlight)}"), Color.White);
				return;
			}

			int npcId = 0;

			if (args.Parameters.Count == 1)
			{
				var npcs = TShock.Utils.GetNPCByIdOrName(args.Parameters[0]);
				if (npcs.Count == 0)
				{
					user.SendErrorMessage(GetString($"\"{args.Parameters[0]}\" is not a valid NPC."));
					return;
				}

				if (npcs.Count > 1)
				{
					user.SendMultipleMatchError(npcs.Select(n => $"{n.FullName}({n.type})"));
					return;
				}
				npcId = npcs[0].netID;
			}

			int kills = 0;
			for (int i = 0; i < Main.npc.Length; i++)
			{
				if (Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC && Main.npc[i].netID != NPCID.TargetDummy) || Main.npc[i].netID == npcId))
				{
					TSPlayer.Server.StrikeNPC(i, (int)(Main.npc[i].life + (Main.npc[i].defense * 0.6)), 0, 0);
					kills++;
				}
			}

			if (args.Silent)
				user.SendSuccessMessage(GetPluralString("You butchered {0} NPC.", "You butchered {0} NPCs.", kills, kills));
			else
				TSPlayer.All.SendInfoMessage(GetPluralString("{0} butchered {1} NPC.", "{0} butchered {1} NPCs.", kills, user.Name, kills));
		}

		private static void Item(CommandArgs args)
		{
			if (args.Parameters.Count < 1)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}item <item name/id> [item amount] [prefix id/name]", Specifier));
				return;
			}

			int amountParamIndex = -1;
			int itemAmount = 0;
			for (int i = 1; i < args.Parameters.Count; i++)
			{
				if (int.TryParse(args.Parameters[i], out itemAmount))
				{
					amountParamIndex = i;
					break;
				}
			}

			string itemNameOrId;
			if (amountParamIndex == -1)
				itemNameOrId = string.Join(" ", args.Parameters);
			else
				itemNameOrId = string.Join(" ", args.Parameters.Take(amountParamIndex));

			Item item;
			List<Item> matchedItems = TShock.Utils.GetItemByIdOrName(itemNameOrId);
			if (matchedItems.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid item type!"));
				return;
			}
			else if (matchedItems.Count > 1)
			{
				args.Player.SendMultipleMatchError(matchedItems.Select(i => $"{i.Name}({i.netID})"));
				return;
			}
			else
			{
				item = matchedItems[0];
			}
			if (item.type < 1 && item.type >= Terraria.ID.ItemID.Count)
			{
				args.Player.SendErrorMessage(GetString("The item type {0} is invalid.", itemNameOrId));
				return;
			}

			int prefixId = 0;
			if (amountParamIndex != -1 && args.Parameters.Count > amountParamIndex + 1)
			{
				string prefixidOrName = args.Parameters[amountParamIndex + 1];
				var prefixIds = TShock.Utils.GetPrefixByIdOrName(prefixidOrName);

				if (item.accessory && prefixIds.Contains(PrefixID.Quick))
				{
					prefixIds.Remove(PrefixID.Quick);
					prefixIds.Remove(PrefixID.Quick2);
					prefixIds.Add(PrefixID.Quick2);
				}
				else if (!item.accessory && prefixIds.Contains(PrefixID.Quick))
					prefixIds.Remove(PrefixID.Quick2);

				if (prefixIds.Count > 1)
				{
					args.Player.SendMultipleMatchError(prefixIds.Select(p => p.ToString()));
					return;
				}
				else if (prefixIds.Count == 0)
				{
					args.Player.SendErrorMessage(GetString("No prefix matched \"{0}\".", prefixidOrName));
					return;
				}
				else
				{
					prefixId = prefixIds[0];
				}
			}

			if (args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)
			{
				if (itemAmount == 0 || itemAmount > item.maxStack)
					itemAmount = item.maxStack;

				if (args.Player.GiveItemCheck(item.type, EnglishLanguage.GetItemNameById(item.type), itemAmount, prefixId))
				{
					item.prefix = (byte)prefixId;
					args.Player.SendSuccessMessage(GetPluralString("Gave {0} {1}.", "Gave {0} {1}s.", itemAmount, itemAmount, item.AffixName()));
				}
				else
				{
					args.Player.SendErrorMessage(GetString("You cannot spawn banned items."));
				}
			}
			else
			{
				args.Player.SendErrorMessage(GetString("Your inventory seems full."));
			}
		}

		private static void RenameNPC(CommandArgs args)
		{
			if (args.Parameters.Count != 2)
			{
				args.Player.SendErrorMessage(GetString("Invalid syntax. Proper syntax: {0}renameNPC <guide, nurse, etc.> <newname>", Specifier));
				return;
			}
			int npcId = 0;
			if (args.Parameters.Count == 2)
			{
				List<NPC> npcs = TShock.Utils.GetNPCByIdOrName(args.Parameters[0]);
				if (npcs.Count == 0)
				{
					args.Player.SendErrorMessage(GetString("Invalid mob type!"));
					return;
				}
				else if (npcs.Count > 1)
				{
					args.Player.SendMultipleMatchError(npcs.Select(n => $"{n.FullName}({n.type})"));
					return;
				}
				else if (args.Parameters[1].Length > 200)
				{
					args.Player.SendErrorMessage(GetString("New name is too large!"));
					return;
				}
				else
				{
					npcId = npcs[0].netID;
				}
			}
			int done = 0;
			for (int i = 0; i < Main.npc.Length; i++)
			{
				if (Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC) || (Main.npc[i].netID == npcId && Main.npc[i].townNPC)))
				{
					Main.npc[i].GivenName = args.Parameters[1];
					NetMessage.SendData(56, -1, -1, NetworkText.FromLiteral(args.Parameters[1]), i, 0f, 0f, 0f, 0);
					done++;
				}
			}
			if (done > 0)
			{
				TSPlayer.All.SendInfoMessage(GetString("{0} renamed the {1}.", args.Player.Name, args.Parameters[0]));
			}
			else
			{
				args.Player.SendErrorMessage(GetString("Could not rename {0}!", args.Parameters[0]));
			}
		}

		private static void Give(CommandArgs args)
		{
			if (args.Parameters.Count < 2)
			{
				args.Player.SendErrorMessage(
					"Invalid syntax. Proper syntax: {0}give <item type/id> <player> [item amount] [prefix id/name]", Specifier);
				return;
			}
			if (args.Parameters[0].Length == 0)
			{
				args.Player.SendErrorMessage(GetString("Missing item name/id."));
				return;
			}
			if (args.Parameters[1].Length == 0)
			{
				args.Player.SendErrorMessage(GetString("Missing player name."));
				return;
			}
			int itemAmount = 0;
			int prefix = 0;
			var items = TShock.Utils.GetItemByIdOrName(args.Parameters[0]);
			args.Parameters.RemoveAt(0);
			string plStr = args.Parameters[0];
			args.Parameters.RemoveAt(0);
			if (args.Parameters.Count == 1)
				int.TryParse(args.Parameters[0], out itemAmount);
			if (items.Count == 0)
			{
				args.Player.SendErrorMessage(GetString("Invalid item type!"));
			}
			else if (items.Count > 1)
			{
				args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));
			}
			else
			{
				var item = items[0];

				if (args.Parameters.Count == 2)
				{
					int.TryParse(args.Parameters[0], out itemAmount);
					var prefixIds = TShock.Utils.GetPrefixByIdOrName(args.Parameters[1]);
					if (item.accessory && prefixIds.Contains(PrefixID.Quick))
					{
						prefixIds.Remove(PrefixID.Quick);
						prefixIds.Remove(PrefixID.Quick2);
						prefixIds.Add(PrefixID.Quick2);
					}
					else if (!item.accessory && prefixIds.Contains(PrefixID.Quick))
						prefixIds.Remove(PrefixID.Quick2);
					if (prefixIds.Count == 1)
						prefix = prefixIds[0];
				}

				if (item.type >= 1 && item.type < Terraria.ID.ItemID.Count)
				{
					var players = TSPlayer.FindByNameOrID(plStr);
					if (players.Count == 0)
					{
						args.Player.SendErrorMessage(GetString("Invalid player!"));
					}
					else if (players.Count > 1)
					{
						args.Player.SendMultipleMatchError(players.Select(p => p.Name));
					}
					else
					{
						var plr = players[0];
						if (plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)
						{
							if (itemAmount == 0 || itemAmount > item.maxStack)
								itemAmount = item.maxStack;
							if (plr.GiveItemCheck(item.type, EnglishLanguage.GetItemNameById(item.type), itemAmount, prefix))
							{
								args.Player.SendSuccessMessage(GetPluralString("Gave {0} {1} {2}.", "Gave {0} {1} {2}s.", itemAmount, plr.Name, itemAmount, item.Name));
								plr.SendSuccessMessage(GetPluralString("{0} gave you {1} {2}.", "{0} gave you {1} {2}s.", itemAmount, args.Player.Name, itemAmount, item.Name));
							}
							else
							{
								args.Player.SendErrorMessage(GetString("You cannot spawn banned items."));
							}

						}
						else
						{
							args.Player.SendErrorMessage(GetString("Player does not have free slots!"));
						}
					}
				}
				else
				{
					args.Player.SendErrorMessage(GetString("Invalid item type!"));
				}
			}
		}

		private static void Heal(CommandArgs args)
		{
			// heal <player> [amount]
			// To-Do: break up heal self and heal other into two separate permissions
			var user = args.Player;
			if (args.Parameters.Count < 1 || args.Parameters.Count > 2)
			{
				user.SendMessage(GetString("Heal Syntax and Example"), Color.White);
				user.SendMessage(GetString($"{"heal".Color(Utils.BoldHighlight)} <{"player".Color(Utils.RedHighlight)}> [{"amount".Color(Utils.GreenHighlight)}]"), Color.White);
				user.SendMessage(GetString($"Example usage: {"heal".Color(Utils.BoldHighlight)} {user.Name.Color(Utils.RedHighlight)} {"100".Color(Utils.GreenHighlight)}"), Color.White);
				user.SendMessage(GetString($"If no amount is specified, it will default to healing the target player by their max HP."), Color.White);
				user.SendMessage(GetString($"To execute this command silently, use {SilentSpecifier.Color(Utils.GreenHighlight)} instead of {Specifier.Color(Utils.RedHighlight)}"), Color.White);
				return;
			}
			if (args.Parameters[0].Length == 0)
			{
				user.SendErrorMessage(GetString($"You didn't put a player name."));
				return;
			}

			string targetName = args.Parameters[0];
			var players = TSPlayer.FindByNameOrID(targetName);
			if (players.Count == 0)
				user.SendErrorMessage(GetString($"Unable to find any players named \"{targetName}\""));
			else if (players.Count > 1)
				user.SendMultipleMatchError(players.Select(p => p.Name));
			else
			{
				var target = players[0];
				int amount = target.TPlayer.statLifeMax2;

				if (target.Dead)
				{
					user.SendErrorMessage(GetString("You can't heal a dead player!"));
					return;
				}

				if (args.Parameters.Count == 2)
				{
					int.TryParse(args.Parameters[1], out amount);
				}
				target.Heal(amount);

				if (args.Silent)
					if (target == user)
						user.SendSuccessMessage(GetString($"You healed yourself for {amount} HP."));
					else
						user.SendSuccessMessage(GetString($"You healed {target.Name} for {amount} HP."));
				else
				{
					if (target == user)
						if (target.TPlayer.Male)
							TSPlayer.All.SendInfoMessage(GetString($"{user.Name} healed himself for {amount} HP."));
						else
							TSPlayer.All.SendInfoMessage(GetString($"{user.Name} healed herself for {amount} HP."));
					else
						TSPlayer.All.SendInfoMessage(GetString($"{user.Name} healed {target.Name} for {amount} HP."));
				}
			}
		}

		private static void Buff(CommandArgs args)
		{
			// buff <"buff name|ID"> [duration]
			var user = args.Player;
			if (args.Parameters.Count < 1 || args.Parameters.Count > 2)
			{
				user.SendMessage(GetString("Buff Syntax and Example"), Color.White);
				user.SendMessage(GetString($"{"buff".Color(Utils.BoldHighlight)} <\"{"buff name".Color(Utils.RedHighlight)}|{"ID".Color(Utils.RedHighlight)}\"> [{"duration".Color(Utils.GreenHighlight)}]"), Color.White);
				user.SendMessage(GetString($"Example usage: {"buff".Color(Utils.BoldHighlight)} \"{"obsidian skin".Color(Utils.RedHighlight)}\" {"-1".Color(Utils.GreenHighlight)}"), Color.White);
				user.SendMessage(GetString($"If you don't specify the duration, it will default to {"60".Color(Utils.GreenHighlight)} seconds."), Color.White);
				user.SendMessage(GetString($"If you put {"-1".Color(Utils.GreenHighlight)} as the duration, it will use the max possible time of 415 days."), Color.White);
				return;
			}

			int id = 0;
			int time = 60;
			var timeLimit = (int.MaxValue / 60) - 1;

			if (!int.TryParse(args.Parameters[0], out id))
			{
				var found = TShock.Utils.GetBuffByName(args.Parameters[0]);

				if (found.Count == 0)
				{
					user.SendErrorMessage(GetString($"Unable to find any buffs named \"{args.Parameters[0]}\""));
					return;
				}

				if (found.Count > 1)
				{
					user.SendMultipleMatchError(found.Select(f => Lang.GetBuffName(f)));
					return;
				}
				id = found[0];
			}

			if (args.Parameters.Count == 2)
				int.TryParse(args.Parameters[1], out time);

			if (id > 0 && id < Terraria.ID.BuffID.Count)
			{
				// Max possible buff duration as of Terraria 1.4.2.3 is 35791393 seconds (415 days).
				if (time < 0 || time > timeLimit)
					time = timeLimit;
				user.SetBuff(id, time * 60);
				user.SendSuccessMessage(GetString($"You buffed yourself with {TShock.Utils.GetBuffName(id)} ({TShock.Utils.GetBuffDescription(id)}) for {time} seconds."));
			}
			else
				user.SendErrorMessage(GetString($"\"{id}\" is not a valid buff ID!"));
		}

		private static void GBuff(CommandArgs args)
		{
			var user = args.Player;
			if (args.Parameters.Count < 2 || args.Parameters.Count > 3)
			{
				user.SendMessage(GetString("Give Buff Syntax and Example"), Color.White);
				user.SendMessage(GetString($"{"gbuff".Color(Utils.BoldHighlight)} <{"player".Color(Utils.RedHighlight)}> <{"buff name".Color(Utils.PinkHighlight)}|{"ID".Color(Utils.PinkHighlight)}> [{"seconds".Color(Utils.GreenHighlight)}]"), Color.White);
				user.SendMessage(GetString($"Example usage: {"gbuff".Color(Utils.BoldHighlight)} {user.Name.Color(Utils.RedHighlight)} {"regen".Color(Utils.PinkHighlight)} {"-1".Color(Utils.GreenHighlight)}"), Color.White);
				user.SendMessage(GetString($"To buff a player without them knowing, use {SilentSpecifier.Color(Utils.RedHighlight)} instead of {Specifier.Color(Utils.GreenHighlight)}"), Color.White);
				return;
			}
			int id = 0;
			int time = 60;
			var timeLimit = (int.MaxValue / 60) - 1;
			var foundplr = TSPlayer.FindByNameOrID(args.Parameters[0]);
			if (foundplr.Count == 0)
			{
				user.SendErrorMessage(GetString($"Unable to find any player named \"{args.Parameters[0]}\""));
				return;
			}
			else if (foundplr.Count > 1)
			{
				user.SendMultipleMatchError(foundplr.Select(p => p.Name));
				return;
			}
			else
			{
				if (!int.TryParse(args.Parameters[1], out id))
				{
					var found = TShock.Utils.GetBuffByName(args.Parameters[1]);
					if (found.Count == 0)
					{
						user.SendErrorMessage(GetString($"Unable to find any buff named \"{args.Parameters[1]}\""));
						return;
					}
					else if (found.Count > 1)
					{
						user.SendMultipleMatchError(found.Select(b => Lang.GetBuffName(b)));
						return;
					}
					id = found[0];
				}
				if (args.Parameters.Count == 3)
					int.TryParse(args.Parameters[2], out time);
				if (id > 0 && id < Terraria.ID.BuffID.Count)
				{
					var target = foundplr[0];
					if (time < 0 || time > timeLimit)
						time = timeLimit;
					target.SetBuff(id, time * 60);
					if (target == user)
						user.SendSuccessMessage(GetString($"You buffed yourself with {TShock.Utils.GetBuffName(id)} ({TShock.Utils.GetBuffDescription(id)}) for {time} seconds."));
					else
						user.SendSuccessMessage(GetString($"You have buffed {target.Name} with {TShock.Utils.GetBuffName(id)} ({TShock.Utils.GetBuffDescription(id)}) for {time} seconds!"));
					if (!args.Silent && target != user)
						target.SendSuccessMessage(GetString($"{user.Name} has buffed you with {TShock.Utils.GetBuffName(id)} ({TShock.Utils.GetBuffDescription(id)}) for {time} seconds!"));
				}
				else
					user.SendErrorMessage(GetString("Invalid buff ID!"));
			}
		}

		public static void Grow(CommandArgs args)
		{
			bool canGrowEvil = args.Player.HasPermission(Permissions.growevil);
			string subcmd = args.Parameters.Count == 0 ? "help" : args.Parameters[0].ToLower();

			var name = "Fail"; // assigned value never used
			var x = args.Player.TileX;
			var y = args.Player.TileY + 3;

			if (!TShock.Regions.CanBuild(x, y, args.Player))
			{
				args.Player.SendErrorMessage(GetString("You're not allowed to change tiles here!"));
				return;
			}

			switch (subcmd)
			{
				case "help":
					{
						if (!PaginationTools.TryParsePageNumber(args.Parameters, 1, args.Player, out int pageNumber))
							return;

						var lines = new List<string>
						{
							GetString("- Default trees :"),
							GetString("     'basic', 'sakura', 'willow', 'boreal', 'mahogany', 'ebonwood', 'shadewood', 'pearlwood'."),
							GetString("- Palm trees :"),
							GetString("     'palm', 'corruptpalm', 'crimsonpalm', 'hallowpalm'."),
							GetString("- Gem trees :"),
							GetString("     'topaz', 'amethyst', 'sapphire', 'emerald', 'ruby', 'diamond', 'amber'."),
							GetString("- Misc :"),
							GetString("     'cactus', 'herb', 'mushroom'.")
						};

						PaginationTools.SendPage(args.Player, pageNumber, lines,
								new PaginationTools.Settings
								{
									HeaderFormat = GetString("Trees types & misc available to use. ({{0}}/{{1}}):"),
									FooterFormat = GetString("Type {0}grow help {{0}} for more sub-commands.", Commands.Specifier)
								}
							);
					}
					break;

					bool rejectCannotGrowEvil()
					{
						if (!canGrowEvil)
						{
							args.Player.SendErrorMessage(GetString("You do not have permission to grow this tree type"));
							return false;
						}

						return true;
					}

					bool prepareAreaForGrow(ushort groundType = TileID.Grass, bool evil = false)
					{
						if (evil && !rejectCannotGrowEvil())
							return false;

						for (var i = x - 2; i < x + 3; i++)
						{
							Main.tile[i, y].active(true);
							Main.tile[i, y].type = groundType;
							Main.tile[i, y].wall = WallID.None;
						}
						Main.tile[x, y - 1].wall = WallID.None;

						return true;
					}

					bool growTree(ushort groundType, string fancyName, bool evil = false)
					{
						if (!prepareAreaForGrow(groundType, evil))
							return false;
						WorldGen.GrowTree(x, y);
						name = fancyName;

						return true;
					}

					bool growTreeByType(ushort groundType, string fancyName, ushort typeToPrepare = 2, bool evil = false)
					{
						if (!prepareAreaForGrow(typeToPrepare, evil))
							return false;
						WorldGen.TryGrowingTreeByType(groundType, x, y);
						name = fancyName;

						return true;
					}

					bool growPalmTree(ushort sandType, ushort supportingType, string properName, bool evil = false)
					{
						if (evil && !rejectCannotGrowEvil())
							return false;

						for (int i = x - 2; i < x + 3; i++)
						{
							Main.tile[i, y].active(true);
							Main.tile[i, y].type = sandType;
							Main.tile[i, y].wall = WallID.None;
						}
						for (int i = x - 2; i < x + 3; i++)
						{
							Main.tile[i, y + 1].active(true);
							Main.tile[i, y + 1].type = supportingType;
							Main.tile[i, y + 1].wall = WallID.None;
						}

						Main.tile[x, y - 1].wall = WallID.None;
						WorldGen.GrowPalmTree(x, y);

						name = properName;

						return true;
					}

				case "basic":
					growTree(TileID.Grass, GetString("Basic Tree"));
					break;

				case "boreal":
					growTree(TileID.SnowBlock, GetString("Boreal Tree"));
					break;

				case "mahogany":
					growTree(TileID.JungleGrass, GetString("Rich Mahogany"));
					break;

				case "sakura":
					growTreeByType(TileID.VanityTreeSakura, GetString("Sakura Tree"));
					break;

				case "willow":
					growTreeByType(TileID.VanityTreeYellowWillow, GetString("Willow Tree"));
					break;

				case "shadewood":
					if (!growTree(TileID.CrimsonGrass, GetString("Shadewood Tree"), true))
						return;
					break;

				case "ebonwood":
					if (!growTree(TileID.CorruptGrass, GetString("Ebonwood Tree"), true))
						return;
					break;

				case "pearlwood":
					if (!growTree(TileID.HallowedGrass, GetString("Pearlwood Tree"), true))
						return;
					break;

				case "palm":
					growPalmTree(TileID.Sand, TileID.HardenedSand, GetString("Desert Palm"));
					break;

				case "hallowpalm":
					if (!growPalmTree(TileID.Pearlsand, TileID.HallowHardenedSand, GetString("Hallow Palm"), true))
						return;
					break;

				case "crimsonpalm":
					if (!growPalmTree(TileID.Crimsand, TileID.CrimsonHardenedSand, GetString("Crimson Palm"), true))
						return;
					break;

				case "corruptpalm":
					if (!growPalmTree(TileID.Ebonsand, TileID.CorruptHardenedSand, GetString("Corruption Palm"), true))
						return;
					break;

				case "topaz":
					growTreeByType(TileID.TreeTopaz, GetString("Topaz Gemtree"), 1);
					break;

				case "amethyst":
					growTreeByType(TileID.TreeAmethyst, GetString("Amethyst Gemtree"), 1);
					break;

				case "sapphire":
					growTreeByType(TileID.TreeSapphire, GetString("Sapphire Gemtree"), 1);
					break;

				case "emerald":
					growTreeByType(TileID.TreeEmerald, GetString("Emerald Gemtree"), 1);
					break;

				case "ruby":
					growTreeByType(TileID.TreeRuby, GetString("Ruby Gemtree"), 1);
					break;

				case "diamond":
					growTreeByType(TileID.TreeDiamond, GetString("Diamond Gemtree"), 1);
					break;

				case "amber":
					growTreeByType(TileID.TreeAmber, GetString("Amber Gemtree"), 1);
					break;

				case "cactus":
					Main.tile[x, y].type = TileID.Sand;
					WorldGen.GrowCactus(x, y);
					name = GetString("Cactus");
					break;

				case "herb":
					Main.tile[x, y].active(true);
					Main.tile[x, y].frameX = 36;
					Main.tile[x, y].type = TileID.MatureHerbs;
					WorldGen.GrowAlch(x, y);
					name = GetString("Herb");
					break;

				case "mushroom":
					prepareAreaForGrow(TileID.MushroomGrass);
					WorldGen.GrowShroom(x, y);
					name = GetString("Glowing Mushroom Tree");
					break;

				default:
					args.Player.SendErrorMessage(GetString("Unknown plant!"));
					return;
			}
			if (args.Parameters.Count == 1)
			{
				args.Player.SendTileSquareCentered(x - 2, y - 20, 25);
				args.Player.SendSuccessMessage(GetString($"Tried to grow a {name}."));
			}
		}

		private static void ToggleGodMode(CommandArgs args)
		{
			TSPlayer playerToGod;
			if (args.Parameters.Count > 0)
			{
				if (!args.Player.HasPermission(Permissions.godmodeother))
				{
					args.Player.SendErrorMessage(GetString("You do not have permission to god mode another player."));
					return;
				}
				string plStr = String.Join(" ", args.Parameters);
				var players = TSPlayer.FindByNameOrID(plStr);
				if (players.Count == 0)
				{
					args.Player.SendErrorMessage(GetString("Invalid player!"));
					return;
				}
				else if (players.Count > 1)
				{
					args.Player.SendMultipleMatchError(players.Select(p => p.Name));
					return;
				}
				else
				{
					playerToGod = players[0];
				}
			}
			else if (!args.Player.RealPlayer)
			{
				args.Player.SendErrorMessage(GetString("You can't god mode a non player!"));
				return;
			}
			else
			{
				playerToGod = args.Player;
			}

			playerToGod.GodMode = !playerToGod.GodMode;

			if (playerToGod != args.Player)
			{
				args.Player.SendSuccessMessage(playerToGod.GodMode
					? GetString("{0} is now in god mode.", playerToGod.Name)
					: GetString("{0} is no longer in god mode.", playerToGod.Name));
			}

			if (!args.Silent || (playerToGod == args.Player))
			{
				playerToGod.SendSuccessMessage(playerToGod.GodMode
					? GetString("You are now in god mode.", playerToGod.Name)
					: GetString("You are no longer in god mode.", playerToGod.Name));
			}
		}

		#endregion Game Commands
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Configuration`
#### File: `temp_TShock-5.2.4/TShockAPI/Configuration/ConfigFile.cs`
```
﻿using Newtonsoft.Json;
using System;
using System.IO;

namespace TShockAPI.Configuration
{
	/// <summary>
	/// Implements <see cref="IConfigFile{TSettings}"/> to provide a generic config file containing some settings
	/// </summary>
	/// <typeparam name="TSettings"></typeparam>
	public class ConfigFile<TSettings> : IConfigFile<TSettings> where TSettings : new()
	{
		/// <summary>
		/// Settings managed by this config file
		/// </summary>
		public virtual TSettings Settings { get; set; } = new TSettings();

		/// <summary>
		/// Action invoked when the config file is read
		/// </summary>
		public static Action<ConfigFile<TSettings>> OnConfigRead;

		/// <summary>
		/// Reads json-formatted settings from a given path.
		/// If the given path does not exist <paramref name="incompleteSettings"/> is set to <see langword="true"/>
		/// and a default <typeparamref name="TSettings"/> object is returned
		/// </summary>
		/// <param name="path">The path to the file containing the settings</param>
		/// <param name="incompleteSettings">
		/// Whether the config object has any new fields in it, meaning that the config file should be
		/// overwritten.
		/// </param>
		/// <returns>Settings object</returns>
		public virtual TSettings Read(string path, out bool incompleteSettings)
		{
			if (!File.Exists(path))
			{
				incompleteSettings = true;
				return default;
			}
			using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				return Read(fs, out incompleteSettings);
			}
		}

		/// <summary>
		/// Reads json-formatted settings from a given stream
		/// </summary>
		/// <param name="stream">stream</param>
		/// <param name="incompleteSettings">
		/// Whether the config object has any new fields in it, meaning that the config file has to be
		/// overwritten.
		/// </param>
		/// <returns>Settings object</returns>
		public virtual TSettings Read(Stream stream, out bool incompleteSettings)
		{
			using (var sr = new StreamReader(stream))
			{
				return ConvertJson(sr.ReadToEnd(), out incompleteSettings);
			}
		}

		/// <summary>
		/// Converts a json-formatted string into the settings object used by this configuration. Invokes the <see cref="OnConfigRead"/> hook
		/// </summary>
		/// <param name="json">Json string to parse</param>
		/// <param name="incompleteSettings">Whether or not the json string contained an incomplete set of settings</param>
		/// <returns>Settings object</returns>
		public virtual TSettings ConvertJson(string json, out bool incompleteSettings)
		{
			var settings = FileTools.LoadConfigAndCheckForChanges<TSettings>(json, out incompleteSettings);

			Settings = settings;
			OnConfigRead?.Invoke(this);

			return settings;
		}

		/// <summary>
		/// Writes the configuration to a given path
		/// </summary>
		/// <param name="path">The file path the configuration file will be written to</param>
		public virtual void Write(string path)
		{
			using (var fs = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.Write))
			{
				Write(fs);
			}
		}

		/// <summary>
		/// Writes the configuration to a stream
		/// </summary>
		/// <param name="stream">stream</param>
		public virtual void Write(Stream stream)
		{
			var str = JsonConvert.SerializeObject(this, Formatting.Indented);
			using (var sw = new StreamWriter(stream))
			{
				sw.Write(str);
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Configuration/IConfigFile.cs`
```
﻿namespace TShockAPI.Configuration
{
	/// <summary>
	/// Describes a generic configuration interface wrapping some settings
	/// </summary>
	/// <typeparam name="TSettings"></typeparam>
	public interface IConfigFile<TSettings>
	{
		/// <summary>
		/// Settings managed by this config file
		/// </summary>
		TSettings Settings { get; set; }

		/// <summary>
		/// Reads settings from a given path
		/// </summary>
		/// <param name="path">The path to the file containing the settings</param>
		/// <param name="incompleteSettings">
		/// Whether the settings object has any new fields in it, meaning that the configuration should be
		/// overwritten.
		/// </param>
		/// <returns>Settings object</returns>
		TSettings Read(string path, out bool incompleteSettings);
		/// <summary>
		/// Reads settings from a given stream
		/// </summary>
		/// <param name="stream">The stream containing the settings</param>
		/// <param name="incompleteSettings">
		/// Whether the settings object has any new fields in it, meaning that the configuration should be
		/// overwritten.
		/// </param>
		/// <returns>Settings object</returns>
		TSettings Read(System.IO.Stream stream, out bool incompleteSettings);

		/// <summary>
		/// Converts a json-formatted string into the settings object used by this configuration
		/// </summary>
		/// <param name="json">Json string to parse</param>
		/// <param name="incompleteSettings">Whether or not the json string contained an incomplete set of settings</param>
		/// <returns>Settings object</returns>
		TSettings ConvertJson(string json, out bool incompleteSettings);

		/// <summary>
		/// Writes this configuration to a given path
		/// </summary>
		/// <param name="path">File location the configuration will be written to</param>
		void Write(string path);
		/// <summary>
		/// Writes this configuration to a stream
		/// </summary>
		/// <param name="stream">Stream the configuration will be written to</param>
		void Write(System.IO.Stream stream);

	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Configuration/ServerSideConfig.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using Newtonsoft.Json;

namespace TShockAPI.Configuration
{
	/// <summary>
	/// Settings used to configure server side characters
	/// </summary>
	public class SscSettings
	{
		/// <summary>
		/// Enable server side characters, causing client data to be saved on the server instead of the client.
		/// </summary>
		[Description("Enable server side characters, causing client data to be saved on the server instead of the client.")]
		public bool Enabled = false;

		/// <summary>
		/// How often SSC should save, in minutes.
		/// </summary>
		[Description("How often SSC should save, in minutes.")]
		public int ServerSideCharacterSave = 5;

		/// <summary>
		/// Time, in milliseconds, to disallow discarding items after logging in when ServerSideCharacters is ON.
		/// </summary>
		[Description("Time, in milliseconds, to disallow discarding items after logging in when ServerSideCharacters is ON.")]
		public int LogonDiscardThreshold = 250;

		/// <summary>
		/// The starting default health for new players when SSC is enabled.
		/// </summary>
		[Description("The starting default health for new players when SSC is enabled.")]
		public int StartingHealth = 100;

		/// <summary>
		/// The starting default mana for new players when SSC is enabled.
		/// </summary>
		[Description("The starting default mana for new players when SSC is enabled.")]
		public int StartingMana = 20;

		/// <summary>
		/// The starting default inventory for new players when SSC is enabled.
		/// </summary>
		[Description("The starting default inventory for new players when SSC is enabled.")]
		public List<NetItem> StartingInventory = new List<NetItem>();

		/// <summary>
		/// Warns players that they have the bypass SSC permission enabled. To disable warning, turn this off.
		/// </summary>
		[Description("Warns players and the console if a player has the tshock.ignore.ssc permission with data in the SSC table.")]
		public bool WarnPlayersAboutBypassPermission = true;
	}

	/// <summary>
	/// Configuration for the server side characters system
	/// </summary>
	public class ServerSideConfig : ConfigFile<SscSettings>
	{
		/// <summary>
		/// Upgrades the configuration file from the old format if required, then reads and returns the currently configured <see cref="SscSettings"/>
		/// </summary>
		/// <param name="json"></param>
		/// <param name="incompleteSettings"></param>
		/// <returns></returns>
		public override SscSettings ConvertJson(string json, out bool incompleteSettings)
		{
			var settings = FileTools.LoadConfigAndCheckForChanges<SscSettings>(json, out incompleteSettings);

			Settings = settings;
			OnConfigRead?.Invoke(this);

			return settings;
		}

		/// <summary>
		/// Dumps all configuration options to a text file in Markdown format
		/// </summary>
		public static void DumpDescriptions()
		{
			var sb = new StringBuilder();
			var defaults = new SscSettings();

			foreach (var field in defaults.GetType().GetFields().OrderBy(f => f.Name))
			{
				if (field.IsStatic)
					continue;

				var name = field.Name;
				var type = field.FieldType.Name;

				var descattr =
					field.GetCustomAttributes(false).FirstOrDefault(o => o is DescriptionAttribute) as DescriptionAttribute;
				var desc = descattr != null && !string.IsNullOrWhiteSpace(descattr.Description) ? descattr.Description : "None";

				var def = field.GetValue(defaults);

				sb.AppendLine($"## {name}  ");
				sb.AppendLine($"{desc}");
				sb.AppendLine(GetString("* **Field type**: `{0}`", type));
				sb.AppendLine(GetString("* **Default**: `{0}`", def));
				sb.AppendLine();
			}

			File.WriteAllText("docs/ssc-config.md", sb.ToString());
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Configuration/TShockConfig.cs`
```
﻿using Rests;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;

namespace TShockAPI.Configuration
{
	/// <summary>
	/// Settings used in the TShock configuration file
	/// </summary>
	public class TShockSettings
	{

		#region Server Settings

		/// <summary>The server password required to join the server.</summary>
		[Description("The server password required to join the server.")]
		public string ServerPassword = "";

		/// <summary>The port the server runs on.</summary>
		[Description("The port the server runs on.")]
		public int ServerPort = 7777;

		/// <summary>Maximum number of clients connected at once. If lower than Terraria's setting, the server will kick excess connections.</summary>
		[Description("Maximum number of clients connected at once.\nIf you want people to be kicked with \"Server is full\" set this to how many players you want max and then set Terraria max players to 2 higher.")]
		public int MaxSlots = 8;

		/// <summary>The number of reserved slots past your max server slots that can be joined by reserved players.</summary>
		[Description("The number of reserved slots past your max server slots that can be joined by reserved players.")]
		public int ReservedSlots = 20;

		/// <summary>Replaces the world name during a session if UseServerName is true.</summary>
		[Description("Replaces the world name during a session if UseServerName is true.")]
		public string ServerName = "";

		/// <summary>Whether or not to use ServerName in place of the world name.</summary>
		[Description("Whether or not to use ServerName in place of the world name.")]
		public bool UseServerName = false;

		/// <summary>The path to the directory where logs should be written to.</summary>
		[Description("The path to the directory where logs should be written to.")]
		public string LogPath = "tshock/logs";

		/// <summary>Whether or not the server should output debug level messages related to system operation.</summary>
		[Description("Whether or not the server should output debug level messages related to system operation.")]
		public bool DebugLogs = false;

		/// <summary>Prevents users from being able to login before they finish connecting.</summary>
		[Description("Prevents users from being able to login before they finish connecting.")]
		public bool DisableLoginBeforeJoin;

		/// <summary>Allows stacks in chests to go beyond the stack limit during world loading.</summary>
		[Description("Allows stacks in chests to go beyond the stack limit during world loading.")]
		public bool IgnoreChestStacksOnLoad = false;

		/// <summary>Allows changing of the default world tile provider.</summary>
		[Description("Allows changing of the default world tile provider.")]
		public string WorldTileProvider = "default";

		#endregion


		#region Backup and Save Settings

		/// <summary>Enable or disable Terraria's built-in world auto save.</summary>
		[Description("Enable or disable Terraria's built-in world auto save.")]
		public bool AutoSave = true;

		/// <summary>Enable or disable world save announcements.</summary>
		[Description("Enable or disable world save announcements.")]
		public bool AnnounceSave = true;

		/// <summary>Whether or not to show backup auto save messages.</summary>
		[Description("Whether or not to show backup auto save messages.")]
		public bool ShowBackupAutosaveMessages = true;

		/// <summary>The interval between backups, in minutes. Backups are stored in the tshock/backups folder.</summary>
		[Description("The interval between backups, in minutes. Backups are stored in the tshock/backups folder.")]
		public int BackupInterval = 10;

		/// <summary>For how long backups are kept in minutes.</summary>
		[Description("For how long backups are kept in minutes.\neg. 2880 = 2 days.")]
		public int BackupKeepFor = 240;

		/// <summary>Whether or not to save the world if the server crashes from an unhandled exception.</summary>
		[Description("Whether or not to save the world if the server crashes from an unhandled exception.")]
		public bool SaveWorldOnCrash = true;

		/// <summary>Whether or not to save the world when the last player disconnects.</summary>
		[Description("Whether or not to save the world when the last player disconnects.")]
		public bool SaveWorldOnLastPlayerExit = true;

		#endregion


		#region World Settings

		/// <summary>Determines the size of invasion events. The equation for calculating invasion size = 100 + (multiplier * (number of active players > 200 hp)).</summary>
		[Description("Determines the size of invasion events.\nThe equation for calculating invasion size is 100 + (multiplier * (number of active players with greater than 200 health)).")]
		public int InvasionMultiplier = 1;

		/// <summary>The default maximum number of mobs that will spawn per wave. Higher means more mobs in that wave.</summary>
		[Description("The default maximum number of mobs that will spawn per wave. Higher means more mobs in that wave.")]
		public int DefaultMaximumSpawns = 5;

		/// <summary>The delay between waves. Lower values lead to more mobs.</summary>
		[Description("The delay between waves. Lower values lead to more mobs.")]
		public int DefaultSpawnRate = 600;

		/// <summary>Enables never-ending invasion events. You still need to start the event.</summary>
		[Description("Enables never ending invasion events. You still need to start the event, such as with the /invade command.")]
		public bool InfiniteInvasion;

		/// <summary>Sets the PvP mode. Valid types are: "normal", "always", "pvpwithnoteam", "disabled".</summary>
		[Description("Sets the PvP mode. Valid types are: \"normal\", \"always\", \"pvpwithnoteam\" and \"disabled\".")]
		public string PvPMode = "normal";

		/// <summary>Prevents tiles from being placed within SpawnProtectionRadius of the default spawn.</summary>
		[Description("Prevents tiles from being placed within SpawnProtectionRadius of the default spawn.")]
		public bool SpawnProtection = true;

		/// <summary>The tile radius around the spawn tile that is protected by the SpawnProtection setting.</summary>
		[Description("The tile radius around the spawn tile that is protected by the SpawnProtection setting.")]
		public int SpawnProtectionRadius = 10;

		/// <summary>Enable or disable anti-cheat range checks based on distance between the player and their block placements.</summary>
		[Description("Enable or disable anti-cheat range checks based on distance between the player and their block placements.")]
		public bool RangeChecks = true;

		/// <summary>Prevents non-hardcore players from connecting.</summary>
		[Description("Prevents non-hardcore players from connecting.")]
		public bool HardcoreOnly;

		/// <summary>Prevents softcore players from connecting.</summary>
		[Description("Prevents softcore players from connecting.")]
		public bool MediumcoreOnly;

		/// <summary>Prevents non-softcore players from connecting.</summary>
		[Description("Prevents non-softcore players from connecting.")]
		public bool SoftcoreOnly;

		/// <summary>Disables any placing, or removal of blocks.</summary>
		[Description("Disables any placing, or removal of blocks.")]
		public bool DisableBuild;

		/// <summary>If enabled, hardmode will not be activated by the Wall of Flesh or the /starthardmode command.</summary>
		[Description("If enabled, hardmode will not be activated by the Wall of Flesh or the /starthardmode command.")]
		public bool DisableHardmode;

		/// <summary>Prevents the dungeon guardian from being spawned while sending players to their spawn point instead.</summary>
		[Description("Prevents the dungeon guardian from being spawned while sending players to their spawn point instead.")]
		public bool DisableDungeonGuardian;

		/// <summary>Disables clown bomb projectiles from spawning.</summary>
		[Description("Disables clown bomb projectiles from spawning.")]
		public bool DisableClownBombs;

		/// <summary>Disables snow ball projectiles from spawning.</summary>
		[Description("Disables snow ball projectiles from spawning.")]
		public bool DisableSnowBalls;

		/// <summary>Disables tombstone dropping during death for all players.</summary>
		[Description("Disables tombstone dropping during death for all players.")]
		public bool DisableTombstones = true;

		/// <summary>
		/// Disables Skeletron Prime Bombs from spawning, useful for preventing unwanted world destruction on for the worthy seed world.
		/// </summary>
		[Description("Disables Skeletron Prime Bombs from spawning, useful for preventing unwanted world destruction on for the worthy seed world.")]
		public bool DisablePrimeBombs;

		/// <summary>Forces the world time to be normal, day, or night.</summary>
		[Description("Forces the world time to be normal, day, or night.")]
		public string ForceTime = "normal";

		/// <summary>Disables the effect of invisibility potions while PvP is enabled by turning the player visible to the other clients.</summary>
		[Description("Disables the effect of invisibility potions while PvP is enabled by turning the player visible to the other clients.")]
		public bool DisableInvisPvP;

		/// <summary>The maximum distance, in tiles, that disabled players can move from.</summary>
		[Description("The maximum distance, in tiles, that disabled players can move from.")]
		public int MaxRangeForDisabled = 10;

		/// <summary>Whether or not region protection should apply to chests.</summary>
		[Description("Whether or not region protection should apply to chests.")]
		public bool RegionProtectChests;

		/// <summary>Whether or not region protection should apply to gem locks.</summary>
		[Description("Whether or not region protection should apply to gem locks.")]
		public bool RegionProtectGemLocks = true;

		/// <summary>Ignores checks to see if a player 'can' update a projectile.</summary>
		[Description("Ignores checks to see if a player 'can' update a projectile.")]
		public bool IgnoreProjUpdate = false;

		/// <summary>Ignores checks to see if a player 'can' kill a projectile.</summary>
		[Description("Ignores checks to see if a player 'can' kill a projectile.")]
		public bool IgnoreProjKill = false;

		/// <summary>Allows players to break temporary tiles (grass, pots, etc) where they cannot usually build.</summary>
		[Description("Allows players to break temporary tiles (grass, pots, etc) where they cannot usually build.")]
		public bool AllowCutTilesAndBreakables = false;

		/// <summary>Allows ice placement even where a user cannot usually build.</summary>
		[Description("Allows ice placement even where a user cannot usually build.")]
		public bool AllowIce = false;

		/// <summary>Allows the crimson to spread when a world is in hardmode.</summary>
		[Description("Allows the crimson to spread when a world is in hardmode.")]
		public bool AllowCrimsonCreep = true;

		/// <summary>Allows the corruption to spread when a world is in hardmode.</summary>
		[Description("Allows the corruption to spread when a world is in hardmode.")]
		public bool AllowCorruptionCreep = true;

		/// <summary>Allows the hallow to spread when a world is in hardmode.</summary>
		[Description("Allows the hallow to spread when a world is in hardmode.")]
		public bool AllowHallowCreep = true;

		/// <summary>How many NPCs a statue can spawn within 200 pixels(?) before it stops spawning.</summary>
		[Description("How many NPCs a statue can spawn within 200 pixels(?) before it stops spawning.\nDefault = 3.")]
		public int StatueSpawn200 = 3;

		/// <summary>How many NPCs a statue can spawn within 600 pixels(?) before it stops spawning.</summary>
		[Description("How many NPCs a statue can spawn within 600 pixels(?) before it stops spawning.\nDefault = 6.")]
		public int StatueSpawn600 = 6;

		/// <summary>How many NPCs a statue can spawn before it stops spawning.</summary>
		[Description("How many NPCs a statue can spawn before it stops spawning.\nDefault = 10.")]
		public int StatueSpawnWorld = 10;

		/// <summary>Prevent banned items from being spawned or given with commands.</summary>
		[Description("Prevent banned items from being spawned or given with commands.")]
		public bool PreventBannedItemSpawn = false;

		/// <summary>Prevent players from interacting with the world while they are dead.</summary>
		[Description("Prevent players from interacting with the world while they are dead.")]
		public bool PreventDeadModification = true;

		/// <summary>Prevents players from placing tiles with an invalid style.</summary>
		[Description("Prevents players from placing tiles with an invalid style.")]
		public bool PreventInvalidPlaceStyle = true;

		/// <summary>Forces Christmas-only events to occur all year.</summary>
		[Description("Forces Christmas-only events to occur all year.")]
		public bool ForceXmas = false;

		/// <summary>Forces Halloween-only events to occur all year.</summary>
		[Description("Forces Halloween-only events to occur all year.")]
		public bool ForceHalloween = false;

		/// <summary>Allows groups on the banned item allowed list to spawn banned items even if PreventBannedItemSpawn is set to true.</summary>
		[Description("Allows groups on the banned item allowed list to spawn banned items even if PreventBannedItemSpawn is set to true.")]
		public bool AllowAllowedGroupsToSpawnBannedItems = false;

		/// <summary>The number of seconds a player must wait before being respawned. Valid range: 0 (default) to 15 seconds. Use at your own risk.</summary>
		[Description("The number of seconds a player must wait before being respawned. Valid range: 0 (default) to 15 seconds. Use at your own risk.")]
		public int RespawnSeconds = 0;

		/// <summary>The number of seconds a player must wait before being respawned if there is a boss nearby. Valid range: 0 (default) to 30 seconds. Use at your own risk.</summary>
		[Description("The number of seconds a player must wait before being respawned if there is a boss nearby. Valid range: 0 (default) to 30 seconds. Use at your own risk.")]
		public int RespawnBossSeconds = 0;

		/// <summary>Whether or not to announce boss spawning or invasion starts.</summary>
		[Description("Whether or not to announce boss spawning or invasion starts.")]
		public bool AnonymousBossInvasions = true;

		/// <summary>The maximum HP a player can have, before equipment buffs.</summary>
		[Description("The maximum HP a player can have, before equipment buffs.")]
		public int MaxHP = 500;

		/// <summary>The maximum MP a player can have, before equipment buffs.</summary>
		[Description("The maximum MP a player can have, before equipment buffs.")]
		public int MaxMP = 200;

		/// <summary>Determines the range in tiles that a bomb can affect tiles from detonation point.</summary>
		[Description("Determines the range in tiles that a bomb can affect tiles from detonation point.")]
		public int BombExplosionRadius = 5;

		/// <summary>If set to true, items given to players will be inserted directly into their inventory. Requires SSC. Otherwise, items given to players will spawn as dropped items.</summary>
		[Description("If set to true, items given to players will be inserted directly into their inventory. Requires SSC. Otherwise, items given to players will spawn as dropped items. Experimental feature. May not work correctly or result in item loss.")]
		public bool GiveItemsDirectly = false;

		#endregion


		#region Login and Ban Settings

		/// <summary>The default group name to place newly registered users under.</summary>
		[Description("The default group name to place newly registered users under.")]
		public string DefaultRegistrationGroupName = "default";

		/// <summary>The default group name to place unregistered players under.</summary>
		[Description("The default group name to place unregistered players under.")]
		public string DefaultGuestGroupName = "guest";

		/// <summary>Remembers where a player left off, based on their IP. Does not persist through server restarts.</summary>
		[Description("Remembers where a player left off, based on their IP. Does not persist through server restarts.\neg. When you try to disconnect, and reconnect to be automatically placed at spawn, you'll be at your last location.")]
		public bool RememberLeavePos;

		/// <summary>Number of failed login attempts before kicking the player.</summary>
		[Description("Number of failed login attempts before kicking the player.")]
		public int MaximumLoginAttempts = 3;

		/// <summary>Whether or not to kick mediumcore players on death.</summary>
		[Description("Whether or not to kick mediumcore players on death.")]
		public bool KickOnMediumcoreDeath;

		/// <summary>The reason given if kicking a mediumcore players on death.</summary>
		[Description("The reason given if kicking a mediumcore players on death.")]
		public string MediumcoreKickReason = "Death results in a kick";

		/// <summary>Whether or not to ban mediumcore players on death.</summary>
		[Description("Whether or not to ban mediumcore players on death.")]
		public bool BanOnMediumcoreDeath;

		/// <summary>The reason given if banning a mediumcore player on death.</summary>
		[Description("The reason given if banning a mediumcore player on death.")]
		public string MediumcoreBanReason = GetString("Death results in a ban");

		/// <summary>Disables IP bans by default, if no arguments are passed to the ban command.</summary>
		[Description("Disables IP bans by default, if no arguments are passed to the ban command.")]
		public bool DisableDefaultIPBan;

		/// <summary>Enable or disable the whitelist based on IP addresses in the whitelist.txt file.</summary>
		[Description("Enable or disable the whitelist based on IP addresses in the whitelist.txt file.")]
		public bool EnableWhitelist;

		/// <summary>The reason given when kicking players for not being on the whitelist.</summary>
		[Description("The reason given when kicking players for not being on the whitelist.")]
		public string WhitelistKickReason = GetString("You are not on the whitelist.");

		/// <summary>The reason given when kicking players that attempt to join while the server is full.</summary>
		[Description("The reason given when kicking players that attempt to join while the server is full.")]
		public string ServerFullReason = GetString("Server is full");

		/// <summary>The reason given when kicking players that attempt to join while the server is full with no reserved slots available.</summary>
		[Description("The reason given when kicking players that attempt to join while the server is full with no reserved slots available.")]
		public string ServerFullNoReservedReason = GetString("Server is full. No reserved slots open.");

		/// <summary>Whether or not to kick hardcore players on death.</summary>
		[Description("Whether or not to kick hardcore players on death.")]
		public bool KickOnHardcoreDeath;

		/// <summary>The reason given when kicking hardcore players on death.</summary>
		[Description("The reason given when kicking hardcore players on death.")]
		public string HardcoreKickReason = GetString("Death results in a kick");

		/// <summary>Whether or not to ban hardcore players on death.</summary>
		[Description("Whether or not to ban hardcore players on death.")]
		public bool BanOnHardcoreDeath;

		/// <summary>The reason given when banning hardcore players on death.</summary>
		[Description("The reason given when banning hardcore players on death.")]
		public string HardcoreBanReason = GetString("Death results in a ban");

		/// <summary>If GeoIP is enabled, this will kick users identified as being under a proxy.</summary>
		[Description("If GeoIP is enabled, this will kick users identified as being under a proxy.")]
		public bool KickProxyUsers = true;

		/// <summary>Require all players to register or login before being allowed to play.</summary>
		[Description("Require all players to register or login before being allowed to play.")]
		public bool RequireLogin;

		/// <summary>Allows users to login to any account even if the username doesn't match their character name.</summary>
		[Description("Allows users to login to any account even if the username doesn't match their character name.")]
		public bool AllowLoginAnyUsername = true;

		/// <summary>Allows users to register a username that doesn't necessarily match their character name.</summary>
		[Description("Allows users to register a username that doesn't necessarily match their character name.")]
		public bool AllowRegisterAnyUsername;

		/// <summary>The minimum password length for new user accounts. Can never be lower than 4.</summary>
		[Description("The minimum password length for new user accounts. Can never be lower than 4.")]
		public int MinimumPasswordLength = 4;

		/// <summary>Determines the BCrypt work factor to use. If increased, all passwords will be upgraded to new work-factor on verify.
		/// The number of computational rounds is 2^n. Increase with caution. Range: 5-31.</summary>
		[Description("Determines the BCrypt work factor to use. If increased, all passwords will be upgraded to new work-factor on verify. The number of computational rounds is 2^n. Increase with caution. Range: 5-31.")]
		public int BCryptWorkFactor = 7;

		/// <summary>Prevents users from being able to login with their client UUID.</summary>
		[Description("Prevents users from being able to login with their client UUID.")]
		public bool DisableUUIDLogin;

		/// <summary>Kick clients that don't send their UUID to the server.</summary>
		[Description("Kick clients that don't send their UUID to the server.")]
		public bool KickEmptyUUID;

		/// <summary>Disables a player if this number of tiles is painted within 1 second.</summary>
		[Description("Disables a player if this number of tiles is painted within 1 second.")]
		public int TilePaintThreshold = 15;

		/// <summary>Whether or not to kick users when they surpass the TilePaint threshold.</summary>
		[Description("Whether or not to kick users when they surpass the TilePaint threshold.")]
		public bool KickOnTilePaintThresholdBroken = false;

		/// <summary>The maximum damage a player/NPC can inflict.</summary>
		[Description("The maximum damage a player/NPC can inflict.")]
		public int MaxDamage = 1175;

		/// <summary>The maximum damage a projectile can inflict.</summary>
		[Description("The maximum damage a projectile can inflict.")]
		public int MaxProjDamage = 1175;

		/// <summary>Whether or not to kick users when they surpass the MaxDamage threshold.</summary>
		[Description("Whether or not to kick users when they surpass the MaxDamage threshold.")]
		public bool KickOnDamageThresholdBroken = false;

		/// <summary>Disables a player and reverts their actions if this number of tile kills is exceeded within 1 second.</summary>
		[Description("Disables a player and reverts their actions if this number of tile kills is exceeded within 1 second.")]
		public int TileKillThreshold = 60;

		/// <summary>Whether or not to kick users when they surpass the TileKill threshold.</summary>
		[Description("Whether or not to kick users when they surpass the TileKill threshold.")]
		public bool KickOnTileKillThresholdBroken = false;

		/// <summary>Disables a player and reverts their actions if this number of tile places is exceeded within 1 second.</summary>
		[Description("Disables a player and reverts their actions if this number of tile places is exceeded within 1 second.")]
		public int TilePlaceThreshold = 32;

		/// <summary>Whether or not to kick users when they surpass the TilePlace threshold.</summary>
		[Description("Whether or not to kick users when they surpass the TilePlace threshold.")]
		public bool KickOnTilePlaceThresholdBroken = false;

		/// <summary>Disables a player if this number of liquid sets is exceeded within 1 second.</summary>
		[Description("Disables a player if this number of liquid sets is exceeded within 1 second.")]
		public int TileLiquidThreshold = 50;

		/// <summary>Whether or not to kick users when they surpass the TileLiquid threshold.</summary>
		[Description("Whether or not to kick users when they surpass the TileLiquid threshold.")]
		public bool KickOnTileLiquidThresholdBroken = false;

		/// <summary>Whether or not to ignore shrapnel from crystal bullets for the projectile threshold count.</summary>
		[Description("Whether or not to ignore shrapnel from crystal bullets for the projectile threshold count.")]
		public bool ProjIgnoreShrapnel = true;

		/// <summary>Disable a player if this number of projectiles is created within 1 second.</summary>
		[Description("Disable a player if this number of projectiles is created within 1 second.")]
		public int ProjectileThreshold = 50;

		/// <summary>Whether or not to kick users when they surpass the Projectile threshold.</summary>
		[Description("Whether or not to kick users when they surpass the Projectile threshold.")]
		public bool KickOnProjectileThresholdBroken = false;

		/// <summary>Disables a player if this number of HealOtherPlayer packets is sent within 1 second.</summary>
		[Description("Disables a player if this number of HealOtherPlayer packets is sent within 1 second.")]
		public int HealOtherThreshold = 50;

		/// <summary>Whether or not to kick users when they surpass the HealOther threshold.</summary>
		[Description("Whether or not to kick users when they surpass the HealOther threshold.")]
		public bool KickOnHealOtherThresholdBroken = false;

		/// <summary>Whether or not the server should suppress build permission failure warnings from regions, spawn point, or server edit failure.</summary>
		[Description("Whether or not the server should suppress build permission failure warnings from regions, spawn point, or server edit failure.")]
		public bool SuppressPermissionFailureNotices = false;

		/// <summary>Prohibit the use of Zenith projectile with different objects instead of weapons.</summary>
		[Description("Prohibit the use of Zenith projectile with different objects instead of weapons.")]
		public bool DisableModifiedZenith = false;

		/// <summary>Allows you to disable or enable protection against creating custom messages with death. Created for developers who came up with a more original solution to this problem.</summary>
		[Description("Allows you to disable or enable protection against creating custom messages with death. Created for developers who came up with a more original solution to this problem.")]
		public bool DisableCustomDeathMessages = true;
		#endregion


		#region Chat Settings

		/// <summary>Specifies which string starts a command.
		/// Note: Will not function properly if the string length is bigger than 1.</summary>
		[Description("Specifies which string starts a command.\nNote: Will not function properly if the string length is bigger than 1.")]
		public string CommandSpecifier = "/";

		/// <summary>Specifies which string starts a command silently.
		/// Note: Will not function properly if the string length is bigger than 1.</summary>
		[Description("Specifies which string starts a command silently.\nNote: Will not function properly if the string length is bigger than 1.")]
		public string CommandSilentSpecifier = ".";

		/// <summary>Disables sending logs as messages to players with the log permission.</summary>
		[Description("Disables sending logs as messages to players with the log permission.")]
		public bool DisableSpewLogs = true;

		/// <summary>Prevents OnSecondUpdate checks from writing to the log file.</summary>
		[Description("Prevents OnSecondUpdate checks from writing to the log file.")]
		public bool DisableSecondUpdateLogs = false;

		/// <summary>The chat color for the superadmin group.</summary>
		[Description("The chat color for the superadmin group.\n#.#.# = Red/Blue/Green\nMax value: 255")]
		public int[] SuperAdminChatRGB = { 255, 255, 255 };

		/// <summary>The superadmin chat prefix.</summary>
		[Description("The superadmin chat prefix.")]
		public string SuperAdminChatPrefix = GetString("(Super Admin) ");

		/// <summary>The superadmin chat suffix.</summary>
		[Description("The superadmin chat suffix.")]
		public string SuperAdminChatSuffix = "";

		/// <summary>Whether or not to announce a player's geographic location on join, based on their IP.</summary>
		[Description("Whether or not to announce a player's geographic location on join, based on their IP.")]
		public bool EnableGeoIP;

		/// <summary>Displays a player's IP on join to users with the log permission.</summary>
		[Description("Displays a player's IP on join to users with the log permission.")]
		public bool DisplayIPToAdmins;

		/// <summary>Changes in-game chat format: {0} = Group Name, {1} = Group Prefix, {2} = Player Name, {3} = Group Suffix, {4} = Chat Message.</summary>
		[Description("Changes in-game chat format: {0} = Group Name, {1} = Group Prefix, {2} = Player Name, {3} = Group Suffix, {4} = Chat Message.")]
		public string ChatFormat = "{1}{2}{3}: {4}";

		/// <summary>Changes the player name when using chat above heads. Starts with a player name wrapped in brackets, as per Terraria's formatting.\nSame formatting as ChatFormat without the message.</summary>
		[Description("Changes the player name when using chat above heads. Starts with a player name wrapped in brackets, as per Terraria's formatting.\nSame formatting as ChatFormat without the message.")]
		public string ChatAboveHeadsFormat = "{2}";

		/// <summary>Whether or not to display chat messages above players' heads.</summary>
		[Description("Whether or not to display chat messages above players' heads.")]
		public bool EnableChatAboveHeads = false;

		/// <summary>The RGB values used for the color of broadcast messages.</summary>
		[Description("The RGB values used for the color of broadcast messages.\n#.#.# = Red/Blue/Green\nMax value: 255")]
		public int[] BroadcastRGB = { 127, 255, 212 };

		#endregion


		#region MySQL Settings

		/// <summary>The type of database to use when storing data (either "sqlite" or "mysql").</summary>
		[Description("The type of database to use when storing data (either \"sqlite\" or \"mysql\").")]
		public string StorageType = "sqlite";

		/// <summary>The path of sqlite db.</summary>
		[Description("The path of sqlite db.")]
		public string SqliteDBPath = "tshock.sqlite";

		/// <summary>The MySQL hostname and port to direct connections to.</summary>
		[Description("The MySQL hostname and port to direct connections to.")]
		public string MySqlHost = "localhost:3306";

		/// <summary>The database name to connect to when using MySQL as the database type.</summary>
		[Description("The database name to connect to when using MySQL as the database type.")]
		public string MySqlDbName = "";

		/// <summary>The username used when connecting to a MySQL database.</summary>
		[Description("The username used when connecting to a MySQL database.")]
		public string MySqlUsername = "";

		/// <summary>The password used when connecting to a MySQL database.</summary>
		[Description("The password used when connecting to a MySQL database.")]
		public string MySqlPassword = "";

		/// <summary>Whether or not to save logs to the SQL database instead of a text file.</summary>
		[Description("Whether or not to save logs to the SQL database instead of a text file.\nDefault = false.")]
		public bool UseSqlLogs = false;

		/// <summary>Number of times the SQL log must fail to insert logs before falling back to the text log.</summary>
		[Description("Number of times the SQL log must fail to insert logs before falling back to the text log.")]
		public int RevertToTextLogsOnSqlFailures = 10;

		#endregion


		#region REST API Settings

		/// <summary>Enable or disable the REST API.</summary>
		[Description("Enable or disable the REST API.")]
		public bool RestApiEnabled;

		/// <summary>The port used by the REST API.</summary>
		[Description("The port used by the REST API.")]
		public int RestApiPort = 7878;

		/// <summary>Whether or not to log REST API connections.</summary>
		[Description("Whether or not to log REST API connections.")]
		public bool LogRest = false;

		/// <summary>Whether or not to require token authentication to use the public REST API endpoints.</summary>
		[Description("Whether or not to require token authentication to use the public REST API endpoints.")]
		public bool EnableTokenEndpointAuthentication;

		/// <summary>The maximum REST requests in the bucket before denying requests. Minimum value is 5.</summary>
		[Description("The maximum REST requests in the bucket before denying requests. Minimum value is 5.")]
		public int RESTMaximumRequestsPerInterval = 5;

		/// <summary>How often in minutes the REST requests bucket is decreased by one. Minimum value is 1 minute.</summary>
		[Description("How often in minutes the REST requests bucket is decreased by one. Minimum value is 1 minute.")]
		public int RESTRequestBucketDecreaseIntervalMinutes = 1;

		/// <summary>A dictionary of REST tokens that external applications may use to make queries to your server.</summary>
		[Description("A dictionary of REST tokens that external applications may use to make queries to your server.")]
		public Dictionary<string, SecureRest.TokenData> ApplicationRestTokens = new Dictionary<string, SecureRest.TokenData>();

		#endregion
	}

	/// <summary>
	/// TShock's configuration file
	/// </summary>
	public class TShockConfig : ConfigFile<TShockSettings>
	{
		/// <summary>
		/// Upgrades the configuration file from the old format if required, then reads and returns the currently configured <see cref="TShockSettings"/>
		/// </summary>
		/// <param name="json"></param>
		/// <param name="incompleteSettings"></param>
		/// <returns></returns>
		public override TShockSettings ConvertJson(string json, out bool incompleteSettings)
		{
			var settings = FileTools.LoadConfigAndCheckForChanges<TShockSettings>(json, out incompleteSettings);

			Settings = settings;
			OnConfigRead?.Invoke(this);

			return settings;
		}

		/// <summary>
		/// Dumps all configuration options to a text file in Markdown format
		/// </summary>
		public static void DumpDescriptions()
		{
			var sb = new StringBuilder();
			var defaults = new TShockSettings();

			foreach (var field in defaults.GetType().GetFields().OrderBy(f => f.Name))
			{
				if (field.IsStatic)
					continue;

				var name = field.Name;
				var type = field.FieldType.Name;

				var descattr =
					field.GetCustomAttributes(false).FirstOrDefault(o => o is DescriptionAttribute) as DescriptionAttribute;
				var desc = descattr != null && !string.IsNullOrWhiteSpace(descattr.Description) ? descattr.Description : "None";

				var def = field.GetValue(defaults);

				sb.AppendLine($"## {name}  ");
				sb.AppendLine($"{desc}");
				sb.AppendLine(GetString("* **Field type**: `{0}`", type));
				sb.AppendLine(GetString("* **Default**: `{0}`", def));
				sb.AppendLine();
			}

			File.WriteAllText("docs/config-file-descriptions.md", sb.ToString());
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/DB`
#### File: `temp_TShock-5.2.4/TShockAPI/DB/BanManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Linq;
using System.Collections.Generic;
using System.Data;
using MySql.Data.MySqlClient;
using System.Collections.ObjectModel;

namespace TShockAPI.DB
{
	/// <summary>
	/// Class that manages bans.
	/// </summary>
	public class BanManager
	{
		private IDbConnection database;

		private Dictionary<int, Ban> _bans;

		/// <summary>
		/// Readonly dictionary of Bans, keyed on ban ticket number.
		/// </summary>
		public ReadOnlyDictionary<int, Ban> Bans => new ReadOnlyDictionary<int, Ban>(_bans);

		/// <summary>
		/// Event invoked when a ban is checked for validity
		/// </summary>
		public static event EventHandler<BanEventArgs> OnBanValidate;
		/// <summary>
		/// Event invoked before a ban is added
		/// </summary>
		public static event EventHandler<BanPreAddEventArgs> OnBanPreAdd;
		/// <summary>
		/// Event invoked after a ban is added
		/// </summary>
		public static event EventHandler<BanEventArgs> OnBanPostAdd;

		/// <summary>
		/// Initializes a new instance of the <see cref="TShockAPI.DB.BanManager"/> class.
		/// </summary>
		/// <param name="db">A valid connection to the TShock database</param>
		public BanManager(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("PlayerBans",
									new SqlColumn("TicketNumber", MySqlDbType.Int32) { Primary = true, AutoIncrement = true },
									new SqlColumn("Identifier", MySqlDbType.Text),
									new SqlColumn("Reason", MySqlDbType.Text),
									new SqlColumn("BanningUser", MySqlDbType.Text),
									new SqlColumn("Date", MySqlDbType.Int64),
									new SqlColumn("Expiration", MySqlDbType.Int64)
				);
			var creator = new SqlTableCreator(db,
				db.GetSqlType() == SqlType.Sqlite
					? (IQueryBuilder)new SqliteQueryCreator()
					: new MysqlQueryCreator());
			try
			{
				creator.EnsureTableStructure(table);
			}
			catch (DllNotFoundException)
			{
				System.Console.WriteLine(GetString("Possible problem with your database - is Sqlite3.dll present?"));
				throw new Exception(GetString("Could not find a database library (probably Sqlite3.dll)"));
			}

			EnsureBansCollection();
			TryConvertBans();

			OnBanValidate += BanValidateCheck;
			OnBanPreAdd += BanAddedCheck;
		}

		/// <summary>
		/// Ensures the <see cref="_bans"/> collection is ready to use.
		/// </summary>
		private void EnsureBansCollection()
		{
			if (_bans == null)
			{
				_bans = RetrieveAllBans().ToDictionary(b => b.TicketNumber);
			}
		}

		/// <summary>
		/// Converts bans from the old ban system to the new.
		/// </summary>
		public void TryConvertBans()
		{
			int res;
			if (database.GetSqlType() == SqlType.Mysql)
			{
				res = database.QueryScalar<int>("SELECT COUNT(table_name) FROM information_schema.tables WHERE table_schema = @0 and table_name = 'Bans'", TShock.Config.Settings.MySqlDbName);
			}
			else
			{
				res = database.QueryScalar<int>("SELECT COUNT(name) FROM sqlite_master WHERE type='table' AND name = 'Bans'");
			}

			if (res != 0)
			{
				var bans = new List<BanPreAddEventArgs>();
				using (var reader = database.QueryReader("SELECT * FROM Bans"))
				{
					while (reader.Read())
					{
						var ip = reader.Get<string>("IP");
						var uuid = reader.Get<string>("UUID");
						var account = reader.Get<string>("AccountName");
						var reason = reader.Get<string>("Reason");
						var banningUser = reader.Get<string>("BanningUser");
						var date = reader.Get<string>("Date");
						var expiration = reader.Get<string>("Expiration");

						if (!DateTime.TryParse(date, out DateTime start))
						{
							start = DateTime.UtcNow;
						}

						if (!DateTime.TryParse(expiration, out DateTime end))
						{
							end = DateTime.MaxValue;
						}

						if (!string.IsNullOrWhiteSpace(ip))
						{
							bans.Add(new BanPreAddEventArgs
							{
								Identifier = $"{Identifier.IP}{ip}",
								Reason = reason,
								BanningUser = banningUser,
								BanDateTime = start,
								ExpirationDateTime = end
							});
						}

						if (!string.IsNullOrWhiteSpace(account))
						{
							bans.Add(new BanPreAddEventArgs
							{
								Identifier = $"{Identifier.Account}{account}",
								Reason = reason,
								BanningUser = banningUser,
								BanDateTime = start,
								ExpirationDateTime = end
							});
						}

						if (!string.IsNullOrWhiteSpace(uuid))
						{
							bans.Add(new BanPreAddEventArgs
							{
								Identifier = $"{Identifier.UUID}{uuid}",
								Reason = reason,
								BanningUser = banningUser,
								BanDateTime = start,
								ExpirationDateTime = end
							});
						}
					}
				}

				foreach (var ban in bans)
					InsertBan(ban);

				database.Query("DROP TABLE Bans");
			}
		}

		internal bool CheckBan(TSPlayer player)
		{
			List<string> identifiers = new List<string>
			{
				$"{Identifier.Name}{player.Name}",
				$"{Identifier.IP}{player.IP}"
			};

			if (player.UUID != null && player.UUID.Length > 0)
			{
				identifiers.Add($"{Identifier.UUID}{player.UUID}");
			}

			if (player.Account != null)
			{
				identifiers.Add($"{Identifier.Account}{player.Account.Name}");
			}

			Ban ban = TShock.Bans.Bans.FirstOrDefault(b => identifiers.Contains(b.Value.Identifier) && TShock.Bans.IsValidBan(b.Value, player)).Value;

			if (ban != null)
			{
				if (ban.ExpirationDateTime == DateTime.MaxValue)
				{
					player.Disconnect(GetParticularString("{0} is ban number, {1} is ban reason", $"#{ban.TicketNumber} - You are banned: {ban.Reason}"));
					return true;
				}

				TimeSpan ts = ban.ExpirationDateTime - DateTime.UtcNow;
				player.Disconnect(GetParticularString("{0} is ban number, {1} is ban reason, {2} is a timestamp", $"#{ban.TicketNumber} - You are banned: {ban.Reason} ({ban.GetPrettyExpirationString()} remaining)"));
				return true;
			}

			return false;
		}

		/// <summary>
		/// Determines whether or not a ban is valid
		/// </summary>
		/// <param name="ban"></param>
		/// <param name="player"></param>
		/// <returns></returns>
		public bool IsValidBan(Ban ban, TSPlayer player)
		{
			BanEventArgs args = new BanEventArgs
			{
				Ban = ban,
				Player = player
			};

			OnBanValidate?.Invoke(this, args);

			return args.Valid;
		}

		internal void BanValidateCheck(object sender, BanEventArgs args)
		{
			//Only perform validation if the event has not been cancelled before we got here
			if (args.Valid)
			{
				//We consider a ban to be valid if the start time is before now and the end time is after now
				args.Valid = (DateTime.UtcNow > args.Ban.BanDateTime && DateTime.UtcNow < args.Ban.ExpirationDateTime);
			}
		}

		internal void BanAddedCheck(object sender, BanPreAddEventArgs args)
		{
			//Only perform validation if the event has not been cancelled before we got here
			if (args.Valid)
			{
				//We consider a ban valid to add if no other *current* bans exist for the identifier provided.
				//E.g., if a previous ban has expired, a new ban is valid.
				//However, if a previous ban on the provided identifier is still in effect, a new ban is not valid
				args.Valid = !Bans.Any(b => b.Value.Identifier == args.Identifier && b.Value.ExpirationDateTime > DateTime.UtcNow);
				args.Message = args.Valid ? null : GetString("The ban is invalid because a current ban for this identifier already exists.");
			}
		}

		/// <summary>
		/// Adds a new ban for the given identifier. Returns a Ban object if the ban was added, else null
		/// </summary>
		/// <param name="identifier"></param>
		/// <param name="reason"></param>
		/// <param name="banningUser"></param>
		/// <param name="fromDate"></param>
		/// <param name="toDate"></param>
		/// <returns></returns>
		public AddBanResult InsertBan(string identifier, string reason, string banningUser, DateTime fromDate, DateTime toDate)
		{
			BanPreAddEventArgs args = new BanPreAddEventArgs
			{
				Identifier = identifier,
				Reason = reason,
				BanningUser = banningUser,
				BanDateTime = fromDate,
				ExpirationDateTime = toDate
			};
			return InsertBan(args);
		}

		/// <summary>
		/// Adds a new ban for the given data. Returns a Ban object if the ban was added, else null
		/// </summary>
		/// <param name="args">A predefined instance of <see cref="BanPreAddEventArgs"/></param>
		/// <returns></returns>
		public AddBanResult InsertBan(BanPreAddEventArgs args)
		{
			OnBanPreAdd?.Invoke(this, args);

			if (!args.Valid)
			{
				string message = args.Message ?? GetString("The ban was not valid for an unknown reason.");
				return new AddBanResult { Message = message };
			}

			string query = "INSERT INTO PlayerBans (Identifier, Reason, BanningUser, Date, Expiration) VALUES (@0, @1, @2, @3, @4);";

			if (database.GetSqlType() == SqlType.Mysql)
			{
				query += "SELECT LAST_INSERT_ID();";
			}
			else
			{
				query += "SELECT CAST(last_insert_rowid() as INT);";
			}

			int ticketId = database.QueryScalar<int>(query, args.Identifier, args.Reason, args.BanningUser, args.BanDateTime.Ticks, args.ExpirationDateTime.Ticks);

			if (ticketId == 0)
			{
				return new AddBanResult { Message = GetString("Inserting the ban into the database failed.") };
			}

			Ban b = new Ban(ticketId, args.Identifier, args.Reason, args.BanningUser, args.BanDateTime, args.ExpirationDateTime);
			_bans.Add(ticketId, b);

			OnBanPostAdd?.Invoke(this, new BanEventArgs { Ban = b });

			return new AddBanResult { Ban = b };
		}

		/// <summary>
		/// Attempts to remove a ban. Returns true if the ban was removed or expired. False if the ban could not be removed or expired
		/// </summary>
		/// <param name="ticketNumber">The ticket number of the ban to change</param>
		/// <param name="fullDelete">If true, deletes the ban from the database. If false, marks the expiration time as now, rendering the ban expired. Defaults to false</param>
		/// <returns></returns>
		public bool RemoveBan(int ticketNumber, bool fullDelete = false)
		{
			int rowsModified;
			if (fullDelete)
			{
				rowsModified = database.Query("DELETE FROM PlayerBans WHERE TicketNumber=@0", ticketNumber);
				_bans.Remove(ticketNumber);
			}
			else
			{
				rowsModified = database.Query("UPDATE PlayerBans SET Expiration=@0 WHERE TicketNumber=@1", DateTime.UtcNow.Ticks, ticketNumber);
				_bans[ticketNumber].ExpirationDateTime = DateTime.UtcNow;
			}

			return rowsModified > 0;
		}

		/// <summary>
		/// Retrieves a single ban from a ban's ticket number
		/// </summary>
		/// <param name="id"></param>
		/// <returns></returns>
		public Ban GetBanById(int id)
		{
			if (Bans.ContainsKey(id))
			{
				return Bans[id];
			}

			using (var reader = database.QueryReader("SELECT * FROM PlayerBans WHERE TicketNumber=@0", id))
			{
				if (reader.Read())
				{
					var ticketNumber = reader.Get<int>("TicketNumber");
					var identifier = reader.Get<string>("Identifier");
					var reason = reader.Get<string>("Reason");
					var banningUser = reader.Get<string>("BanningUser");
					var date = reader.Get<long>("Date");
					var expiration = reader.Get<long>("Expiration");

					return new Ban(ticketNumber, identifier, reason, banningUser, date, expiration);
				}
			}

			return null;
		}

		/// <summary>
		/// Retrieves an enumerable of all bans for a given identifier
		/// </summary>
		/// <param name="identifier">Identifier to search with</param>
		/// <param name="currentOnly">Whether or not to exclude expired bans</param>
		/// <returns></returns>
		public IEnumerable<Ban> RetrieveBansByIdentifier(string identifier, bool currentOnly = true)
		{
			string query = "SELECT * FROM PlayerBans WHERE Identifier=@0";
			if (currentOnly)
			{
				query += $" AND Expiration > {DateTime.UtcNow.Ticks}";
			}

			using (var reader = database.QueryReader(query, identifier))
			{
				while (reader.Read())
				{
					var ticketNumber = reader.Get<int>("TicketNumber");
					var ident = reader.Get<string>("Identifier");
					var reason = reader.Get<string>("Reason");
					var banningUser = reader.Get<string>("BanningUser");
					var date = reader.Get<long>("Date");
					var expiration = reader.Get<long>("Expiration");

					yield return new Ban(ticketNumber, ident, reason, banningUser, date, expiration);
				}
			}
		}

		/// <summary>
		/// Retrieves an enumerable of bans for a given set of identifiers
		/// </summary>
		/// <param name="currentOnly">Whether or not to exclude expired bans</param>
		/// <param name="identifiers"></param>
		/// <returns></returns>
		public IEnumerable<Ban> GetBansByIdentifiers(bool currentOnly = true, params string[] identifiers)
		{
			//Generate a sequence of '@0, @1, @2, ... etc'
			var parameters = string.Join(", ", Enumerable.Range(0, identifiers.Count()).Select(p => $"@{p}"));

			string query = $"SELECT * FROM PlayerBans WHERE Identifier IN ({parameters})";
			if (currentOnly)
			{
				query += $" AND Expiration > {DateTime.UtcNow.Ticks}";
			}

			using (var reader = database.QueryReader(query, identifiers))
			{
				while (reader.Read())
				{
					var ticketNumber = reader.Get<int>("TicketNumber");
					var identifier = reader.Get<string>("Identifier");
					var reason = reader.Get<string>("Reason");
					var banningUser = reader.Get<string>("BanningUser");
					var date = reader.Get<long>("Date");
					var expiration = reader.Get<long>("Expiration");

					yield return new Ban(ticketNumber, identifier, reason, banningUser, date, expiration);
				}
			}
		}

		/// <summary>
		/// Retrieves a list of bans from the database, sorted by their addition date from newest to oldest
		/// </summary>
		public IEnumerable<Ban> RetrieveAllBans() => RetrieveAllBansSorted(BanSortMethod.AddedNewestToOldest);

		/// <summary>
		/// Retrieves an enumerable of <see cref="Ban"/>s from the database, sorted using the provided sort method
		/// </summary>
		/// <param name="sortMethod"></param>
		/// <returns></returns>
		public IEnumerable<Ban> RetrieveAllBansSorted(BanSortMethod sortMethod)
		{
			List<Ban> banlist = new List<Ban>();
			try
			{
				var orderBy = SortToOrderByMap[sortMethod];
				using (var reader = database.QueryReader($"SELECT * FROM PlayerBans ORDER BY {orderBy}"))
				{
					while (reader.Read())
					{
						var ticketNumber = reader.Get<int>("TicketNumber");
						var identifier = reader.Get<string>("Identifier");
						var reason = reader.Get<string>("Reason");
						var banningUser = reader.Get<string>("BanningUser");
						var date = reader.Get<long>("Date");
						var expiration = reader.Get<long>("Expiration");

						var ban = new Ban(ticketNumber, identifier, reason, banningUser, date, expiration);
						banlist.Add(ban);
					}
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
				Console.WriteLine(ex.StackTrace);
			}

			return banlist;
		}

		/// <summary>
		/// Removes all bans from the database
		/// </summary>
		/// <returns><c>true</c>, if bans were cleared, <c>false</c> otherwise.</returns>
		public bool ClearBans()
		{
			try
			{
				return database.Query("DELETE FROM PlayerBans") != 0;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		internal Dictionary<BanSortMethod, string> SortToOrderByMap = new Dictionary<BanSortMethod, string>
		{
			{ BanSortMethod.AddedNewestToOldest, "Date DESC" },
			{ BanSortMethod.AddedOldestToNewest, "Date ASC" },
			{ BanSortMethod.ExpirationSoonestToLatest, "Expiration ASC" },
			{ BanSortMethod.ExpirationLatestToSoonest, "Expiration DESC" }
		};
	}

	/// <summary>
	/// Enum containing sort options for ban retrieval
	/// </summary>
	public enum BanSortMethod
	{
		/// <summary>
		/// Bans will be sorted on expiration date, from soonest to latest
		/// </summary>
		ExpirationSoonestToLatest,
		/// <summary>
		/// Bans will be sorted on expiration date, from latest to soonest
		/// </summary>
		ExpirationLatestToSoonest,
		/// <summary>
		/// Bans will be sorted by the date they were added, from newest to oldest
		/// </summary>
		AddedNewestToOldest,
		/// <summary>
		/// Bans will be sorted by the date they were added, from oldest to newest
		/// </summary>
		AddedOldestToNewest,
		/// <summary>
		/// Bans will be sorted by their ticket number
		/// </summary>
		TicketNumber
	}

	/// <summary>
	/// Result of an attempt to add a ban
	/// </summary>
	public class AddBanResult
	{
		/// <summary>
		/// Message generated from the attempt
		/// </summary>
		public string Message { get; set; }
		/// <summary>
		/// Ban object generated from the attempt, or null if the attempt failed
		/// </summary>
		public Ban Ban { get; set; }
	}

	/// <summary>
	/// Event args used for completed bans
	/// </summary>
	public class BanEventArgs : EventArgs
	{
		/// <summary>
		/// Complete ban object
		/// </summary>
		public Ban Ban { get; set; }

		/// <summary>
		/// Player ban is being applied to
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// Whether or not the operation should be considered to be valid
		/// </summary>
		public bool Valid { get; set; } = true;
	}

	/// <summary>
	/// Event args used for ban data prior to a ban being formalized
	/// </summary>
	public class BanPreAddEventArgs : EventArgs
	{
		/// <summary>
		/// An identifiable piece of information to ban
		/// </summary>
		public string Identifier { get; set; }

		/// <summary>
		/// Gets or sets the ban reason.
		/// </summary>
		/// <value>The ban reason.</value>
		public string Reason { get; set; }

		/// <summary>
		/// Gets or sets the name of the user who added this ban entry.
		/// </summary>
		/// <value>The banning user.</value>
		public string BanningUser { get; set; }

		/// <summary>
		/// DateTime from which the ban will take effect
		/// </summary>
		public DateTime BanDateTime { get; set; }

		/// <summary>
		/// DateTime at which the ban will end
		/// </summary>
		public DateTime ExpirationDateTime { get; set; }

		/// <summary>
		/// Whether or not the operation should be considered to be valid
		/// </summary>
		public bool Valid { get; set; } = true;

		/// <summary>
		/// Optional message to explain why the event was invalidated, if it was
		/// </summary>
		public string Message { get; set; }
	}

	/// <summary>
	/// Describes an identifier used by the ban system
	/// </summary>
	public class Identifier
	{
		/// <summary>
		/// Identifiers currently registered
		/// </summary>
		public static List<Identifier> Available = new List<Identifier>();

		/// <summary>
		/// The prefix of the identifier. E.g, 'ip:'
		/// </summary>
		public string Prefix { get; }
		/// <summary>
		/// Short description of the identifier and its basic usage
		/// </summary>
		public string Description { get; set; }

		/// <summary>
		/// IP identifier
		/// </summary>
		public static Identifier IP = Register("ip:", GetString($"An identifier for an IP Address in octet format. e.g., '{"127.0.0.1".Color(Utils.RedHighlight)}'."));
		/// <summary>
		/// UUID identifier
		/// </summary>
		public static Identifier UUID = Register("uuid:", GetString("An identifier for a UUID."));
		/// <summary>
		/// Player name identifier
		/// </summary>
		public static Identifier Name = Register("name:", GetString("An identifier for a character name."));
		/// <summary>
		/// User account identifier
		/// </summary>
		public static Identifier Account = Register("acc:", GetString("An identifier for a TShock User Account name."));

		private Identifier(string prefix, string description)
		{
			Prefix = prefix;
			Description = description;
		}

		/// <summary>
		/// Returns the identifier's prefix
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return Prefix;
		}

		/// <summary>
		/// Registers a new identifier with the given prefix and description
		/// </summary>
		/// <param name="prefix"></param>
		/// <param name="description"></param>
		public static Identifier Register(string prefix, string description)
		{
			var ident = new Identifier(prefix, description);
			Available.Add(ident);

			return ident;
		}
	}

	/// <summary>
	/// Model class that represents a ban entry in the TShock database.
	/// </summary>
	public class Ban
	{
		/// <summary>
		/// A unique ID assigned to this ban
		/// </summary>
		public int TicketNumber { get; set; }

		/// <summary>
		/// An identifiable piece of information to ban
		/// </summary>
		public string Identifier { get; set; }

		/// <summary>
		/// Gets or sets the ban reason.
		/// </summary>
		/// <value>The ban reason.</value>
		public string Reason { get; set; }

		/// <summary>
		/// Gets or sets the name of the user who added this ban entry.
		/// </summary>
		/// <value>The banning user.</value>
		public string BanningUser { get; set; }

		/// <summary>
		/// DateTime from which the ban will take effect
		/// </summary>
		public DateTime BanDateTime { get; set; }

		/// <summary>
		/// DateTime at which the ban will end
		/// </summary>
		public DateTime ExpirationDateTime { get; set; }

		/// <summary>
		/// Returns a string in the format dd:mm:hh:ss indicating the time until the ban expires.
		/// If the ban is not set to expire (ExpirationDateTime == DateTime.MaxValue), returns the string 'Never'
		/// </summary>
		/// <returns></returns>
		public string GetPrettyExpirationString()
		{
			if (ExpirationDateTime == DateTime.MaxValue)
			{
				return "Never";
			}

			TimeSpan ts = (ExpirationDateTime - DateTime.UtcNow).Duration(); // Use duration to avoid pesky negatives for expired bans
			return $"{ts.Days:00}:{ts.Hours:00}:{ts.Minutes:00}:{ts.Seconds:00}";
		}

		/// <summary>
		/// Returns a string in the format dd:mm:hh:ss indicating the time elapsed since the ban was added.
		/// </summary>
		/// <returns></returns>
		public string GetPrettyTimeSinceBanString()
		{
			TimeSpan ts = (DateTime.UtcNow - BanDateTime).Duration();
			return $"{ts.Days:00}:{ts.Hours:00}:{ts.Minutes:00}:{ts.Seconds:00}";
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="TShockAPI.DB.Ban"/> class.
		/// </summary>
		/// <param name="ticketNumber">Unique ID assigned to the ban</param>
		/// <param name="identifier">Identifier to apply the ban to</param>
		/// <param name="reason">Reason for the ban</param>
		/// <param name="banningUser">Account name that executed the ban</param>
		/// <param name="start">System ticks at which the ban began</param>
		/// <param name="end">System ticks at which the ban will end</param>
		public Ban(int ticketNumber, string identifier, string reason, string banningUser, long start, long end)
			: this(ticketNumber, identifier, reason, banningUser, new DateTime(start), new DateTime(end))
		{
		}


		/// <summary>
		/// Initializes a new instance of the <see cref="TShockAPI.DB.Ban"/> class.
		/// </summary>
		/// <param name="ticketNumber">Unique ID assigned to the ban</param>
		/// <param name="identifier">Identifier to apply the ban to</param>
		/// <param name="reason">Reason for the ban</param>
		/// <param name="banningUser">Account name that executed the ban</param>
		/// <param name="start">DateTime at which the ban will start</param>
		/// <param name="end">DateTime at which the ban will end</param>
		public Ban(int ticketNumber, string identifier, string reason, string banningUser, DateTime start, DateTime end)
		{
			TicketNumber = ticketNumber;
			Identifier = identifier;
			Reason = reason;
			BanningUser = banningUser;
			BanDateTime = start;
			ExpirationDateTime = end;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/CharacterManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using MySql.Data.MySqlClient;
using Terraria;

namespace TShockAPI.DB
{
	public class CharacterManager
	{
		public IDbConnection database;

		public CharacterManager(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("tsCharacter",
			                         new SqlColumn("Account", MySqlDbType.Int32) {Primary = true},
									 new SqlColumn("Health", MySqlDbType.Int32),
			                         new SqlColumn("MaxHealth", MySqlDbType.Int32),
									 new SqlColumn("Mana", MySqlDbType.Int32),
			                         new SqlColumn("MaxMana", MySqlDbType.Int32),
			                         new SqlColumn("Inventory", MySqlDbType.Text),
									 new SqlColumn("extraSlot", MySqlDbType.Int32),
									 new SqlColumn("spawnX", MySqlDbType.Int32),
									 new SqlColumn("spawnY", MySqlDbType.Int32),
									 new SqlColumn("skinVariant", MySqlDbType.Int32),
									 new SqlColumn("hair", MySqlDbType.Int32),
									 new SqlColumn("hairDye", MySqlDbType.Int32),
									 new SqlColumn("hairColor", MySqlDbType.Int32),
									 new SqlColumn("pantsColor", MySqlDbType.Int32),
									 new SqlColumn("shirtColor", MySqlDbType.Int32),
									 new SqlColumn("underShirtColor", MySqlDbType.Int32),
									 new SqlColumn("shoeColor", MySqlDbType.Int32),
									 new SqlColumn("hideVisuals", MySqlDbType.Int32),
									 new SqlColumn("skinColor", MySqlDbType.Int32),
									 new SqlColumn("eyeColor", MySqlDbType.Int32),
									 new SqlColumn("questsCompleted", MySqlDbType.Int32),
									 new SqlColumn("usingBiomeTorches", MySqlDbType.Int32),
									 new SqlColumn("happyFunTorchTime", MySqlDbType.Int32),
									 new SqlColumn("unlockedBiomeTorches", MySqlDbType.Int32),
									 new SqlColumn("currentLoadoutIndex", MySqlDbType.Int32),
									 new SqlColumn("ateArtisanBread", MySqlDbType.Int32),
									 new SqlColumn("usedAegisCrystal", MySqlDbType.Int32),
									 new SqlColumn("usedAegisFruit", MySqlDbType.Int32),
									 new SqlColumn("usedArcaneCrystal", MySqlDbType.Int32),
									 new SqlColumn("usedGalaxyPearl", MySqlDbType.Int32),
									 new SqlColumn("usedGummyWorm", MySqlDbType.Int32),
									 new SqlColumn("usedAmbrosia", MySqlDbType.Int32),
									 new SqlColumn("unlockedSuperCart", MySqlDbType.Int32),
									 new SqlColumn("enabledSuperCart", MySqlDbType.Int32)
				);
			var creator = new SqlTableCreator(db,
			                                  db.GetSqlType() == SqlType.Sqlite
			                                  	? (IQueryBuilder) new SqliteQueryCreator()
			                                  	: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
		}

		public PlayerData GetPlayerData(TSPlayer player, int acctid)
		{
			PlayerData playerData = new PlayerData(true);

			try
			{
				using (var reader = database.QueryReader("SELECT * FROM tsCharacter WHERE Account=@0", acctid))
				{
					if (reader.Read())
					{
						playerData.exists = true;
						playerData.health = reader.Get<int>("Health");
						playerData.maxHealth = reader.Get<int>("MaxHealth");
						playerData.mana = reader.Get<int>("Mana");
						playerData.maxMana = reader.Get<int>("MaxMana");
						List<NetItem> inventory = reader.Get<string>("Inventory").Split('~').Select(NetItem.Parse).ToList();
						if (inventory.Count < NetItem.MaxInventory)
						{
							//TODO: unhardcode this - stop using magic numbers and use NetItem numbers
							//Set new armour slots empty
							inventory.InsertRange(67, new NetItem[2]);
							//Set new vanity slots empty
							inventory.InsertRange(77, new NetItem[2]);
							//Set new dye slots empty
							inventory.InsertRange(87, new NetItem[2]);
							//Set the rest of the new slots empty
							inventory.AddRange(new NetItem[NetItem.MaxInventory - inventory.Count]);
						}
						playerData.inventory = inventory.ToArray();
						playerData.extraSlot = reader.Get<int>("extraSlot");
						playerData.spawnX = reader.Get<int>("spawnX");
						playerData.spawnY = reader.Get<int>("spawnY");
						playerData.skinVariant = reader.Get<int?>("skinVariant");
						playerData.hair = reader.Get<int?>("hair");
						playerData.hairDye = (byte)reader.Get<int>("hairDye");
						playerData.hairColor = TShock.Utils.DecodeColor(reader.Get<int?>("hairColor"));
						playerData.pantsColor = TShock.Utils.DecodeColor(reader.Get<int?>("pantsColor"));
						playerData.shirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("shirtColor"));
						playerData.underShirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("underShirtColor"));
						playerData.shoeColor = TShock.Utils.DecodeColor(reader.Get<int?>("shoeColor"));
						playerData.hideVisuals = TShock.Utils.DecodeBoolArray(reader.Get<int?>("hideVisuals"));
						playerData.skinColor = TShock.Utils.DecodeColor(reader.Get<int?>("skinColor"));
						playerData.eyeColor = TShock.Utils.DecodeColor(reader.Get<int?>("eyeColor"));
						playerData.questsCompleted = reader.Get<int>("questsCompleted");
						playerData.usingBiomeTorches = reader.Get<int>("usingBiomeTorches");
						playerData.happyFunTorchTime = reader.Get<int>("happyFunTorchTime");
						playerData.unlockedBiomeTorches = reader.Get<int>("unlockedBiomeTorches");
						playerData.currentLoadoutIndex = reader.Get<int>("currentLoadoutIndex");
						playerData.ateArtisanBread = reader.Get<int>("ateArtisanBread");
						playerData.usedAegisCrystal = reader.Get<int>("usedAegisCrystal");
						playerData.usedAegisFruit = reader.Get<int>("usedAegisFruit");
						playerData.usedArcaneCrystal = reader.Get<int>("usedArcaneCrystal");
						playerData.usedGalaxyPearl = reader.Get<int>("usedGalaxyPearl");
						playerData.usedGummyWorm = reader.Get<int>("usedGummyWorm");
						playerData.usedAmbrosia = reader.Get<int>("usedAmbrosia");
						playerData.unlockedSuperCart = reader.Get<int>("unlockedSuperCart");
						playerData.enabledSuperCart = reader.Get<int>("enabledSuperCart");
						return playerData;
					}
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}

			return playerData;
		}

		public bool SeedInitialData(UserAccount account)
		{
			var inventory = new StringBuilder();

			var items = new List<NetItem>(TShock.ServerSideCharacterConfig.Settings.StartingInventory);
			if (items.Count < NetItem.MaxInventory)
				items.AddRange(new NetItem[NetItem.MaxInventory - items.Count]);

			string initialItems = String.Join("~", items.Take(NetItem.MaxInventory));
			try
			{
				database.Query("INSERT INTO tsCharacter (Account, Health, MaxHealth, Mana, MaxMana, Inventory, spawnX, spawnY, questsCompleted) VALUES (@0, @1, @2, @3, @4, @5, @6, @7, @8);",
							   account.ID,
							   TShock.ServerSideCharacterConfig.Settings.StartingHealth,
							   TShock.ServerSideCharacterConfig.Settings.StartingHealth,
							   TShock.ServerSideCharacterConfig.Settings.StartingMana,
							   TShock.ServerSideCharacterConfig.Settings.StartingMana,
							   initialItems,
							   -1,
							   -1,
							   0);
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}

			return false;
		}

		/// <summary>
		/// Inserts player data to the tsCharacter database table
		/// </summary>
		/// <param name="player">player to take data from</param>
		/// <returns>true if inserted successfully</returns>
		public bool InsertPlayerData(TSPlayer player, bool fromCommand = false)
		{
			PlayerData playerData = player.PlayerData;

			if (!player.IsLoggedIn)
				return false;

			if (player.State < (int)ConnectionState.Complete)
				return false;

			if (player.HasPermission(Permissions.bypassssc) && !fromCommand)
			{
				TShock.Log.ConsoleInfo(GetParticularString("{0} is a player name", $"Skipping SSC save (due to tshock.ignore.ssc) for {player.Account.Name}"));
				return false;
			}

			if (!GetPlayerData(player, player.Account.ID).exists)
			{
				try
				{
					database.Query(
						"INSERT INTO tsCharacter (Account, Health, MaxHealth, Mana, MaxMana, Inventory, extraSlot, spawnX, spawnY, skinVariant, hair, hairDye, hairColor, pantsColor, shirtColor, underShirtColor, shoeColor, hideVisuals, skinColor, eyeColor, questsCompleted, usingBiomeTorches, happyFunTorchTime, unlockedBiomeTorches, currentLoadoutIndex,ateArtisanBread, usedAegisCrystal, usedAegisFruit, usedArcaneCrystal, usedGalaxyPearl, usedGummyWorm, usedAmbrosia, unlockedSuperCart, enabledSuperCart) VALUES (@0, @1, @2, @3, @4, @5, @6, @7, @8, @9, @10, @11, @12, @13, @14, @15, @16, @17, @18, @19, @20, @21, @22, @23, @24, @25, @26, @27, @28, @29, @30, @31, @32, @33);",
						player.Account.ID, playerData.health, playerData.maxHealth, playerData.mana, playerData.maxMana, String.Join("~", playerData.inventory), playerData.extraSlot, player.TPlayer.SpawnX, player.TPlayer.SpawnY, player.TPlayer.skinVariant, player.TPlayer.hair, player.TPlayer.hairDye, TShock.Utils.EncodeColor(player.TPlayer.hairColor), TShock.Utils.EncodeColor(player.TPlayer.pantsColor),TShock.Utils.EncodeColor(player.TPlayer.shirtColor), TShock.Utils.EncodeColor(player.TPlayer.underShirtColor), TShock.Utils.EncodeColor(player.TPlayer.shoeColor), TShock.Utils.EncodeBoolArray(player.TPlayer.hideVisibleAccessory), TShock.Utils.EncodeColor(player.TPlayer.skinColor),TShock.Utils.EncodeColor(player.TPlayer.eyeColor), player.TPlayer.anglerQuestsFinished, player.TPlayer.UsingBiomeTorches ? 1 : 0, player.TPlayer.happyFunTorchTime ? 1 : 0, player.TPlayer.unlockedBiomeTorches ? 1 : 0, player.TPlayer.CurrentLoadoutIndex, player.TPlayer.ateArtisanBread ? 1 : 0, player.TPlayer.usedAegisCrystal ? 1 : 0, player.TPlayer.usedAegisFruit ? 1 : 0, player.TPlayer.usedArcaneCrystal ? 1 : 0, player.TPlayer.usedGalaxyPearl ? 1 : 0, player.TPlayer.usedGummyWorm ? 1 : 0, player.TPlayer.usedAmbrosia ? 1 : 0, player.TPlayer.unlockedSuperCart ? 1 : 0, player.TPlayer.enabledSuperCart ? 1 : 0);
					return true;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
			else
			{
				try
				{
					database.Query(
						"UPDATE tsCharacter SET Health = @0, MaxHealth = @1, Mana = @2, MaxMana = @3, Inventory = @4, spawnX = @6, spawnY = @7, hair = @8, hairDye = @9, hairColor = @10, pantsColor = @11, shirtColor = @12, underShirtColor = @13, shoeColor = @14, hideVisuals = @15, skinColor = @16, eyeColor = @17, questsCompleted = @18, skinVariant = @19, extraSlot = @20, usingBiomeTorches = @21, happyFunTorchTime = @22, unlockedBiomeTorches = @23, currentLoadoutIndex = @24, ateArtisanBread = @25, usedAegisCrystal = @26, usedAegisFruit = @27, usedArcaneCrystal = @28, usedGalaxyPearl = @29, usedGummyWorm = @30, usedAmbrosia = @31, unlockedSuperCart = @32, enabledSuperCart = @33 WHERE Account = @5;",
						playerData.health, playerData.maxHealth, playerData.mana, playerData.maxMana, String.Join("~", playerData.inventory), player.Account.ID, player.TPlayer.SpawnX, player.TPlayer.SpawnY, player.TPlayer.hair, player.TPlayer.hairDye, TShock.Utils.EncodeColor(player.TPlayer.hairColor), TShock.Utils.EncodeColor(player.TPlayer.pantsColor), TShock.Utils.EncodeColor(player.TPlayer.shirtColor), TShock.Utils.EncodeColor(player.TPlayer.underShirtColor), TShock.Utils.EncodeColor(player.TPlayer.shoeColor), TShock.Utils.EncodeBoolArray(player.TPlayer.hideVisibleAccessory), TShock.Utils.EncodeColor(player.TPlayer.skinColor), TShock.Utils.EncodeColor(player.TPlayer.eyeColor), player.TPlayer.anglerQuestsFinished, player.TPlayer.skinVariant, player.TPlayer.extraAccessory ? 1 : 0, player.TPlayer.UsingBiomeTorches ? 1 : 0, player.TPlayer.happyFunTorchTime ? 1 : 0, player.TPlayer.unlockedBiomeTorches ? 1 : 0, player.TPlayer.CurrentLoadoutIndex, player.TPlayer.ateArtisanBread ? 1 : 0, player.TPlayer.usedAegisCrystal ? 1 : 0, player.TPlayer.usedAegisFruit ? 1 : 0, player.TPlayer.usedArcaneCrystal ? 1 : 0, player.TPlayer.usedGalaxyPearl ? 1 : 0, player.TPlayer.usedGummyWorm ? 1 : 0, player.TPlayer.usedAmbrosia ? 1 : 0, player.TPlayer.unlockedSuperCart ? 1 : 0, player.TPlayer.enabledSuperCart ? 1 : 0);
					return true;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
			return false;
		}

		/// <summary>
		/// Removes a player's data from the tsCharacter database table
		/// </summary>
		/// <param name="userid">User ID of the player</param>
		/// <returns>true if removed successfully</returns>
		public bool RemovePlayer(int userid)
		{
			try
			{
				database.Query("DELETE FROM tsCharacter WHERE Account = @0;", userid);
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}

			return false;
		}

		/// <summary>
		/// Inserts a specific PlayerData into the SSC table for a player.
		/// </summary>
		/// <param name="player">The player to store the data for.</param>
		/// <param name="data">The player data to store.</param>
		/// <returns>If the command succeeds.</returns>
		public bool InsertSpecificPlayerData(TSPlayer player, PlayerData data)
		{
			PlayerData playerData = data;

			if (!player.IsLoggedIn)
				return false;

			if (player.HasPermission(Permissions.bypassssc))
			{
				TShock.Log.ConsoleInfo(GetParticularString("{0} is a player name", $"Skipping SSC save (due to tshock.ignore.ssc) for {player.Account.Name}"));
				return true;
			}

			if (!GetPlayerData(player, player.Account.ID).exists)
			{
				try
				{
					database.Query(
						"INSERT INTO tsCharacter (Account, Health, MaxHealth, Mana, MaxMana, Inventory, extraSlot, spawnX, spawnY, skinVariant, hair, hairDye, hairColor, pantsColor, shirtColor, underShirtColor, shoeColor, hideVisuals, skinColor, eyeColor, questsCompleted, usingBiomeTorches, happyFunTorchTime, unlockedBiomeTorches, currentLoadoutIndex, ateArtisanBread, usedAegisCrystal, usedAegisFruit, usedArcaneCrystal, usedGalaxyPearl, usedGummyWorm, usedAmbrosia, unlockedSuperCart, enabledSuperCart) VALUES (@0, @1, @2, @3, @4, @5, @6, @7, @8, @9, @10, @11, @12, @13, @14, @15, @16, @17, @18, @19, @20, @21, @22, @23, @24, @25, @26, @27, @28, @29, @30, @31, @32, @33);",
						player.Account.ID,
						playerData.health,
						playerData.maxHealth,
						playerData.mana,
						playerData.maxMana,
						String.Join("~", playerData.inventory),
						playerData.extraSlot,
						playerData.spawnX,
						playerData.spawnX,
						playerData.skinVariant,
						playerData.hair,
						playerData.hairDye,
						TShock.Utils.EncodeColor(playerData.hairColor),
						TShock.Utils.EncodeColor(playerData.pantsColor),
						TShock.Utils.EncodeColor(playerData.shirtColor),
						TShock.Utils.EncodeColor(playerData.underShirtColor),
						TShock.Utils.EncodeColor(playerData.shoeColor),
						TShock.Utils.EncodeBoolArray(playerData.hideVisuals),
						TShock.Utils.EncodeColor(playerData.skinColor),
						TShock.Utils.EncodeColor(playerData.eyeColor),
						playerData.questsCompleted,
						playerData.usingBiomeTorches,
						playerData.happyFunTorchTime,
						playerData.unlockedBiomeTorches,
						playerData.currentLoadoutIndex,
						playerData.ateArtisanBread,
						playerData.usedAegisCrystal,
						playerData.usedAegisFruit,
						playerData.usedArcaneCrystal,
						playerData.usedGalaxyPearl,
						playerData.usedGummyWorm,
						playerData.usedAmbrosia,
						playerData.unlockedSuperCart,
						playerData.enabledSuperCart);
					return true;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
			else
			{
				try
				{
					database.Query(
						"UPDATE tsCharacter SET Health = @0, MaxHealth = @1, Mana = @2, MaxMana = @3, Inventory = @4, spawnX = @6, spawnY = @7, hair = @8, hairDye = @9, hairColor = @10, pantsColor = @11, shirtColor = @12, underShirtColor = @13, shoeColor = @14, hideVisuals = @15, skinColor = @16, eyeColor = @17, questsCompleted = @18, skinVariant = @19, extraSlot = @20, usingBiomeTorches = @21, happyFunTorchTime = @22, unlockedBiomeTorches = @23, currentLoadoutIndex = @24, ateArtisanBread = @25, usedAegisCrystal = @26, usedAegisFruit = @27, usedArcaneCrystal = @28, usedGalaxyPearl = @29, usedGummyWorm = @30, usedAmbrosia = @31, unlockedSuperCart = @32, enabledSuperCart = @33 WHERE Account = @5;",
						playerData.health,
						playerData.maxHealth,
						playerData.mana,
						playerData.maxMana,
						String.Join("~", playerData.inventory),
						player.Account.ID,
						playerData.spawnX,
						playerData.spawnX,
						playerData.skinVariant,
						playerData.hair,
						playerData.hairDye,
						TShock.Utils.EncodeColor(playerData.hairColor),
						TShock.Utils.EncodeColor(playerData.pantsColor),
						TShock.Utils.EncodeColor(playerData.shirtColor),
						TShock.Utils.EncodeColor(playerData.underShirtColor),
						TShock.Utils.EncodeColor(playerData.shoeColor),
						TShock.Utils.EncodeBoolArray(playerData.hideVisuals),
						TShock.Utils.EncodeColor(playerData.skinColor),
						TShock.Utils.EncodeColor(playerData.eyeColor),
						playerData.questsCompleted,
						playerData.extraSlot ?? 0,
						playerData.usingBiomeTorches,
						playerData.happyFunTorchTime,
						playerData.unlockedBiomeTorches,
						playerData.currentLoadoutIndex,
						playerData.ateArtisanBread,
						playerData.usedAegisCrystal,
						playerData.usedAegisFruit,
						playerData.usedArcaneCrystal,
						playerData.usedGalaxyPearl,
						playerData.usedGummyWorm,
						playerData.usedAmbrosia,
						playerData.unlockedSuperCart,
						playerData.enabledSuperCart);
					return true;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
			return false;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/GroupManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Linq;
using MySql.Data.MySqlClient;

namespace TShockAPI.DB
{
	/// <summary>
	/// Represents the GroupManager, which is in charge of group management.
	/// </summary>
	public class GroupManager : IEnumerable<Group>
	{
		private IDbConnection database;
		public readonly List<Group> groups = new List<Group>();

		/// <summary>
		/// Initializes a new instance of the <see cref="GroupManager"/> class with the specified database connection.
		/// </summary>
		/// <param name="db">The connection.</param>
		public GroupManager(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("GroupList",
				new SqlColumn("GroupName", MySqlDbType.VarChar, 32) { Primary = true },
				new SqlColumn("Parent", MySqlDbType.VarChar, 32),
				new SqlColumn("Commands", MySqlDbType.Text),
				new SqlColumn("ChatColor", MySqlDbType.Text),
				new SqlColumn("Prefix", MySqlDbType.Text),
				new SqlColumn("Suffix", MySqlDbType.Text)
			);
			var creator = new SqlTableCreator(db,
				db.GetSqlType() == SqlType.Sqlite
					? (IQueryBuilder)new SqliteQueryCreator()
					: new MysqlQueryCreator());
			if (creator.EnsureTableStructure(table))
			{
				// Add default groups if they don't exist
				AddDefaultGroup(TShock.Config.Settings.DefaultGuestGroupName, "",
					string.Join(",",
						Permissions.canbuild,
						Permissions.canregister,
						Permissions.canlogin,
						Permissions.canpartychat,
						Permissions.cantalkinthird,
						Permissions.canchat,
						Permissions.synclocalarea,
						Permissions.sendemoji));

				AddDefaultGroup(TShock.Config.Settings.DefaultRegistrationGroupName, TShock.Config.Settings.DefaultGuestGroupName,
					string.Join(",",
						Permissions.warp,
						Permissions.canchangepassword,
						Permissions.canlogout,
						Permissions.summonboss,
						Permissions.spawnpets,
						Permissions.worldupgrades,
						Permissions.whisper,
						Permissions.wormhole,
						Permissions.canpaint,
						Permissions.pylon,
						Permissions.tppotion,
						Permissions.magicconch,
						Permissions.demonconch));

				AddDefaultGroup("vip", TShock.Config.Settings.DefaultRegistrationGroupName,
					string.Join(",",
						Permissions.reservedslot,
						Permissions.renamenpc,
						Permissions.startinvasion,
						Permissions.summonboss,
						Permissions.whisper,
						Permissions.wormhole));

				AddDefaultGroup("newadmin", "vip",
					string.Join(",",
						Permissions.kick,
						Permissions.editspawn,
						Permissions.reservedslot,
						Permissions.annoy,
						Permissions.checkaccountinfo,
						Permissions.getpos,
						Permissions.mute,
						Permissions.rod,
						Permissions.savessc,
						Permissions.seeids,
						"tshock.world.time.*"));

				AddDefaultGroup("admin", "newadmin",
					string.Join(",",
						Permissions.ban,
						Permissions.whitelist,
						Permissions.spawnboss,
						Permissions.spawnmob,
						Permissions.managewarp,
						Permissions.time,
						Permissions.tp,
						Permissions.slap,
						Permissions.kill,
						Permissions.logs,
						Permissions.immunetokick,
						Permissions.tpothers,
						Permissions.advaccountinfo,
						Permissions.broadcast,
						Permissions.home,
						Permissions.tpallothers,
						Permissions.tpallow,
						Permissions.tpnpc,
						Permissions.tppos,
						Permissions.tpsilent,
						Permissions.userinfo,
						Permissions.spawn));

				AddDefaultGroup("trustedadmin", "admin",
					string.Join(",",
						Permissions.maintenance,
						"tshock.cfg.*",
						"tshock.world.*",
						Permissions.butcher,
						Permissions.item,
						Permissions.give,
						Permissions.heal,
						Permissions.immunetoban,
						Permissions.usebanneditem,
						Permissions.allowclientsideworldedit,
						Permissions.buff,
						Permissions.buffplayer,
						Permissions.clear,
						Permissions.clearangler,
						Permissions.godmode,
						Permissions.godmodeother,
						Permissions.ignoredamagecap,
						Permissions.ignorehp,
						Permissions.ignorekilltiledetection,
						Permissions.ignoreliquidsetdetection,
						Permissions.ignoremp,
						Permissions.ignorepaintdetection,
						Permissions.ignoreplacetiledetection,
						Permissions.ignoreprojectiledetection,
						Permissions.ignorestackhackdetection,
						Permissions.invade,
						Permissions.startdd2,
						Permissions.uploaddata,
						Permissions.uploadothersdata,
						Permissions.spawnpets,
						Permissions.journey_timefreeze,
						Permissions.journey_timeset,
						Permissions.journey_timespeed,
						Permissions.journey_godmode,
						Permissions.journey_windstrength,
						Permissions.journey_windfreeze,
						Permissions.journey_rainstrength,
						Permissions.journey_rainfreeze,
						Permissions.journey_placementrange,
						Permissions.journey_setdifficulty,
						Permissions.journey_biomespreadfreeze,
						Permissions.journey_setspawnrate,
						Permissions.journey_contributeresearch));

				AddDefaultGroup("owner", "trustedadmin",
					string.Join(",",
						Permissions.su,
						Permissions.allowdroppingbanneditems,
						Permissions.antibuild,
						Permissions.canusebannedprojectiles,
						Permissions.canusebannedtiles,
						Permissions.managegroup,
						Permissions.manageitem,
						Permissions.manageprojectile,
						Permissions.manageregion,
						Permissions.managetile,
						Permissions.maxspawns,
						Permissions.serverinfo,
						Permissions.settempgroup,
						Permissions.spawnrate,
						Permissions.tpoverride,
						Permissions.createdumps));
			}

			// Load Permissions from the DB
			LoadPermisions();

			Group.DefaultGroup = GetGroupByName(TShock.Config.Settings.DefaultGuestGroupName);

			AssertCoreGroupsPresent();
		}

		internal void AssertCoreGroupsPresent()
		{
			if (!GroupExists(TShock.Config.Settings.DefaultGuestGroupName))
			{
				TShock.Log.ConsoleError(GetString("The guest group could not be found. This may indicate a typo in the configuration file, or that the group was renamed or deleted."));
				throw new Exception(GetString("The guest group could not be found."));
			}

			if (!GroupExists(TShock.Config.Settings.DefaultRegistrationGroupName))
			{
				TShock.Log.ConsoleError(GetString("The default usergroup could not be found. This may indicate a typo in the configuration file, or that the group was renamed or deleted."));
				throw new Exception(GetString("The default usergroup could not be found."));
			}
		}

		/// <summary>
		/// Asserts that the group reference can be safely assigned to the player object.
		/// <para>If this assertion fails, and <paramref name="kick"/> is true, the player is disconnected. If <paramref name="kick"/> is false, the player will receive an error message.</para>
		/// </summary>
		/// <param name="player">The player in question</param>
		/// <param name="group">The group we want to assign them</param>
		/// <param name="kick">Whether or not failing this check disconnects the player.</param>
		/// <returns></returns>
		public bool AssertGroupValid(TSPlayer player, Group group, bool kick)
		{
			if (group == null)
			{
				if (kick)
					player.Disconnect(GetString("Your account's group could not be loaded. Please contact server administrators about this."));
				else
					player.SendErrorMessage(GetString("Your account's group could not be loaded. Please contact server administrators about this."));
				return false;
			}

			return true;
		}

		private void AddDefaultGroup(string name, string parent, string permissions)
		{
			if (!GroupExists(name))
				AddGroup(name, parent, permissions, Group.defaultChatColor);
		}

		/// <summary>
		/// Determines whether the given group exists.
		/// </summary>
		/// <param name="group">The group.</param>
		/// <returns><c>true</c> if it does; otherwise, <c>false</c>.</returns>
		public bool GroupExists(string group)
		{
			if (group == "superadmin")
				return true;

			return groups.Any(g => g.Name.Equals(group));
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		/// <summary>
		/// Gets the enumerator.
		/// </summary>
		/// <returns>The enumerator.</returns>
		public IEnumerator<Group> GetEnumerator()
		{
			return groups.GetEnumerator();
		}

		/// <summary>
		/// Gets the group matching the specified name.
		/// </summary>
		/// <param name="name">The name.</param>
		/// <returns>The group.</returns>
		public Group GetGroupByName(string name)
		{
			var ret = groups.Where(g => g.Name == name);
			return 1 == ret.Count() ? ret.ElementAt(0) : null;
		}

		/// <summary>
		/// Adds group with name and permissions if it does not exist.
		/// </summary>
		/// <param name="name">name of group</param>
		/// <param name="parentname">parent of group</param>
		/// <param name="permissions">permissions</param>
		/// <param name="chatcolor">chatcolor</param>
		public void AddGroup(String name, string parentname, String permissions, String chatcolor)
		{
			if (GroupExists(name))
			{
				throw new GroupExistsException(name);
			}

			var group = new Group(name, null, chatcolor);
			group.Permissions = permissions;
			if (!string.IsNullOrWhiteSpace(parentname))
			{
				var parent = groups.FirstOrDefault(gp => gp.Name == parentname);
				if (parent == null || name == parentname)
				{
					var error = GetString($"Invalid parent group {parentname} for group {group.Name}");
					TShock.Log.ConsoleError(error);
					throw new GroupManagerException(error);
				}
				group.Parent = parent;
			}

			string query = (TShock.Config.Settings.StorageType.ToLower() == "sqlite")
				? "INSERT OR IGNORE INTO GroupList (GroupName, Parent, Commands, ChatColor) VALUES (@0, @1, @2, @3);"
				: "INSERT IGNORE INTO GroupList SET GroupName=@0, Parent=@1, Commands=@2, ChatColor=@3";
			if (database.Query(query, name, parentname, permissions, chatcolor) == 1)
			{
				groups.Add(group);
			}
			else
				throw new GroupManagerException(GetString($"Failed to add group {name}."));
		}

		/// <summary>
		/// Updates a group including permissions
		/// </summary>
		/// <param name="name">name of the group to update</param>
		/// <param name="parentname">parent of group</param>
		/// <param name="permissions">permissions</param>
		/// <param name="chatcolor">chatcolor</param>
		/// <param name="suffix">suffix</param>
		/// <param name="prefix">prefix</param> //why is suffix before prefix?!
		public void UpdateGroup(string name, string parentname, string permissions, string chatcolor, string suffix, string prefix)
		{
			Group group = GetGroupByName(name);
			if (group == null)
				throw new GroupNotExistException(name);

			Group parent = null;
			if (!string.IsNullOrWhiteSpace(parentname))
			{
				parent = GetGroupByName(parentname);
				if (parent == null || parent == group)
					throw new GroupManagerException(GetString($"Invalid parent group {parentname} for group {name}."));

				// Check if the new parent would cause loops.
				List<Group> groupChain = new List<Group> { group, parent };
				Group checkingGroup = parent.Parent;
				while (checkingGroup != null)
				{
					if (groupChain.Contains(checkingGroup))
						throw new GroupManagerException(
							GetString($"Parenting group {group} to {parentname} would cause loops in the parent chain."));

					groupChain.Add(checkingGroup);
					checkingGroup = checkingGroup.Parent;
				}
			}

			// Ensure any group validation is also persisted to the DB.
			var newGroup = new Group(name, parent, chatcolor, permissions);
			newGroup.Prefix = prefix;
			newGroup.Suffix = suffix;
			string query = "UPDATE GroupList SET Parent=@0, Commands=@1, ChatColor=@2, Suffix=@3, Prefix=@4 WHERE GroupName=@5";
			if (database.Query(query, parentname, newGroup.Permissions, newGroup.ChatColor, suffix, prefix, name) != 1)
				throw new GroupManagerException(GetString($"Failed to update group \"{name}\"."));

			group.ChatColor = chatcolor;
			group.Permissions = permissions;
			group.Parent = parent;
			group.Prefix = prefix;
			group.Suffix = suffix;
		}

		/// <summary>
		/// Renames the specified group.
		/// </summary>
		/// <param name="name">The group's name.</param>
		/// <param name="newName">The new name.</param>
		/// <returns>The result from the operation to be sent back to the user.</returns>
		public String RenameGroup(string name, string newName)
		{
			if (!GroupExists(name))
			{
				throw new GroupNotExistException(name);
			}

			if (GroupExists(newName))
			{
				throw new GroupExistsException(newName);
			}

			using (var db = database.CloneEx())
			{
				db.Open();
				using (var transaction = db.BeginTransaction())
				{
					try
					{
						using (var command = db.CreateCommand())
						{
							command.CommandText = "UPDATE GroupList SET GroupName = @0 WHERE GroupName = @1";
							command.AddParameter("@0", newName);
							command.AddParameter("@1", name);
							command.ExecuteNonQuery();
						}

						var oldGroup = GetGroupByName(name);
						var newGroup = new Group(newName, oldGroup.Parent, oldGroup.ChatColor, oldGroup.Permissions)
						{
							Prefix = oldGroup.Prefix,
							Suffix = oldGroup.Suffix
						};
						groups.Remove(oldGroup);
						groups.Add(newGroup);

						// We need to check if the old group has been referenced as a parent and update those references accordingly
						using (var command = db.CreateCommand())
						{
							command.CommandText = "UPDATE GroupList SET Parent = @0 WHERE Parent = @1";
							command.AddParameter("@0", newName);
							command.AddParameter("@1", name);
							command.ExecuteNonQuery();
						}
						foreach (var group in groups.Where(g => g.Parent != null && g.Parent == oldGroup))
						{
							group.Parent = newGroup;
						}

						// Read the config file to prevent the possible loss of any unsaved changes
						TShock.Config.Read(FileTools.ConfigPath, out bool writeConfig);
						if (TShock.Config.Settings.DefaultGuestGroupName == oldGroup.Name)
						{
							TShock.Config.Settings.DefaultGuestGroupName = newGroup.Name;
							Group.DefaultGroup = newGroup;
						}
						if (TShock.Config.Settings.DefaultRegistrationGroupName == oldGroup.Name)
						{
							TShock.Config.Settings.DefaultRegistrationGroupName = newGroup.Name;
						}
						if (writeConfig)
						{
							TShock.Config.Write(FileTools.ConfigPath);
						}

						// We also need to check if any users belong to the old group and automatically apply changes
						using (var command = db.CreateCommand())
						{
							command.CommandText = "UPDATE Users SET Usergroup = @0 WHERE Usergroup = @1";
							command.AddParameter("@0", newName);
							command.AddParameter("@1", name);
							command.ExecuteNonQuery();
						}
						foreach (var player in TShock.Players.Where(p => p?.Group == oldGroup))
						{
							player.Group = newGroup;
						}

						transaction.Commit();
						return GetString($"Group {name} has been renamed to {newName}.");
					}
					catch (Exception ex)
					{
						TShock.Log.Error(GetString($"An exception has occurred during database transaction: {ex.Message}"));
						try
						{
							transaction.Rollback();
						}
						catch (Exception rollbackEx)
						{
							TShock.Log.Error(GetString($"An exception has occurred during database rollback: {rollbackEx.Message}"));
						}
					}
				}
			}

			throw new GroupManagerException(GetString($"Failed to rename group {name}."));
		}

		/// <summary>
		/// Deletes the specified group.
		/// </summary>
		/// <param name="name">The group's name.</param>
		/// <param name="exceptions">Whether exceptions will be thrown in case something goes wrong.</param>
		/// <returns>The result from the operation to be sent back to the user.</returns>
		public String DeleteGroup(String name, bool exceptions = false)
		{
			if (!GroupExists(name))
			{
				if (exceptions)
					throw new GroupNotExistException(name);
				return GetString($"Group {name} doesn't exist.");
			}

			if (name == Group.DefaultGroup.Name)
			{
				if (exceptions)
					throw new GroupManagerException(GetString("You can't remove the default guest group."));
				return GetString("You can't remove the default guest group.");
			}

			if (database.Query("DELETE FROM GroupList WHERE GroupName=@0", name) == 1)
			{
				groups.Remove(TShock.Groups.GetGroupByName(name));
				return GetString($"Group {name} has been deleted successfully.");
			}

			if (exceptions)
				throw new GroupManagerException(GetString($"Failed to delete group {name}."));
			return GetString($"Failed to delete group {name}.");
		}

		/// <summary>
		/// Enumerates the given permission list and adds permissions for the specified group accordingly.
		/// </summary>
		/// <param name="name">The group name.</param>
		/// <param name="permissions">The permission list.</param>
		/// <returns>The result from the operation to be sent back to the user.</returns>
		public String AddPermissions(String name, List<String> permissions)
		{
			if (!GroupExists(name))
				return GetString($"Group {name} doesn't exist.");

			var group = TShock.Groups.GetGroupByName(name);
			var oldperms = group.Permissions; // Store old permissions in case of error
			permissions.ForEach(p => group.AddPermission(p));

			if (database.Query("UPDATE GroupList SET Commands=@0 WHERE GroupName=@1", group.Permissions, name) == 1)
				return "Group " + name + " has been modified successfully.";

			// Restore old permissions so DB and internal object are in a consistent state
			group.Permissions = oldperms;
			return "";
		}

		/// <summary>
		/// Enumerates the given permission list and removes valid permissions for the specified group accordingly.
		/// </summary>
		/// <param name="name">The group name.</param>
		/// <param name="permissions">The permission list.</param>
		/// <returns>The result from the operation to be sent back to the user.</returns>
		public String DeletePermissions(String name, List<String> permissions)
		{
			if (!GroupExists(name))
				return GetString($"Group {name} doesn't exist.");

			var group = TShock.Groups.GetGroupByName(name);
			var oldperms = group.Permissions; // Store old permissions in case of error
			permissions.ForEach(p => group.RemovePermission(p));

			if (database.Query("UPDATE GroupList SET Commands=@0 WHERE GroupName=@1", group.Permissions, name) == 1)
				return "Group " + name + " has been modified successfully.";

			// Restore old permissions so DB and internal object are in a consistent state
			group.Permissions = oldperms;
			return "";
		}

		/// <summary>
		/// Enumerates the group list and loads permissions for each group appropriately.
		/// </summary>
		public void LoadPermisions()
		{
			try
			{
				List<Group> newGroups = new List<Group>(groups.Count);
				Dictionary<string, string> newGroupParents = new Dictionary<string, string>(groups.Count);
				using (var reader = database.QueryReader("SELECT * FROM GroupList"))
				{
					while (reader.Read())
					{
						string groupName = reader.Get<string>("GroupName");
						if (groupName == "superadmin")
						{
							TShock.Log.ConsoleWarn(GetString("Group \"superadmin\" is defined in the database even though it's a reserved group name."));
							continue;
						}

						newGroups.Add(new Group(groupName, null, reader.Get<string>("ChatColor"), reader.Get<string>("Commands"))
						{
							Prefix = reader.Get<string>("Prefix"),
							Suffix = reader.Get<string>("Suffix"),
						});

						try
						{
							newGroupParents.Add(groupName, reader.Get<string>("Parent"));
						}
						catch (ArgumentException)
						{
							// Just in case somebody messed with the unique primary key.
							TShock.Log.ConsoleError(GetString($"The group {groupName} appeared more than once. Keeping current group settings."));
							return;
						}
					}
				}

				try
				{
					// Get rid of deleted groups.
					for (int i = 0; i < groups.Count; i++)
						if (newGroups.All(g => g.Name != groups[i].Name))
							groups.RemoveAt(i--);

					// Apply changed group settings while keeping the current instances and add new groups.
					foreach (Group newGroup in newGroups)
					{
						Group currentGroup = groups.FirstOrDefault(g => g.Name == newGroup.Name);
						if (currentGroup != null)
							newGroup.AssignTo(currentGroup);
						else
							groups.Add(newGroup);
					}

					// Resolve parent groups.
					Debug.Assert(newGroups.Count == newGroupParents.Count);
					for (int i = 0; i < groups.Count; i++)
					{
						Group group = groups[i];
						string parentGroupName;
						if (!newGroupParents.TryGetValue(group.Name, out parentGroupName) || string.IsNullOrEmpty(parentGroupName))
							continue;

						group.Parent = groups.FirstOrDefault(g => g.Name == parentGroupName);
						if (group.Parent == null)
						{
							TShock.Log.ConsoleError(
								GetString($"Group {group.Name} is referencing a non existent parent group {parentGroupName}, parent reference was removed."));
						}
						else
						{
							if (group.Parent == group)
								TShock.Log.ConsoleWarn(
									GetString($"Group {group.Name} is referencing itself as parent group; parent reference was removed."));

							List<Group> groupChain = new List<Group> { group };
							Group checkingGroup = group;
							while (checkingGroup.Parent != null)
							{
								if (groupChain.Contains(checkingGroup.Parent))
								{
									TShock.Log.ConsoleError(
										GetString($"Group \"{checkingGroup.Name}\" is referencing parent group {checkingGroup.Parent.Name} which is already part of the parent chain. Parent reference removed."));

									checkingGroup.Parent = null;
									break;
								}
								groupChain.Add(checkingGroup);
								checkingGroup = checkingGroup.Parent;
							}
						}
					}
				}
				finally
				{
					if (!groups.Any(g => g is SuperAdminGroup))
						groups.Add(new SuperAdminGroup());
				}
			}
			catch (Exception ex)
			{
				TShock.Log.ConsoleError(GetString($"Error on reloading groups: {ex}"));
			}
		}
	}

	/// <summary>
	/// Represents the base GroupManager exception.
	/// </summary>
	[Serializable]
	public class GroupManagerException : Exception
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="GroupManagerException"/> with the specified message.
		/// </summary>
		/// <param name="message">The message.</param>
		public GroupManagerException(string message)
			: base(message)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="GroupManagerException"/> with the specified message and inner exception.
		/// </summary>
		/// <param name="message">The message.</param>
		/// <param name="inner">The inner exception.</param>
		public GroupManagerException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}

	/// <summary>
	/// Represents the GroupExists exception.
	/// This exception is thrown whenever an attempt to add an existing group into the database is made.
	/// </summary>
	[Serializable]
	public class GroupExistsException : GroupManagerException
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="GroupExistsException"/> with the specified group name.
		/// </summary>
		/// <param name="name">The group name.</param>
		public GroupExistsException(string name)
			: base(GetString($"Group {name} already exists"))
		{
		}
	}

	/// <summary>
	/// Represents the GroupNotExist exception.
	/// This exception is thrown whenever we try to access a group that does not exist.
	/// </summary>
	[Serializable]
	public class GroupNotExistException : GroupManagerException
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="GroupNotExistException"/> with the specified group name.
		/// </summary>
		/// <param name="name">The group name.</param>
		public GroupNotExistException(string name)
			: base(GetString($"Group {name} does not exist"))
		{
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/IQueryBuilder.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using MySql.Data.MySqlClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using TShockAPI.Extensions;

namespace TShockAPI.DB
{
	/// <summary>
	/// Interface for various SQL related utilities.
	/// </summary>
	public interface IQueryBuilder
	{
		/// <summary>
		/// Creates a table from a SqlTable object.
		/// </summary>
		/// <param name="table">The SqlTable to create the table from</param>
		/// <returns>The sql query for the table creation.</returns>
		string CreateTable(SqlTable table);

		/// <summary>
		/// Alter a table from source to destination
		/// </summary>
		/// <param name="from">Must have name and column names. Column types are not required</param>
		/// <param name="to">Must have column names and column types.</param>
		/// <returns>The SQL Query</returns>
		string AlterTable(SqlTable from, SqlTable to);

		/// <summary>
		/// Converts the MySqlDbType enum to it's string representation.
		/// </summary>
		/// <param name="type">The MySqlDbType type</param>
		/// <param name="length">The length of the datatype</param>
		/// <returns>The string representation</returns>
		string DbTypeToString(MySqlDbType type, int? length);

		/// <summary>
		/// A UPDATE Query
		/// </summary>
		/// <param name="table">The table to update</param>
		/// <param name="values">The values to change</param>
		/// <param name="wheres"></param>
		/// <returns>The SQL query</returns>
		string UpdateValue(string table, List<SqlValue> values, List<SqlValue> wheres);

		/// <summary>
		/// A INSERT query
		/// </summary>
		/// <param name="table">The table to insert to</param>
		/// <param name="values"></param>
		/// <returns>The SQL Query</returns>
		string InsertValues(string table, List<SqlValue> values);

		/// <summary>
		/// A SELECT query to get all columns
		/// </summary>
		/// <param name="table">The table to select from</param>
		/// <param name="wheres"></param>
		/// <returns>The SQL query</returns>
		string ReadColumn(string table, List<SqlValue> wheres);

		/// <summary>
		/// Deletes row(s).
		/// </summary>
		/// <param name="table">The table to delete the row from</param>
		/// <param name="wheres"></param>
		/// <returns>The SQL query</returns>
		string DeleteRow(string table, List<SqlValue> wheres);

		/// <summary>
		/// Renames the given table.
		/// </summary>
		/// <param name="from">Old name of the table</param>
		/// <param name="to">New name of the table</param>
		/// <returns>The sql query for renaming the table.</returns>
		string RenameTable(string from, string to);
	}

	/// <summary>
	/// Query Creator for Sqlite
	/// </summary>
	public class SqliteQueryCreator : GenericQueryCreator, IQueryBuilder
	{
		/// <summary>
		/// Creates a table from a SqlTable object.
		/// </summary>
		/// <param name="table">The SqlTable to create the table from</param>
		/// <returns>The sql query for the table creation.</returns>
		public override string CreateTable(SqlTable table)
		{
			ValidateSqlColumnType(table.Columns);
			var columns =
				table.Columns.Select(
					c =>
					"'{0}' {1} {2} {3} {4} {5}".SFormat(c.Name,
													DbTypeToString(c.Type, c.Length),
													c.Primary ? "PRIMARY KEY" : "",
													c.AutoIncrement ? "AUTOINCREMENT" : "",
													c.NotNull ? "NOT NULL" : "",
													c.DefaultCurrentTimestamp ? "DEFAULT CURRENT_TIMESTAMP" : ""));
			var uniques = table.Columns.Where(c => c.Unique).Select(c => c.Name);
			return "CREATE TABLE {0} ({1} {2})".SFormat(EscapeTableName(table.Name),
														string.Join(", ", columns),
														uniques.Count() > 0 ? ", UNIQUE({0})".SFormat(string.Join(", ", uniques)) : "");
		}

		/// <summary>
		/// Renames the given table.
		/// </summary>
		/// <param name="from">Old name of the table</param>
		/// <param name="to">New name of the table</param>
		/// <returns>The sql query for renaming the table.</returns>
		public override string RenameTable(string from, string to)
		{
			return "ALTER TABLE {0} RENAME TO {1}".SFormat(from, to);
		}

		private static readonly Dictionary<MySqlDbType, string> TypesAsStrings = new Dictionary<MySqlDbType, string>
		{
			{ MySqlDbType.VarChar, "TEXT" },
			{ MySqlDbType.String, "TEXT" },
			{ MySqlDbType.Text, "TEXT" },
			{ MySqlDbType.TinyText, "TEXT" },
			{ MySqlDbType.MediumText, "TEXT" },
			{ MySqlDbType.LongText, "TEXT" },
			{ MySqlDbType.Float, "REAL" },
			{ MySqlDbType.Double, "REAL" },
			{ MySqlDbType.Int32, "INTEGER" },
			{ MySqlDbType.Blob, "BLOB" },
			{ MySqlDbType.Int64, "BIGINT"},
			{ MySqlDbType.DateTime, "DATETIME"},
		};

		/// <summary>
		/// Converts the MySqlDbType enum to it's string representation.
		/// </summary>
		/// <param name="type">The MySqlDbType type</param>
		/// <param name="length">The length of the datatype</param>
		/// <returns>The string representation</returns>
		public string DbTypeToString(MySqlDbType type, int? length)
		{
			string ret;
			if (TypesAsStrings.TryGetValue(type, out ret))
				return ret;
			throw new NotImplementedException(Enum.GetName(typeof(MySqlDbType), type));
		}

		/// <summary>
		/// Escapes the table name
		/// </summary>
		/// <param name="table">The name of the table to be escaped</param>
		/// <returns></returns>
		protected override string EscapeTableName(string table)
		{
			return $"\'{table}\'";
		}
	}

	/// <summary>
	/// Query Creator for MySQL
	/// </summary>
	public class MysqlQueryCreator : GenericQueryCreator, IQueryBuilder
	{
		/// <summary>
		/// Creates a table from a SqlTable object.
		/// </summary>
		/// <param name="table">The SqlTable to create the table from</param>
		/// <returns>The sql query for the table creation.</returns>
		public override string CreateTable(SqlTable table)
		{
			ValidateSqlColumnType(table.Columns);
			var columns =
				table.Columns.Select(
					c =>
					"`{0}` {1} {2} {3} {4} {5}".SFormat(c.Name, DbTypeToString(c.Type, c.Length),
												c.Primary ? "PRIMARY KEY" : "",
												c.AutoIncrement ? "AUTO_INCREMENT" : "",
												c.NotNull ? "NOT NULL" : "",
												c.DefaultCurrentTimestamp ? "DEFAULT CURRENT_TIMESTAMP" : ""));
			var uniques = table.Columns.Where(c => c.Unique).Select(c => $"`{c.Name}`");
			return "CREATE TABLE {0} ({1} {2})".SFormat(EscapeTableName(table.Name), string.Join(", ", columns),
														uniques.Count() > 0
															? ", UNIQUE({0})".SFormat(string.Join(", ", uniques))
															: "");
		}

		/// <summary>
		/// Renames the given table.
		/// </summary>
		/// <param name="from">Old name of the table</param>
		/// <param name="to">New name of the table</param>
		/// <returns>The sql query for renaming the table.</returns>
		public override string RenameTable(string from, string to)
		{
			return "RENAME TABLE {0} TO {1}".SFormat(from, to);
		}

		private static readonly Dictionary<MySqlDbType, string> TypesAsStrings = new Dictionary<MySqlDbType, string>
		{
			{ MySqlDbType.VarChar, "VARCHAR" },
			{ MySqlDbType.String, "CHAR" },
			{ MySqlDbType.Text, "TEXT" },
			{ MySqlDbType.TinyText, "TINYTEXT" },
			{ MySqlDbType.MediumText, "MEDIUMTEXT" },
			{ MySqlDbType.LongText, "LONGTEXT" },
			{ MySqlDbType.Float, "FLOAT" },
			{ MySqlDbType.Double, "DOUBLE" },
			{ MySqlDbType.Int32, "INT" },
			{ MySqlDbType.Int64, "BIGINT"},
			{ MySqlDbType.DateTime, "DATETIME"},
		};

		/// <summary>
		/// Converts the MySqlDbType enum to it's string representation.
		/// </summary>
		/// <param name="type">The MySqlDbType type</param>
		/// <param name="length">The length of the datatype</param>
		/// <returns>The string representation</returns>
		public string DbTypeToString(MySqlDbType type, int? length)
		{
			string ret;
			if (TypesAsStrings.TryGetValue(type, out ret))
				return ret + (length != null ? "({0})".SFormat((int)length) : "");
			throw new NotImplementedException(Enum.GetName(typeof(MySqlDbType), type));
		}

		/// <summary>
		/// Escapes the table name
		/// </summary>
		/// <param name="table">The name of the table to be escaped</param>
		/// <returns></returns>
		protected override string EscapeTableName(string table)
		{
			return table.SFormat("`{0}`", table);
		}
	}

	/// <summary>
	/// A Generic Query Creator (abstract)
	/// </summary>
	public abstract class GenericQueryCreator
	{
		protected static Random rand = new Random();

		/// <summary>
		/// Escapes the table name
		/// </summary>
		/// <param name="table">The name of the table to be escaped</param>
		/// <returns></returns>
		protected abstract string EscapeTableName(string table);

		/// <summary>
		/// Creates a table from a SqlTable object.
		/// </summary>
		/// <param name="table">The SqlTable to create the table from</param>
		/// <returns>The sql query for the table creation.</returns>
		public abstract string CreateTable(SqlTable table);

		/// <summary>
		/// Renames the given table.
		/// </summary>
		/// <param name="from">Old name of the table</param>
		/// <param name="to">New name of the table</param>
		/// <returns>The sql query for renaming the table.</returns>
		public abstract string RenameTable(string from, string to);

		/// <summary>
		/// Alter a table from source to destination
		/// </summary>
		/// <param name="from">Must have name and column names. Column types are not required</param>
		/// <param name="to">Must have column names and column types.</param>
		/// <returns>The SQL Query</returns>
		public string AlterTable(SqlTable from, SqlTable to)
		{
			var rstr = rand.NextString(20);
			var escapedTable = EscapeTableName(from.Name);
			var tmpTable = EscapeTableName("{0}_{1}".SFormat(rstr, from.Name));
			var alter = RenameTable(escapedTable, tmpTable);
			var create = CreateTable(to);
			// combine all columns in the 'from' variable excluding ones that aren't in the 'to' variable.
			// exclude the ones that aren't in 'to' variable because if the column is deleted, why try to import the data?
			var columns = string.Join(", ", from.Columns.Where(c => to.Columns.Any(c2 => c2.Name == c.Name)).Select(c => $"`{c.Name}`"));
			var insert = "INSERT INTO {0} ({1}) SELECT {1} FROM {2}".SFormat(escapedTable, columns, tmpTable);
			var drop = "DROP TABLE {0}".SFormat(tmpTable);
			return "{0}; {1}; {2}; {3};".SFormat(alter, create, insert, drop);
		}

		/// <summary>
		/// Check for errors in the columns.
		/// </summary>
		/// <param name="columns"></param>
		/// <exception cref="SqlColumnException"></exception>
		public void ValidateSqlColumnType(List<SqlColumn> columns)
		{
			columns.ForEach(x =>
			{
				if (x.DefaultCurrentTimestamp && x.Type != MySqlDbType.DateTime)
				{
					throw new SqlColumnException(GetString("Can't set to true SqlColumn.DefaultCurrentTimestamp when the MySqlDbType is not DateTime"));
				}
			});
		}

		/// <summary>
		/// Deletes row(s).
		/// </summary>
		/// <param name="table">The table to delete the row from</param>
		/// <param name="wheres"></param>
		/// <returns>The SQL query</returns>
		public string DeleteRow(string table, List<SqlValue> wheres)
		{
			return "DELETE FROM {0} {1}".SFormat(EscapeTableName(table), BuildWhere(wheres));
		}

		/// <summary>
		/// A UPDATE Query
		/// </summary>
		/// <param name="table">The table to update</param>
		/// <param name="values">The values to change</param>
		/// <param name="wheres"></param>
		/// <returns>The SQL query</returns>
		public string UpdateValue(string table, List<SqlValue> values, List<SqlValue> wheres)
		{
			if (0 == values.Count)
				throw new ArgumentException(GetString("No values supplied"));

			return "UPDATE {0} SET {1} {2}".SFormat(EscapeTableName(table), string.Join(", ", values.Select(v => v.Name + " = " + v.Value)), BuildWhere(wheres));
		}

		/// <summary>
		/// A SELECT query to get all columns
		/// </summary>
		/// <param name="table">The table to select from</param>
		/// <param name="wheres"></param>
		/// <returns>The SQL query</returns>
		public string ReadColumn(string table, List<SqlValue> wheres)
		{
			return "SELECT * FROM {0} {1}".SFormat(EscapeTableName(table), BuildWhere(wheres));
		}

		/// <summary>
		/// A INSERT query
		/// </summary>
		/// <param name="table">The table to insert to</param>
		/// <param name="values"></param>
		/// <returns>The SQL Query</returns>
		public string InsertValues(string table, List<SqlValue> values)
		{
			var sbnames = new StringBuilder();
			var sbvalues = new StringBuilder();
			int count = 0;
			foreach (SqlValue value in values)
			{
				sbnames.Append(value.Name);
				sbvalues.Append(value.Value.ToString());

				if (count != values.Count - 1)
				{
					sbnames.Append(", ");
					sbvalues.Append(", ");
				}
				count++;
			}

			return "INSERT INTO {0} ({1}) VALUES ({2})".SFormat(EscapeTableName(table), sbnames, sbvalues);
		}

		/// <summary>
		/// Builds the SQL WHERE clause
		/// </summary>
		/// <param name="wheres"></param>
		/// <returns></returns>
		protected static string BuildWhere(List<SqlValue> wheres)
		{
			if (0 == wheres.Count)
				return string.Empty;

			return "WHERE {0}".SFormat(string.Join(", ", wheres.Select(v => $"{v.Name}" + " = " + v.Value)));
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/ItemManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using MySql.Data.MySqlClient;
using TShockAPI.Hooks;

namespace TShockAPI.DB
{
	public class ItemManager
	{
		private IDbConnection database;
		public List<ItemBan> ItemBans = new List<ItemBan>();

		public ItemManager(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("ItemBans",
			                         new SqlColumn("ItemName", MySqlDbType.VarChar, 50) {Primary = true},
			                         new SqlColumn("AllowedGroups", MySqlDbType.Text)
				);
			var creator = new SqlTableCreator(db,
			                                  db.GetSqlType() == SqlType.Sqlite
			                                  	? (IQueryBuilder) new SqliteQueryCreator()
			                                  	: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
			UpdateItemBans();
		}

		public void UpdateItemBans()
		{
			ItemBans.Clear();

			using (var reader = database.QueryReader("SELECT * FROM ItemBans"))
			{
				while (reader != null && reader.Read())
				{
					ItemBan ban = new ItemBan(reader.Get<string>("ItemName"));
					ban.SetAllowedGroups(reader.Get<string>("AllowedGroups"));
					ItemBans.Add(ban);
				}
			}
		}

		public void AddNewBan(string itemname = "")
		{
			try
			{
				database.Query("INSERT INTO ItemBans (ItemName, AllowedGroups) VALUES (@0, @1);",
				               itemname, "");
				if (!ItemIsBanned(itemname, null))
					ItemBans.Add(new ItemBan(itemname));
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
		}

		public void RemoveBan(string itemname)
		{
			if (!ItemIsBanned(itemname, null))
				return;
			try
			{
				database.Query("DELETE FROM ItemBans WHERE ItemName=@0;", itemname);
				ItemBans.Remove(new ItemBan(itemname));
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
		}

		public bool ItemIsBanned(string name)
		{
			if (ItemBans.Contains(new ItemBan(name)))
			{
				return true;
			}
			return false;
		}

		public bool ItemIsBanned(string name, TSPlayer ply)
		{
			ItemBan b = GetItemBanByName(name);
			return b != null &&!b.HasPermissionToUseItem(ply);
		}

		public bool AllowGroup(string item, string name)
		{
			string groupsNew = "";
			ItemBan b = GetItemBanByName(item);
			if (b != null)
			{
				try
				{
					groupsNew = String.Join(",", b.AllowedGroups);
					if (groupsNew.Length > 0)
						groupsNew += ",";
					groupsNew += name;
					b.SetAllowedGroups(groupsNew);

					int q = database.Query("UPDATE ItemBans SET AllowedGroups=@0 WHERE ItemName=@1", groupsNew,
					                       item);
					
					return q > 0;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}

			return false;
		}

		public bool RemoveGroup(string item, string group)
		{
			ItemBan b = GetItemBanByName(item);
			if (b != null)
			{
				try
				{				
					b.RemoveGroup(group);
					string groups = string.Join(",", b.AllowedGroups);
					int q = database.Query("UPDATE ItemBans SET AllowedGroups=@0 WHERE ItemName=@1", groups,
					                       item);
					
					if (q > 0)
						return true;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
			return false;
		}

		public ItemBan GetItemBanByName(String name)
		{
			for (int i = 0; i < ItemBans.Count; i++)
			{
				if (ItemBans[i].Name == name)
				{
					return ItemBans[i];
				}
			}
			return null;
		}
	}

	public class ItemBan : IEquatable<ItemBan>
	{
		public string Name { get; set; }
		public List<string> AllowedGroups { get; set; }

		public ItemBan(string name)
			: this()
		{
			Name = name;
			AllowedGroups = new List<string>();
		}

		public ItemBan()
		{
			Name = "";
			AllowedGroups = new List<string>();
		}

		public bool Equals(ItemBan other)
		{
			return Name == other.Name;
		}

		public bool HasPermissionToUseItem(TSPlayer ply)
		{
			if (ply == null)
				return false;

			if (ply.HasPermission(Permissions.usebanneditem))
				return true;

			PermissionHookResult hookResult = PlayerHooks.OnPlayerItembanPermission(ply, this);
			if (hookResult != PermissionHookResult.Unhandled)
				return hookResult == PermissionHookResult.Granted;

			var cur = ply.Group;
			var traversed = new List<Group>();
			while (cur != null)
			{
				if (AllowedGroups.Contains(cur.Name))
				{
					return true;
				}
				if (traversed.Contains(cur))
				{
					throw new InvalidOperationException("Infinite group parenting ({0})".SFormat(cur.Name));
				}
				traversed.Add(cur);
				cur = cur.Parent;
			}
			return false;
			// could add in the other permissions in this class instead of a giant if switch.
		}

		public void SetAllowedGroups(String groups)
		{
			// prevent null pointer exceptions
			if (!string.IsNullOrEmpty(groups))
			{
				List<String> groupArr = groups.Split(',').ToList();

				for (int i = 0; i < groupArr.Count; i++)
				{
					groupArr[i] = groupArr[i].Trim();
					//Console.WriteLine(groupArr[i]);
				}
				AllowedGroups = groupArr;
			}
		}

		public bool RemoveGroup(string groupName)
		{
			return AllowedGroups.Remove(groupName);
		}
		
		public override string ToString()
		{
			return Name + (AllowedGroups.Count > 0 ? " (" + String.Join(",", AllowedGroups) + ")" : "");
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/ProjectileManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using MySql.Data.MySqlClient;
using TShockAPI.Hooks;

namespace TShockAPI.DB
{
	public class ProjectileManagager
	{
		private IDbConnection database;
		public List<ProjectileBan> ProjectileBans = new List<ProjectileBan>();

		public ProjectileManagager(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("ProjectileBans",
				new SqlColumn("ProjectileID", MySqlDbType.Int32) {Primary = true},
				new SqlColumn("AllowedGroups", MySqlDbType.Text)
				);
			var creator = new SqlTableCreator(db,
				db.GetSqlType() == SqlType.Sqlite
					? (IQueryBuilder) new SqliteQueryCreator()
					: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
			UpdateBans();
		}

		public void UpdateBans()
		{
			ProjectileBans.Clear();

			using (var reader = database.QueryReader("SELECT * FROM ProjectileBans"))
			{
				while (reader != null && reader.Read())
				{
					ProjectileBan ban = new ProjectileBan((short) reader.Get<Int32>("ProjectileID"));
					ban.SetAllowedGroups(reader.Get<string>("AllowedGroups"));
					ProjectileBans.Add(ban);
				}
			}
		}

		public void AddNewBan(short id = 0)
		{
			try
			{
				database.Query("INSERT INTO ProjectileBans (ProjectileID, AllowedGroups) VALUES (@0, @1);",
					id, "");

				if (!ProjectileIsBanned(id, null))
					ProjectileBans.Add(new ProjectileBan(id));
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
		}

		public void RemoveBan(short id)
		{
			if (!ProjectileIsBanned(id, null))
				return;
			try
			{
				database.Query("DELETE FROM ProjectileBans WHERE ProjectileId=@0;", id);
				ProjectileBans.Remove(new ProjectileBan(id));
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
		}

		public bool ProjectileIsBanned(short id)
		{
			if (ProjectileBans.Contains(new ProjectileBan(id)))
			{
				return true;
			}
			return false;
		}

		public bool ProjectileIsBanned(short id, TSPlayer ply)
		{
			if (ProjectileBans.Contains(new ProjectileBan(id)))
			{
				ProjectileBan b = GetBanById(id);
				return !b.HasPermissionToCreateProjectile(ply);
			}
			return false;
		}

		public bool AllowGroup(short id, string name)
		{
			string groupsNew = "";
			ProjectileBan b = GetBanById(id);
			if (b != null)
			{
					try
				{
					groupsNew = String.Join(",", b.AllowedGroups);
					if (groupsNew.Length > 0)
						groupsNew += ",";
					groupsNew += name;
					b.SetAllowedGroups(groupsNew);

					int q = database.Query("UPDATE ProjectileBans SET AllowedGroups=@0 WHERE ProjectileId=@1", groupsNew,
						id);

					return q > 0;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}

			return false;
		}

		public bool RemoveGroup(short id, string group)
		{
			ProjectileBan b = GetBanById(id);
			if (b != null)
			{
				try
				{
					b.RemoveGroup(group);
					string groups = string.Join(",", b.AllowedGroups);
					int q = database.Query("UPDATE ProjectileBans SET AllowedGroups=@0 WHERE ProjectileId=@1", groups,
						id);

					if (q > 0)
						return true;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
			return false;
		}

		public ProjectileBan GetBanById(short id)
		{
			foreach (ProjectileBan b in ProjectileBans)
			{
				if (b.ID == id)
				{
					return b;
				}
			}
			return null;
		}
	}

	public class ProjectileBan : IEquatable<ProjectileBan>
	{
		public short ID { get; set; }
		public List<string> AllowedGroups { get; set; }

		public ProjectileBan(short id)
			: this()
		{
			ID = id;
			AllowedGroups = new List<string>();
		}

		public ProjectileBan()
		{
			ID = 0;
			AllowedGroups = new List<string>();
		}

		public bool Equals(ProjectileBan other)
		{
			return ID == other.ID;
		}

		public bool HasPermissionToCreateProjectile(TSPlayer ply)
		{
			if (ply == null)
				return false;

			if (ply.HasPermission(Permissions.canusebannedprojectiles))
				return true;

			PermissionHookResult hookResult = PlayerHooks.OnPlayerProjbanPermission(ply, this);
			if (hookResult != PermissionHookResult.Unhandled)
				return hookResult == PermissionHookResult.Granted;

			var cur = ply.Group;
			var traversed = new List<Group>();
			while (cur != null)
			{
				if (AllowedGroups.Contains(cur.Name))
				{
					return true;
				}
				if (traversed.Contains(cur))
				{
					throw new InvalidOperationException(GetString($"Infinite group parenting ({cur.Name})"));
				}
				traversed.Add(cur);
				cur = cur.Parent;
			}
			return false;
			// could add in the other permissions in this class instead of a giant if switch.
		}

		public void SetAllowedGroups(String groups)
		{
			// prevent null pointer exceptions
			if (!string.IsNullOrEmpty(groups))
			{
				List<String> groupArr = groups.Split(',').ToList();

				for (int i = 0; i < groupArr.Count; i++)
				{
					groupArr[i] = groupArr[i].Trim();
					//Console.WriteLine(groupArr[i]);
				}
				AllowedGroups = groupArr;
			}
		}

		public bool RemoveGroup(string groupName)
		{
			return AllowedGroups.Remove(groupName);
		}

		public override string ToString()
		{
			return ID + (AllowedGroups.Count > 0 ? " (" + String.Join(",", AllowedGroups) + ")" : "");
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/RegionManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using MySql.Data.MySqlClient;
using Terraria;
using Microsoft.Xna.Framework;

namespace TShockAPI.DB
{
	/// <summary>
	/// Represents the Region database manager.
	/// </summary>
	public class RegionManager
	{
		/// <summary>
		/// The list of regions.
		/// </summary>
		public List<Region> Regions = new List<Region>();

		private IDbConnection database;

		internal RegionManager(IDbConnection db)
		{
			database = db;
			var table = new SqlTable("Regions",
									 new SqlColumn("Id", MySqlDbType.Int32) {Primary = true, AutoIncrement = true},
									 new SqlColumn("X1", MySqlDbType.Int32),
									 new SqlColumn("Y1", MySqlDbType.Int32),
									 new SqlColumn("width", MySqlDbType.Int32),
									 new SqlColumn("height", MySqlDbType.Int32),
									 new SqlColumn("RegionName", MySqlDbType.VarChar, 50) {Unique = true},
									 new SqlColumn("WorldID", MySqlDbType.VarChar, 50) { Unique = true },
									 new SqlColumn("UserIds", MySqlDbType.Text),
									 new SqlColumn("Protected", MySqlDbType.Int32),
									 new SqlColumn("Groups", MySqlDbType.Text),
									 new SqlColumn("Owner", MySqlDbType.VarChar, 50),
									 new SqlColumn("Z", MySqlDbType.Int32){ DefaultValue = "0" }
				);
			var creator = new SqlTableCreator(db,
											  db.GetSqlType() == SqlType.Sqlite
											  	? (IQueryBuilder) new SqliteQueryCreator()
											  	: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
		}

		/// <summary>
		/// Reloads all regions.
		/// </summary>
		public void Reload()
		{
			try
			{
				using (var reader = database.QueryReader("SELECT * FROM Regions WHERE WorldID=@0", Main.worldID.ToString()))
				{
					Regions.Clear();
					while (reader.Read())
					{
						int id = reader.Get<int>("Id");
						int X1 = reader.Get<int>("X1");
						int Y1 = reader.Get<int>("Y1");
						int height = reader.Get<int>("height");
						int width = reader.Get<int>("width");
						int Protected = reader.Get<int>("Protected");
						string mergedids = reader.Get<string>("UserIds");
						string name = reader.Get<string>("RegionName");
						string owner = reader.Get<string>("Owner");
						string groups = reader.Get<string>("Groups");
						int z = reader.Get<int>("Z");

						string[] splitids = mergedids.Split(new[] {','}, StringSplitOptions.RemoveEmptyEntries);

						Region r = new Region(id, new Rectangle(X1, Y1, width, height), name, owner, Protected != 0, Main.worldID.ToString(), z);
						r.SetAllowedGroups(groups);
						try
						{
							for (int i = 0; i < splitids.Length; i++)
							{
								int userid;

								if (Int32.TryParse(splitids[i], out userid)) // if unparsable, it's not an int, so silently skip
									r.AllowedIDs.Add(userid);
								else
									TShock.Log.Warn(GetString($"One of your UserIDs is not a usable integer: {splitids[i]}"));
							}
						}
						catch (Exception e)
						{
							TShock.Log.Error(GetString("Your database contains invalid UserIDs (they should be integers)."));
							TShock.Log.Error(GetString("A lot of things will fail because of this. You must manually delete and re-create the allowed field."));
							TShock.Log.Error(e.ToString());
							TShock.Log.Error(e.StackTrace);
						}

						Regions.Add(r);
					}
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
		}

		/// <summary>
		/// Adds a region to the database.
		/// </summary>
		/// <param name="tx">TileX of the top left corner.</param>
		/// <param name="ty">TileY of the top left corner.</param>
		/// <param name="width">Width of the region in tiles.</param>
		/// <param name="height">Height of the region in tiles.</param>
		/// <param name="regionname">The name of the region.</param>
		/// <param name="owner">The User Account Name of the person who created this region.</param>
		/// <param name="worldid">The world id that this region is in.</param>
		/// <param name="z">The Z index of the region.</param>
		/// <returns>Whether the region was created and added successfully.</returns>
		public bool AddRegion(int tx, int ty, int width, int height, string regionname, string owner, string worldid, int z = 0)
		{
			if (GetRegionByName(regionname) != null)
			{
				return false;
			}
			try
			{
				database.Query(
					"INSERT INTO Regions (X1, Y1, width, height, RegionName, WorldID, UserIds, Protected, `Groups`, Owner, Z) VALUES (@0, @1, @2, @3, @4, @5, @6, @7, @8, @9, @10);",
					tx, ty, width, height, regionname, worldid, "", 1, "", owner, z);
				int id;
				using (QueryResult res = database.QueryReader("SELECT Id FROM Regions WHERE RegionName = @0 AND WorldID = @1", regionname, worldid))
				{
					if (res.Read())
					{
						id = res.Get<int>("Id");
					}
					else
					{
						return false;
					}
				}
				Region region = new Region(id, new Rectangle(tx, ty, width, height), regionname, owner, true, worldid, z);
				Regions.Add(region);
				Hooks.RegionHooks.OnRegionCreated(region);
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Deletes the region from this world with a given ID.
		/// </summary>
		/// <param name="id">The ID of the region to delete.</param>
		/// <returns>Whether the region was successfully deleted.</returns>
		public bool DeleteRegion(int id)
		{
			try
			{
				database.Query("DELETE FROM Regions WHERE Id=@0 AND WorldID=@1", id, Main.worldID.ToString());
				var worldid = Main.worldID.ToString();
				var region = Regions.FirstOrDefault(r => r.ID == id && r.WorldID == worldid);
				Regions.RemoveAll(r => r.ID == id && r.WorldID == worldid);
				Hooks.RegionHooks.OnRegionDeleted(region);
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Deletes the region from this world with a given name.
		/// </summary>
		/// <param name="name">The name of the region to delete.</param>
		/// <returns>Whether the region was successfully deleted.</returns>
		public bool DeleteRegion(string name)
		{
			try
			{
				database.Query("DELETE FROM Regions WHERE RegionName=@0 AND WorldID=@1", name, Main.worldID.ToString());
				var worldid = Main.worldID.ToString();
				var region = Regions.FirstOrDefault(r => r.Name == name && r.WorldID == worldid);
				Regions.RemoveAll(r => r.Name == name && r.WorldID == worldid);
				Hooks.RegionHooks.OnRegionDeleted(region);
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Sets the protected state of the region with a given ID.
		/// </summary>
		/// <param name="id">The ID of the region to change.</param>
		/// <param name="state">New protected state of the region.</param>
		/// <returns>Whether the region's state was successfully changed.</returns>
		public bool SetRegionState(int id, bool state)
		{
			try
			{
				database.Query("UPDATE Regions SET Protected = @0 WHERE Id = @1 AND WorldID = @2", state ? 1 : 0, id,
							   Main.worldID.ToString());
				var region = GetRegionByID(id);
				if (region != null)
				{
					region.DisableBuild = state;
				}
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
				return false;
			}
		}

		/// <summary>
		/// Sets the protected state of the region with a given name.
		/// </summary>
		/// <param name="name">The name of the region to change.</param>
		/// <param name="state">New protected state of the region.</param>
		/// <returns>Whether the region's state was successfully changed.</returns>
		public bool SetRegionState(string name, bool state)
		{
			try
			{
				database.Query("UPDATE Regions SET Protected=@0 WHERE RegionName=@1 AND WorldID=@2", state ? 1 : 0, name,
							   Main.worldID.ToString());
				var region = GetRegionByName(name);
				if (region != null)
					region.DisableBuild = state;
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
				return false;
			}
		}

		/// <summary>
		/// Checks if a given player can build in a region at the given (x, y) coordinate
		/// </summary>
		/// <param name="x">X coordinate</param>
		/// <param name="y">Y coordinate</param>
		/// <param name="ply">Player to check permissions with</param>
		/// <returns>Whether the player can build at the given (x, y) coordinate</returns>
		public bool CanBuild(int x, int y, TSPlayer ply)
		{
			if (!ply.HasPermission(Permissions.canbuild))
			{
				return false;
			}
			Region top = null;

			foreach (Region region in Regions.ToList())
			{
				if (region.InArea(x, y))
				{
					if (top == null || region.Z > top.Z)
						top = region;
				}
			}
			return top == null || top.HasPermissionToBuildInRegion(ply);
		}

		/// <summary>
		/// Checks if any regions exist at the given (x, y) coordinate
		/// </summary>
		/// <param name="x">X coordinate</param>
		/// <param name="y">Y coordinate</param>
		/// <returns>Whether any regions exist at the given (x, y) coordinate</returns>
		public bool InArea(int x, int y)
		{
			return Regions.Any(r => r.InArea(x, y));
		}

		/// <summary>
		/// Checks if any regions exist at the given (x, y) coordinate
		/// and returns an IEnumerable containing their names
		/// </summary>
		/// <param name="x">X coordinate</param>
		/// <param name="y">Y coordinate</param>
		/// <returns>The names of any regions that exist at the given (x, y) coordinate</returns>
		public IEnumerable<string> InAreaRegionName(int x, int y)
		{
			return Regions.Where(r => r.InArea(x, y)).Select(r => r.Name);
		}

		/// <summary>
		/// Checks if any regions exist at the given (x, y) coordinate
		/// and returns an IEnumerable containing their IDs
		/// </summary>
		/// <param name="x">X coordinate</param>
		/// <param name="y">Y coordinate</param>
		/// <returns>The IDs of any regions that exist at the given (x, y) coordinate</returns>
		public IEnumerable<int> InAreaRegionID(int x, int y)
		{
			return Regions.Where(r => r.InArea(x, y)).Select(r => r.ID);
		}

		/// <summary>
		/// Checks if any regions exist at the given (x, y) coordinate
		/// and returns an IEnumerable containing their <see cref="Region"/> objects
		/// </summary>
		/// <param name="x">X coordinate</param>
		/// <param name="y">Y coordinate</param>
		/// <returns>The <see cref="Region"/> objects of any regions that exist at the given (x, y) coordinate</returns>
		public IEnumerable<Region> InAreaRegion(int x, int y)
		{
			return Regions.Where(r => r.InArea(x, y));
		}

		/// <summary>
		/// Changes the size of a given region
		/// </summary>
		/// <param name="regionName">Name of the region to resize</param>
		/// <param name="addAmount">Amount to resize</param>
		/// <param name="direction">Direction to resize in:
		/// 0 = resize height and Y.
		/// 1 = resize width.
		/// 2 = resize height.
		/// 3 = resize width and X.</param>
		/// <returns></returns>
		public bool ResizeRegion(string regionName, int addAmount, int direction)
		{
			//0 = up
			//1 = right
			//2 = down
			//3 = left
			int X = 0;
			int Y = 0;
			int height = 0;
			int width = 0;

			try
			{
				using (var reader = database.QueryReader("SELECT X1, Y1, height, width FROM Regions WHERE RegionName=@0 AND WorldID=@1",
													  regionName, Main.worldID.ToString()))
				{
					if (reader.Read())
					{
						X = reader.Get<int>("X1");
						width = reader.Get<int>("width");
						Y = reader.Get<int>("Y1");
						height = reader.Get<int>("height");
					}
				}
				switch (direction)
				{
					case 0:
						Y -= addAmount;
						height += addAmount;
						break;
					case 1:
						width += addAmount;
						break;
					case 2:
						height += addAmount;
						break;
					case 3:
						X -= addAmount;
						width += addAmount;
						break;
					default:
						return false;
				}

				foreach (var region in Regions.Where(r => r.Name == regionName))
					region.Area = new Rectangle(X, Y, width, height);
				int q = database.Query("UPDATE Regions SET X1 = @0, Y1 = @1, width = @2, height = @3 WHERE RegionName = @4 AND WorldID=@5", X, Y, width,
						height, regionName, Main.worldID.ToString());
				if (q > 0)
					return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Renames a region
		/// </summary>
		/// <param name="oldName">Name of the region to rename</param>
		/// <param name="newName">New name of the region</param>
		/// <returns>true if renamed successfully, false otherwise</returns>
		public bool RenameRegion(string oldName, string newName)
		{
			Region region = null;
			string worldID = Main.worldID.ToString();

			bool result = false;

			try
			{
				int q = database.Query("UPDATE Regions SET RegionName = @0 WHERE RegionName = @1 AND WorldID = @2",
																					newName, oldName, worldID);

				if (q > 0)
				{
					region = Regions.First(r => r.Name == oldName && r.WorldID == worldID);
					region.Name = newName;
					Hooks.RegionHooks.OnRegionRenamed(region, oldName, newName);
					result = true;
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}

			return result;
		}

		/// <summary>
		/// Removes an allowed user from a region
		/// </summary>
		/// <param name="regionName">Name of the region to modify</param>
		/// <param name="userName">Username to remove</param>
		/// <returns>true if removed successfully</returns>
		public bool RemoveUser(string regionName, string userName)
		{
			Region r = GetRegionByName(regionName);
			if (r != null)
			{
				if (!r.RemoveID(TShock.UserAccounts.GetUserAccountID(userName)))
				{
					return false;
				}

				string ids = string.Join(",", r.AllowedIDs);
				return database.Query("UPDATE Regions SET UserIds=@0 WHERE RegionName=@1 AND WorldID=@2", ids,
									   regionName, Main.worldID.ToString()) > 0;
			}

			return false;
		}

		/// <summary>
		/// Adds a user to a region's allowed user list
		/// </summary>
		/// <param name="regionName">Name of the region to modify</param>
		/// <param name="userName">Username to add</param>
		/// <returns>true if added successfully</returns>
		public bool AddNewUser(string regionName, string userName)
		{
			try
			{
				string mergedIDs = string.Empty;
				using (
					var reader = database.QueryReader("SELECT UserIds FROM Regions WHERE RegionName=@0 AND WorldID=@1", regionName,
													  Main.worldID.ToString()))
				{
					if (reader.Read())
						mergedIDs = reader.Get<string>("UserIds");
				}

				string userIdToAdd = Convert.ToString(TShock.UserAccounts.GetUserAccountID(userName));
				string[] ids = mergedIDs.Split(',');
				// Is the user already allowed to the region?
				if (ids.Contains(userIdToAdd))
					return true;

				if (string.IsNullOrEmpty(mergedIDs))
					mergedIDs = userIdToAdd;
				else
					mergedIDs = string.Concat(mergedIDs, ",", userIdToAdd);

				int q = database.Query("UPDATE Regions SET UserIds=@0 WHERE RegionName=@1 AND WorldID=@2", mergedIDs,
									   regionName, Main.worldID.ToString());
				foreach (var r in Regions)
				{
					if (r.Name == regionName && r.WorldID == Main.worldID.ToString())
						r.SetAllowedIDs(mergedIDs);
				}
				return q != 0;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Sets the position of a region.
		/// </summary>
		/// <param name="regionName">The region name.</param>
		/// <param name="x">The X position.</param>
		/// <param name="y">The Y position.</param>
		/// <param name="height">The height.</param>
		/// <param name="width">The width.</param>
		/// <returns>Whether the operation succeeded.</returns>
		public bool PositionRegion(string regionName, int x, int y, int width, int height)
		{
			try
			{
				Region region = Regions.First(r => String.Equals(regionName, r.Name, StringComparison.OrdinalIgnoreCase));
				region.Area = new Rectangle(x, y, width, height);

				if (database.Query("UPDATE Regions SET X1 = @0, Y1 = @1, width = @2, height = @3 WHERE RegionName = @4 AND WorldID = @5",
					x, y, width, height, regionName, Main.worldID.ToString()) > 0)
					return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Gets all the regions names from world
		/// </summary>
		/// <param name="worldid">World name to get regions from</param>
		/// <returns>List of regions with only their names</returns>
		public List<Region> ListAllRegions(string worldid)
		{
			var regions = new List<Region>();
			try
			{
				using (var reader = database.QueryReader("SELECT RegionName FROM Regions WHERE WorldID=@0", worldid))
				{
					while (reader.Read())
						regions.Add(new Region {Name = reader.Get<string>("RegionName")});
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return regions;
		}

		/// <summary>
		/// Returns a region with the given name
		/// </summary>
		/// <param name="name">Region name</param>
		/// <returns>The region with the given name, or null if not found</returns>
		public Region GetRegionByName(String name)
		{
			return Regions.FirstOrDefault(r => r.Name.Equals(name) && r.WorldID == Main.worldID.ToString());
		}

		/// <summary>
		/// Returns a region with the given ID
		/// </summary>
		/// <param name="id">Region ID</param>
		/// <returns>The region with the given ID, or null if not found</returns>
		public Region GetRegionByID(int id)
		{
			return Regions.FirstOrDefault(r => r.ID == id && r.WorldID == Main.worldID.ToString());
		}

		/// <summary>
		/// Changes the owner of the region with the given name
		/// </summary>
		/// <param name="regionName">Region name</param>
		/// <param name="newOwner">New owner's username</param>
		/// <returns>Whether the change was successful</returns>
		public bool ChangeOwner(string regionName, string newOwner)
		{
			var region = GetRegionByName(regionName);
			if (region != null)
			{
				region.Owner = newOwner;
				int q = database.Query("UPDATE Regions SET Owner=@0 WHERE RegionName=@1 AND WorldID=@2", newOwner,
									   regionName, Main.worldID.ToString());
				if (q > 0)
					return true;
			}
			return false;
		}

		/// <summary>
		/// Allows a group to use a region
		/// </summary>
		/// <param name="regionName">Region name</param>
		/// <param name="groupName">Group's name</param>
		/// <returns>Whether the change was successful</returns>
		public bool AllowGroup(string regionName, string groupName)
		{
			string mergedGroups = "";
			using (
				var reader = database.QueryReader("SELECT `Groups` FROM Regions WHERE RegionName=@0 AND WorldID=@1", regionName,
												  Main.worldID.ToString()))
			{
				if (reader.Read())
					mergedGroups = reader.Get<string>("Groups");
			}

			string[] groups = mergedGroups.Split(',');
			// Is the group already allowed to the region?
			if (groups.Contains(groupName))
				return true;

			if (mergedGroups != "")
				mergedGroups += ",";
			mergedGroups += groupName;

			int q = database.Query("UPDATE Regions SET `Groups`=@0 WHERE RegionName=@1 AND WorldID=@2", mergedGroups,
								   regionName, Main.worldID.ToString());

			Region r = GetRegionByName(regionName);
			if (r != null)
			{
				r.SetAllowedGroups(mergedGroups);
			}
			else
			{
				return false;
			}

			return q > 0;
		}

		/// <summary>
		/// Removes a group's access to a region
		/// </summary>
		/// <param name="regionName">Region name</param>
		/// <param name="group">Group name</param>
		/// <returns>Whether the change was successful</returns>
		public bool RemoveGroup(string regionName, string group)
		{
			Region r = GetRegionByName(regionName);
			if (r != null)
			{
				r.RemoveGroup(group);
				string groups = string.Join(",", r.AllowedGroups);
				int q = database.Query("UPDATE Regions SET `Groups`=@0 WHERE RegionName=@1 AND WorldID=@2", groups,
									   regionName, Main.worldID.ToString());
				if (q > 0)
					return true;
			}
			return false;
		}

		/// <summary>
		/// Returns the <see cref="Region"/> with the highest Z index of the given list
		/// </summary>
		/// <param name="regions">List of Regions to compare</param>
		/// <returns></returns>
		public Region GetTopRegion(IEnumerable<Region> regions)
		{
			Region ret = null;
			foreach (Region r in regions)
			{
				if (ret == null)
					ret = r;
				else
				{
					if (r.Z > ret.Z)
						ret = r;
				}
			}
			return ret;
		}

		/// <summary>
		/// Sets the Z index of a given region
		/// </summary>
		/// <param name="name">Region name</param>
		/// <param name="z">New Z index</param>
		/// <returns>Whether the change was successful</returns>
		public bool SetZ(string name, int z)
		{
			try
			{
				database.Query("UPDATE Regions SET Z=@0 WHERE RegionName=@1 AND WorldID=@2", z, name,
							   Main.worldID.ToString());

				var region = GetRegionByName(name);
				if (region != null)
					region.Z = z;
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
				return false;
			}
		}
	}

	public class Region
	{
		public int ID { get; set; }
		public Rectangle Area { get; set; }
		public string Name { get; set; }
		public string Owner { get; set; }
		public bool DisableBuild { get; set; }
		public string WorldID { get; set; }
		public List<int> AllowedIDs { get; set; }
		public List<string> AllowedGroups { get; set; }
		public int Z { get; set; }

		public Region(int id, Rectangle region, string name, string owner, bool disablebuild, string RegionWorldIDz, int z)
			: this()
		{
			ID = id;
			Area = region;
			Name = name;
			Owner = owner;
			DisableBuild = disablebuild;
			WorldID = RegionWorldIDz;
			Z = z;
		}

		public Region()
		{
			Area = Rectangle.Empty;
			Name = string.Empty;
			DisableBuild = true;
			WorldID = string.Empty;
			AllowedIDs = new List<int>();
			AllowedGroups = new List<string>();
			Z = 0;
		}

		/// <summary>
		/// Checks if a given point is in the region's area
		/// </summary>
		/// <param name="point">Point to check</param>
		/// <returns>Whether the point exists in the region's area</returns>
		public bool InArea(Rectangle point)
		{
			return InArea(point.X, point.Y);
		}

		/// <summary>
		/// Checks if a given (x, y) coordinate is in the region's area
		/// </summary>
		/// <param name="x">X coordinate to check</param>
		/// <param name="y">Y coordinate to check</param>
		/// <returns>Whether the coordinate exists in the region's area</returns>
		public bool InArea(int x, int y) //overloaded with x,y
		{
			/*
			DO NOT CHANGE TO Area.Contains(x, y)!
			Area.Contains does not account for the right and bottom 'border' of the rectangle,
			which results in regions being trimmed.
			*/
			return x >= Area.X && x <= Area.X + Area.Width && y >= Area.Y && y <= Area.Y + Area.Height;
		}

		/// <summary>
		/// Checks if a given player has permission to build in the region
		/// </summary>
		/// <param name="ply">Player to check permissions with</param>
		/// <returns>Whether the player has permission</returns>
		public bool HasPermissionToBuildInRegion(TSPlayer ply)
		{
			if (!DisableBuild)
			{
				return true;
			}
			if (!ply.IsLoggedIn)
			{
				if (!ply.HasBeenNaggedAboutLoggingIn)
				{
					ply.SendMessage(GetString("You must be logged in to take advantage of protected regions."), Color.Red);
					ply.HasBeenNaggedAboutLoggingIn = true;
				}
				return false;
			}

			return ply.HasPermission(Permissions.editregion) || AllowedIDs.Contains(ply.Account.ID) || AllowedGroups.Contains(ply.Group.Name) || Owner == ply.Account.Name;
		}

		/// <summary>
		/// Sets the user IDs which are allowed to use the region
		/// </summary>
		/// <param name="ids">String of IDs to set</param>
		public void SetAllowedIDs(String ids)
		{
			String[] idArr = ids.Split(',');
			List<int> idList = new List<int>();

			foreach (String id in idArr)
			{
				int i = 0;
				if (int.TryParse(id, out i) && i != 0)
				{
					idList.Add(i);
				}
			}
			AllowedIDs = idList;
		}

		/// <summary>
		/// Sets the group names which are allowed to use the region
		/// </summary>
		/// <param name="groups">String of group names to set</param>
		public void SetAllowedGroups(String groups)
		{
			// prevent null pointer exceptions
			if (!string.IsNullOrEmpty(groups))
			{
				List<String> groupList = groups.Split(',').ToList();

				for (int i = 0; i < groupList.Count; i++)
				{
					groupList[i] = groupList[i].Trim();
				}

				AllowedGroups = groupList;
			}
		}

		/// <summary>
		/// Removes a user's access to the region
		/// </summary>
		/// <param name="id">User ID to remove</param>
		/// <returns>true if the user was found and removed from the region's allowed users</returns>
		public bool RemoveID(int id)
		{
			return AllowedIDs.Remove(id);
		}

		/// <summary>
		/// Removes a group's access to the region
		/// </summary>
		/// <param name="groupName">Group name to remove</param>
		/// <returns></returns>
		public bool RemoveGroup(string groupName)
		{
			return AllowedGroups.Remove(groupName);
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/RememberedPosManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Data;
using MySql.Data.MySqlClient;
using Terraria;
using Microsoft.Xna.Framework;

namespace TShockAPI.DB
{
	public class RememberedPosManager
	{
		public IDbConnection database;

		public RememberedPosManager(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("RememberedPos",
			                         new SqlColumn("Name", MySqlDbType.VarChar, 50) {Primary = true},
			                         new SqlColumn("IP", MySqlDbType.Text),
			                         new SqlColumn("X", MySqlDbType.Int32),
			                         new SqlColumn("Y", MySqlDbType.Int32),
			                         new SqlColumn("WorldID", MySqlDbType.Text)
				);
			var creator = new SqlTableCreator(db,
			                                  db.GetSqlType() == SqlType.Sqlite
			                                  	? (IQueryBuilder) new SqliteQueryCreator()
			                                  	: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
		}

		public Vector2 CheckLeavePos(string name)
		{
			try
			{
				using (var reader = database.QueryReader("SELECT * FROM RememberedPos WHERE Name=@0", name))
				{
					if (reader.Read())
					{
						int checkX=reader.Get<int>("X");
						int checkY=reader.Get<int>("Y");
						//fix leftover inconsistencies
						if (checkX==0)
						   checkX++;
						if (checkY==0)
						   checkY++;
						return new Vector2(checkX, checkY);
					}
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}

			return new Vector2();
		}



		public Vector2 GetLeavePos(string name, string IP)
		{
			try
			{
				using (var reader = database.QueryReader("SELECT * FROM RememberedPos WHERE Name=@0 AND IP=@1 AND WorldID=@2", name, IP, Main.worldID.ToString()))
				{
					if (reader.Read())
					{
						return new Vector2(reader.Get<int>("X"), reader.Get<int>("Y"));
					}
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}

			return new Vector2();
		}

		public void InsertLeavePos(string name, string IP, int X, int Y)
		{
			if (CheckLeavePos(name) == Vector2.Zero)
			{
				try
				{
					if ((X != 0) && ( Y !=0)) //invalid pos!
					database.Query("INSERT INTO RememberedPos (Name, IP, X, Y, WorldID) VALUES (@0, @1, @2, @3, @4);", name, IP, X, Y , Main.worldID.ToString());
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
			else
			{
				try
				{
					if ((X != 0) && ( Y !=0)) //invalid pos!
					database.Query("UPDATE RememberedPos SET X = @0, Y = @1, IP = @2, WorldID = @3 WHERE Name = @4;", X, Y, IP, Main.worldID.ToString(), name);
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/ResearchDatastore.cs`
```
﻿using MySql.Data.MySqlClient;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria;
using Terraria.ID;

namespace TShockAPI.DB
{
	/// <summary>
	/// This class is used as the data interface for Journey mode research.
	/// This information is maintained such that SSC characters will be properly set up with
	/// the world's current research.
	/// </summary>
	public class ResearchDatastore
	{
		private IDbConnection database;

		/// <summary>
		/// In-memory cache of what items have been sacrificed.
		/// The first call to GetSacrificedItems will load this with data from the database.
		/// </summary>
		private Dictionary<int, int> _itemsSacrificed;

		/// <summary>
		/// Initializes a new instance of the <see cref="TShockAPI.DB.ResearchDatastore"/> class.
		/// </summary>
		/// <param name="db">A valid connection to the TShock database</param>
		public ResearchDatastore(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("Research",
									new SqlColumn("WorldId", MySqlDbType.Int32),
									new SqlColumn("PlayerId", MySqlDbType.Int32),
									new SqlColumn("ItemId", MySqlDbType.Int32),
									new SqlColumn("AmountSacrificed", MySqlDbType.Int32),
									new SqlColumn("TimeSacrificed", MySqlDbType.DateTime)
				);
			var creator = new SqlTableCreator(db,
				db.GetSqlType() == SqlType.Sqlite
					? (IQueryBuilder)new SqliteQueryCreator()
					: new MysqlQueryCreator());
			try
			{
				creator.EnsureTableStructure(table);
			}
			catch (DllNotFoundException)
			{
				TShock.Log.ConsoleWarn(GetString("Possible problem with your database - is Sqlite3.dll present?"));
				throw new Exception(GetString("Could not find a database library (probably Sqlite3.dll)"));
			}
		}

		/// <summary>
		/// This call will return the memory-cached list of items sacrificed.
		/// If the cache is not initialized, it will be initialized from the database.
		/// </summary>
		/// <returns></returns>
		public Dictionary<int, int> GetSacrificedItems()
		{
			if (_itemsSacrificed == null)
			{
				_itemsSacrificed = ReadFromDatabase();
			}

			return _itemsSacrificed;
		}

		/// <summary>
		/// This function will return a Dictionary&lt;ItemId, AmountSacrificed&gt; representing
		/// what the progress of research on items is for this world.
		/// </summary>
		/// <returns>A dictionary of ItemID keys and Amount Sacrificed values.</returns>
		private Dictionary<int, int> ReadFromDatabase()
		{
			Dictionary<int, int> sacrificedItems = new Dictionary<int, int>();

			var sql = @"select itemId, sum(AmountSacrificed) totalSacrificed
  from Research
	where WorldId = @0
      group by itemId";

			try {
				using (var reader = database.QueryReader(sql, Main.worldID))
				{
					while (reader.Read())
					{
						var itemId = reader.Get<Int32>("itemId");
						var amount = reader.Get<Int32>("totalSacrificed");
						sacrificedItems[itemId] = amount;
					}
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return sacrificedItems;
		}

		/// <summary>
		/// This method will sacrifice an amount of an item for research.
		/// </summary>
		/// <param name="itemId">The net ItemId that is being researched.</param>
		/// <param name="amount">The amount of items being sacrificed.</param>
		/// <param name="player">The player who sacrificed the item for research.</param>
		/// <returns>The cumulative total sacrifices for this item.</returns>
		public int SacrificeItem(int itemId, int amount, TSPlayer player)
		{
			var itemsSacrificed = GetSacrificedItems();
			if (!(itemsSacrificed.ContainsKey(itemId)))
				itemsSacrificed[itemId] = 0;

			var sql = @"insert into Research (WorldId, PlayerId, ItemId, AmountSacrificed, TimeSacrificed) values (@0, @1, @2, @3, @4)";

			var result = 0;
			try
			{
				result = database.Query(sql, Main.worldID, player.Account.ID, itemId, amount, DateTime.Now);
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}

			if (result == 1)
			{
				itemsSacrificed[itemId] += amount;
			}

			return itemsSacrificed[itemId];
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/SqlColumn.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using MySql.Data.MySqlClient;
using System;

namespace TShockAPI.DB
{
	public class SqlColumn
	{
		//Required
		public string Name { get; set; }
		public MySqlDbType Type { get; set; }


		//Optional
		/// <summary>
		/// Sets/Gets if it's unique 
		/// </summary>
		public bool Unique { get; set; }
		/// <summary>
		/// Sets/Gets if it's primary key
		/// </summary>
		public bool Primary { get; set; }
		/// <summary>
		/// Sets/Gets if it autoincrements
		/// </summary>
		public bool AutoIncrement { get; set; }
		/// <summary>
		/// Sets/Gets if it can be or not null
		/// </summary>
		public bool NotNull { get; set; }
		/// <summary>
		/// Sets the default value
		/// </summary>
		public string DefaultValue { get; set; }
		/// <summary>
		/// Use on DateTime only, if true, sets the default value to the current date when creating the row.
		/// </summary>
		public bool DefaultCurrentTimestamp { get; set; }

		/// <summary>
		/// Length of the data type, null = default
		/// </summary>
		public int? Length { get; set; }

		public SqlColumn(string name, MySqlDbType type)
			: this(name, type, null)
		{
		}

		public SqlColumn(string name, MySqlDbType type, int? length)
		{
			Name = name;
			Type = type;
			Length = length;
		}
	}

	/// <summary>
	/// Used when a SqlColumn has validation errors.
	/// </summary>
	[Serializable]
	public class SqlColumnException : Exception
	{
		/// <summary>
		/// Creates a new SqlColumnException with the given message.
		/// </summary>
		/// <param name="message"></param>
		public SqlColumnException(string message) : base(message)
		{
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/SqlTable.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using MySql.Data.MySqlClient;

namespace TShockAPI.DB
{
	public class SqlTable
	{
		public List<SqlColumn> Columns { get; protected set; }
		public string Name { get; protected set; }

		public SqlTable(string name, params SqlColumn[] columns)
			: this(name, new List<SqlColumn>(columns))
		{
		}

		public SqlTable(string name, List<SqlColumn> columns)
		{
			Name = name;
			Columns = columns;
		}
	}

	public class SqlTableCreator
	{
		private IDbConnection database;
		private IQueryBuilder creator;

		public SqlTableCreator(IDbConnection db, IQueryBuilder provider)
		{
			database = db;
			creator = provider;
		}

		// Returns true if the table was created; false if it was not.
		public bool EnsureTableStructure(SqlTable table)
		{
			var columns = GetColumns(table);
			if (columns.Count > 0)
			{
				if (!table.Columns.All(c => columns.Contains(c.Name)) || !columns.All(c => table.Columns.Any(c2 => c2.Name == c)))
				{
					var from = new SqlTable(table.Name, columns.Select(s => new SqlColumn(s, MySqlDbType.String)).ToList());
					database.Query(creator.AlterTable(from, table));
				}
			}
			else
			{
				database.Query(creator.CreateTable(table));
				return true;
			}
			return false;
		}

		public List<string> GetColumns(SqlTable table)
		{
			var ret = new List<string>();
			var name = database.GetSqlType();
			if (name == SqlType.Sqlite)
			{
				using (var reader = database.QueryReader("PRAGMA table_info({0})".SFormat(table.Name)))
				{
					while (reader.Read())
						ret.Add(reader.Get<string>("name"));
				}
			}
			else if (name == SqlType.Mysql)
			{
				using (
					var reader =
						database.QueryReader(
							"SELECT COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_NAME=@0 AND TABLE_SCHEMA=@1", table.Name,
							database.Database))
				{
					while (reader.Read())
						ret.Add(reader.Get<string>("COLUMN_NAME"));
				}
			}
			else
			{
				throw new NotSupportedException();
			}

			return ret;
		}

		public void DeleteRow(string table, List<SqlValue> wheres)
		{
			database.Query(creator.DeleteRow(table, wheres));
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/SqlValue.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Data;

namespace TShockAPI.DB
{
	public class SqlValue
	{
		public string Name { get; set; }
		public object Value { get; set; }

		public SqlValue(string name, object value)
		{
			Name = name;
			Value = value;
		}
	}

	public class SqlTableEditor
	{
		private IDbConnection database;
		private IQueryBuilder creator;

		public SqlTableEditor(IDbConnection db, IQueryBuilder provider)
		{
			database = db;
			creator = provider;
		}

		public void UpdateValues(string table, List<SqlValue> values, List<SqlValue> wheres)
		{
			database.Query(creator.UpdateValue(table, values, wheres));
		}

		public void InsertValues(string table, List<SqlValue> values)
		{
			database.Query(creator.InsertValues(table, values));
		}

		public List<object> ReadColumn(string table, string column, List<SqlValue> wheres)
		{
			List<object> values = new List<object>();

			using (var reader = database.QueryReader(creator.ReadColumn(table, wheres)))
			{
				while (reader.Read())
					values.Add(reader.Reader.Get<object>(column));
			}

			return values;
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/TileManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using MySql.Data.MySqlClient;
using TShockAPI.Hooks;

namespace TShockAPI.DB
{
	public class TileManager
	{
		private IDbConnection database;
		public List<TileBan> TileBans = new List<TileBan>();

		public TileManager(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("TileBans",
				new SqlColumn("TileId", MySqlDbType.Int32) { Primary = true },
				new SqlColumn("AllowedGroups", MySqlDbType.Text)
				);
			var creator = new SqlTableCreator(db,
				db.GetSqlType() == SqlType.Sqlite
					? (IQueryBuilder)new SqliteQueryCreator()
					: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
			UpdateBans();
		}

		public void UpdateBans()
		{
			TileBans.Clear();

			using (var reader = database.QueryReader("SELECT * FROM TileBans"))
			{
				while (reader != null && reader.Read())
				{
					TileBan ban = new TileBan((short)reader.Get<Int32>("TileId"));
					ban.SetAllowedGroups(reader.Get<string>("AllowedGroups"));
					TileBans.Add(ban);
				}
			}
		}

		public void AddNewBan(short id = 0)
		{
			try
			{
				database.Query("INSERT INTO TileBans (TileId, AllowedGroups) VALUES (@0, @1);",
					id, "");

				if (!TileIsBanned(id, null))
					TileBans.Add(new TileBan(id));
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
		}

		public void RemoveBan(short id)
		{
			if (!TileIsBanned(id, null))
				return;
			try
			{
				database.Query("DELETE FROM TileBans WHERE TileId=@0;", id);
				TileBans.Remove(new TileBan(id));
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
		}

		public bool TileIsBanned(short id)
		{
			if (TileBans.Contains(new TileBan(id)))
			{
				return true;
			}
			return false;
		}

		public bool TileIsBanned(short id, TSPlayer ply)
		{
			if (TileBans.Contains(new TileBan(id)))
			{
				TileBan b = GetBanById(id);
				return !b.HasPermissionToPlaceTile(ply);
			}
			return false;
		}

		public bool AllowGroup(short id, string name)
		{
			string groupsNew = "";
			TileBan b = GetBanById(id);
			if (b != null)
			{
				try
				{
					groupsNew = String.Join(",", b.AllowedGroups);
					if (groupsNew.Length > 0)
						groupsNew += ",";
					groupsNew += name;
					b.SetAllowedGroups(groupsNew);

					int q = database.Query("UPDATE TileBans SET AllowedGroups=@0 WHERE TileId=@1", groupsNew,
						id);

					return q > 0;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}

			return false;
		}

		public bool RemoveGroup(short id, string group)
		{
			TileBan b = GetBanById(id);
			if (b != null)
			{
				try
				{
					b.RemoveGroup(group);
					string groups = string.Join(",", b.AllowedGroups);
					int q = database.Query("UPDATE TileBans SET AllowedGroups=@0 WHERE TileId=@1", groups,
						id);

					if (q > 0)
						return true;
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
				}
			}
			return false;
		}

		public TileBan GetBanById(short id)
		{
			foreach (TileBan b in TileBans)
			{
				if (b.ID == id)
				{
					return b;
				}
			}
			return null;
		}
	}

	public class TileBan : IEquatable<TileBan>
	{
		public short ID { get; set; }
		public List<string> AllowedGroups { get; set; }

		public TileBan(short id)
			: this()
		{
			ID = id;
			AllowedGroups = new List<string>();
		}

		public TileBan()
		{
			ID = 0;
			AllowedGroups = new List<string>();
		}

		public bool Equals(TileBan other)
		{
			return ID == other.ID;
		}

		public bool HasPermissionToPlaceTile(TSPlayer ply)
		{
			if (ply == null)
				return false;

			if (ply.HasPermission(Permissions.canusebannedtiles))
				return true;

			PermissionHookResult hookResult = PlayerHooks.OnPlayerTilebanPermission(ply, this);
			if (hookResult != PermissionHookResult.Unhandled)
				return hookResult == PermissionHookResult.Granted;

			var cur = ply.Group;
			var traversed = new List<Group>();
			while (cur != null)
			{
				if (AllowedGroups.Contains(cur.Name))
				{
					return true;
				}
				if (traversed.Contains(cur))
				{
					throw new InvalidOperationException(GetString($"Infinite group parenting ({cur.Name})"));
				}
				traversed.Add(cur);
				cur = cur.Parent;
			}
			return false;
			// could add in the other permissions in this class instead of a giant if switch.
		}

		public void SetAllowedGroups(String groups)
		{
			// prevent null pointer exceptions
			if (!string.IsNullOrEmpty(groups))
			{
				List<String> groupArr = groups.Split(',').ToList();

				for (int i = 0; i < groupArr.Count; i++)
				{
					groupArr[i] = groupArr[i].Trim();
					//Console.WriteLine(groupArr[i]);
				}
				AllowedGroups = groupArr;
			}
		}

		public bool RemoveGroup(string groupName)
		{
			return AllowedGroups.Remove(groupName);
		}

		public override string ToString()
		{
			return ID + (AllowedGroups.Count > 0 ? " (" + String.Join(",", AllowedGroups) + ")" : "");
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/UserManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Data;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MySql.Data.MySqlClient;
using System.Text.RegularExpressions;
using BCrypt.Net;
using System.Security.Cryptography;
using TShockAPI.Hooks;

namespace TShockAPI.DB
{
	/// <summary>UserAccountManager - Methods for dealing with database user accounts and other related functionality within TShock.</summary>
	public class UserAccountManager
	{
		/// <summary>database - The database object to use for connections.</summary>
		private IDbConnection _database;

		/// <summary>Creates a UserAccountManager object. During instantiation, this method will verify the table structure against the format below.</summary>
		/// <param name="db">The database to connect to.</param>
		/// <returns>A UserAccountManager object.</returns>
		public UserAccountManager(IDbConnection db)
		{
			_database = db;

			var table = new SqlTable("Users",
				new SqlColumn("ID", MySqlDbType.Int32) {Primary = true, AutoIncrement = true},
				new SqlColumn("Username", MySqlDbType.VarChar, 32) {Unique = true},
				new SqlColumn("Password", MySqlDbType.VarChar, 128),
				new SqlColumn("UUID", MySqlDbType.VarChar, 128),
				new SqlColumn("Usergroup", MySqlDbType.Text),
				new SqlColumn("Registered", MySqlDbType.Text),
				new SqlColumn("LastAccessed", MySqlDbType.Text),
				new SqlColumn("KnownIPs", MySqlDbType.Text)
				);
			var creator = new SqlTableCreator(db,
				db.GetSqlType() == SqlType.Sqlite
				? (IQueryBuilder) new SqliteQueryCreator()
				: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
		}

		/// <summary>
		/// Adds the given user account to the database
		/// </summary>
		/// <param name="account">The user account to be added</param>
		public void AddUserAccount(UserAccount account)
		{
			if (!TShock.Groups.GroupExists(account.Group))
				throw new GroupNotExistsException(account.Group);

			int ret;
			try
			{
				ret = _database.Query("INSERT INTO Users (Username, Password, UUID, UserGroup, Registered) VALUES (@0, @1, @2, @3, @4);", account.Name,
					account.Password, account.UUID, account.Group, DateTime.UtcNow.ToString("s"));
			}
			catch (Exception ex)
			{
				// Detect duplicate user using a regexp as Sqlite doesn't have well structured exceptions
				if (Regex.IsMatch(ex.Message, "Username.*not unique|UNIQUE constraint failed: Users\\.Username"))
					throw new UserAccountExistsException(account.Name);
				throw new UserAccountManagerException(GetString($"AddUser SQL returned an error ({ex.Message})"), ex);
			}

			if (1 > ret)
				throw new UserAccountExistsException(account.Name);

			Hooks.AccountHooks.OnAccountCreate(account);
		}

		/// <summary>
		/// Removes all user accounts from the database whose usernames match the given user account
		/// </summary>
		/// <param name="account">The user account</param>
		public void RemoveUserAccount(UserAccount account)
		{
			try
			{
				// Logout any player logged in as the account to be removed
				TShock.Players.Where(p => p?.IsLoggedIn == true && p.Account.Name == account.Name).ForEach(p => p.Logout());

				UserAccount tempuser = GetUserAccount(account);
				int affected = _database.Query("DELETE FROM Users WHERE Username=@0", account.Name);

				if (affected < 1)
					throw new UserAccountNotExistException(account.Name);

				Hooks.AccountHooks.OnAccountDelete(tempuser);

			}
			catch (Exception ex)
			{
				throw new UserAccountManagerException(GetString("RemoveUser SQL returned an error"), ex);
			}
		}

		/// <summary>
		/// Sets the Hashed Password for a given username
		/// </summary>
		/// <param name="account">The user account</param>
		/// <param name="password">The user account password to be set</param>
		public void SetUserAccountPassword(UserAccount account, string password)
		{
			try
			{
				account.CreateBCryptHash(password);

				if (
					_database.Query("UPDATE Users SET Password = @0 WHERE Username = @1;", account.Password,
						account.Name) == 0)
					throw new UserAccountNotExistException(account.Name);
			}
			catch (Exception ex)
			{
				throw new UserAccountManagerException(GetString("SetUserPassword SQL returned an error"), ex);
			}
		}

		/// <summary>
		/// Sets the UUID for a given username
		/// </summary>
		/// <param name="account">The user account</param>
		/// <param name="uuid">The user account uuid to be set</param>
		public void SetUserAccountUUID(UserAccount account, string uuid)
		{
			try
			{
				if (
					_database.Query("UPDATE Users SET UUID = @0 WHERE Username = @1;", uuid,
								   account.Name) == 0)
					throw new UserAccountNotExistException(account.Name);
			}
			catch (Exception ex)
			{
				throw new UserAccountManagerException(GetString("SetUserUUID SQL returned an error"), ex);
			}
		}

		/// <summary>
		/// Sets the group for a given username
		/// </summary>
		/// <param name="account">The user account</param>
		/// <param name="group">The user account group to be set</param>
		public void SetUserGroup(UserAccount account, string group)
		{
			Group grp = TShock.Groups.GetGroupByName(group);
			if (null == grp)
				throw new GroupNotExistsException(group);

			if (AccountHooks.OnAccountGroupUpdate(account, ref grp))
				throw new UserGroupUpdateLockedException(account.Name);

			if (_database.Query("UPDATE Users SET UserGroup = @0 WHERE Username = @1;", grp.Name, account.Name) == 0)
				throw new UserAccountNotExistException(account.Name);

			try
			{
				// Update player group reference for any logged in player
				foreach (var player in TShock.Players.Where(p => p != null && p.Account != null && p.Account.Name == account.Name))
				{
					player.Group = grp;
				}
			}
			catch (Exception ex)
			{
				throw new UserAccountManagerException(GetString("SetUserGroup SQL returned an error"), ex);
			}
		}
		/// <summary>
		/// Sets the group for a given username
		/// </summary>
		/// <param name="author">Who changes the group</param>
		/// <param name="account">The user account</param>
		/// <param name="group">The user account group to be set</param>
		public void SetUserGroup(TSPlayer author, UserAccount account, string group)
		{
			Group grp = TShock.Groups.GetGroupByName(group);
			if (null == grp)
				throw new GroupNotExistsException(group);

			if (AccountHooks.OnAccountGroupUpdate(account, author, ref grp))
				throw new UserGroupUpdateLockedException(account.Name);

			if (_database.Query("UPDATE Users SET UserGroup = @0 WHERE Username = @1;", grp.Name, account.Name) == 0)
				throw new UserAccountNotExistException(account.Name);

			try
			{
				// Update player group reference for any logged in player
				foreach (var player in TShock.Players.Where(p => p != null && p.Account != null && p.Account.Name == account.Name))
				{
					player.Group = grp;
				}
			}
			catch (Exception ex)
			{
				throw new UserAccountManagerException(GetString("SetUserGroup SQL returned an error"), ex);
			}
		}

		/// <summary>Updates the last accessed time for a database user account to the current time.</summary>
		/// <param name="account">The user account object to modify.</param>
		public void UpdateLogin(UserAccount account)
		{
			try
			{
				if (_database.Query("UPDATE Users SET LastAccessed = @0, KnownIps = @1 WHERE Username = @2;", DateTime.UtcNow.ToString("s"), account.KnownIps, account.Name) == 0)
					throw new UserAccountNotExistException(account.Name);
			}
			catch (Exception ex)
			{
				throw new UserAccountManagerException(GetString("UpdateLogin SQL returned an error"), ex);
			}
		}

		/// <summary>Gets the database ID of a given user account object from the database.</summary>
		/// <param name="username">The username of the user account to query for.</param>
		/// <returns>The user account ID</returns>
		public int GetUserAccountID(string username)
		{
			try
			{
				using (var reader = _database.QueryReader("SELECT * FROM Users WHERE Username=@0", username))
				{
					if (reader.Read())
					{
						return reader.Get<int>("ID");
					}
				}
			}
			catch (Exception ex)
			{
				TShock.Log.ConsoleError(GetString($"FetchHashedPasswordAndGroup SQL returned an error: {ex}"));
			}
			return -1;
		}

		/// <summary>Gets a user account object by name.</summary>
		/// <param name="name">The user's name.</param>
		/// <returns>The user account object returned from the search.</returns>
		public UserAccount GetUserAccountByName(string name)
		{
			try
			{
				return GetUserAccount(new UserAccount {Name = name});
			}
			catch (UserAccountManagerException)
			{
				return null;
			}
		}

		/// <summary>Gets a user account object by their user account ID.</summary>
		/// <param name="id">The user's ID.</param>
		/// <returns>The user account object returned from the search.</returns>
		public UserAccount GetUserAccountByID(int id)
		{
			try
			{
				return GetUserAccount(new UserAccount {ID = id});
			}
			catch (UserAccountManagerException)
			{
				return null;
			}
		}

		/// <summary>Gets a user account object by a user account object.</summary>
		/// <param name="account">The user account object to search by.</param>
		/// <returns>The user object that is returned from the search.</returns>
		public UserAccount GetUserAccount(UserAccount account)
		{
			bool multiple = false;
			string query;
			string type;
			object arg;
			if (account.ID != 0)
			{
				query = "SELECT * FROM Users WHERE ID=@0";
				arg = account.ID;
				type = "id";
			}
			else
			{
				query = "SELECT * FROM Users WHERE Username=@0";
				arg = account.Name;
				type = "name";
			}

			try
			{
				using (var result = _database.QueryReader(query, arg))
				{
					if (result.Read())
					{
						account = LoadUserAccountFromResult(account, result);
						// Check for multiple matches
						if (!result.Read())
							return account;
						multiple = true;
					}
				}
			}
			catch (Exception ex)
			{
				throw new UserAccountManagerException(GetString($"GetUser SQL returned an error {ex.Message}"), ex);
			}
			if (multiple)
				throw new UserAccountManagerException(GetString($"Multiple user accounts found for {type} '{arg}'"));

			throw new UserAccountNotExistException(account.Name);
		}

		/// <summary>Gets all the user accounts from the database.</summary>
		/// <returns>The user accounts from the database.</returns>
		public List<UserAccount> GetUserAccounts()
		{
			try
			{
				List<UserAccount> accounts = new List<UserAccount>();
				using (var reader = _database.QueryReader("SELECT * FROM Users"))
				{
					while (reader.Read())
					{
						accounts.Add(LoadUserAccountFromResult(new UserAccount(), reader));
					}
					return accounts;
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return null;
		}

		/// <summary>
		/// Gets all user accounts from the database with a username that starts with or contains <see cref="username"/>
		/// </summary>
		/// <param name="username">Rough username search. "n" will match "n", "na", "nam", "name", etc</param>
		/// <param name="notAtStart">If <see cref="username"/> is not the first part of the username. If true then "name" would match "name", "username", "wordsnamewords", etc</param>
		/// <returns>Matching users or null if exception is thrown</returns>
		public List<UserAccount> GetUserAccountsByName(string username, bool notAtStart = false)
		{
			try
			{
				List<UserAccount> accounts = new List<UserAccount>();
				string search = notAtStart ? string.Format("%{0}%", username) : string.Format("{0}%", username);
				using (var reader = _database.QueryReader("SELECT * FROM Users WHERE Username LIKE @0",
					search))
				{
					while (reader.Read())
					{
						accounts.Add(LoadUserAccountFromResult(new UserAccount(), reader));
					}
				}
				return accounts;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return null;
		}

		/// <summary>Fills out the fields of a User account object with the results from a QueryResult object.</summary>
		/// <param name="account">The user account to add data to.</param>
		/// <param name="result">The QueryResult object to add data from.</param>
		/// <returns>The 'filled out' user object.</returns>
		private UserAccount LoadUserAccountFromResult(UserAccount account, QueryResult result)
		{
			account.ID = result.Get<int>("ID");
			account.Group = result.Get<string>("Usergroup");
			account.Password = result.Get<string>("Password");
			account.UUID = result.Get<string>("UUID");
			account.Name = result.Get<string>("Username");
			account.Registered = result.Get<string>("Registered");
			account.LastAccessed = result.Get<string>("LastAccessed");
			account.KnownIps = result.Get<string>("KnownIps");
			return account;
		}
	}

	/// <summary>A database user account.</summary>
	public class UserAccount : IEquatable<UserAccount>
	{
		/// <summary>The database ID of the user account.</summary>
		public int ID { get; set; }

		/// <summary>The user's name.</summary>
		public string Name { get; set; }

		/// <summary>The hashed password for the user account.</summary>
		public string Password { get; internal set; }

		/// <summary>The user's saved Universally Unique Identifier token.</summary>
		public string UUID { get; set; }

		/// <summary>The group object that the user account is a part of.</summary>
		public string Group { get; set; }

		/// <summary>The unix epoch corresponding to the registration date of the user account.</summary>
		public string Registered { get; set; }

		/// <summary>The unix epoch corresponding to the last access date of the user account.</summary>
		public string LastAccessed { get; set; }

		/// <summary>A JSON serialized list of known IP addresses for a user account.</summary>
		public string KnownIps { get; set; }

		/// <summary>Constructor for the user account object, assuming you define everything yourself.</summary>
		/// <param name="name">The user's name.</param>
		/// <param name="pass">The user's password hash.</param>
		/// <param name="uuid">The user's UUID.</param>
		/// <param name="group">The user's group name.</param>
		/// <param name="registered">The unix epoch for the registration date.</param>
		/// <param name="last">The unix epoch for the last access date.</param>
		/// <param name="known">The known IPs for the user account, serialized as a JSON object</param>
		/// <returns>A completed user account object.</returns>
		public UserAccount(string name, string pass, string uuid, string group, string registered, string last, string known)
		{
			Name = name;
			Password = pass;
			UUID = uuid;
			Group = group;
			Registered = registered;
			LastAccessed = last;
			KnownIps = known;
		}

		/// <summary>Default constructor for a user account object; holds no data.</summary>
		/// <returns>A user account object.</returns>
		public UserAccount()
		{
			Name = "";
			Password = "";
			UUID = "";
			Group = "";
			Registered = "";
			LastAccessed = "";
			KnownIps = "";
		}

		/// <summary>
		/// Verifies if a password matches the one stored in the database.
		/// If the password is stored in an unsafe hashing algorithm, it will be converted to BCrypt.
		/// If the password is stored using BCrypt, it will be re-saved if the work factor in the config
		/// is greater than the existing work factor with the new work factor.
		/// </summary>
		/// <param name="password">The password to check against the user account object.</param>
		/// <returns>bool true, if the password matched, or false, if it didn't.</returns>
		public bool VerifyPassword(string password)
		{
			try
			{
				if (BCrypt.Net.BCrypt.Verify(password, Password))
				{
					// If necessary, perform an upgrade to the highest work factor.
					UpgradePasswordWorkFactor(password);
					return true;
				}
			}
			catch (SaltParseException)
			{
				TShock.Log.ConsoleError(GetString($"Unable to verify the password hash for user {Name} ({ID})"));
				return false;
			}
			return false;
		}

		/// <summary>Upgrades a password to the highest work factor available in the config.</summary>
		/// <param name="password">The raw user account password (unhashed) to upgrade</param>
		protected void UpgradePasswordWorkFactor(string password)
		{
			// If the destination work factor is not greater, we won't upgrade it or re-hash it
			int currentWorkFactor;
			try
			{
				currentWorkFactor = Int32.Parse((Password.Split('$')[2]));
			}
			catch (FormatException)
			{
				TShock.Log.ConsoleWarn(GetString("Not upgrading work factor because bcrypt hash in an invalid format."));
				return;
			}

			if (currentWorkFactor < TShock.Config.Settings.BCryptWorkFactor)
			{
				try
				{
					TShock.UserAccounts.SetUserAccountPassword(this, password);
				}
				catch (UserAccountManagerException e)
				{
					TShock.Log.ConsoleError(e.ToString());
				}
			}
		}

		/// <summary>Creates a BCrypt hash for a user account and stores it in this object.</summary>
		/// <param name="password">The plain text password to hash</param>
		public void CreateBCryptHash(string password)
		{
			if (password.Trim().Length < Math.Max(4, TShock.Config.Settings.MinimumPasswordLength))
			{
				int minLength = TShock.Config.Settings.MinimumPasswordLength;
				throw new ArgumentOutOfRangeException("password", GetString($"Password must be at least {minLength} characters."));
			}
			try
			{
				Password = BCrypt.Net.BCrypt.HashPassword(password.Trim(), TShock.Config.Settings.BCryptWorkFactor);
			}
			catch (ArgumentOutOfRangeException)
			{
				TShock.Log.ConsoleError(GetString("Invalid BCrypt work factor in config file! Creating new hash using default work factor."));
				Password = BCrypt.Net.BCrypt.HashPassword(password.Trim());
			}
		}

		/// <summary>Creates a BCrypt hash for a user account and stores it in this object.</summary>
		/// <param name="password">The plain text password to hash</param>
		/// <param name="workFactor">The work factor to use in generating the password hash</param>
		public void CreateBCryptHash(string password, int workFactor)
		{
			if (password.Trim().Length < Math.Max(4, TShock.Config.Settings.MinimumPasswordLength))
			{
				int minLength = TShock.Config.Settings.MinimumPasswordLength;
				throw new ArgumentOutOfRangeException("password", GetString($"Password must be at least {minLength} characters."));
			}
			Password = BCrypt.Net.BCrypt.HashPassword(password.Trim(), workFactor);
		}

		#region IEquatable

		/// <summary>Indicates whether the current <see cref="UserAccount"/> is equal to another <see cref="UserAccount"/>.</summary>
		/// <returns>true if the <see cref="UserAccount"/> is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
		/// <param name="other">An <see cref="UserAccount"/> to compare with this <see cref="UserAccount"/>.</param>
		public bool Equals(UserAccount other)
		{
			if (ReferenceEquals(null, other)) return false;
			if (ReferenceEquals(this, other)) return true;
			return ID == other.ID && string.Equals(Name, other.Name);
		}

		/// <summary>Indicates whether the current <see cref="UserAccount"/> is equal to another object.</summary>
		/// <returns>true if the <see cref="UserAccount"/> is equal to the <paramref name="obj" /> parameter; otherwise, false.</returns>
		/// <param name="obj">An <see cref="object"/> to compare with this <see cref="UserAccount"/>.</param>
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			if (obj.GetType() != this.GetType()) return false;
			return Equals((UserAccount)obj);
		}

		/// <summary>Serves as the hash function. </summary>
		/// <returns>A hash code for the current <see cref="UserAccount"/>.</returns>
		public override int GetHashCode()
		{
			unchecked
			{
				return (ID * 397) ^ (Name != null ? Name.GetHashCode() : 0);
			}
		}

		/// <summary>
		/// Compares equality of two <see cref="UserAccount"/> objects.
		/// </summary>
		/// <param name="left">Left hand of the comparison.</param>
		/// <param name="right">Right hand of the comparison.</param>
		/// <returns>true if the <see cref="UserAccount"/> objects are equal; otherwise, false.</returns>
		public static bool operator ==(UserAccount left, UserAccount right)
		{
			return Equals(left, right);
		}

		/// <summary>
		/// Compares equality of two <see cref="UserAccount"/> objects.
		/// </summary>
		/// <param name="left">Left hand of the comparison.</param>
		/// <param name="right">Right hand of the comparison.</param>
		/// <returns>true if the <see cref="UserAccount"/> objects aren't equal; otherwise, false.</returns>
		public static bool operator !=(UserAccount left, UserAccount right)
		{
			return !Equals(left, right);
		}

		#endregion

		/// <summary>
		/// Converts the UserAccount to it's string representation
		/// </summary>
		/// <returns>Returns the UserAccount string representation</returns>
		public override string ToString() => Name;
	}

	/// <summary>UserAccountManagerException - An exception generated by the user account manager.</summary>
	[Serializable]
	public class UserAccountManagerException : Exception
	{
		/// <summary>Creates a new UserAccountManagerException object.</summary>
		/// <param name="message">The message for the object.</param>
		/// <returns>A new UserAccountManagerException object.</returns>
		public UserAccountManagerException(string message)
			: base(message)
		{
		}

		/// <summary>Creates a new UserAccountManager Object with an internal exception.</summary>
		/// <param name="message">The message for the object.</param>
		/// <param name="inner">The inner exception for the object.</param>
		/// <returns>A new UserAccountManagerException with a defined inner exception.</returns>
		public UserAccountManagerException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}

	/// <summary>A UserExistsException object, used when a user account already exists when attempting to create a new one.</summary>
	[Serializable]
	public class UserAccountExistsException : UserAccountManagerException
	{
		/// <summary>Creates a new UserAccountExistsException object.</summary>
		/// <param name="name">The name of the user account that already exists.</param>
		/// <returns>A UserAccountExistsException object with the user's name passed in the message.</returns>
		public UserAccountExistsException(string name)
			: base(GetString($"User account {name} already exists"))
		{
		}
	}

	/// <summary>A UserNotExistException, used when a user does not exist and a query failed as a result of it.</summary>
	[Serializable]
	public class UserAccountNotExistException : UserAccountManagerException
	{
		/// <summary>Creates a new UserAccountNotExistException object, with the user account name in the message.</summary>
		/// <param name="name">The user account name to be passed in the message.</param>
		/// <returns>A new UserAccountNotExistException object with a message containing the user account name that does not exist.</returns>
		public UserAccountNotExistException(string name)
			: base(GetString($"User account {name} does not exist"))
		{
		}
	}

	/// <summary>The UserGroupUpdateLockedException used when the user group update failed and the request failed as a result.</summary>.
	[Serializable]
	public class UserGroupUpdateLockedException : UserAccountManagerException
	{
		/// <summary>Creates a new UserGroupUpdateLockedException object.</summary>
		/// <param name="name">The name of the user who failed to change the group.</param>
		/// <returns>New UserGroupUpdateLockedException object with a message containing the name of the user account that failed to change the group.</returns>
		public UserGroupUpdateLockedException(string name) :
			base(GetString($"Unable to update group of user {name}."))
		{
		}
	}


	/// <summary>A GroupNotExistsException, used when a group does not exist.</summary>
	[Serializable]
	public class GroupNotExistsException : UserAccountManagerException
	{
		/// <summary>Creates a new GroupNotExistsException object with the group's name in the message.</summary>
		/// <param name="group">The group name.</param>
		/// <returns>A new GroupNotExistsException with the group that does not exist's name in the message.</returns>
		public GroupNotExistsException(string group)
			: base(GetString($"Group {group} does not exist"))
		{
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/DB/WarpsManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using MySql.Data.MySqlClient;
using Terraria;
using Microsoft.Xna.Framework;

namespace TShockAPI.DB
{
	public class WarpManager
	{
		private IDbConnection database;
		/// <summary>
		/// The list of warps.
		/// </summary>
		public List<Warp> Warps = new List<Warp>();

		[SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
		internal WarpManager(IDbConnection db)
		{
			database = db;

			var table = new SqlTable("Warps",
			                         new SqlColumn("Id", MySqlDbType.Int32){Primary = true, AutoIncrement = true},
									 new SqlColumn("WarpName", MySqlDbType.VarChar, 50) {Unique = true},
			                         new SqlColumn("X", MySqlDbType.Int32),
			                         new SqlColumn("Y", MySqlDbType.Int32),
									 new SqlColumn("WorldID", MySqlDbType.VarChar, 50) { Unique = true },
			                         new SqlColumn("Private", MySqlDbType.Text)
				);
			var creator = new SqlTableCreator(db,
			                                  db.GetSqlType() == SqlType.Sqlite
			                                  	? (IQueryBuilder) new SqliteQueryCreator()
			                                  	: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
		}

		/// <summary>
		/// Adds a warp.
		/// </summary>
		/// <param name="x">The X position.</param>
		/// <param name="y">The Y position.</param>
		/// <param name="name">The name.</param>
		/// <returns>Whether the operation succeeded.</returns>
		public bool Add(int x, int y, string name)
		{
			try
			{
				if (database.Query("INSERT INTO Warps (X, Y, WarpName, WorldID) VALUES (@0, @1, @2, @3);",
					x, y, name, Main.worldID.ToString()) > 0)
				{
					Warps.Add(new Warp(new Point(x, y), name));
					return true;
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Reloads all warps.
		/// </summary>
		public void ReloadWarps()
		{
			Warps.Clear();

			using (var reader = database.QueryReader("SELECT * FROM Warps WHERE WorldID = @0",
				Main.worldID.ToString()))
			{
				while (reader.Read())
				{
					Warps.Add(new Warp(
						new Point(reader.Get<int>("X"), reader.Get<int>("Y")),
						reader.Get<string>("WarpName"),
						(reader.Get<string>("Private") ?? "0") != "0"));
				}
			}
		}

		/// <summary>
		/// Removes a warp.
		/// </summary>
		/// <param name="warpName">The warp name.</param>
		/// <returns>Whether the operation succeeded.</returns>
		public bool Remove(string warpName)
		{
			try
			{
				if (database.Query("DELETE FROM Warps WHERE WarpName = @0 AND WorldID = @1",
					warpName, Main.worldID.ToString()) > 0)
				{
					Warps.RemoveAll(w => String.Equals(w.Name, warpName, StringComparison.OrdinalIgnoreCase));
					return true;
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Finds the warp with the given name.
		/// </summary>
		/// <param name="warpName">The name.</param>
		/// <returns>The warp, if it exists, or else null.</returns>
		public Warp Find(string warpName)
		{
			return Warps.FirstOrDefault(w => String.Equals(w.Name, warpName, StringComparison.OrdinalIgnoreCase));
		}

		/// <summary>
		/// Sets the position of a warp.
		/// </summary>
		/// <param name="warpName">The warp name.</param>
		/// <param name="x">The X position.</param>
		/// <param name="y">The Y position.</param>
		/// <returns>Whether the operation succeeded.</returns>
		public bool Position(string warpName, int x, int y)
		{
			try
			{
				if (database.Query("UPDATE Warps SET X = @0, Y = @1 WHERE WarpName = @2 AND WorldID = @3",
					x, y, warpName, Main.worldID.ToString()) > 0)
				{
					Warps.Find(w => String.Equals(w.Name, warpName, StringComparison.OrdinalIgnoreCase)).Position = new Point(x, y);
					return true;
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Sets the hidden state of a warp.
		/// </summary>
		/// <param name="warpName">The warp name.</param>
		/// <param name="state">The state.</param>
		/// <returns>Whether the operation succeeded.</returns>
		public bool Hide(string warpName, bool state)
		{
			try
			{
				if (database.Query("UPDATE Warps SET Private = @0 WHERE WarpName = @1 AND WorldID = @2",
					state ? "1" : "0", warpName, Main.worldID.ToString()) > 0)
				{
					Warps.Find(w => String.Equals(w.Name, warpName, StringComparison.OrdinalIgnoreCase)).IsPrivate = state;
					return true;
				}
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}
	}

	/// <summary>
	/// Represents a warp.
	/// </summary>
	public class Warp
	{
		/// <summary>
		/// Gets or sets the name.
		/// </summary>
		public string Name { get; set; }
		/// <summary>
		/// Gets or sets the warp's privacy state.
		/// </summary>
		public bool IsPrivate { get; set; }
		/// <summary>
		/// Gets or sets the position.
		/// </summary>
		public Point Position { get; set; }

		public Warp(Point position, string name, bool isPrivate = false)
		{
			Name = name;
			Position = position;
			IsPrivate = isPrivate;
		}

		/// <summary>Creates a warp with a default coordinate of zero, an empty name, public.</summary>
		public Warp()
		{
			Position = Point.Zero;
			Name = "";
			IsPrivate = false;
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Extensions`
#### File: `temp_TShock-5.2.4/TShockAPI/Extensions/DbExt.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics.CodeAnalysis;

namespace TShockAPI.DB
{
	/// <summary>
	/// Database extensions
	/// </summary>
	public static class DbExt
	{
		/// <summary>
		/// Executes a query on a database.
		/// </summary>
		/// <param name="olddb">Database to query</param>
		/// <param name="query">Query string with parameters as @0, @1, etc.</param>
		/// <param name="args">Parameters to be put in the query</param>
		/// <returns>Rows affected by query</returns>
		[SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities")]
		public static int Query(this IDbConnection olddb, string query, params object[] args)
		{
			using (var db = olddb.CloneEx())
			{
				db.Open();
				using (var com = db.CreateCommand())
				{
					com.CommandText = query;
					for (int i = 0; i < args.Length; i++)
						com.AddParameter("@" + i, args[i] ?? DBNull.Value);
					return com.ExecuteNonQuery();
				}
			}
		}

		/// <summary>
		/// Executes a query on a database.
		/// </summary>
		/// <param name="olddb">Database to query</param>
		/// <param name="query">Query string with parameters as @0, @1, etc.</param>
		/// <param name="args">Parameters to be put in the query</param>
		/// <returns>Query result as IDataReader</returns>
		[SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities")]
		public static QueryResult QueryReader(this IDbConnection olddb, string query, params object[] args)
		{
			var db = olddb.CloneEx();
			try
			{
				db.Open();
				var com = db.CreateCommand(); // this will be disposed via the QueryResult instance
				{
					com.CommandText = query;
					for (int i = 0; i < args.Length; i++)
						com.AddParameter("@" + i, args[i]);

					return new QueryResult(db, com.ExecuteReader(), com);
				}
			}
			catch (Exception ex)
			{
				throw new Exception(GetString("Fatal TShock initialization exception: failed to connect to MySQL database. See inner exception for details."), ex);
			}
		}

		/// <summary>
		/// Executes a query on a database, returning the first column of the first row of the result set.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="olddb">Database to query</param>
		/// <param name="query">Query string with parameters as @0, @1, etc.</param>
		/// <param name="args">Parameters to be put in the query</param>
		/// <returns></returns>
		public static T QueryScalar<T>(this IDbConnection olddb, string query, params object[] args)
		{
			using (var db = olddb.CloneEx())
			{
				db.Open();
				using (var com = db.CreateCommand())
				{
					com.CommandText = query;
					for (int i = 0; i < args.Length; i++)
						com.AddParameter("@" + i, args[i]);

					object output = com.ExecuteScalar();
					if (output.GetType() != typeof(T))
					{
						if (typeof(IConvertible).IsAssignableFrom(output.GetType()))
						{
							return (T)Convert.ChangeType(output, typeof(T));
						}
					}

					return (T)output;
				}
			}
		}

		public static QueryResult QueryReaderDict(this IDbConnection olddb, string query, Dictionary<string, object> values)
		{
			var db = olddb.CloneEx();
			db.Open();
			var com = db.CreateCommand(); // this will be disposed via the QueryResult instance
			{
				com.CommandText = query;
				foreach (var kv in values)
					com.AddParameter("@" + kv.Key, kv.Value);

				return new QueryResult(db, com.ExecuteReader(), com);
			}
		}

		public static IDbDataParameter AddParameter(this IDbCommand command, string name, object data)
		{
			var parm = command.CreateParameter();
			parm.ParameterName = name;
			parm.Value = data;
			command.Parameters.Add(parm);
			return parm;
		}

		public static IDbConnection CloneEx(this IDbConnection conn)
		{
			var clone = (IDbConnection)Activator.CreateInstance(conn.GetType());
			clone.ConnectionString = conn.ConnectionString;
			return clone;
		}

		public static SqlType GetSqlType(this IDbConnection conn)
		{
			var name = conn.GetType().Name;
			if (name == "SqliteConnection" || name == "SQLiteConnection")
				return SqlType.Sqlite;
			if (name == "MySqlConnection")
				return SqlType.Mysql;
			return SqlType.Unknown;
		}

		private static readonly Dictionary<Type, Func<IDataReader, int, object>> ReadFuncs = new Dictionary
			<Type, Func<IDataReader, int, object>>
		{
			{
				typeof (bool),
				(s, i) => s.GetBoolean(i)
			},
			{
				typeof (bool?),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetBoolean(i)
			},
			{
				typeof (byte),
				(s, i) => s.GetByte(i)
			},
			{
				typeof (byte?),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetByte(i)
			},
			{
				typeof (Int16),
				(s, i) => s.GetInt16(i)
			},
			{
				typeof (Int16?),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetInt16(i)
			},
			{
				typeof (Int32),
				(s, i) => s.GetInt32(i)
			},
			{
				typeof (Int32?),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetInt32(i)
			},
			{
				typeof (Int64),
				(s, i) => s.GetInt64(i)
			},
			{
				typeof (Int64?),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetInt64(i)
			},
			{
				typeof (string),
				(s, i) => s.GetString(i)
			},
			{
				typeof (decimal),
				(s, i) => s.GetDecimal(i)
			},
			{
				typeof (decimal?),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetDecimal(i)
			},
			{
				typeof (float),
				(s, i) => s.GetFloat(i)
			},
			{
				typeof (float?),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetFloat(i)
			},
			{
				typeof (double),
				(s, i) => s.GetDouble(i)
			},
			{
				typeof (double?),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetDouble(i)
			},
			{
				typeof (DateTime),
				(s, i) => s.IsDBNull(i) ? null : (object)s.GetDateTime(i)
			},
			{
				typeof (object),
				(s, i) => s.GetValue(i)
			},
		};

		public static T Get<T>(this IDataReader reader, string column)
		{
			return reader.Get<T>(reader.GetOrdinal(column));
		}

		public static T Get<T>(this IDataReader reader, int column)
		{
			if (reader.IsDBNull(column))
				return default;

			if (ReadFuncs.ContainsKey(typeof(T)))
				return (T)ReadFuncs[typeof(T)](reader, column);

			Type t;
			if (typeof(T) != (t = reader.GetFieldType(column)))
			{
				string columnName = reader.GetName(column);
				throw new InvalidCastException(GetString($"Received type '{typeof(T).Name}', however column '{columnName}' expects type '{t.Name}'"));
			}

			if (reader.IsDBNull(column))
			{
				return default;
			}

			return (T)reader.GetValue(column);
		}
	}

	public enum SqlType
	{
		Unknown,
		Sqlite,
		Mysql
	}

	public class QueryResult : IDisposable
	{
		public IDbConnection Connection { get; protected set; }
		public IDataReader Reader { get; protected set; }
		public IDbCommand Command { get; protected set; }

		public QueryResult(IDbConnection conn, IDataReader reader, IDbCommand command)
		{
			Connection = conn;
			Reader = reader;
			Command = command;
		}

		~QueryResult()
		{
			Dispose(false);
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (Reader != null)
				{
					Reader.Dispose();
					Reader = null;
				}
				if (Command != null)
				{
					Command.Dispose();
					Command = null;
				}
				if (Connection != null)
				{
					Connection.Dispose();
					Connection = null;
				}
			}
		}

		public bool Read()
		{
			if (Reader == null)
				return false;
			return Reader.Read();
		}

		public T Get<T>(string column)
		{
			if (Reader == null)
				return default(T);
			return Reader.Get<T>(Reader.GetOrdinal(column));
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Extensions/ExceptionExt.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

﻿using System;
namespace TShockAPI.Extensions
{
	/// <summary>
	/// Extensions for Exceptions
	/// </summary>
	public static class ExceptionExt
	{
		/// <summary>
		/// Builds a formatted string containing the messages of the given exception, and any inner exceptions it contains
		/// </summary>
		/// <param name="ex"></param>
		/// <returns></returns>
		public static string BuildExceptionString(this Exception ex)
		{
			string msg = ex.Message;
			Exception inner = ex.InnerException;
			while (inner != null)
			{
				msg += $"\r\n\t-> {inner.Message}";
				inner = inner.InnerException;
			}

			return msg;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Extensions/LinqExt.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Linq;

namespace TShockAPI
{
	public static class LinqExt
	{
		public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)
		{
			if (source == null) throw new ArgumentNullException("source");
			if (action == null) throw new ArgumentNullException("action");

			foreach (T item in source)
				action(item);
		}

		/// <summary>
		/// Attempts to retrieve the value at the given index from the enumerable
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="enumerable"></param>
		/// <param name="index"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public static bool TryGetValue<T>(this IEnumerable<T> enumerable, int index, out T value)
		{
			if (index < enumerable.Count())
			{
				value = enumerable.ElementAt(index);
				return true;
			}

			value = default;
			return false;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Extensions/RandomExt.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;

namespace TShockAPI.Extensions
{
	public static class RandomExt
	{
		public static string NextString(this Random rand, int length)
		{
			var sb = new StringBuilder();
			for (int i = 0; i < length; i++)
			{
				switch (rand.Next(0, 3))
				{
					case 0:
						sb.Append((char) rand.Next('a', 'z' + 1));
						break;
					case 1:
						sb.Append((char) rand.Next('A', 'Z' + 1));
						break;
					case 2:
						sb.Append((char) rand.Next('0', '9' + 1));
						break;
				}
			}
			return sb.ToString();
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/Extensions/StringExt.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using Microsoft.Xna.Framework;
using System;

namespace TShockAPI
{
	public static class StringExt
	{
		//Can't name it Format :(
		public static String SFormat(this String str, params object[] args)
		{
			return String.Format(str, args);
		}

		/// <summary>
		/// Wraps the string representation of an object with a Terraria color code for the given color
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="color"></param>
		/// <returns></returns>
		public static string Color(this object obj, string color)
		{
			return $"[c/{color}:{obj}]";
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI`
#### File: `temp_TShock-5.2.4/TShockAPI/FileTools.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace TShockAPI
{
	public class FileTools
	{
		private const string MotdFormat =
			"Welcome to [c/ffff00:%map%] on [c/7ddff8:T][c/81dbf6:S][c/86d7f4:h][c/8ad3f3:o][c/8ecef1:c][c/93caef:k] for [c/55d284:T][c/62d27a:e][c/6fd16f:r][c/7cd165:r][c/89d15a:a][c/95d150:r][c/a4d145:i][c/b1d03b:a].\n[c/FFFFFF:Online players (%onlineplayers%/%serverslots%):] [c/FFFF00:%players%]\nType [c/55D284:%specifier%][c/62D27A:h][c/6FD16F:e][c/7CD165:l][c/89D15A:p] for a list of commands.\n";
		/// <summary>
		/// Path to the file containing the rules.
		/// </summary>
		internal static string RulesPath
		{
			get { return Path.Combine(TShock.SavePath, "rules.txt"); }
		}

		/// <summary>
		/// Path to the file containing the message of the day.
		/// </summary>
		internal static string MotdPath
		{
			get { return Path.Combine(TShock.SavePath, "motd.txt"); }
		}

		/// <summary>
		/// Path to the file containing the whitelist.
		/// </summary>
		internal static string WhitelistPath
		{
			get { return Path.Combine(TShock.SavePath, "whitelist.txt"); }
		}

		/// <summary>
		/// Path to the file containing the config.
		/// </summary>
		internal static string ConfigPath
		{
			get { return Path.Combine(TShock.SavePath, "config.json"); }
		}

		/// <summary>
		/// Path to the file containing the config.
		/// </summary>
		internal static string ServerSideCharacterConfigPath
		{
			get { return Path.Combine(TShock.SavePath, "sscconfig.json"); }
		}

		/// <summary>
		/// Creates an empty file at the given path.
		/// </summary>
		/// <param name="file">The path to the file.</param>
		public static void CreateFile(string file)
		{
			File.Create(file).Close();
		}

		/// <summary>
		/// Creates a file if the files doesn't already exist.
		/// </summary>
		/// <param name="file">The path to the files</param>
		/// <param name="data">The data to write to the file.</param>
		public static void CreateIfNot(string file, string data = "")
		{
			if (!File.Exists(file))
			{
				File.WriteAllText(file, data);
			}
		}

		/// <summary>
		/// Sets up the configuration file for all variables, and creates any missing files.
		/// </summary>
		public static void SetupConfig()
		{
			if (!Directory.Exists(TShock.SavePath))
			{
				Directory.CreateDirectory(TShock.SavePath);
			}

			CreateIfNot(RulesPath, "Respect the admins!\nDon't use TNT!");
			CreateIfNot(MotdPath, MotdFormat);
						
			CreateIfNot(WhitelistPath);
			bool writeConfig = true; // Default to true if the file doesn't exist
			if (File.Exists(ConfigPath))
			{
				TShock.Config.Read(ConfigPath, out writeConfig);
			}
			if (writeConfig)
			{
				// Add all the missing config properties in the json file
				TShock.Config.Write(ConfigPath);
			}

			bool writeSSCConfig = true; // Default to true if the file doesn't exist
			if (File.Exists(ServerSideCharacterConfigPath))
			{
				TShock.ServerSideCharacterConfig.Read(ServerSideCharacterConfigPath, out writeSSCConfig);
			}
			if (writeSSCConfig)
			{
				// Add all the missing config properties in the json file
				TShock.ServerSideCharacterConfig = new Configuration.ServerSideConfig
				{
					Settings = { StartingInventory =
						new List<NetItem>
						{
							new NetItem(-15, 1, 0),
							new NetItem(-13, 1, 0),
							new NetItem(-16, 1, 0)
						}
					}
				};
				TShock.ServerSideCharacterConfig.Write(ServerSideCharacterConfigPath);
			}
		}

		/// <summary>
		/// Tells if a user is on the whitelist
		/// </summary>
		/// <param name="ip">string ip of the user</param>
		/// <returns>true/false</returns>
		public static bool OnWhitelist(string ip)
		{
			if (!TShock.Config.Settings.EnableWhitelist)
			{
				return true;
			}
			CreateIfNot(WhitelistPath, "127.0.0.1");
			using (var tr = new StreamReader(WhitelistPath))
			{
				string whitelist = tr.ReadToEnd();
				ip = TShock.Utils.GetRealIP(ip);
				bool contains = whitelist.Contains(ip);
				if (!contains)
				{
					foreach (var line in whitelist.Split(Environment.NewLine.ToCharArray()))
					{
						if (string.IsNullOrWhiteSpace(line))
							continue;
						contains = TShock.Utils.GetIPv4AddressFromHostname(line).Equals(ip);
						if (contains)
							return true;
					}
					return false;
				}
				return true;
			}
		}

		/// <summary>
		/// Looks for a 'Settings' token in the json object. If one is not found, returns a new json object with all tokens of the previous object added
		/// as children to a root 'Settings' token
		/// </summary>
		/// <param name="cfg"></param>
		/// <param name="requiredUpgrade"></param>
		/// <returns></returns>
		internal static JObject AttemptConfigUpgrade(JObject cfg, out bool requiredUpgrade)
		{
			requiredUpgrade = false;

			if (cfg.SelectToken("Settings") == null)
			{
				JObject newCfg = new JObject
				{
					{ "Settings", cfg }
				};
				cfg = newCfg;
				requiredUpgrade = true;
			}

			return cfg;
		}

		internal static TSettings LoadConfigAndCheckForChanges<TSettings>(string json, out bool writeConfig) where TSettings : new()
		{
			//If an empty file is attempting to be loaded as a config, instead use an empty json object. Otherwise Newtonsoft throws an exception here
			if (string.IsNullOrWhiteSpace(json))
			{
				json = "{}";
			}

			return LoadConfigAndCheckForChanges<TSettings>(JObject.Parse(json), out writeConfig);
		}

		/// <summary>
		/// Parses a JObject into a TSettings object, also emitting a bool indicating if the JObject was incomplete
		/// </summary>
		/// <typeparam name="TSettings">The type of the config file object</typeparam>
		/// <param name="jObject">The json object to parse</param>
		/// <param name="writeConfig">Whether the config needs to be written to disk again</param>
		/// <returns>The config object</returns>
		internal static TSettings LoadConfigAndCheckForChanges<TSettings>(JObject jObject, out bool writeConfig) where TSettings : new()
		{
			JObject cfg = AttemptConfigUpgrade(jObject, out bool requiredUpgrade);

			var configFields = new HashSet<string>(typeof(TSettings).GetFields()
				.Where(field => !field.IsStatic)
				.Select(field => field.Name));

			var jsonFields = new HashSet<string>(cfg.SelectToken("Settings")
				.Children()
				.Select(field => field as JProperty)
				.Where(field => field != null)
				.Select(field => field.Name));

			bool missingFields = !configFields.SetEquals(jsonFields);


			//If the config file had to be upgraded or the fields in the given TSettings don't match the config, we'll want the config to be rewritten with the correct data
			writeConfig = requiredUpgrade || missingFields;

			return cfg.SelectToken("Settings").ToObject<TSettings>();
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/GeoIPCountry.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* GeoIPCountry.cs
 *
 * Copyright (C) 2008 MaxMind, Inc.  All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;

// This code is based on MaxMind's original C# code, which was ported from Java.
// This version is very simplified and does not support a majority of features for speed.

namespace MaxMind
{
	/// <summary>
	/// Allows for looking up a country based on an IP address.  See www.maxmind.com for more details.
	/// </summary>
	/// <example>
	///		static void Main(string[] args)
	///		{
	///			using(GeoIPCountry geo = new GeoIPCountry("GeoIP.dat"))
	///			{
	///				try
	///				{
	///					Console.WriteLine("Country code of IP address 67.15.94.80: " + geo.GetCountryCode("67.15.94.80"));
	///				}
	///				catch(Exception ex)
	///				{
	///					Console.WriteLine(ex.ToString());
	///				}
	///			}
	///		}
	/// </example>
	public sealed class GeoIPCountry : IDisposable
	{
		private Stream _geodata;
		private bool _close;

		// hard coded position of where country data starts in the data file.
		private const long COUNTRY_BEGIN = 16776960;

		private static readonly string[] CountryCodes = {
		                                                	"--", "AP", "EU", "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN",
		                                                	"AO", "AQ", "AR", "AS",
		                                                	"AT", "AU", "AW", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH",
		                                                	"BI", "BJ", "BM", "BN",
		                                                	"BO", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD",
		                                                	"CF", "CG", "CH", "CI",
		                                                	"CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CX", "CY", "CZ",
		                                                	"DE", "DJ", "DK", "DM",
		                                                	"DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ",
		                                                	"FK", "FM", "FO", "FR",
		                                                	"FX", "GA", "GB", "GD", "GE", "GF", "GH", "GI", "GL", "GM", "GN",
		                                                	"GP", "GQ", "GR", "GS",
		                                                	"GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID",
		                                                	"IE", "IL", "IN", "IO",
		                                                	"IQ", "IR", "IS", "IT", "JM", "JO", "JP", "KE", "KG", "KH", "KI",
		                                                	"KM", "KN", "KP", "KR",
		                                                	"KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT",
		                                                	"LU", "LV", "LY", "MA",
		                                                	"MC", "MD", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ",
		                                                	"MR", "MS", "MT", "MU",
		                                                	"MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI",
		                                                	"NL", "NO", "NP", "NR",
		                                                	"NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM",
		                                                	"PN", "PR", "PS", "PT",
		                                                	"PW", "PY", "QA", "RE", "RO", "RU", "RW", "SA", "SB", "SC", "SD",
		                                                	"SE", "SG", "SH", "SI",
		                                                	"SJ", "SK", "SL", "SM", "SN", "SO", "SR", "ST", "SV", "SY", "SZ",
		                                                	"TC", "TD", "TF", "TG",
		                                                	"TH", "TJ", "TK", "TM", "TN", "TO", "TL", "TR", "TT", "TV", "TW",
		                                                	"TZ", "UA", "UG", "UM",
		                                                	"US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF",
		                                                	"WS", "YE", "YT", "RS",
		                                                	"ZA", "ZM", "ME", "ZW", "A1", "A2", "O1", "AX", "GG", "IM", "JE",
		                                                	"BL", "MF"
		                                                };

		private static readonly string[] CountryNames = {
		                                                	"N/A", "Asia/Pacific Region", "Europe", "Andorra",
		                                                	"United Arab Emirates", "Afghanistan",
		                                                	"Antigua and Barbuda", "Anguilla", "Albania", "Armenia",
		                                                	"Netherlands Antilles", "Angola",
		                                                	"Antarctica", "Argentina", "American Samoa", "Austria", "Australia",
		                                                	"Aruba", "Azerbaijan",
		                                                	"Bosnia and Herzegovina", "Barbados", "Bangladesh", "Belgium",
		                                                	"Burkina Faso", "Bulgaria",
		                                                	"Bahrain", "Burundi", "Benin", "Bermuda", "Brunei Darussalam",
		                                                	"Bolivia", "Brazil", "Bahamas",
		                                                	"Bhutan", "Bouvet Island", "Botswana", "Belarus", "Belize", "Canada",
		                                                	"Cocos (Keeling) Islands",
		                                                	"Congo, The Democratic Republic of the", "Central African Republic",
		                                                	"Congo", "Switzerland",
		                                                	"Cote D'Ivoire", "Cook Islands", "Chile", "Cameroon", "China",
		                                                	"Colombia", "Costa Rica", "Cuba",
		                                                	"Cape Verde", "Christmas Island", "Cyprus", "Czech Republic",
		                                                	"Germany", "Djibouti", "Denmark",
		                                                	"Dominica", "Dominican Republic", "Algeria", "Ecuador", "Estonia",
		                                                	"Egypt", "Western Sahara",
		                                                	"Eritrea", "Spain", "Ethiopia", "Finland", "Fiji",
		                                                	"Falkland Islands (Malvinas)",
		                                                	"Micronesia, Federated States of", "Faroe Islands", "France",
		                                                	"France, Metropolitan", "Gabon",
		                                                	"United Kingdom", "Grenada", "Georgia", "French Guiana", "Ghana",
		                                                	"Gibraltar", "Greenland",
		                                                	"Gambia", "Guinea", "Guadeloupe", "Equatorial Guinea", "Greece",
		                                                	"South Georgia and the South Sandwich Islands", "Guatemala", "Guam",
		                                                	"Guinea-Bissau", "Guyana",
		                                                	"Hong Kong", "Heard Island and McDonald Islands", "Honduras",
		                                                	"Croatia", "Haiti", "Hungary",
		                                                	"Indonesia", "Ireland", "Israel", "India",
		                                                	"British Indian Ocean Territory", "Iraq",
		                                                	"Iran, Islamic Republic of", "Iceland", "Italy", "Jamaica", "Jordan",
		                                                	"Japan", "Kenya",
		                                                	"Kyrgyzstan", "Cambodia", "Kiribati", "Comoros",
		                                                	"Saint Kitts and Nevis",
		                                                	"Korea, Democratic People's Republic of", "Korea, Republic of",
		                                                	"Kuwait", "Cayman Islands",
		                                                	"Kazakstan", "Lao People's Democratic Republic", "Lebanon",
		                                                	"Saint Lucia", "Liechtenstein",
		                                                	"Sri Lanka", "Liberia", "Lesotho", "Lithuania", "Luxembourg",
		                                                	"Latvia", "Libyan Arab Jamahiriya",
		                                                	"Morocco", "Monaco", "Moldova, Republic of", "Madagascar",
		                                                	"Marshall Islands", "Macedonia",
		                                                	"Mali", "Myanmar", "Mongolia", "Macau", "Northern Mariana Islands",
		                                                	"Martinique", "Mauritania",
		                                                	"Montserrat", "Malta", "Mauritius", "Maldives", "Malawi", "Mexico",
		                                                	"Malaysia", "Mozambique",
		                                                	"Namibia", "New Caledonia", "Niger", "Norfolk Island", "Nigeria",
		                                                	"Nicaragua", "Netherlands",
		                                                	"Norway", "Nepal", "Nauru", "Niue", "New Zealand", "Oman", "Panama",
		                                                	"Peru", "French Polynesia",
		                                                	"Papua New Guinea", "Philippines", "Pakistan", "Poland",
		                                                	"Saint Pierre and Miquelon",
		                                                	"Pitcairn Islands", "Puerto Rico", "Palestinian Territory",
		                                                	"Portugal", "Palau", "Paraguay",
		                                                	"Qatar", "Reunion", "Romania", "Russian Federation", "Rwanda",
		                                                	"Saudi Arabia",
		                                                	"Solomon Islands", "Seychelles", "Sudan", "Sweden", "Singapore",
		                                                	"Saint Helena", "Slovenia",
		                                                	"Svalbard and Jan Mayen", "Slovakia", "Sierra Leone", "San Marino",
		                                                	"Senegal", "Somalia",
		                                                	"Suriname", "Sao Tome and Principe", "El Salvador",
		                                                	"Syrian Arab Republic", "Swaziland",
		                                                	"Turks and Caicos Islands", "Chad", "French Southern Territories",
		                                                	"Togo", "Thailand",
		                                                	"Tajikistan", "Tokelau", "Turkmenistan", "Tunisia", "Tonga",
		                                                	"Timor-Leste", "Turkey",
		                                                	"Trinidad and Tobago", "Tuvalu", "Taiwan",
		                                                	"Tanzania, United Republic of", "Ukraine", "Uganda",
		                                                	"United States Minor Outlying Islands", "United States", "Uruguay",
		                                                	"Uzbekistan",
		                                                	"Holy See (Vatican City State)", "Saint Vincent and the Grenadines",
		                                                	"Venezuela",
		                                                	"Virgin Islands, British", "Virgin Islands, U.S.", "Vietnam",
		                                                	"Vanuatu", "Wallis and Futuna",
		                                                	"Samoa", "Yemen", "Mayotte", "Serbia", "South Africa", "Zambia",
		                                                	"Montenegro", "Zimbabwe",
		                                                	"Anonymous Proxy", "Satellite Provider", "Other", "Aland Islands",
		                                                	"Guernsey", "Isle of Man",
		                                                	"Jersey", "Saint Barthelemy", "Saint Martin"
		                                                };

		//
		// Constructor
		//

		/// <summary>
		/// Initialises a new instance of this class.
		/// </summary>
		/// <param name="datafile">An already open stream pointing to the contents of a GeoIP.dat file.</param>
		/// <remarks>The stream is not closed when this class is disposed. Be sure to clean up afterwards!</remarks>
		public GeoIPCountry(Stream datafile)
		{
			_geodata = datafile;
			_close = false;
		}

		/// <summary>
		/// Initialises a new instance of this class, using an on-disk database.
		/// </summary>
		/// <param name="filename">Path to database file.</param>
		/// <remarks>The file will be closed when this class is disposed.</remarks>
		public GeoIPCountry(string filename)
		{
			FileStream fs = new FileStream(filename, FileMode.Open);
			_geodata = fs;
			_close = true;
		}

		/// <summary>
		/// Retrieves a two-letter code, defined by MaxMind, which details the country the specified IP address is located.
		/// </summary>
		/// <param name="ip">IP address to query.</param>
		/// <returns>A two-letter code string. Throws exceptions on failure.</returns>
		/// <remarks>The IP address must be IPv4.</remarks>
		public string GetCountryCode(IPAddress ip)
		{
			return CountryCodes[FindIndex(ip)];
		}

		/// <summary>
		/// Retrieves a two-letter code, defined by MaxMind, which details the country the specified IP address is located. Does not throw exceptions on failure.
		/// </summary>
		/// <param name="ip">IP address to query.</param>
		/// <returns>Two-letter country code or null on failure.</returns>
		public string TryGetCountryCode(IPAddress ip)
		{
			try
			{
				return CountryCodes[FindIndex(ip)];
			}
			catch (Exception)
			{
				return null;
			}
		}

		/// <summary>
		/// Gets the English name of a country, by a country code.
		/// </summary>
		/// <param name="countrycode">Country code to look up, returned by GetCountryCode or TryGetCountryCode.</param>
		/// <returns>English name of the country, or null on failure.</returns>
		public static string GetCountryNameByCode(string countrycode)
		{
			int index = Array.IndexOf(CountryCodes, countrycode);
			return index == -1 ? null : CountryNames[index];
		}

		private int FindIndex(IPAddress ip)
		{
			return (int) FindCountryCode(0, AddressToLong(ip), 31);
		}

		// Converts an IPv4 address into a long, for reading from geo database
		private long AddressToLong(IPAddress ip)
		{
			if (ip.AddressFamily != AddressFamily.InterNetwork)
				throw new InvalidOperationException("IP address is not IPv4");

			long num = 0;
			byte[] bytes = ip.GetAddressBytes();
			for (int i = 0; i < 4; ++i)
			{
				long y = bytes[i];
				if (y < 0)
					y += 256;
				num += y << ((3 - i)*8);
			}

			return num;
		}

		// Traverses the GeoIP binary data looking for a country code based
		// on the IP address mask
		private long FindCountryCode(long offset, long ipnum, int depth)
		{
			byte[] buffer = new byte[6]; // 2 * MAX_RECORD_LENGTH
			long[] x = new long[2];
			if (depth < 0)
				throw new IOException("Cannot seek GeoIP database");

			_geodata.Seek(6*offset, SeekOrigin.Begin);
			_geodata.Read(buffer, 0, 6);

			for (int i = 0; i < 2; i++)
			{
				x[i] = 0;
				for (int j = 0; j < 3; j++)
				{
					int y = buffer[i*3 + j];
					if (y < 0)
						y += 256;
					x[i] += (y << (j*8));
				}
			}

			if ((ipnum & (1 << depth)) > 0)
			{
				if (x[1] >= COUNTRY_BEGIN)
					return x[1] - COUNTRY_BEGIN;
				return FindCountryCode(x[1], ipnum, depth - 1);
			}
			else
			{
				if (x[0] >= COUNTRY_BEGIN)
					return x[0] - COUNTRY_BEGIN;
				return FindCountryCode(x[0], ipnum, depth - 1);
			}
		}

		public void Dispose()
		{
			if (_close && _geodata != null)
			{
				_geodata.Close();
				_geodata = null;
			}
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/GetDataHandlers.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.IO.Streams;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria.ID;
using TShockAPI.DB;
using TShockAPI.Net;
using Terraria;
using Terraria.ObjectData;
using Terraria.DataStructures;
using Terraria.GameContent.Tile_Entities;
using Terraria.Localization;
using Microsoft.Xna.Framework;
using TShockAPI.Localization;
using TShockAPI.Models;
using TShockAPI.Models.PlayerUpdate;
using TShockAPI.Models.Projectiles;
using Terraria.Net;
using Terraria.GameContent.NetModules;

namespace TShockAPI
{
	public delegate bool GetDataHandlerDelegate(GetDataHandlerArgs args);

	public class GetDataHandlerArgs : EventArgs
	{
		public TSPlayer Player { get; private set; }
		public MemoryStream Data { get; private set; }

		public Player TPlayer
		{
			get { return Player.TPlayer; }
		}

		public GetDataHandlerArgs(TSPlayer player, MemoryStream data)
		{
			Player = player;
			Data = data;
		}
	}

	/// <summary>
	/// A custom HandledEventArgs that contains TShock's TSPlayer for the triggering uesr and the Terraria MP data stream.
	/// Differentiated by GetDataHandlerArgs because it can be handled and responds to being handled.
	/// </summary>
	public class GetDataHandledEventArgs : HandledEventArgs
	{
		/// <summary>The TSPlayer that triggered the event.</summary>
		public TSPlayer Player { get; set; }

		/// <summary>The raw MP packet data associated with the event.</summary>
		public MemoryStream Data { get; set; }
	}

	public static class GetDataHandlers
	{
		private static Dictionary<PacketTypes, GetDataHandlerDelegate> GetDataHandlerDelegates;

		public static void InitGetDataHandler()
		{
			GetDataHandlerDelegates = new Dictionary<PacketTypes, GetDataHandlerDelegate>
				{
					{ PacketTypes.PlayerInfo, HandlePlayerInfo },
					{ PacketTypes.PlayerSlot, HandlePlayerSlot },
					{ PacketTypes.ContinueConnecting2, HandleConnecting },
					{ PacketTypes.TileGetSection, HandleGetSection },
					{ PacketTypes.PlayerSpawn, HandleSpawn },
					{ PacketTypes.PlayerUpdate, HandlePlayerUpdate },
					{ PacketTypes.PlayerHp, HandlePlayerHp },
					{ PacketTypes.Tile, HandleTile },
					{ PacketTypes.DoorUse, HandleDoorUse },
					{ PacketTypes.TileSendSquare, HandleSendTileRect },
					{ PacketTypes.ItemDrop, HandleItemDrop },
					{ PacketTypes.ItemOwner, HandleItemOwner },
					{ PacketTypes.NpcItemStrike, HandleNpcItemStrike },
					{ PacketTypes.ProjectileNew, HandleProjectileNew },
					{ PacketTypes.NpcStrike, HandleNpcStrike },
					{ PacketTypes.ProjectileDestroy, HandleProjectileKill },
					{ PacketTypes.TogglePvp, HandleTogglePvp },
					{ PacketTypes.ChestGetContents, HandleChestOpen },
					{ PacketTypes.ChestItem, HandleChestItem },
					{ PacketTypes.ChestOpen, HandleChestActive },
					{ PacketTypes.PlaceChest, HandlePlaceChest },
					{ PacketTypes.Zones, HandlePlayerZone },
					{ PacketTypes.PasswordSend, HandlePassword },
					{ PacketTypes.NpcTalk, HandleNpcTalk },
					{ PacketTypes.PlayerAnimation, HandlePlayerAnimation },
					{ PacketTypes.PlayerMana, HandlePlayerMana },
					{ PacketTypes.PlayerTeam, HandlePlayerTeam },
					{ PacketTypes.SignRead, HandleSignRead },
					{ PacketTypes.SignNew, HandleSign },
					{ PacketTypes.LiquidSet, HandleLiquidSet },
					{ PacketTypes.PlayerBuff, HandlePlayerBuffList },
					{ PacketTypes.NpcSpecial, HandleSpecial },
					{ PacketTypes.NpcAddBuff, HandleNPCAddBuff },
					{ PacketTypes.PlayerAddBuff, HandlePlayerAddBuff },
					{ PacketTypes.UpdateNPCHome, HandleUpdateNPCHome },
					{ PacketTypes.SpawnBossorInvasion, HandleSpawnBoss },
					{ PacketTypes.PaintTile, HandlePaintTile },
					{ PacketTypes.PaintWall, HandlePaintWall },
					{ PacketTypes.Teleport, HandleTeleport },
					{ PacketTypes.PlayerHealOther, HandleHealOther },
					{ PacketTypes.CatchNPC, HandleCatchNpc },
					{ PacketTypes.ReleaseNPC, HandleReleaseNpc },
					{ PacketTypes.TeleportationPotion, HandleTeleportationPotion },
					{ PacketTypes.CompleteAnglerQuest, HandleCompleteAnglerQuest },
					{ PacketTypes.NumberOfAnglerQuestsCompleted, HandleNumberOfAnglerQuestsCompleted },
					{ PacketTypes.PlaceObject, HandlePlaceObject },
					{ PacketTypes.LoadNetModule, HandleLoadNetModule },
					{ PacketTypes.PlaceTileEntity, HandlePlaceTileEntity },
					{ PacketTypes.PlaceItemFrame, HandlePlaceItemFrame },
					{ PacketTypes.UpdateItemDrop, HandleItemDrop },
					{ PacketTypes.SyncExtraValue, HandleSyncExtraValue },
					{ PacketTypes.KillPortal, HandleKillPortal },
					{ PacketTypes.PlayerTeleportPortal, HandlePlayerPortalTeleport },
					{ PacketTypes.NpcTeleportPortal, HandleNpcTeleportPortal },
					{ PacketTypes.GemLockToggle, HandleGemLockToggle },
					{ PacketTypes.MassWireOperation, HandleMassWireOperation },
					{ PacketTypes.ToggleParty, HandleToggleParty },
					{ PacketTypes.CrystalInvasionStart, HandleOldOnesArmy },
					{ PacketTypes.PlayerHurtV2, HandlePlayerDamageV2 },
					{ PacketTypes.PlayerDeathV2, HandlePlayerKillMeV2 },
					{ PacketTypes.Emoji, HandleEmoji },
					{ PacketTypes.TileEntityDisplayDollItemSync, HandleTileEntityDisplayDollItemSync },
					{ PacketTypes.RequestTileEntityInteraction, HandleRequestTileEntityInteraction },
					{ PacketTypes.SyncTilePicking, HandleSyncTilePicking },
					{ PacketTypes.SyncRevengeMarker, HandleSyncRevengeMarker },
					{ PacketTypes.LandGolfBallInCup, HandleLandGolfBallInCup },
					{ PacketTypes.FishOutNPC, HandleFishOutNPC },
					{ PacketTypes.FoodPlatterTryPlacing, HandleFoodPlatterTryPlacing },
					{ PacketTypes.SyncCavernMonsterType, HandleSyncCavernMonsterType },
					{ PacketTypes.SyncLoadout, HandleSyncLoadout }
				};
		}

		public static bool HandlerGetData(PacketTypes type, TSPlayer player, MemoryStream data)
		{
			GetDataHandlerDelegate handler;
			if (GetDataHandlerDelegates.TryGetValue(type, out handler))
			{
				try
				{
					return handler(new GetDataHandlerArgs(player, data));
				}
				catch (Exception ex)
				{
					TShock.Log.Error(ex.ToString());
					return true;
				}
			}
			return false;
		}

		#region Events

		public class PlayerInfoEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// Hair color
			/// </summary>
			public byte Hair { get; set; }
			/// <summary>
			/// Clothing style. 0-3 are for male characters, and 4-7 are for female characters.
			/// </summary>
			public int Style { get; set; }
			/// <summary>
			/// Character difficulty
			/// </summary>
			public byte Difficulty { get; set; }
			/// <summary>
			/// Player/character name
			/// </summary>
			public string Name { get; set; }
		}
		/// <summary>
		/// PlayerInfo - called at a PlayerInfo event
		/// If this is cancelled, the server will kick the player. If this should be changed in the future, let someone know.
		/// </summary>
		public static HandlerList<PlayerInfoEventArgs> PlayerInfo = new HandlerList<PlayerInfoEventArgs>();
		private static bool OnPlayerInfo(TSPlayer player, MemoryStream data, byte _plrid, byte _hair, int _style, byte _difficulty, string _name)
		{
			if (PlayerInfo == null)
				return false;

			var args = new PlayerInfoEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = _plrid,
				Hair = _hair,
				Style = _style,
				Difficulty = _difficulty,
				Name = _name,
			};
			PlayerInfo.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerSlot event
		/// </summary>
		public class PlayerSlotEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// The slot edited
			/// </summary>
			public short Slot { get; set; }
			/// <summary>
			/// The stack edited
			/// </summary>
			public short Stack { get; set; }
			/// <summary>
			/// The item prefix
			/// </summary>
			public byte Prefix { get; set; }
			/// <summary>
			/// Item type
			/// </summary>
			public short Type { get; set; }
		}
		/// <summary>
		/// PlayerSlot - called at a PlayerSlot event
		/// </summary>
		public static HandlerList<PlayerSlotEventArgs> PlayerSlot = new HandlerList<PlayerSlotEventArgs>();
		private static bool OnPlayerSlot(TSPlayer player, MemoryStream data, byte _plr, short _slot, short _stack, byte _prefix, short _type)
		{
			if (PlayerSlot == null)
				return false;

			var args = new PlayerSlotEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = _plr,
				Slot = _slot,
				Stack = _stack,
				Prefix = _prefix,
				Type = _type
			};
			PlayerSlot.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>The arguments to a GetSection packet.</summary>
		public class GetSectionEventArgs : GetDataHandledEventArgs
		{
			/// <summary>The X position requested. Or -1 for spawn.</summary>
			public int X { get; set; }

			/// <summary>The Y position requested. Or -1 for spawn.</summary>
			public int Y { get; set; }
		}
		/// <summary>The hook for a GetSection event.</summary>
		public static HandlerList<GetSectionEventArgs> GetSection = new HandlerList<GetSectionEventArgs>();
		private static bool OnGetSection(TSPlayer player, MemoryStream data, int x, int y)
		{
			if (GetSection == null)
				return false;

			var args = new GetSectionEventArgs
			{
				Player = player,
				Data = data,
				X = x,
				Y = y,
			};

			GetSection.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerUpdate event
		/// </summary>
		public class PlayerUpdateEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// Control direction (BitFlags)
			/// </summary>
			public ControlSet Control { get; set; }
			/// <summary>
			/// Misc Data Set 1
			/// </summary>
			public MiscDataSet1 MiscData1 { get; set; }
			/// <summary>
			/// Misc Data Set 2
			/// </summary>
			public MiscDataSet2 MiscData2 { get; set; }
			/// <summary>
			/// Misc Data Set 3
			/// </summary>
			public MiscDataSet3 MiscData3 { get; set; }
			/// <summary>
			/// The selected item in player's hand.
			/// </summary>
			public byte SelectedItem { get; set; }
			/// <summary>
			/// Position of the player.
			/// </summary>
			public Vector2 Position { get; set; }
			/// <summary>
			/// Velocity of the player.
			/// </summary>
			public Vector2 Velocity { get; set; }
			/// <summary>
			/// Original position of the player when using Potion of Return.
			/// </summary>
			public Vector2? OriginalPos { get; set; }
			/// <summary>
			/// Home Position of the player for Potion of Return.
			/// </summary>
			public Vector2? HomePos { get; set; }

		}
		/// <summary>
		/// PlayerUpdate - When the player sends it's updated information to the server
		/// </summary>
		public static HandlerList<PlayerUpdateEventArgs> PlayerUpdate = new HandlerList<PlayerUpdateEventArgs>();
		private static bool OnPlayerUpdate(
			TSPlayer player,
			MemoryStream data,
			byte plr,
			ControlSet control,
			MiscDataSet1 miscData1,
			MiscDataSet2 miscData2,
			MiscDataSet3 miscData3,
			byte selectedItem,
			Vector2 position,
			Vector2 velocity,
			Vector2? originalPos,
			Vector2? homePos)
		{
			if (PlayerUpdate == null)
				return false;

			var args = new PlayerUpdateEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = plr,
				Control = control,
				MiscData1 = miscData1,
				MiscData2 = miscData2,
				MiscData3 = miscData3,
				SelectedItem = selectedItem,
				Position = position,
				Velocity = velocity,
				OriginalPos = originalPos,
				HomePos = homePos
			};
			PlayerUpdate.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerHP event
		/// </summary>
		public class PlayerHPEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// Current HP
			/// </summary>
			public short Current { get; set; }
			/// <summary>
			/// Maximum HP
			/// </summary>
			public short Max { get; set; }
		}
		/// <summary>
		/// PlayerHP - called at a PlayerHP event
		/// </summary>
		public static HandlerList<PlayerHPEventArgs> PlayerHP = new HandlerList<PlayerHPEventArgs>();
		private static bool OnPlayerHP(TSPlayer player, MemoryStream data, byte _plr, short _cur, short _max)
		{
			if (PlayerHP == null)
				return false;

			var args = new PlayerHPEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = _plr,
				Current = _cur,
				Max = _max,
			};
			PlayerHP.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// Used when a TileEdit event is called.
		/// </summary>
		public class TileEditEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The tile coordinate on the X plane
			/// </summary>
			public int X { get; set; }

			/// <summary>
			/// The tile coordinate on the Y plane
			/// </summary>
			public int Y { get; set; }

			/// <summary>
			/// The Tile ID being edited.
			/// </summary>
			public short EditData { get; set; }
			/// <summary>
			/// The EditType.
			/// (KillTile = 0, PlaceTile = 1, KillWall = 2, PlaceWall = 3, KillTileNoItem = 4, PlaceWire = 5, KillWire = 6)
			/// </summary>
			public EditAction Action { get; set; }

			/// <summary>
			/// Did the tile get destroyed successfully.
			/// </summary>
			public EditType editDetail { get; set; }

			/// <summary>
			/// Used when a tile is placed to denote a subtype of tile. (e.g. for tile id 21: Chest = 0, Gold Chest = 1)
			/// </summary>
			public byte Style { get; set; }
		}
		/// <summary>
		/// TileEdit - called when a tile is placed or destroyed
		/// </summary>
		public static HandlerList<TileEditEventArgs> TileEdit = new HandlerList<TileEditEventArgs>();
		private static bool OnTileEdit(TSPlayer ply, MemoryStream data, int x, int y, EditAction action, EditType editDetail, short editData, byte style)
		{
			if (TileEdit == null)
				return false;

			var args = new TileEditEventArgs
			{
				Player = ply,
				Data = data,
				X = x,
				Y = y,
				Action = action,
				EditData = editData,
				editDetail = editDetail,
				Style = style
			};
			TileEdit.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// DoorUseEventArgs - the arguments for a DoorUse event
		/// </summary>
		public class DoorUseEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// X - The x position of the door being used
			/// </summary>
			public short X { get; set; }
			/// <summary>
			/// Y - The y position of the door being used
			/// </summary>
			public short Y { get; set; }
			/// <summary>
			/// Direction - Information about which way the door opens or where the player is relative to the door
			/// </summary>
			public byte Direction { get; set; }
			/// <summary>
			/// Action - The type of thing happening to the door
			/// </summary>
			public DoorAction Action { get; set; }
		}

		/// <summary>
		/// DoorUse - called when a door is opened or closed (normal or trap)
		/// </summary>
		public static HandlerList<DoorUseEventArgs> DoorUse = new HandlerList<DoorUseEventArgs>();
		private static bool OnDoorUse(TSPlayer ply, MemoryStream data, short x, short y, byte direction, DoorAction action)
		{
			if (DoorUse == null)
				return false;

			var args = new DoorUseEventArgs
			{
				Player = ply,
				X = x,
				Y = y,
				Direction = direction,
				Action = action
			};
			DoorUse.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a SendTileRect event
		/// </summary>
		public class SendTileRectEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// X position of the rectangle
			/// </summary>
			public short TileX { get; set; }

			/// <summary>
			/// Y position of the rect
			/// </summary>
			public short TileY { get; set; }

			/// <summary>
			/// Width of the rectangle
			/// </summary>
			public byte Width { get; set; }

			/// <summary>
			/// Length of the rectangle
			/// </summary>
			public byte Length { get; set; }

			/// <summary>
			/// Change type involved in the rectangle
			/// </summary>
			public TileChangeType ChangeType { get; set; }
		}

		/// <summary>
		/// When the player sends a tile square
		/// </summary>
		public static HandlerList<SendTileRectEventArgs> SendTileRect = new HandlerList<SendTileRectEventArgs>();
		private static bool OnSendTileRect(TSPlayer player, MemoryStream data, short tilex, short tiley, byte width, byte length, TileChangeType changeType = TileChangeType.None)
		{
			if (SendTileRect == null)
				return false;

			var args = new SendTileRectEventArgs
			{
				Player = player,
				Data = data,
				TileX = tilex,
				TileY = tiley,
				Width = width,
				Length = length,
				ChangeType = changeType
			};

			SendTileRect.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in an ItemDrop event
		/// </summary>
		public class ItemDropEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// ID of the item.
			/// If below 400 and NetID(Type) is 0 Then Set Null. If ItemID is 400 Then New Item
			/// </summary>
			public short ID { get; set; }
			/// <summary>
			/// Position of the item
			/// </summary>
			public Vector2 Position { get; set; }
			/// <summary>
			/// Velocity at which the item is deployed
			/// </summary>
			public Vector2 Velocity { get; set; }
			/// <summary>
			/// Stacks
			/// </summary>
			public short Stacks { get; set; }
			/// <summary>
			/// Prefix of the item
			/// </summary>
			public byte Prefix { get; set; }
			/// <summary>
			/// No Delay on pickup
			/// </summary>
			public bool NoDelay { get; set; }
			/// <summary>
			/// Item type
			/// </summary>
			public short Type { get; set; }
		}
		/// <summary>
		/// ItemDrop - Called when an item is dropped
		/// </summary>
		public static HandlerList<ItemDropEventArgs> ItemDrop = new HandlerList<ItemDropEventArgs>();
		private static bool OnItemDrop(TSPlayer player, MemoryStream data, short id, Vector2 pos, Vector2 vel, short stacks, byte prefix, bool noDelay, short type)
		{
			if (ItemDrop == null)
				return false;

			var args = new ItemDropEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				Position = pos,
				Velocity = vel,
				Stacks = stacks,
				Prefix = prefix,
				NoDelay = noDelay,
				Type = type,
			};
			ItemDrop.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a NewProjectile event
		/// </summary>
		public class NewProjectileEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// ???
			/// </summary>
			public short Identity { get; set; }
			/// <summary>
			/// Location of the projectile
			/// </summary>
			public Vector2 Position { get; set; }
			/// <summary>
			/// Velocity of the projectile
			/// </summary>
			public Vector2 Velocity { get; set; }
			/// <summary>
			/// Knockback
			/// </summary>
			public float Knockback { get; set; }
			/// <summary>
			/// Damage from the projectile
			/// </summary>
			public short Damage { get; set; }
			/// <summary>
			/// Terraria playerID owner of the projectile
			/// </summary>
			public byte Owner { get; set; }
			/// <summary>
			/// Type of projectile
			/// </summary>
			public short Type { get; set; }
			/// <summary>
			/// ???
			/// </summary>
			public int Index { get; set; }

			/// <summary>
			/// The special meaning of the projectile.
			/// </summary>
			public float[] Ai { get; set; }
		}
		/// <summary>
		/// NewProjectile - Called when a client creates a new projectile
		/// </summary>
		public static HandlerList<NewProjectileEventArgs> NewProjectile = new HandlerList<NewProjectileEventArgs>();
		private static bool OnNewProjectile(MemoryStream data, short ident, Vector2 pos, Vector2 vel, float knockback, short dmg, byte owner, short type, int index, TSPlayer player, float[] ai)
		{
			if (NewProjectile == null)
				return false;

			var args = new NewProjectileEventArgs
			{
				Data = data,
				Identity = ident,
				Position = pos,
				Velocity = vel,
				Knockback = knockback,
				Damage = dmg,
				Owner = owner,
				Type = type,
				Index = index,
				Player = player,
				Ai = ai
			};
			NewProjectile.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use with a NPCStrike event
		/// </summary>
		public class NPCStrikeEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// ???
			/// </summary>
			public short ID { get; set; }
			/// <summary>
			/// Direction the damage occurred from
			/// </summary>
			public byte Direction { get; set; }
			/// <summary>
			/// Amount of damage
			/// </summary>
			public short Damage { get; set; }
			/// <summary>
			/// Knockback
			/// </summary>
			public float Knockback { get; set; }
			/// <summary>
			/// Critical?
			/// </summary>
			public byte Critical { get; set; }
		}
		/// <summary>
		/// NPCStrike - Called when an NPC is attacked
		/// </summary>
		public static HandlerList<NPCStrikeEventArgs> NPCStrike = new HandlerList<NPCStrikeEventArgs>();
		private static bool OnNPCStrike(TSPlayer player, MemoryStream data, short id, byte dir, short dmg, float knockback, byte crit)
		{
			if (NPCStrike == null)
				return false;

			var args = new NPCStrikeEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				Direction = dir,
				Damage = dmg,
				Knockback = knockback,
				Critical = crit,
			};
			NPCStrike.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>The arguments to the ProjectileKill packet.</summary>
		public class ProjectileKillEventArgs : GetDataHandledEventArgs
		{
			/// <summary>The projectile's identity...?</summary>
			public int ProjectileIdentity;
			/// <summary>The player index of the projectile's owner (Main.players).</summary>
			public byte ProjectileOwner;
			/// <summary>The index of the projectile in Main.projectile.</summary>
			public int ProjectileIndex;
		}
		/// <summary>The event fired when a projectile kill packet is received.</summary>
		public static HandlerList<ProjectileKillEventArgs> ProjectileKill = new HandlerList<ProjectileKillEventArgs>();
		/// <summary>Fires the ProjectileKill event.</summary>
		/// <param name="player">The TSPlayer that caused the event.</param>
		/// <param name="data">The MemoryStream containing the raw event data.</param>
		/// <param name="identity">The projectile identity (from the packet).</param>
		/// <param name="owner">The projectile's owner (from the packet).</param>
		/// <param name="index">The projectile's index (from Main.projectiles).</param>
		/// <returns>bool</returns>
		private static bool OnProjectileKill(TSPlayer player, MemoryStream data, int identity, byte owner, int index)
		{
			if (ProjectileKill == null)
				return false;

			var args = new ProjectileKillEventArgs
			{
				Player = player,
				Data = data,
				ProjectileIdentity = identity,
				ProjectileOwner = owner,
				ProjectileIndex = index,
			};

			ProjectileKill.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a TogglePvp event
		/// </summary>
		public class TogglePvpEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria player ID of the player
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// Enable/disable pvp?
			/// </summary>
			public bool Pvp { get; set; }
		}
		/// <summary>
		/// TogglePvp - called when a player toggles pvp
		/// </summary>
		public static HandlerList<TogglePvpEventArgs> TogglePvp = new HandlerList<TogglePvpEventArgs>();
		private static bool OnPvpToggled(TSPlayer player, MemoryStream data, byte _id, bool _pvp)
		{
			if (TogglePvp == null)
				return false;

			var args = new TogglePvpEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = _id,
				Pvp = _pvp,
			};
			TogglePvp.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerSpawn event
		/// </summary>
		public class SpawnEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// X location of the player's spawn
			/// </summary>
			public int SpawnX { get; set; }
			/// <summary>
			/// Y location of the player's spawn
			/// </summary>
			public int SpawnY { get; set; }
			/// <summary>
			/// Value of the timer countdown before the player can respawn alive.
			/// If > 0, then player is still dead.
			/// </summary>
			public int RespawnTimer { get; set; }
			/// <summary>
			/// Number Of Deaths PVE
			/// </summary>
			public int NumberOfDeathsPVE { get; set; }
			/// <summary>
			/// Number Of Deaths PVP
			/// </summary>
			public int NumberOfDeathsPVP { get; set; }
			/// <summary>
			/// Context of where the player is spawning from.
			/// </summary>
			public PlayerSpawnContext SpawnContext { get; set; }
		}
		/// <summary>
		/// PlayerSpawn - When a player spawns
		/// </summary>
		public static HandlerList<SpawnEventArgs> PlayerSpawn = new HandlerList<SpawnEventArgs>();
		private static bool OnPlayerSpawn(TSPlayer player, MemoryStream data, byte pid, int spawnX, int spawnY, int respawnTimer, int numberOfDeathsPVE, int numberOfDeathsPVP, PlayerSpawnContext spawnContext)
		{
			if (PlayerSpawn == null)
				return false;

			var args = new SpawnEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = pid,
				SpawnX = spawnX,
				SpawnY = spawnY,
				RespawnTimer = respawnTimer,
				NumberOfDeathsPVE = numberOfDeathsPVE,
				NumberOfDeathsPVP = numberOfDeathsPVP,
				SpawnContext = spawnContext
			};
			PlayerSpawn.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a ChestItemChange event
		/// </summary>
		public class ChestItemEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// ChestID
			/// </summary>
			public short ID { get; set; }
			/// <summary>
			/// Slot of the item
			/// </summary>
			public byte Slot { get; set; }
			/// <summary>
			/// How many?
			/// </summary>
			public short Stacks { get; set; }
			/// <summary>
			/// Item prefix
			/// </summary>
			public byte Prefix { get; set; }
			/// <summary>
			/// Item type
			/// </summary>
			public short Type { get; set; }
		}
		/// <summary>
		/// ChestItemChange - Called when an item in a chest changes
		/// </summary>
		public static HandlerList<ChestItemEventArgs> ChestItemChange = new HandlerList<ChestItemEventArgs>();
		private static bool OnChestItemChange(TSPlayer player, MemoryStream data, short id, byte slot, short stacks, byte prefix, short type)
		{
			if (ChestItemChange == null)
				return false;

			var args = new ChestItemEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				Slot = slot,
				Stacks = stacks,
				Prefix = prefix,
				Type = type,
			};
			ChestItemChange.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use with a ChestOpen event
		/// </summary>
		public class ChestOpenEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// X location of said chest
			/// </summary>
			public int X { get; set; }
			/// <summary>
			/// Y location of said chest
			/// </summary>
			public int Y { get; set; }
		}
		/// <summary>
		/// ChestOpen - Called when any chest is opened
		/// </summary>
		public static HandlerList<ChestOpenEventArgs> ChestOpen = new HandlerList<ChestOpenEventArgs>();
		private static bool OnChestOpen(MemoryStream data, int x, int y, TSPlayer player)
		{
			if (ChestOpen == null)
				return false;

			var args = new ChestOpenEventArgs
			{
				Data = data,
				X = x,
				Y = y,
				Player = player,
			};
			ChestOpen.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlaceChest event
		/// </summary>
		public class PlaceChestEventArgs : GetDataHandledEventArgs
		{
			/// <summary>What the packet is doing (see MP packet docs).</summary>
			public int Flag { get; set; }
			/// <summary>
			/// The X coordinate
			/// </summary>
			public int TileX { get; set; }
			/// <summary>
			/// The Y coordinate
			/// </summary>
			public int TileY { get; set; }
			/// <summary>
			/// Place style used
			/// </summary>
			public short Style { get; set; }
		}
		/// <summary>
		/// When a chest is added or removed from the world.
		/// </summary>
		public static HandlerList<PlaceChestEventArgs> PlaceChest = new HandlerList<PlaceChestEventArgs>();
		private static bool OnPlaceChest(TSPlayer player, MemoryStream data, int flag, int tilex, int tiley, short style)
		{
			if (PlaceChest == null)
				return false;

			var args = new PlaceChestEventArgs
			{
				Player = player,
				Data = data,
				Flag = flag,
				TileX = tilex,
				TileY = tiley,
				Style = style
			};
			PlaceChest.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerZone event
		/// </summary>
		public class PlayerZoneEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// 0 = Dungeon, 1 = Corruption,2 =Holy, 3 = Meteor, 4 = Jungle, 5 = Snow, 6 = Crimson, 7 = Water Candle
			/// </summary>
			public BitsByte Zone1 { get; set; }
			/// <summary>
			/// 0 = Peace Candle, 1 = Solar Tower, 2 = Vortex Tower, 3 = Nebula Tower, 4 = Stardust Tower, 5 = Desert, 6 = Glowshroom, 7 = Underground Desert
			/// </summary>
			public BitsByte Zone2 { get; set; }
			/// <summary>
			/// 0 = Overworld, 1 = Dirt Layer, 2 = Rock Layer, 3 = Underworld, 4 = Beach, 5 = Rain, 6 = Sandstorm
			/// </summary>
			public BitsByte Zone3 { get; set; }
			/// <summary>
			/// 0 = Old One's Army, 1 = Granite, 2 = Marble, 3 = Hive, 4 = Gem Cave, 5 = Lihzhard Temple, 6 = Graveyard
			/// </summary>
			public BitsByte Zone4 { get; set; }
			/// <summary>
			/// 0 = The Aether
			/// </summary>
			public BitsByte Zone5 { get; set; }
		}
		/// <summary>
		/// PlayerZone - When the player sends it's zone/biome information to the server
		/// </summary>
		public static HandlerList<PlayerZoneEventArgs> PlayerZone = new HandlerList<PlayerZoneEventArgs>();
		private static bool OnPlayerZone(TSPlayer player, MemoryStream data, byte plr, BitsByte zone1, BitsByte zone2, BitsByte zone3, BitsByte zone4, BitsByte zone5)
		{
			if (PlayerZone == null)
				return false;

			var args = new PlayerZoneEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = plr,
				Zone1 = zone1,
				Zone2 = zone2,
				Zone3 = zone3,
				Zone4 = zone4,
				Zone5 = zone5
			};
			PlayerZone.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// Using when player trying to talk to a NPC
		/// </summary>
		public class NpcTalkEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria ID of the player talking to the NPC
			/// </summary>
			public byte PlayerId { get; set; }

			/// <summary>
			/// The NPC ID of the NPC the player is talking to
			/// </summary>
			public short NPCTalkTarget { get; set; }
		}
		public static HandlerList<NpcTalkEventArgs> NpcTalk = new HandlerList<NpcTalkEventArgs>();
		private static bool OnNpcTalk(TSPlayer player, MemoryStream data, byte _plr, short _npctarget)
		{
			if (NpcTalk == null)
			{
				return false;
			}

			var args = new NpcTalkEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = _plr,
				NPCTalkTarget = _npctarget,
			};
			NpcTalk.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use with a PlayerAnimation event
		/// </summary>
		public class PlayerAnimationEventArgs : GetDataHandledEventArgs { }
		/// <summary>
		/// PlayerAnimation - Called when a player animates
		/// </summary>
		public static HandlerList<PlayerAnimationEventArgs> PlayerAnimation = new HandlerList<PlayerAnimationEventArgs>();
		private static bool OnPlayerAnimation(TSPlayer player, MemoryStream data)
		{
			if (PlayerAnimation == null)
				return false;

			var args = new PlayerAnimationEventArgs
			{
				Player = player,
				Data = data,
			};
			PlayerAnimation.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerMana event
		/// </summary>
		public class PlayerManaEventArgs : GetDataHandledEventArgs
		{
			public byte PlayerId { get; set; }
			public short Current { get; set; }
			public short Max { get; set; }
		}
		/// <summary>
		/// PlayerMana - called at a PlayerMana event
		/// </summary>
		public static HandlerList<PlayerManaEventArgs> PlayerMana = new HandlerList<PlayerManaEventArgs>();
		private static bool OnPlayerMana(TSPlayer player, MemoryStream data, byte _plr, short _cur, short _max)
		{
			if (PlayerMana == null)
				return false;

			var args = new PlayerManaEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = _plr,
				Current = _cur,
				Max = _max,
			};
			PlayerMana.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerTeam event
		/// </summary>
		public class PlayerTeamEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria player ID of the player
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// Enable/disable pvp?
			/// </summary>
			public byte Team { get; set; }
		}
		/// <summary>
		/// TogglePvp - called when a player toggles pvp
		/// </summary>
		public static HandlerList<PlayerTeamEventArgs> PlayerTeam = new HandlerList<PlayerTeamEventArgs>();
		private static bool OnPlayerTeam(TSPlayer player, MemoryStream data, byte _id, byte _team)
		{
			if (PlayerTeam == null)
				return false;

			var args = new PlayerTeamEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = _id,
				Team = _team,
			};
			PlayerTeam.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a SignRead event
		/// </summary>
		public class SignReadEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// X location of the sign
			/// </summary>
			public int X { get; set; }

			/// <summary>
			/// Y location of the sign
			/// </summary>
			public int Y { get; set; }
		}

		/// <summary>
		/// Sign - Called when a sign is read
		/// </summary>
		public static HandlerList<SignReadEventArgs> SignRead = new HandlerList<SignReadEventArgs>();

		private static bool OnSignRead(TSPlayer player, MemoryStream data, int x, int y)
		{
			if (SignRead == null)
				return false;

			var args = new SignReadEventArgs
			{
				Player = player,
				Data = data,
				X = x,
				Y = y,
			};
			SignRead.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a Sign event
		/// </summary>
		public class SignEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public short ID { get; set; }
			/// <summary>
			/// X location of the sign
			/// </summary>
			public int X { get; set; }
			/// <summary>
			/// Y location of the sign
			/// </summary>
			public int Y { get; set; }
		}
		/// <summary>
		/// Sign - Called when a sign is changed
		/// </summary>
		public static HandlerList<SignEventArgs> Sign = new HandlerList<SignEventArgs>();
		private static bool OnSignEvent(TSPlayer player, MemoryStream data, short id, int x, int y)
		{
			if (Sign == null)
				return false;

			var args = new SignEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				X = x,
				Y = y,
			};
			Sign.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a LiquidSet event
		/// </summary>
		public class LiquidSetEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// X location of the tile
			/// </summary>
			public int TileX { get; set; }
			/// <summary>
			/// Y location of the tile
			/// </summary>
			public int TileY { get; set; }
			/// <summary>
			/// Amount of liquid
			/// </summary>
			public byte Amount { get; set; }
			/// <summary>
			/// Type of Liquid: 0=water, 1=lava, 2=honey
			/// </summary>
			public LiquidType Type { get; set; }
		}

		/// <summary>
		/// LiquidType - supported liquid types
		/// </summary>
		public enum LiquidType : byte
		{
			Water = 0,
			Lava = 1,
			Honey = 2,
			Shimmer = 3,
			Removal = 255 //@Olink: lets hope they never invent 255 fluids or decide to also use this :(
		}

		/// <summary>
		/// LiquidSet - When ever a liquid is set
		/// </summary>
		public static HandlerList<LiquidSetEventArgs> LiquidSet = new HandlerList<LiquidSetEventArgs>();
		private static bool OnLiquidSet(TSPlayer player, MemoryStream data, int tilex, int tiley, byte amount, byte type)
		{
			if (LiquidSet == null)
				return false;

			var args = new LiquidSetEventArgs
			{
				Player = player,
				Data = data,
				TileX = tilex,
				TileY = tiley,
				Amount = amount,
				Type = (LiquidType)type,
			};
			LiquidSet.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerBuffUpdate event
		/// </summary>
		public class PlayerBuffUpdateEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte ID { get; set; }
		}
		/// <summary>
		/// PlayerBuffUpdate - Called when a player updates buffs
		/// </summary>
		public static HandlerList<PlayerBuffUpdateEventArgs> PlayerBuffUpdate = new HandlerList<PlayerBuffUpdateEventArgs>();
		private static bool OnPlayerBuffUpdate(TSPlayer player, MemoryStream data, byte id)
		{
			if (PlayerBuffUpdate == null)
				return false;

			var args = new PlayerBuffUpdateEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
			};
			PlayerBuffUpdate.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use with a NPCSpecial event
		/// </summary>
		public class NPCSpecialEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// ???
			/// </summary>
			public byte ID { get; set; }
			/// <summary>
			/// Type...?
			/// </summary>
			public byte Type { get; set; }
		}
		/// <summary>
		/// NPCSpecial - Called at some point
		/// </summary>
		public static HandlerList<NPCSpecialEventArgs> NPCSpecial = new HandlerList<NPCSpecialEventArgs>();
		private static bool OnNPCSpecial(TSPlayer player, MemoryStream data, byte id, byte type)
		{
			if (NPCSpecial == null)
				return false;

			var args = new NPCSpecialEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				Type = type,
			};
			NPCSpecial.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a NPCAddBuff event
		/// </summary>
		public class NPCAddBuffEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The ID of the npc
			/// </summary>
			public short ID { get; set; }
			/// <summary>
			/// Buff Type
			/// </summary>
			public int Type { get; set; }
			/// <summary>
			/// Time the buff lasts
			/// </summary>
			public short Time { get; set; }
		}
		/// <summary>
		/// NPCAddBuff - Called when a npc is buffed
		/// </summary>
		public static HandlerList<NPCAddBuffEventArgs> NPCAddBuff = new HandlerList<NPCAddBuffEventArgs>();
		private static bool OnNPCAddBuff(TSPlayer player, MemoryStream data, short id, int type, short time)
		{
			if (NPCAddBuff == null)
				return false;

			var args = new NPCAddBuffEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				Type = type,
				Time = time
			};
			NPCAddBuff.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerBuff event
		/// </summary>
		public class PlayerBuffEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte ID { get; set; }
			/// <summary>
			/// Buff Type
			/// </summary>
			public int Type { get; set; }
			/// <summary>
			/// Time the buff lasts
			/// </summary>
			public int Time { get; set; }
		}
		/// <summary>
		/// PlayerBuff - Called when a player is buffed
		/// </summary>
		public static HandlerList<PlayerBuffEventArgs> PlayerBuff = new HandlerList<PlayerBuffEventArgs>();
		private static bool OnPlayerBuff(TSPlayer player, MemoryStream data, byte id, int type, int time)
		{
			if (PlayerBuff == null)
				return false;

			var args = new PlayerBuffEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				Type = type,
				Time = time
			};
			PlayerBuff.Invoke(null, args);
			return args.Handled;
		}

		public enum HouseholdStatus : byte
		{
			None = 0,
			Homeless = 1,
			HasRoom = 2,
		}

		/// <summary>
		/// For use in a NPCHome event
		/// </summary>
		public class NPCHomeChangeEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public short ID { get; set; }
			/// <summary>
			/// X location of the NPC home change
			/// </summary>
			public short X { get; set; }
			/// <summary>
			/// Y location of the NPC home change
			/// </summary>
			public short Y { get; set; }
			/// <summary>
			/// HouseholdStatus of the NPC
			/// </summary>
			public HouseholdStatus HouseholdStatus { get; set; }
		}
		/// <summary>
		/// NPCHome - Called when an NPC's home is changed
		/// </summary>
		public static HandlerList<NPCHomeChangeEventArgs> NPCHome = new HandlerList<NPCHomeChangeEventArgs>();
		private static bool OnUpdateNPCHome(TSPlayer player, MemoryStream data, short id, short x, short y, byte houseHoldStatus)
		{
			if (NPCHome == null)
				return false;

			var args = new NPCHomeChangeEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				X = x,
				Y = y,
				HouseholdStatus = (HouseholdStatus)houseHoldStatus,
			};
			NPCHome.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use with a PaintTile event
		/// </summary>
		public class PaintTileEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// X Location
			/// </summary>
			public Int32 X { get; set; }
			/// <summary>
			/// Y Location
			/// </summary>
			public Int32 Y { get; set; }
			/// <summary>
			/// Type
			/// </summary>
			public byte type { get; set; }
			/// <summary>
			/// Paint Coat Tile
			/// </summary>
			public byte coatTile { get; set; }
		}
		/// <summary>
		/// NPCStrike - Called when an NPC is attacked
		/// </summary>
		public static HandlerList<PaintTileEventArgs> PaintTile = new HandlerList<PaintTileEventArgs>();
		private static bool OnPaintTile(TSPlayer player, MemoryStream data, Int32 x, Int32 y, byte t, byte ct)
		{
			if (PaintTile == null)
				return false;

			var args = new PaintTileEventArgs
			{
				Player = player,
				Data = data,
				X = x,
				Y = y,
				type = t,
				coatTile = ct
			};
			PaintTile.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use with a PaintWall event
		/// </summary>
		public class PaintWallEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// X Location
			/// </summary>
			public Int32 X { get; set; }
			/// <summary>
			/// Y Location
			/// </summary>
			public Int32 Y { get; set; }
			/// <summary>
			/// Type
			/// </summary>
			public byte type { get; set; }
			/// <summary>
			/// Paint Coat Wall
			/// </summary>
			public byte coatWall { get; set; }
		}
		/// <summary>
		/// Called When a wall is painted
		/// </summary>
		public static HandlerList<PaintWallEventArgs> PaintWall = new HandlerList<PaintWallEventArgs>();
		private static bool OnPaintWall(TSPlayer player, MemoryStream data, Int32 x, Int32 y, byte t, byte cw)
		{
			if (PaintWall == null)
				return false;

			var args = new PaintWallEventArgs
			{
				Player = player,
				Data = data,
				X = x,
				Y = y,
				type = t,
				coatWall = cw
			};
			PaintWall.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use with a NPCStrike event
		/// </summary>
		public class TeleportEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// ???
			/// </summary>
			public Int16 ID { get; set; }
			/// <summary>
			/// Flag is a bit field
			///   if the first bit is set -> 0 = player, 1 = NPC
			///	  if the second bit is set, ignore this packet
			///   if the third bit is set, "get extra info from target" is true
			///   if the fourth bit is set, extra information is valid to read
			/// </summary>
			public byte Flag { get; set; }
			/// <summary>
			/// X Location
			/// </summary>
			public float X { get; set; }
			/// <summary>
			/// Y Location
			/// </summary>
			public float Y { get; set; }
			/// <summary>
			/// Style
			/// </summary>
			public byte Style { get; set; }
			/// <summary>
			/// "Extra info"
			/// </summary>
			public int ExtraInfo { get; set; }
		}
		/// <summary>
		/// NPCStrike - Called when an NPC is attacked
		/// </summary>
		public static HandlerList<TeleportEventArgs> Teleport = new HandlerList<TeleportEventArgs>();
		private static bool OnTeleport(TSPlayer player, MemoryStream data, Int16 id, byte f, float x, float y, byte style, int extraInfo)
		{
			if (Teleport == null)
				return false;

			var args = new TeleportEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				Flag = f,
				X = x,
				Y = y,
				Style = style,
				ExtraInfo = extraInfo
			};
			Teleport.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>The event args object for the HealOtherPlayer event</summary>
		public class HealOtherPlayerEventArgs : GetDataHandledEventArgs
		{
			/// <summary>The Terraria player index of the target player</summary>
			public byte TargetPlayerIndex { get; set; }

			/// <summary>The amount to heal by</summary>
			public short Amount { get; set; }
		}
		/// <summary>When a player heals another player</summary>
		public static HandlerList<HealOtherPlayerEventArgs> HealOtherPlayer = new HandlerList<HealOtherPlayerEventArgs>();
		private static bool OnHealOtherPlayer(TSPlayer player, MemoryStream data, byte targetPlayerIndex, short amount)
		{
			if (HealOtherPlayer == null)
				return false;

			var args = new HealOtherPlayerEventArgs
			{
				Player = player,
				Data = data,
				TargetPlayerIndex = targetPlayerIndex,
				Amount = amount,
			};

			HealOtherPlayer.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// The ReleaseNPC event arguments
		/// </summary>
		public class ReleaseNpcEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The X value of where NPC released
			/// </summary>
			public int X { get; set; }

			/// <summary>
			/// The Y value of where NPC released
			/// </summary>
			public int Y { get; set; }

			/// <summary>
			/// The NPC Type that player release
			/// </summary>
			public short Type { get; set; }

			/// <summary>
			/// The NPC release style
			/// </summary>
			public byte Style { get; set; }
		}

		/// <summary>
		/// Called when player release a NPC, for checking critter released from item.
		/// </summary>
		public static HandlerList<ReleaseNpcEventArgs> ReleaseNPC = new HandlerList<ReleaseNpcEventArgs>();
		private static bool OnReleaseNpc(TSPlayer player, MemoryStream data, int _x, int _y, short _type, byte _style)
		{
			if (ReleaseNPC == null)
			{
				return false;
			}

			var args = new ReleaseNpcEventArgs
			{
				Player = player,
				Data = data,
				X = _x,
				Y = _y,
				Type = _type,
				Style = _style
			};
			ReleaseNPC.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>The arguments to the PlaceObject hook.</summary>
		public class PlaceObjectEventArgs : GetDataHandledEventArgs
		{
			/// <summary>The X location where the object was placed.</summary>
			public short X { get; set; }

			/// <summary>The Y location where the object was placed.</summary>
			public short Y { get; set; }

			/// <summary>The type of object that was placed.</summary>
			public short Type { get; set; }

			/// <summary>The style of the object was placed.</summary>
			public short Style { get; set; }

			/// <summary>Alternate variation of the object placed.</summary>
			public byte Alternate { get; set; }

			/// <summary>Related to Rubblemaker.</summary>
			public sbyte Random { get; set; }

			/// <summary>The direction the object was placed.</summary>
			public bool Direction { get; set; }
		}
		/// <summary>Fired when an object is placed in the world.</summary>
		public static HandlerList<PlaceObjectEventArgs> PlaceObject = new HandlerList<PlaceObjectEventArgs>();
		private static bool OnPlaceObject(TSPlayer player, MemoryStream data, short x, short y, short type, short style, byte alternate, sbyte random, bool direction)
		{
			if (PlaceObject == null)
				return false;

			var args = new PlaceObjectEventArgs
			{
				Player = player,
				Data = data,
				X = x,
				Y = y,
				Type = type,
				Style = style,
				Alternate = alternate,
				Random = random,
				Direction = direction
			};

			PlaceObject.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>For use in a PlaceTileEntity event.</summary>
		public class PlaceTileEntityEventArgs : GetDataHandledEventArgs
		{
			/// <summary>The X coordinate of the event.</summary>
			public short X { get; set; }

			/// <summary>The Y coordinate of the event.</summary>
			public short Y { get; set; }

			/// <summary>The Type of event.</summary>
			public byte Type { get; set; }
		}
		/// <summary>Fired when a PlaceTileEntity event occurs.</summary>
		public static HandlerList<PlaceTileEntityEventArgs> PlaceTileEntity = new HandlerList<PlaceTileEntityEventArgs>();
		private static bool OnPlaceTileEntity(TSPlayer player, MemoryStream data, short x, short y, byte type)
		{
			if (PlaceTileEntity == null)
				return false;

			var args = new PlaceTileEntityEventArgs
			{
				Player = player,
				Data = data,
				X = x,
				Y = y,
				Type = type
			};

			PlaceTileEntity.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>The arguments to the PlaceItemFrame event.</summary>
		public class PlaceItemFrameEventArgs : GetDataHandledEventArgs
		{
			/// <summary>The X coordinate of the item frame.</summary>
			public short X { get; set; }

			/// <summary>The Y coordinate of the item frame.</summary>
			public short Y { get; set; }

			/// <summary>The ItemID of the item frame.</summary>
			public short ItemID { get; set; }

			/// <summary>The prefix.</summary>
			public byte Prefix { get; set; }

			/// <summary>The stack.</summary>
			public short Stack { get; set; }

			/// <summary>The ItemFrame object associated with this event.</summary>
			public TEItemFrame ItemFrame { get; set; }
		}
		/// <summary>Fired when an ItemFrame is placed.</summary>
		public static HandlerList<PlaceItemFrameEventArgs> PlaceItemFrame = new HandlerList<PlaceItemFrameEventArgs>();
		private static bool OnPlaceItemFrame(TSPlayer player, MemoryStream data, short x, short y, short itemID, byte prefix, short stack, TEItemFrame itemFrame)
		{
			if (PlaceItemFrame == null)
				return false;

			var args = new PlaceItemFrameEventArgs
			{
				Player = player,
				Data = data,
				X = x,
				Y = y,
				ItemID = itemID,
				Prefix = prefix,
				Stack = stack,
				ItemFrame = itemFrame,
			};

			PlaceItemFrame.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>The event args object for the PortalTeleport event</summary>
		public class TeleportThroughPortalEventArgs : GetDataHandledEventArgs
		{
			/// <summary>The Terraria player index of the target player</summary>
			public byte TargetPlayerIndex { get; set; }

			/// <summary>
			/// The position the target player will be at after going through the portal
			/// </summary>
			public Vector2 NewPosition { get; set; }

			/// <summary>
			/// The velocity the target player will have after going through the portal
			/// </summary>
			public Vector2 NewVelocity { get; set; }

			/// <summary>
			/// Index of the portal's color (for use with <see cref="Terraria.GameContent.PortalHelper.GetPortalColor(int)"/>)
			/// </summary>
			public int PortalColorIndex { get; set; }
		}
		/// <summary>When a player passes through a portal</summary>
		public static HandlerList<TeleportThroughPortalEventArgs> PortalTeleport = new HandlerList<TeleportThroughPortalEventArgs>();
		private static bool OnPlayerTeleportThroughPortal(TSPlayer sender, byte targetPlayerIndex, MemoryStream data, Vector2 position, Vector2 velocity, int colorIndex)
		{
			TeleportThroughPortalEventArgs args = new TeleportThroughPortalEventArgs
			{
				TargetPlayerIndex = targetPlayerIndex,
				Data = data,
				Player = sender,
				NewPosition = position,
				NewVelocity = velocity,
				PortalColorIndex = colorIndex
			};

			PortalTeleport.Invoke(null, args);

			return args.Handled;
		}

		/// <summary>
		/// For use with a ToggleGemLock event
		/// </summary>
		public class GemLockToggleEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// X Location
			/// </summary>
			public short X { get; set; }
			/// <summary>
			/// Y Location
			/// </summary>
			public short Y { get; set; }
			/// <summary>
			/// On status
			/// </summary>
			public bool On { get; set; }
		}
		/// <summary>
		/// GemLockToggle - Called when a gem lock is switched
		/// </summary>
		public static HandlerList<GemLockToggleEventArgs> GemLockToggle = new HandlerList<GemLockToggleEventArgs>();
		private static bool OnGemLockToggle(TSPlayer player, MemoryStream data, short x, short y, bool on)
		{
			if (GemLockToggle == null)
				return false;

			var args = new GemLockToggleEventArgs
			{
				Player = player,
				Data = data,
				X = x,
				Y = y,
				On = on
			};
			GemLockToggle.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>The arguments to the MassWireOperation event.</summary>
		public class MassWireOperationEventArgs : GetDataHandledEventArgs
		{
			/// <summary>The start X point in the operation.</summary>
			public short StartX { get; set; }

			/// <summary>The start Y point in the operation.</summary>
			public short StartY { get; set; }

			/// <summary>The end X point in the operation.</summary>
			public short EndX { get; set; }

			/// <summary>The end Y point in the operation.</summary>
			public short EndY { get; set; }

			/// <summary>ToolMode</summary>
			public byte ToolMode { get; set; }
		}
		/// <summary>Fired on a mass wire edit operation.</summary>
		public static HandlerList<MassWireOperationEventArgs> MassWireOperation = new HandlerList<MassWireOperationEventArgs>();
		private static bool OnMassWireOperation(TSPlayer player, MemoryStream data, short startX, short startY, short endX, short endY, byte toolMode)
		{
			if (MassWireOperation == null)
				return false;

			var args = new MassWireOperationEventArgs
			{
				Player = player,
				Data = data,
				StartX = startX,
				StartY = startY,
				EndX = endX,
				EndY = endY,
				ToolMode = toolMode,
			};

			MassWireOperation.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a PlayerDamage event
		/// </summary>
		public class PlayerDamageEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte ID { get; set; }
			/// <summary>
			/// The direction the damage is occurring from
			/// </summary>
			public byte Direction { get; set; }
			/// <summary>
			/// Amount of damage
			/// </summary>
			public short Damage { get; set; }
			/// <summary>
			/// If the player has PVP on
			/// </summary>
			public bool PVP { get; set; }
			/// <summary>
			/// Is the damage critical?
			/// </summary>
			public bool Critical { get; set; }
			/// <summary>
			/// Cooldown Counter
			/// </summary>
			public sbyte CooldownCounter { get; set; }
			/// <summary>The reason the player took damage and/or died.</summary>
			public PlayerDeathReason PlayerDeathReason { get; set; }
		}
		/// <summary>
		/// PlayerDamage - Called when a player is damaged
		/// </summary>
		public static HandlerList<PlayerDamageEventArgs> PlayerDamage = new HandlerList<PlayerDamageEventArgs>();
		private static bool OnPlayerDamage(TSPlayer player, MemoryStream data, byte id, byte dir, short dmg, bool pvp, bool crit, sbyte cooldownCounter, PlayerDeathReason playerDeathReason)
		{
			if (PlayerDamage == null)
				return false;

			var args = new PlayerDamageEventArgs
			{
				Player = player,
				Data = data,
				ID = id,
				Direction = dir,
				Damage = dmg,
				PVP = pvp,
				Critical = crit,
				CooldownCounter = cooldownCounter,
				PlayerDeathReason = playerDeathReason,
			};
			PlayerDamage.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a KillMe event
		/// </summary>
		public class KillMeEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The Terraria playerID of the player
			/// </summary>
			public byte PlayerId { get; set; }
			/// <summary>
			/// The direction the damage is coming from (?)
			/// </summary>
			public byte Direction { get; set; }
			/// <summary>
			/// Amount of damage dealt
			/// </summary>
			public short Damage { get; set; }
			/// <summary>
			/// Player's current pvp setting
			/// </summary>
			public bool Pvp { get; set; }
			/// <summary>The reason the player died.</summary>
			public PlayerDeathReason PlayerDeathReason { get; set; }
		}
		/// <summary>
		/// KillMe - Terraria's crappy way of handling damage from players
		/// </summary>
		public static HandlerList<KillMeEventArgs> KillMe = new HandlerList<KillMeEventArgs>();
		private static bool OnKillMe(TSPlayer player, MemoryStream data, byte plr, byte direction, short damage, bool pvp, PlayerDeathReason playerDeathReason)
		{
			if (KillMe == null)
				return false;

			var args = new KillMeEventArgs
			{
				Player = player,
				Data = data,
				PlayerId = plr,
				Direction = direction,
				Damage = damage,
				Pvp = pvp,
				PlayerDeathReason = playerDeathReason,
			};
			KillMe.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in an Emoji event.
		/// </summary>
		public class EmojiEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The player index in the packet, who sends the emoji.
			/// </summary>
			public byte PlayerIndex { get; set; }
			/// <summary>
			/// The ID of the emoji, that is being received.
			/// </summary>
			public byte EmojiID { get; set; }
		}
		/// <summary>
		/// Called when a player sends an emoji.
		/// </summary>
		public static HandlerList<EmojiEventArgs> Emoji = new HandlerList<EmojiEventArgs>();
		private static bool OnEmoji(TSPlayer player, MemoryStream data, byte playerIndex, byte emojiID)
		{
			if (Emoji == null)
				return false;

			var args = new EmojiEventArgs
			{
				Player = player,
				Data = data,
				PlayerIndex = playerIndex,
				EmojiID = emojiID
			};
			Emoji.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a TileEntityDisplayDollItemSync event.
		/// </summary>
		public class DisplayDollItemSyncEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The player index in the packet who modifies the DisplayDoll item slot.
			/// </summary>
			public byte PlayerIndex { get; set; }
			/// <summary>
			/// The ID of the TileEntity that is being modified.
			/// </summary>
			public int TileEntityID { get; set; }
			/// <summary>
			/// The TEDisplayDoll object that is being modified.
			/// </summary>
			public TEDisplayDoll DisplayDollEntity { get; set; }
			/// <summary>
			/// The slot of the DisplayDoll that is being modified.
			/// </summary>
			public int Slot { get; set; }
			/// <summary>
			/// Whether or not the slot that is being modified is a Dye slot.
			/// </summary>
			public bool IsDye { get; set; }
			/// <summary>
			/// The current item that is present in the slot before the modification.
			/// </summary>
			public Item OldItem { get; set; }
			/// <summary>
			/// The item that is about to replace the OldItem in the slot that is being modified.
			/// </summary>
			public Item NewItem { get; set; }
		}
		/// <summary>
		/// Called when a player modifies a DisplayDoll (Mannequin) item slot.
		/// </summary>
		public static HandlerList<DisplayDollItemSyncEventArgs> DisplayDollItemSync = new HandlerList<DisplayDollItemSyncEventArgs>();
		private static bool OnDisplayDollItemSync(TSPlayer player, MemoryStream data, byte playerIndex, int tileEntityID, TEDisplayDoll displayDollEntity, int slot, bool isDye, Item oldItem, Item newItem)
		{
			if (DisplayDollItemSync == null)
				return false;

			var args = new DisplayDollItemSyncEventArgs
			{
				Player = player,
				Data = data,
				PlayerIndex = playerIndex,
				TileEntityID = tileEntityID,
				DisplayDollEntity = displayDollEntity,
				Slot = slot,
				IsDye = isDye,
				OldItem = oldItem,
				NewItem = newItem
			};
			DisplayDollItemSync.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in an OnRequestTileEntityInteraction event.
		/// </summary>
		public class RequestTileEntityInteractionEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The TileEntity object that the player is requesting interaction with.
			/// </summary>
			public TileEntity TileEntity { get; set; }
			/// <summary>
			/// The player index in the packet who requests interaction with the TileEntity.
			/// </summary>
			public byte PlayerIndex { get; set; }
		}
		/// <summary>
		/// Called when a player requests interaction with a TileEntity.
		/// </summary>
		public static HandlerList<RequestTileEntityInteractionEventArgs> RequestTileEntityInteraction = new HandlerList<RequestTileEntityInteractionEventArgs>();
		private static bool OnRequestTileEntityInteraction(TSPlayer player, MemoryStream data, TileEntity tileEntity, byte playerIndex)
		{
			if (RequestTileEntityInteraction == null)
				return false;

			var args = new RequestTileEntityInteractionEventArgs
			{
				Player = player,
				Data = data,
				PlayerIndex = playerIndex,
				TileEntity = tileEntity
			};
			RequestTileEntityInteraction.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a SyncTilePicking event.
		/// </summary>
		public class SyncTilePickingEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The player index in the packet, who sends the tile picking data.
			/// </summary>
			public byte PlayerIndex { get; set; }
			/// <summary>
			/// The X world position of the tile that is being picked.
			/// </summary>
			public short TileX { get; set; }
			/// <summary>
			/// The Y world position of the tile that is being picked.
			/// </summary>
			public short TileY { get; set; }
			/// <summary>
			/// The damage that is being dealt on the tile.
			/// </summary>
			public byte TileDamage { get; set; }
		}
		/// <summary>
		/// Called when a player hits and damages a tile.
		/// </summary>
		public static HandlerList<SyncTilePickingEventArgs> SyncTilePicking = new HandlerList<SyncTilePickingEventArgs>();
		private static bool OnSyncTilePicking(TSPlayer player, MemoryStream data, byte playerIndex, short tileX, short tileY, byte tileDamage)
		{
			if (SyncTilePicking == null)
				return false;

			var args = new SyncTilePickingEventArgs
			{
				Player = player,
				PlayerIndex = playerIndex,
				TileX = tileX,
				TileY = tileY,
				TileDamage = tileDamage
			};
			SyncTilePicking.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a LandBallInCup event.
		/// </summary>
		public class LandGolfBallInCupEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The player index in the packet, who puts the ball in the cup.
			/// </summary>
			public byte PlayerIndex { get; set; }
			/// <summary>
			/// The X tile position of where the ball lands in a cup.
			/// </summary>
			public ushort TileX { get; set; }
			/// <summary>
			/// The Y tile position of where the ball lands in a cup.
			/// </summary>
			public ushort TileY { get; set; }
			/// <summary>
			/// The amount of hits it took for the player to land the ball in the cup.
			/// </summary>
			public ushort Hits { get; set; }
			/// <summary>
			/// The type of the projectile that was landed in the cup. A golfball in legit cases.
			/// </summary>
			public ushort ProjectileType { get; set; }
		}

		/// <summary>
		/// Called when a player lands a golf ball in a cup.
		/// </summary>
		public static HandlerList<LandGolfBallInCupEventArgs> LandGolfBallInCup = new HandlerList<LandGolfBallInCupEventArgs>();
		private static bool OnLandGolfBallInCup(TSPlayer player, MemoryStream data, byte playerIndex, ushort tileX, ushort tileY, ushort hits, ushort projectileType)
		{
			if (LandGolfBallInCup == null)
				return false;

			var args = new LandGolfBallInCupEventArgs
			{
				Player = player,
				Data = data,
				PlayerIndex = playerIndex,
				TileX = tileX,
				TileY = tileY,
				Hits = hits,
				ProjectileType = projectileType
			};
			LandGolfBallInCup.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// For use in a FishOutNPC event.
		/// </summary>
		public class FishOutNPCEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The X world position of the spawning NPC.
			/// </summary>
			public ushort TileX { get; set; }
			/// <summary>
			/// The Y world position of the spawning NPC.
			/// </summary>
			public ushort TileY { get; set; }
			/// <summary>
			/// The NPC type that is being spawned.
			/// </summary>
			public short NpcID { get; set; }
		}
		/// <summary>
		/// Called when a player fishes out an NPC.
		/// </summary>
		public static HandlerList<FishOutNPCEventArgs> FishOutNPC = new HandlerList<FishOutNPCEventArgs>();
		private static bool OnFishOutNPC(TSPlayer player, MemoryStream data, ushort tileX, ushort tileY, short npcID)
		{
			if (FishOutNPC == null)
				return false;

			var args = new FishOutNPCEventArgs
			{
				Player = player,
				Data = data,
				TileX = tileX,
				TileY = tileY,
				NpcID = npcID
			};
			FishOutNPC.Invoke(null, args);
			return args.Handled;
		}

		public class FoodPlatterTryPlacingEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The X tile position of the placement action.
			/// </summary>
			public short TileX { get; set; }
			/// <summary>
			/// The Y tile position of the placement action.
			/// </summary>
			public short TileY { get; set; }
			/// <summary>
			/// The Item ID that is being placed in the plate.
			/// </summary>
			public short ItemID { get; set; }
			/// <summary>
			/// The prefix of the item that is being placed in the plate.
			/// </summary>
			public byte Prefix { get; set; }
			/// <summary>
			/// The stack of the item that is being placed in the plate.
			/// </summary>
			public short Stack { get; set; }
		}
		/// <summary>
		/// Called when a player is placing an item in a food plate.
		/// </summary>
		public static HandlerList<FoodPlatterTryPlacingEventArgs> FoodPlatterTryPlacing = new HandlerList<FoodPlatterTryPlacingEventArgs>();
		private static bool OnFoodPlatterTryPlacing(TSPlayer player, MemoryStream data, short tileX, short tileY, short itemID, byte prefix, short stack)
		{
			if (FoodPlatterTryPlacing == null)
				return false;

			var args = new FoodPlatterTryPlacingEventArgs
			{
				Player = player,
				Data = data,
				TileX = tileX,
				TileY = tileY,
				ItemID = itemID,
				Prefix = prefix,
				Stack = stack,
			};
			FoodPlatterTryPlacing.Invoke(null, args);
			return args.Handled;
		}

		/// <summary>
		/// Used when a net module is loaded
		/// </summary>
		public class ReadNetModuleEventArgs : GetDataHandledEventArgs
		{
			/// <summary>
			/// The type of net module being loaded
			/// </summary>
			public NetModuleType ModuleType { get; set; }
		}

		/// <summary>
		/// Called when a net module is received
		/// </summary>
		public static HandlerList<ReadNetModuleEventArgs> ReadNetModule = new HandlerList<ReadNetModuleEventArgs>();

		private static bool OnReadNetModule(TSPlayer player, MemoryStream data, NetModuleType moduleType)
		{
			if (ReadNetModule == null)
			{
				return false;
			}

			var args = new ReadNetModuleEventArgs
			{
				Player = player,
				Data = data,
				ModuleType = moduleType
			};

			ReadNetModule.Invoke(null, args);
			return args.Handled;
		}

		#endregion

		private static bool HandlePlayerInfo(GetDataHandlerArgs args)
		{
			byte playerid = args.Data.ReadInt8();
			// 0-3 male; 4-7 female
			int skinVariant = args.Data.ReadByte();
			var hair = args.Data.ReadInt8();
			string name = args.Data.ReadString();
			byte hairDye = args.Data.ReadInt8();

			BitsByte hideVisual = args.Data.ReadInt8();
			BitsByte hideVisual2 = args.Data.ReadInt8();
			BitsByte hideMisc = args.Data.ReadInt8();

			Color hairColor = new Color(args.Data.ReadInt8(), args.Data.ReadInt8(), args.Data.ReadInt8());
			Color skinColor = new Color(args.Data.ReadInt8(), args.Data.ReadInt8(), args.Data.ReadInt8());
			Color eyeColor = new Color(args.Data.ReadInt8(), args.Data.ReadInt8(), args.Data.ReadInt8());
			Color shirtColor = new Color(args.Data.ReadInt8(), args.Data.ReadInt8(), args.Data.ReadInt8());
			Color underShirtColor = new Color(args.Data.ReadInt8(), args.Data.ReadInt8(), args.Data.ReadInt8());
			Color pantsColor = new Color(args.Data.ReadInt8(), args.Data.ReadInt8(), args.Data.ReadInt8());
			Color shoeColor = new Color(args.Data.ReadInt8(), args.Data.ReadInt8(), args.Data.ReadInt8());

			BitsByte extra = args.Data.ReadInt8();
			byte difficulty = 0;
			if (extra[0])
			{
				difficulty = 1;
			}
			else if (extra[1])
			{
				difficulty = 2;
			}
			else if (extra[3])
			{
				difficulty = 3;
			}
			bool extraSlot = extra[2];
			BitsByte torchFlags = args.Data.ReadInt8();
			bool usingBiomeTorches = torchFlags[0];
			bool happyFunTorchTime = torchFlags[1];
			bool unlockedBiomeTorches = torchFlags[2];
			bool unlockedSuperCart = torchFlags[3];
			bool enabledSuperCart = torchFlags[4];
			BitsByte bitsByte10 = args.Data.ReadInt8();
			bool usedAegisCrystal = bitsByte10[0];
			bool usedAegisFruit = bitsByte10[1];
			bool usedArcaneCrystal = bitsByte10[2];
			bool usedGalaxyPearl = bitsByte10[3];
			bool usedGummyWorm = bitsByte10[4];
			bool usedAmbrosia = bitsByte10[5];
			bool ateArtisanBread = bitsByte10[6];

			if (OnPlayerInfo(args.Player, args.Data, playerid, hair, skinVariant, difficulty, name))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerInfo rejected plugin phase {0}", name));
				args.Player.Kick(GetString("A plugin on this server stopped your login."), true, true);
				return true;
			}

			if (name.Trim().Length == 0)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerInfo rejected name length 0"));
				args.Player.Kick(GetString("You have been Bounced."), true, true);
				return true;
			}

			if (name.Trim().StartsWith("tsi:") || name.Trim().StartsWith("tsn:"))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / rejecting player for name prefix starting with tsi: or tsn:."));
				args.Player.Kick(GetString("Illegal name: prefixes tsi: and tsn: are forbidden."), true, true);
				return true;
			}

			if (args.Player.ReceivedInfo)
			{
				// Since Terraria 1.2.3 these character properties can change ingame.
				args.Player.TPlayer.hair = hair;
				args.Player.TPlayer.hairColor = hairColor;
				args.Player.TPlayer.hairDye = hairDye;
				args.Player.TPlayer.skinVariant = skinVariant;
				args.Player.TPlayer.skinColor = skinColor;
				args.Player.TPlayer.eyeColor = eyeColor;
				args.Player.TPlayer.pantsColor = pantsColor;
				args.Player.TPlayer.shirtColor = shirtColor;
				args.Player.TPlayer.underShirtColor = underShirtColor;
				args.Player.TPlayer.shoeColor = shoeColor;
				//@Olink: If you need to change bool[10], please make sure you also update the for loops below to account for it.
				//There are two arrays from terraria that we only have a single array for.  You will need to make sure that you are looking
				//at the correct terraria array (hideVisual or hideVisual2).
				args.Player.TPlayer.hideVisibleAccessory = new bool[10];
				for (int i = 0; i < 8; i++)
					args.Player.TPlayer.hideVisibleAccessory[i] = hideVisual[i];
				for (int i = 0; i < 2; i++)
					args.Player.TPlayer.hideVisibleAccessory[i + 8] = hideVisual2[i];
				args.Player.TPlayer.hideMisc = hideMisc;
				args.Player.TPlayer.extraAccessory = extraSlot;
				args.Player.TPlayer.UsingBiomeTorches = usingBiomeTorches;
				args.Player.TPlayer.happyFunTorchTime = happyFunTorchTime;
				args.Player.TPlayer.unlockedBiomeTorches = unlockedBiomeTorches;
				args.Player.TPlayer.ateArtisanBread = ateArtisanBread;
				args.Player.TPlayer.usedAegisCrystal = usedAegisCrystal;
				args.Player.TPlayer.usedAegisFruit = usedAegisFruit;
				args.Player.TPlayer.usedArcaneCrystal = usedArcaneCrystal;
				args.Player.TPlayer.usedGalaxyPearl = usedGalaxyPearl;
				args.Player.TPlayer.usedGummyWorm = usedGummyWorm;
				args.Player.TPlayer.usedAmbrosia = usedAmbrosia;
				args.Player.TPlayer.unlockedSuperCart = unlockedSuperCart;
				args.Player.TPlayer.enabledSuperCart = enabledSuperCart;

				NetMessage.SendData((int)PacketTypes.PlayerInfo, -1, args.Player.Index, NetworkText.FromLiteral(args.Player.Name), args.Player.Index);
				return true;
			}
			if (TShock.Config.Settings.SoftcoreOnly && difficulty != 0)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerInfo rejected softcore required"));
				args.Player.Kick(GetString("You need to join with a softcore player."), true, true);
				return true;
			}
			if (TShock.Config.Settings.MediumcoreOnly && difficulty < 1)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerInfo rejected mediumcore required"));
				args.Player.Kick(GetString("You need to join with a mediumcore player or higher."), true, true);
				return true;
			}
			if (TShock.Config.Settings.HardcoreOnly && difficulty < 2)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerInfo rejected hardcore required"));
				args.Player.Kick(GetString("You need to join with a hardcore player."), true, true);
				return true;
			}
			args.Player.Difficulty = difficulty;
			args.TPlayer.name = name;
			args.Player.ReceivedInfo = true;

			return false;
		}

		private static bool HandlePlayerSlot(GetDataHandlerArgs args)
		{
			byte plr = args.Data.ReadInt8();
			short slot = args.Data.ReadInt16();
			short stack = args.Data.ReadInt16();
			byte prefix = args.Data.ReadInt8();
			short type = args.Data.ReadInt16();

			// Players send a slot update packet for each inventory slot right after they've joined.
			bool bypassTrashCanCheck = false;
			if (plr == args.Player.Index && !args.Player.HasSentInventory && slot == NetItem.MaxInventory)
			{
				args.Player.HasSentInventory = true;
				bypassTrashCanCheck = true;
			}

			if (OnPlayerSlot(args.Player, args.Data, plr, slot, stack, prefix, type) || plr != args.Player.Index || slot < 0 ||
				slot > NetItem.MaxInventory)
				return true;
			if (args.Player.IgnoreSSCPackets)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerSlot rejected ignore ssc packets"));
				args.Player.SendData(PacketTypes.PlayerSlot, "", args.Player.Index, slot, prefix);
				return true;
			}

			// Garabage? Or will it cause some internal initialization or whatever?
			var item = new Item();
			item.netDefaults(type);
			item.Prefix(prefix);

			if (args.Player.IsLoggedIn)
			{
				args.Player.PlayerData.StoreSlot(slot, type, prefix, stack);
			}
			else if (Main.ServerSideCharacter && TShock.Config.Settings.DisableLoginBeforeJoin && !bypassTrashCanCheck &&
					 args.Player.HasSentInventory && !args.Player.HasPermission(Permissions.bypassssc))
			{
				// The player might have moved an item to their trash can before they performed a single login attempt yet.
				args.Player.IsDisabledPendingTrashRemoval = true;
			}

			if (slot == 58) //this is the hand
			{
				item.stack = stack;
				args.Player.ItemInHand = item;
			}

			return false;
		}

		private static bool HandleConnecting(GetDataHandlerArgs args)
		{
			var account = TShock.UserAccounts.GetUserAccountByName(args.Player.Name);
			args.Player.DataWhenJoined = new PlayerData(false);
			args.Player.DataWhenJoined.CopyCharacter(args.Player);
			args.Player.PlayerData = new PlayerData(false);
			args.Player.PlayerData.CopyCharacter(args.Player);

			if (account != null && !TShock.Config.Settings.DisableUUIDLogin)
			{
				if (account.UUID == args.Player.UUID)
				{
					if (args.Player.State == (int)ConnectionState.AssigningPlayerSlot)
						args.Player.State = (int)ConnectionState.AwaitingPlayerInfo;

					NetMessage.SendData((int)PacketTypes.WorldInfo, args.Player.Index);

					var group = TShock.Groups.GetGroupByName(account.Group);

					if (!TShock.Groups.AssertGroupValid(args.Player, group, true))
						return true;

					args.Player.PlayerData = TShock.CharacterDB.GetPlayerData(args.Player, account.ID);

					args.Player.Group = group;
					args.Player.tempGroup = null;
					args.Player.Account = account;
					args.Player.IsLoggedIn = true;
					args.Player.IsDisabledForSSC = false;

					if (Main.ServerSideCharacter)
					{
						if (args.Player.HasPermission(Permissions.bypassssc))
						{
							if (args.Player.PlayerData.exists && TShock.ServerSideCharacterConfig.Settings.WarnPlayersAboutBypassPermission)
							{
								args.Player.SendWarningMessage(GetString("Bypass SSC is enabled for your account. SSC data will not be loaded or saved."));
								TShock.Log.ConsoleInfo(GetString($"{args.Player.Name} has SSC data in the database, but has the tshock.ignore.ssc permission. This means their SSC data is being ignored."));
								TShock.Log.ConsoleInfo(GetString("You may wish to consider removing the tshock.ignore.ssc permission or negating it for this player."));
							}
							args.Player.PlayerData.CopyCharacter(args.Player);
							TShock.CharacterDB.InsertPlayerData(args.Player);
						}
						args.Player.PlayerData.RestoreCharacter(args.Player);
					}
					args.Player.LoginFailsBySsi = false;

					if (args.Player.HasPermission(Permissions.ignorestackhackdetection))
						args.Player.IsDisabledForStackDetection = false;

					if (args.Player.HasPermission(Permissions.usebanneditem))
						args.Player.IsDisabledForBannedWearable = false;

					args.Player.SendSuccessMessage(GetString($"Authenticated as {account.Name} successfully."));
					TShock.Log.ConsoleInfo(GetString($"{args.Player.Name} authenticated successfully as user {args.Player.Name}."));
					Hooks.PlayerHooks.OnPlayerPostLogin(args.Player);
					return true;
				}
			}
			else if (account != null && !TShock.Config.Settings.DisableLoginBeforeJoin)
			{
				args.Player.RequiresPassword = true;
				NetMessage.SendData((int)PacketTypes.PasswordRequired, args.Player.Index);
				return true;
			}
			else if (!string.IsNullOrEmpty(TShock.Config.Settings.ServerPassword))
			{
				args.Player.RequiresPassword = true;
				NetMessage.SendData((int)PacketTypes.PasswordRequired, args.Player.Index);
				return true;
			}

			if (args.Player.State == (int)ConnectionState.AssigningPlayerSlot)
				args.Player.State = (int)ConnectionState.AwaitingPlayerInfo;

			NetMessage.SendData((int)PacketTypes.WorldInfo, args.Player.Index);
			return true;
		}

		private static bool HandleGetSection(GetDataHandlerArgs args)
		{
			if (OnGetSection(args.Player, args.Data, args.Data.ReadInt32(), args.Data.ReadInt32()))
				return true;

			if (TShock.Utils.GetActivePlayerCount() + 1 > TShock.Config.Settings.MaxSlots &&
				!args.Player.HasPermission(Permissions.reservedslot))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleGetSection rejected reserve slot"));
				args.Player.Kick(TShock.Config.Settings.ServerFullReason, true, true);
				return true;
			}

			NetMessage.SendData((int)PacketTypes.TimeSet, -1, -1, NetworkText.Empty, Main.dayTime ? 1 : 0, (int)Main.time, Main.sunModY, Main.moonModY);
			return false;
		}

		private static bool HandleSpawn(GetDataHandlerArgs args)
		{
			if (args.Player.Dead && args.Player.RespawnTimer > 0)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSpawn rejected dead player spawn request {0}", args.Player.Name));
				return true;
			}

			byte player = args.Data.ReadInt8();
			short spawnX = args.Data.ReadInt16();
			short spawnY = args.Data.ReadInt16();
			int respawnTimer = args.Data.ReadInt32();
			short numberOfDeathsPVE = args.Data.ReadInt16();
			short numberOfDeathsPVP = args.Data.ReadInt16();
			PlayerSpawnContext context = (PlayerSpawnContext)args.Data.ReadByte();

			if (args.Player.State >= (int)ConnectionState.RequestingWorldData && !args.Player.FinishedHandshake)
				args.Player.FinishedHandshake = true; //If the player has requested world data before sending spawn player, they should be at the obvious ClientRequestedWorldData state. Also only set this once to remove redundant updates.

			if (OnPlayerSpawn(args.Player, args.Data, player, spawnX, spawnY, respawnTimer, numberOfDeathsPVE, numberOfDeathsPVP, context))
				return true;
			
			args.Player.Dead = respawnTimer > 0;

			if (Main.ServerSideCharacter)
			{
				// As long as the player has not changed his spawnpoint since initial connection,
				// we should not use the client's spawnpoint value. This is because the spawnpoint 
				// value is not saved on the client when SSC is enabled. Hence, we have to assert 
				// the server-saved spawnpoint value until we can detect that the player has changed 
				// his spawn. Once we detect the spawnpoint changed, the client's spawnpoint value
				// becomes the correct one to use.
				//
				// Note that spawnpoint changes (right-clicking beds) are not broadcasted to the 
				// server. Hence, the only way to detect spawnpoint changes is from the 
				// PlayerSpawn packet.

				// handle initial connection
				if (args.Player.State == 3)
				{
					// server saved spawnpoint value
					args.Player.initialSpawn = true;
					args.Player.initialServerSpawnX = args.TPlayer.SpawnX;
					args.Player.initialServerSpawnY = args.TPlayer.SpawnY;

					// initial client spawn point, do not use this to spawn the player
					// we only use it to detect if the spawnpoint has changed during this session
					args.Player.initialClientSpawnX = spawnX;
					args.Player.initialClientSpawnY = spawnY;

					// we first let the game handle completing the connection (state 3 => 10), 
					// then we will spawn the player at the saved spawnpoint in the next second, 
					// by reasserting the correct spawnpoint value
					return false;
				}

				// once we detect the client has changed his spawnpoint in the current session, 
				// the client spawnpoint value will be correct for the rest of the session
				if (args.Player.spawnSynced || args.Player.initialClientSpawnX != spawnX || args.Player.initialClientSpawnY != spawnY)
				{
					// Player has changed his spawnpoint, client and server TPlayer.Spawn{X,Y} is now synced
					args.Player.spawnSynced = true;
					return false;
				}

				// spawn the player before teleporting
				NetMessage.SendData((int)PacketTypes.PlayerSpawn, -1, args.Player.Index, null, args.Player.Index, (int)PlayerSpawnContext.ReviveFromDeath);

				// the player has not changed his spawnpoint yet, so we assert the server-saved spawnpoint 
				// by teleporting the player instead of letting the game use the client's incorrect spawnpoint.
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSpawn force ssc teleport for {0} at ({1},{2})", args.Player.Name, args.TPlayer.SpawnX, args.TPlayer.SpawnY));
				args.Player.TeleportSpawnpoint();
				
				args.TPlayer.respawnTimer = respawnTimer;
				args.TPlayer.numberOfDeathsPVE = numberOfDeathsPVE;
				args.TPlayer.numberOfDeathsPVP = numberOfDeathsPVP;
				return true;
			}
			return false;
		}

		private static bool HandlePlayerUpdate(GetDataHandlerArgs args)
		{
			if (args.Player == null || args.TPlayer == null || args.Data == null)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / OnPlayerUpdate rejected from null player."));
				return true;
			}

			byte playerID = args.Data.ReadInt8();
			ControlSet controls = new ControlSet((BitsByte)args.Data.ReadByte());
			MiscDataSet1 miscData1 = new MiscDataSet1((BitsByte)args.Data.ReadByte());
			MiscDataSet2 miscData2 = new MiscDataSet2((BitsByte)args.Data.ReadByte());
			MiscDataSet3 miscData3 = new MiscDataSet3((BitsByte)args.Data.ReadByte());
			byte selectedItem = args.Data.ReadInt8();
			Vector2 position = args.Data.ReadVector2();

			Vector2 velocity = Vector2.Zero;
			if (miscData1.HasVelocity)
				velocity = args.Data.ReadVector2();

			Vector2? originalPosition = new Vector2?();
			Vector2? homePosition = Vector2.Zero;
			if (miscData2.CanReturnWithPotionOfReturn)
			{
				originalPosition = new Vector2?(args.Data.ReadVector2());
				homePosition = new Vector2?(args.Data.ReadVector2());
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerUpdate home position delta {0}", args.Player.Name));
			}

			if (OnPlayerUpdate(args.Player, args.Data, playerID, controls, miscData1, miscData2, miscData3, selectedItem, position, velocity, originalPosition, homePosition))
				return true;

			return false;
		}

		private static bool HandlePlayerHp(GetDataHandlerArgs args)
		{
			var plr = args.Data.ReadInt8();
			var cur = args.Data.ReadInt16();
			var max = args.Data.ReadInt16();

			if (OnPlayerHP(args.Player, args.Data, plr, cur, max) || cur <= 0 || max <= 0 || args.Player.IgnoreSSCPackets)
				return true;

			if (max > TShock.Config.Settings.MaxHP && !args.Player.HasPermission(Permissions.ignorehp))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerHp rejected over max hp {0}", args.Player.Name));
				args.Player.Disable("Maximum HP beyond limit", DisableFlags.WriteToLogAndConsole);
				return true;
			}

			if (args.Player.IsLoggedIn)
			{
				args.Player.TPlayer.statLife = cur;
				args.Player.TPlayer.statLifeMax = max;
				args.Player.PlayerData.maxHealth = max;
			}

			return false;
		}

		private static bool HandleTile(GetDataHandlerArgs args)
		{
			EditAction action = (EditAction)args.Data.ReadInt8();
			short tileX = args.Data.ReadInt16();
			short tileY = args.Data.ReadInt16();
			short editData = args.Data.ReadInt16();
			EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||
							 action == EditAction.KillTileNoItem || action == EditAction.TryKillTile)
				? EditType.Fail
				: (action == EditAction.PlaceTile || action == EditAction.PlaceWall || action == EditAction.ReplaceTile || action == EditAction.ReplaceWall)
					? EditType.Type
					: EditType.Slope;

			byte style = args.Data.ReadInt8();

			if (OnTileEdit(args.Player, args.Data, tileX, tileY, action, type, editData, style))
				return true;

			return false;
		}

		private static bool HandleDoorUse(GetDataHandlerArgs args)
		{
			byte action = (byte)args.Data.ReadByte();
			short x = args.Data.ReadInt16();
			short y = args.Data.ReadInt16();
			byte direction = (byte)args.Data.ReadByte();

			DoorAction doorAction = (DoorAction)action;

			if (OnDoorUse(args.Player, args.Data, x, y, direction, doorAction))
				return true;

			ushort tileType = Main.tile[x, y].type;

			if (x >= Main.maxTilesX || y >= Main.maxTilesY || x < 0 || y < 0) // Check for out of range
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleDoorUse rejected out of range door {0}", args.Player.Name));
				return true;
			}

			if (action < 0 || action > 5)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleDoorUse rejected type 0 5 check {0}", args.Player.Name));
				return true;
			}


			if (tileType != TileID.ClosedDoor && tileType != TileID.OpenDoor
											  && tileType != TileID.TallGateClosed && tileType != TileID.TallGateOpen
											  && tileType != TileID.TrapdoorClosed && tileType != TileID.TrapdoorOpen)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleDoorUse rejected door gap check {0}", args.Player.Name));
				return true;
			}

			return false;
		}

		private static bool HandleSendTileRect(GetDataHandlerArgs args)
		{
			var player = args.Player;

			var tileX = args.Data.ReadInt16();
			var tileY = args.Data.ReadInt16();
			var width = (byte)args.Data.ReadByte();
			var length = (byte)args.Data.ReadByte();

			var changeByte = (byte)args.Data.ReadByte();
			var changeType = TileChangeType.None;
			if (Enum.IsDefined(typeof(TileChangeType), changeByte))
			{
				changeType = (TileChangeType)changeByte;
			}

			var data = args.Data;

			if (OnSendTileRect(player, data, tileX, tileY, width, length, changeType))
				return true;

			return false;
		}

		private static bool HandleItemDrop(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt16();
			var pos = new Vector2(args.Data.ReadSingle(), args.Data.ReadSingle());
			var vel = new Vector2(args.Data.ReadSingle(), args.Data.ReadSingle());
			var stacks = args.Data.ReadInt16();
			var prefix = args.Data.ReadInt8();
			var noDelay = args.Data.ReadInt8() == 1;
			var type = args.Data.ReadInt16();

			if (OnItemDrop(args.Player, args.Data, id, pos, vel, stacks, prefix, noDelay, type))
				return true;

			return false;
		}

		private static bool HandleItemOwner(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt16();
			var owner = args.Data.ReadInt8();

			if (id < 0 || id > 400)
				return true;

			if (id == 400 && owner == 255)
			{
				args.Player.IgnoreSSCPackets = false;
				return true;
			}

			return false;
		}

		private static bool HandleNpcItemStrike(GetDataHandlerArgs args)
		{
			// Never sent by vanilla client, ignore this
			TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleNpcItemStrike surprise packet! Someone tell the TShock team! {0}", args.Player.Name));
			return true;
		}

		private static bool HandleProjectileNew(GetDataHandlerArgs args)
		{
			short ident = args.Data.ReadInt16();
			Vector2 pos = args.Data.ReadVector2();
			Vector2 vel = args.Data.ReadVector2();
			byte owner = args.Data.ReadInt8();
			short type = args.Data.ReadInt16();
			BitsByte bitsByte = (BitsByte)args.Data.ReadByte();
			BitsByte bitsByte2 = (BitsByte)(bitsByte[2] ? args.Data.ReadByte() : 0);
			float[] ai = new float[Projectile.maxAI];
			for (int i = 0; i < Projectile.maxAI; ++i) ai[i] = 0f;
			ai[0] = bitsByte[0] ? args.Data.ReadSingle() : 0f;
			ai[1] = bitsByte[1] ? args.Data.ReadSingle() : 0f;
			ushort bannerId = (ushort)(bitsByte[3] ? args.Data.ReadUInt16() : 0);
			short dmg = (short)(bitsByte[4] ? args.Data.ReadInt16() : 0);
			float knockback = bitsByte[5] ? args.Data.ReadSingle() : 0f;
			short origDmg = (short)(bitsByte[6] ? args.Data.ReadInt16() : 0);
			short projUUID = (short)(bitsByte[7] ? args.Data.ReadInt16() : -1);
			if (projUUID >= 1000) projUUID = -1;
			ai[2] = (bitsByte2[0] ? args.Data.ReadSingle() : 0f);

			var index = TShock.Utils.SearchProjectile(ident, owner);

			if (OnNewProjectile(args.Data, ident, pos, vel, knockback, dmg, owner, type, index, args.Player, ai))
				return true;

			lock (args.Player.RecentlyCreatedProjectiles)
			{
				if (!args.Player.RecentlyCreatedProjectiles.Any(p => p.Index == index))
				{
					args.Player.RecentlyCreatedProjectiles.Add(new GetDataHandlers.ProjectileStruct()
					{
						Index = index,
						Type = type,
						CreatedAt = DateTime.Now
					});
				}
			}
			return false;
		}

		private static bool HandleNpcStrike(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt16();
			var dmg = args.Data.ReadInt16();
			var knockback = args.Data.ReadSingle();
			var direction = (byte)(args.Data.ReadInt8() - 1);
			var crit = args.Data.ReadInt8();

			if (OnNPCStrike(args.Player, args.Data, id, direction, dmg, knockback, crit))
				return true;

			if (Main.npc[id].townNPC && !args.Player.HasPermission(Permissions.hurttownnpc))
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to hurt Town NPCs."));
				args.Player.SendData(PacketTypes.NpcUpdate, "", id);
				TShock.Log.ConsoleDebug(GetString($"GetDataHandlers / HandleNpcStrike rejected npc strike {args.Player.Name}"));
				return true;
			}

			if (Main.npc[id].netID == NPCID.EmpressButterfly)
			{
				if (!args.Player.HasPermission(Permissions.summonboss))
				{
					args.Player.SendErrorMessage(GetString("You do not have permission to summon the Empress of Light."));
					args.Player.SendData(PacketTypes.NpcUpdate, "", id);
					TShock.Log.ConsoleDebug(GetString($"GetDataHandlers / HandleNpcStrike rejected EoL summon from {args.Player.Name}"));
					return true;
				}
				else if (!TShock.Config.Settings.AnonymousBossInvasions)
				{
					TShock.Utils.Broadcast(GetString($"{args.Player.Name} summoned the Empress of Light!"), 175, 75, 255);
				}
				else
					TShock.Utils.SendLogs(GetString($"{args.Player.Name} summoned the Empress of Light!"), Color.PaleVioletRed, args.Player);
			}

			if (Main.npc[id].netID == NPCID.CultistDevote || Main.npc[id].netID == NPCID.CultistArcherBlue)
			{
				if (!args.Player.HasPermission(Permissions.summonboss))
				{
					args.Player.SendErrorMessage(GetString("You do not have permission to summon the Lunatic Cultist!"));
					args.Player.SendData(PacketTypes.NpcUpdate, "", id);
					TShock.Log.ConsoleDebug(GetString($"GetDataHandlers / HandleNpcStrike rejected Cultist summon from {args.Player.Name}"));
					return true;
				}
			}
			return false;
		}

		private static bool HandleProjectileKill(GetDataHandlerArgs args)
		{
			var ident = args.Data.ReadInt16();
			var owner = args.Data.ReadInt8();
			owner = (byte)args.Player.Index;
			var index = TShock.Utils.SearchProjectile(ident, owner);

			if (OnProjectileKill(args.Player, args.Data, ident, owner, index))
			{
				return true;
			}

			short type = (short)Main.projectile[index].type;

			// TODO: This needs to be moved somewhere else.

			if (type == ProjectileID.Tombstone)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleProjectileKill rejected tombstone {0}", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				return true;
			}

			if (TShock.ProjectileBans.ProjectileIsBanned(type, args.Player) && !TShock.Config.Settings.IgnoreProjKill)
			{
				// According to 2012 deathmax, this is a workaround to fix skeletron prime issues
				// https://github.com/Pryaxis/TShock/commit/a5aa9231239926f361b7246651e32144bbf28dda
				if (type == ProjectileID.Bomb || type == ProjectileID.DeathLaser)
				{
					TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleProjectileKill permitted skeletron prime exemption {0}", args.Player.Name));
					TShock.Log.ConsoleDebug(GetString("If this was not skeletron prime related, please report to TShock what happened."));
					return false;
				}
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleProjectileKill rejected banned projectile {0}", args.Player.Name));
				args.Player.RemoveProjectile(ident, owner);
				return true;
			}

			args.Player.LastKilledProjectile = type;
			lock (args.Player.RecentlyCreatedProjectiles)
			{
				args.Player.RecentlyCreatedProjectiles.ForEach(s => { if (s.Index == index) { s.Killed = true; } });
			}

			return false;
		}

		private static bool HandleTogglePvp(GetDataHandlerArgs args)
		{
			byte id = args.Data.ReadInt8();
			bool pvp = args.Data.ReadBoolean();
			if (OnPvpToggled(args.Player, args.Data, id, pvp))
				return true;

			if (id != args.Player.Index)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTogglePvp rejected index mismatch {0}", args.Player.Name));
				return true;
			}

			string pvpMode = TShock.Config.Settings.PvPMode.ToLowerInvariant();
			if (pvpMode == "disabled" || pvpMode == "always" || pvpMode == "pvpwithnoteam" || (DateTime.UtcNow - args.Player.LastPvPTeamChange).TotalSeconds < 5)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTogglePvp rejected fastswitch {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.TogglePvp, "", id);
				return true;
			}

			args.Player.LastPvPTeamChange = DateTime.UtcNow;
			return false;
		}

		private static bool HandleChestOpen(GetDataHandlerArgs args)
		{
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();

			if (OnChestOpen(args.Data, x, y, args.Player))
				return true;

			return false;
		}

		private static bool HandleChestItem(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt16();
			var slot = args.Data.ReadInt8();
			var stacks = args.Data.ReadInt16();
			var prefix = args.Data.ReadInt8();
			var type = args.Data.ReadInt16();

			if (OnChestItemChange(args.Player, args.Data, id, slot, stacks, prefix, type))
				return true;

			Item item = new Item();
			item.netDefaults(type);
			if (stacks > item.maxStack)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleChestItem rejected max stacks {0}", args.Player.Name));
				return true;
			}

			return false;
		}

		private static bool HandleChestActive(GetDataHandlerArgs args)
		{
			//chest ID
			var id = args.Data.ReadInt16();
			//chest x
			var x = args.Data.ReadInt16();
			//chest y
			var y = args.Data.ReadInt16();
			//chest name length
			var nameLen = args.Data.ReadInt8();

			if (nameLen != 0 && nameLen <= 20)
				args.Data.ReadString(); // Ignore the name

			args.Player.ActiveChest = id;

			if (!args.Player.HasBuildPermission(x, y) && TShock.Config.Settings.RegionProtectChests)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleChestActive rejected build permission and region check {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.ChestOpen, "", -1);
				return true;
			}

			return false;
		}

		private static bool HandlePlaceChest(GetDataHandlerArgs args)
		{
			int flag = args.Data.ReadByte();
			int tileX = args.Data.ReadInt16();
			int tileY = args.Data.ReadInt16();
			short style = args.Data.ReadInt16();

			if (OnPlaceChest(args.Player, args.Data, flag, tileX, tileY, style))
				return true;

			return false;
		}

		private static bool HandlePlayerZone(GetDataHandlerArgs args)
		{
			if (args.Player == null || args.TPlayer == null || args.Data == null)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerZone rejected null check"));
				return true;
			}

			var plr = args.Data.ReadInt8();
			BitsByte zone1 = args.Data.ReadInt8();
			BitsByte zone2 = args.Data.ReadInt8();
			BitsByte zone3 = args.Data.ReadInt8();
			BitsByte zone4 = args.Data.ReadInt8();
			BitsByte zone5 = args.Data.ReadInt8();

			if (OnPlayerZone(args.Player, args.Data, plr, zone1, zone2, zone3, zone4, zone5))
				return true;

			return false;
		}

		private static bool HandlePassword(GetDataHandlerArgs args)
		{
			if (!args.Player.RequiresPassword)
				return true;

			string password = args.Data.ReadString();

			if (Hooks.PlayerHooks.OnPlayerPreLogin(args.Player, args.Player.Name, password))
				return true;

			var account = TShock.UserAccounts.GetUserAccountByName(args.Player.Name);
			if (account != null && !TShock.Config.Settings.DisableLoginBeforeJoin)
			{
				if (account.VerifyPassword(password))
				{
					args.Player.RequiresPassword = false;
					args.Player.PlayerData = TShock.CharacterDB.GetPlayerData(args.Player, account.ID);

					if (args.Player.State == (int)ConnectionState.AssigningPlayerSlot)
						args.Player.State = (int)ConnectionState.AwaitingPlayerInfo;

					NetMessage.SendData((int)PacketTypes.WorldInfo, args.Player.Index);

					var group = TShock.Groups.GetGroupByName(account.Group);

					if (!TShock.Groups.AssertGroupValid(args.Player, group, true))
						return true;

					args.Player.Group = group;
					args.Player.tempGroup = null;
					args.Player.Account = account;
					args.Player.IsLoggedIn = true;
					args.Player.IsDisabledForSSC = false;

					if (Main.ServerSideCharacter)
					{
						if (args.Player.HasPermission(Permissions.bypassssc))
						{
							args.Player.PlayerData.CopyCharacter(args.Player);
							TShock.CharacterDB.InsertPlayerData(args.Player);
						}
						args.Player.PlayerData.RestoreCharacter(args.Player);
					}
					args.Player.LoginFailsBySsi = false;

					if (args.Player.HasPermission(Permissions.ignorestackhackdetection))
						args.Player.IsDisabledForStackDetection = false;

					if (args.Player.HasPermission(Permissions.usebanneditem))
						args.Player.IsDisabledForBannedWearable = false;


					args.Player.SendMessage(GetString($"Authenticated as {args.Player.Name} successfully."), Color.LimeGreen);
					TShock.Log.ConsoleInfo(GetString($"{args.Player.Name} authenticated successfully as user {args.Player.Name}."));
					TShock.UserAccounts.SetUserAccountUUID(account, args.Player.UUID);
					Hooks.PlayerHooks.OnPlayerPostLogin(args.Player);
					return true;
				}
				args.Player.Kick(GetString("Your password did not match this character's password."), true, true);
				return true;
			}

			if (!string.IsNullOrEmpty(TShock.Config.Settings.ServerPassword))
			{
				if (TShock.Config.Settings.ServerPassword == password)
				{
					args.Player.RequiresPassword = false;

					if (args.Player.State == (int)ConnectionState.AssigningPlayerSlot)
						args.Player.State = (int)ConnectionState.AwaitingPlayerInfo;

					NetMessage.SendData((int)PacketTypes.WorldInfo, args.Player.Index);
					return true;
				}
				args.Player.Kick(GetString("Invalid server password."), true, true);
				return true;
			}

			args.Player.Kick(GetParticularString("Likely non-vanilla client send zero-length password", "You have been Bounced for invalid password."), true, true);
			return true;
		}

		private static bool HandleNpcTalk(GetDataHandlerArgs args)
		{
			var plr = args.Data.ReadInt8();
			var npc = args.Data.ReadInt16();

			if (OnNpcTalk(args.Player, args.Data, plr, npc))
				return true;

			//Rejecting player who trying to talk to a npc if player were disabled, mainly for unregistered and logged out players. Preventing smuggling or duplicating their items if player put it in a npc's item slot
			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleNpcTalk rejected npc talk {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.NpcTalk, "", plr, -1);
				return true;
			}

			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / HandleNpcTalk rejected from bouncer throttle from {0}", args.Player.Name));
				return true;
			}

			// -1 is a magic value, represents not talking to an NPC
			if (npc < -1 || npc >= Main.maxNPCs)
			{
				TShock.Log.ConsoleDebug(GetString("Bouncer / HandleNpcTalk rejected from bouncer out of bounds from {0}", args.Player.Name));
				return true;
			}
			return false;
		}

		private static bool HandlePlayerAnimation(GetDataHandlerArgs args)
		{
			if (OnPlayerAnimation(args.Player, args.Data))
				return true;

			return false;
		}

		private static bool HandlePlayerMana(GetDataHandlerArgs args)
		{
			var plr = args.Data.ReadInt8();
			var cur = args.Data.ReadInt16();
			var max = args.Data.ReadInt16();

			if (OnPlayerMana(args.Player, args.Data, plr, cur, max) || cur < 0 || max < 0 || args.Player.IgnoreSSCPackets)
				return true;

			if (max > TShock.Config.Settings.MaxMP && !args.Player.HasPermission(Permissions.ignoremp))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerMana rejected max mana {0} {1}/{2}", args.Player.Name, max, TShock.Config.Settings.MaxMP));
				args.Player.Disable("Maximum MP beyond limit", DisableFlags.WriteToLogAndConsole);
				return true;
			}

			if (args.Player.IsLoggedIn)
			{
				args.Player.TPlayer.statMana = cur;
				args.Player.TPlayer.statManaMax = max;
				args.Player.PlayerData.maxMana = max;
			}
			return false;
		}

		private static bool HandlePlayerTeam(GetDataHandlerArgs args)
		{
			byte id = args.Data.ReadInt8();
			byte team = args.Data.ReadInt8();
			if (OnPlayerTeam(args.Player, args.Data, id, team))
				return true;

			if (id != args.Player.Index)
				return true;

			string pvpMode = TShock.Config.Settings.PvPMode.ToLowerInvariant();
			if (pvpMode == "pvpwithnoteam" || (DateTime.UtcNow - args.Player.LastPvPTeamChange).TotalSeconds < 5)
			{
				args.Player.SendData(PacketTypes.PlayerTeam, "", id);
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerTeam rejected team fastswitch {0}", args.Player.Name));
				return true;
			}

			args.Player.LastPvPTeamChange = DateTime.UtcNow;
			return false;
		}

		private static bool HandleSignRead(GetDataHandlerArgs args)
		{
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();

			if (OnSignRead(args.Player, args.Data, x, y))
				return true;

			if (x < 0 || y < 0 || x >= Main.maxTilesX || y >= Main.maxTilesY)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSignRead rejected out of bounds {0}", args.Player.Name));
				return true;
			}

			return false;
		}

		private static bool HandleSign(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt16();
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();
			args.Data.ReadString(); // Ignore sign text

			if (OnSignEvent(args.Player, args.Data, id, x, y))
				return true;

			if (!args.Player.HasBuildPermission(x, y))
			{
				args.Player.SendData(PacketTypes.SignNew, "", id);
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSign rejected sign on build permission {0}", args.Player.Name));
				return true;
			}

			if (!args.Player.IsInRange(x, y))
			{
				args.Player.SendData(PacketTypes.SignNew, "", id);
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSign rejected sign range check {0}", args.Player.Name));
				return true;
			}
			return false;
		}

		private static bool HandleLiquidSet(GetDataHandlerArgs args)
		{
			int tileX = args.Data.ReadInt16();
			int tileY = args.Data.ReadInt16();
			byte amount = args.Data.ReadInt8();
			byte type = args.Data.ReadInt8();

			if (OnLiquidSet(args.Player, args.Data, tileX, tileY, amount, type))
				return true;

			return false;
		}

		private static bool HandlePlayerBuffList(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt8();

			if (OnPlayerBuffUpdate(args.Player, args.Data, id))
				return true;

			for (int i = 0; i < Terraria.Player.maxBuffs; i++)
			{
				var buff = args.Data.ReadUInt16();

				if (buff == 10 && TShock.Config.Settings.DisableInvisPvP && args.TPlayer.hostile)
					buff = 0;

				if (Netplay.Clients[args.TPlayer.whoAmI].State < (int)ConnectionState.AwaitingPlayerInfo && (buff == 156 || buff == 47 || buff == 149))
				{
					TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerBuffList zeroed player buff due to below state awaiting player information {0} {1}", args.Player.Name, buff));
					buff = 0;
				}

				args.TPlayer.buffType[i] = buff;
				if (args.TPlayer.buffType[i] > 0)
				{
					args.TPlayer.buffTime[i] = 60;
				}
				else
				{
					args.TPlayer.buffTime[i] = 0;
				}
			}

			TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerBuffList handled event and sent data {0}", args.Player.Name));
			NetMessage.SendData((int)PacketTypes.PlayerBuff, -1, args.Player.Index, NetworkText.Empty, args.Player.Index);
			return true;
		}

		private static bool HandleSpecial(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt8();
			var type = args.Data.ReadInt8();

			if (OnNPCSpecial(args.Player, args.Data, id, type))
				return true;

			if (type == 1)
			{
				if (!args.Player.HasPermission(Permissions.summonboss))
				{
					args.Player.SendErrorMessage(GetString("You do not have permission to summon the Skeletron."));
					TShock.Log.ConsoleDebug(GetString($"GetDataHandlers / HandleNpcStrike rejected Skeletron summon from {args.Player.Name}"));
					return true;
				}

				return false;
			}
			else if (type == 2)
			{
				// Plays SoundID.Item1
				return false;
			}
			else if (type == 3)
			{
				if (!args.Player.HasPermission(Permissions.usesundial))
				{
					TShock.Log.ConsoleDebug(GetString($"GetDataHandlers / HandleSpecial rejected enchanted sundial permission {args.Player.Name}"));
					args.Player.SendErrorMessage(GetString("You do not have permission to use the Enchanted Sundial."));
					return true;
				}
				else if (TShock.Config.Settings.ForceTime != "normal")
				{
					TShock.Log.ConsoleDebug(GetString($"GetDataHandlers / HandleSpecial rejected enchanted sundial permission (ForceTime) {args.Player.Name}"));
					if (!args.Player.HasPermission(Permissions.cfgreload))
					{
						args.Player.SendErrorMessage(GetString("You cannot use the Enchanted Sundial because time is stopped."));
					}
					else
						args.Player.SendErrorMessage(GetString("You must set ForceTime to normal via config to use the Enchanted Sundial."));
					return true;
				}
			}
			else if (type == 4)
			{
				// Big Mimic Spawn Smoke
				return false;
			}
			else if (type == 5)
			{
				// Register Kill for Torch God in Bestiary
				return false;
			}
			else if (type == 6)
			{
				if (!args.Player.HasPermission(Permissions.usemoondial))
				{
					TShock.Log.ConsoleDebug(GetString($"GetDataHandlers / HandleSpecial rejected enchanted moondial permission {args.Player.Name}"));
					args.Player.SendErrorMessage(GetString("You do not have permission to use the Enchanted Moondial."));
					return true;
				}
				else if (TShock.Config.Settings.ForceTime != "normal")
				{
					TShock.Log.ConsoleDebug(GetString($"GetDataHandlers / HandleSpecial rejected enchanted moondial permission (ForceTime) {args.Player.Name}"));
					if (!args.Player.HasPermission(Permissions.cfgreload))
					{
						args.Player.SendErrorMessage(GetString("You cannot use the Enchanted Moondial because time is stopped."));
					}
					else
						args.Player.SendErrorMessage(GetString("You must set ForceTime to normal via config to use the Enchanted Moondial."));
					return true;
				}
			}
			else if (!args.Player.HasPermission($"tshock.specialeffects.{type}"))
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to use this effect."));
				TShock.Log.ConsoleError(GetString("Unrecognized special effect (Packet 51). Please report this to the TShock developers."));
				return true;
			}

			return false;
		}

		private static bool HandleNPCAddBuff(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt16();
			var type = args.Data.ReadUInt16();
			var time = args.Data.ReadInt16();

			if (OnNPCAddBuff(args.Player, args.Data, id, type, time))
				return true;

			return false;
		}

		private static bool HandlePlayerAddBuff(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt8();
			var type = args.Data.ReadUInt16();
			var time = args.Data.ReadInt32();

			if (OnPlayerBuff(args.Player, args.Data, id, type, time))
				return true;

			return false;
		}

		private static bool HandleUpdateNPCHome(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt16();
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();
			var householdStatus = args.Data.ReadInt8();

			if (OnUpdateNPCHome(args.Player, args.Data, id, x, y, householdStatus))
				return true;

			if (!args.Player.HasPermission(Permissions.movenpc))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / UpdateNPCHome rejected no permission {0}", args.Player.Name));
				args.Player.SendErrorMessage(GetString("You do not have permission to relocate Town NPCs."));
				args.Player.SendData(PacketTypes.UpdateNPCHome, "", id, Main.npc[id].homeTileX, Main.npc[id].homeTileY,
					Convert.ToByte(Main.npc[id].homeless));
				return true;
			}
			return false;
		}

		private static readonly int[] invasions = { -1, -2, -3, -4, -5, -6, -7, -8, -10 };
		private static readonly int[] pets = { -12, -13, -14, -15 };
		private static readonly int[] upgrades = { -11, -17, -18 };
		private static bool HandleSpawnBoss(GetDataHandlerArgs args)
		{
			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSpawnBoss rejected bouner throttled {0}", args.Player.Name));
				return true;
			}

			var plr = args.Data.ReadInt16();
			var thingType = args.Data.ReadInt16();

			var isKnownBoss = (thingType > 0 && thingType < Terraria.ID.NPCID.Count && NPCID.Sets.MPAllowedEnemies[thingType]) || thingType == -16;
			if (isKnownBoss && !args.Player.HasPermission(Permissions.summonboss))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSpawnBoss rejected boss {0} {1}", args.Player.Name, thingType));
				args.Player.SendErrorMessage(GetString("You do not have permission to summon bosses."));
				return true;
			}

			if (invasions.Contains(thingType) && !args.Player.HasPermission(Permissions.startinvasion))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSpawnBoss rejected invasion {0} {1}", args.Player.Name, thingType));
				args.Player.SendErrorMessage(GetString("You do not have permission to start invasions."));
				return true;
			}

			if (pets.Contains(thingType) && !args.Player.HasPermission(Permissions.spawnpets))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSpawnBoss rejected pet {0} {1}", args.Player.Name, thingType));
				args.Player.SendErrorMessage(GetString("You do not have permission to spawn pets."));
				return true;
			}

			if (upgrades.Contains(thingType) && !args.Player.HasPermission(Permissions.worldupgrades))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSpawnBoss rejected upgrade {0} {1}", args.Player.Name, thingType));
				args.Player.SendErrorMessage(GetString("You do not have permission to use permanent boosters."));
				return true;
			}

			if (plr != args.Player.Index)
				return true;

			string thing;
			switch (thingType)
			{
				case -18:
					thing = GetString("{0} applied traveling merchant's satchel!", args.Player.Name);
					break;
				case -17:
					thing = GetString("{0} applied advanced combat techniques volume 2!", args.Player.Name);
					break;
				case -16:
					thing = GetString("{0} summoned a Mechdusa!", args.Player.Name);
					break;
				case -15:
					thing = GetString("{0} has sent a request to the slime delivery service!", args.Player.Name);
					break;
				case -14:
					thing = GetString("{0} has sent a request to the bunny delivery service!", args.Player.Name);
					break;
				case -13:
					thing = GetString("{0} has sent a request to the dog delivery service!", args.Player.Name);
					break;
				case -12:
					thing = GetString("{0} has sent a request to the cat delivery service!", args.Player.Name);
					break;
				case -11:
					thing = GetString("{0} applied advanced combat techniques!", args.Player.Name);
					break;
				case -10:
					thing = GetString("{0} summoned a Blood Moon!", args.Player.Name);
					break;
				case -8:
					thing = GetString("{0} summoned a Moon Lord!", args.Player.Name);
					break;
				case -7:
					thing = GetString("{0} summoned a Martian invasion!", args.Player.Name);
					break;
				case -6:
					thing = GetString("{0} summoned an eclipse!", args.Player.Name);
					break;
				case -5:
					thing = GetString("{0} summoned a frost moon!", args.Player.Name);
					break;
				case -4:
					thing = GetString("{0} summoned a pumpkin moon!", args.Player.Name);
					break;
				case -3:
					thing = GetString("{0} summoned the Pirates!", args.Player.Name);
					break;
				case -2:
					thing = GetString("{0} summoned the Snow Legion!", args.Player.Name);
					break;
				case -1:
					thing = GetString("{0} summoned a Goblin Invasion!", args.Player.Name);
					break;
				default:
					if (!isKnownBoss)
						TShock.Log.ConsoleDebug("GetDataHandlers / HandleSpawnBoss unknown boss {0} summoned by {1}", thingType, args.Player.Name);
					NPC npc = new NPC();
					npc.SetDefaults(thingType);
					thing = GetString("{0} summoned the {1}!", args.Player.Name, npc.FullName);
					break;
			}

			if (thingType < 0 || isKnownBoss)
			{
				if (TShock.Config.Settings.AnonymousBossInvasions)
					TShock.Utils.SendLogs(thing, Color.PaleVioletRed, args.Player);
				else
					TShock.Utils.Broadcast(thing, 175, 75, 255);
			}

			return false;
		}

		private static bool HasPaintSprayerAbilities(Item item)
			=> item is not null && item.stack > 0 && (
			   item.type == ItemID.PaintSprayer ||
			   item.type == ItemID.ArchitectGizmoPack ||
			   item.type == ItemID.HandOfCreation);

		private static bool HandlePaintTile(GetDataHandlerArgs args)
		{
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();
			var t = args.Data.ReadInt8();
			var ct = args.Data.ReadInt8();//PaintCoatTile

			if (x < 0 || y < 0 || x >= Main.maxTilesX || y >= Main.maxTilesY || t > Main.numTileColors)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePaintTile rejected range check {0}", args.Player.Name));
				return true;
			}
			if (OnPaintTile(args.Player, args.Data, x, y, t, ct))
			{
				return true;
			}

			// Not selecting paintbrush or paint scraper or the spectre versions? Hacking.
			if (args.Player.SelectedItem.type != ItemID.PaintRoller &&
				args.Player.SelectedItem.type != ItemID.PaintScraper &&
				args.Player.SelectedItem.type != ItemID.Paintbrush &&
				args.Player.SelectedItem.type != ItemID.SpectrePaintRoller &&
				args.Player.SelectedItem.type != ItemID.SpectrePaintScraper &&
				args.Player.SelectedItem.type != ItemID.SpectrePaintbrush &&
				!args.Player.Accessories.Any(HasPaintSprayerAbilities) &&
				!args.Player.Inventory.Any(HasPaintSprayerAbilities))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePaintTile rejected select consistency {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PaintTile, "", x, y, Main.tile[x, y].color());
				return true;
			}

			if (args.Player.IsBouncerThrottled() ||
				!args.Player.HasPaintPermission(x, y) ||
				!args.Player.IsInRange(x, y))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePaintTile rejected throttle/permission/range check {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PaintTile, "", x, y, Main.tile[x, y].color());
				return true;
			}

			if (!args.Player.HasPermission(Permissions.ignorepaintdetection))
			{
				args.Player.PaintThreshold++;
			}
			return false;
		}

		private static bool HandlePaintWall(GetDataHandlerArgs args)
		{
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();
			var t = args.Data.ReadInt8();
			var cw = args.Data.ReadInt8();//PaintCoatWall

			if (x < 0 || y < 0 || x >= Main.maxTilesX || y >= Main.maxTilesY || t > Main.numTileColors)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePaintWall rejected range check {0}", args.Player.Name));
				return true;
			}
			if (OnPaintWall(args.Player, args.Data, x, y, t, cw))
			{
				return true;
			}

			// Not selecting paint roller or paint scraper or the spectre versions? Hacking.
			if (args.Player.SelectedItem.type != ItemID.PaintRoller &&
				args.Player.SelectedItem.type != ItemID.PaintScraper &&
				args.Player.SelectedItem.type != ItemID.Paintbrush &&
				args.Player.SelectedItem.type != ItemID.SpectrePaintRoller &&
				args.Player.SelectedItem.type != ItemID.SpectrePaintScraper &&
				args.Player.SelectedItem.type != ItemID.SpectrePaintbrush &&
				!args.Player.Accessories.Any(HasPaintSprayerAbilities) &&
				!args.Player.Inventory.Any(HasPaintSprayerAbilities))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePaintWall rejected selector consistency {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PaintWall, "", x, y, Main.tile[x, y].wallColor());
				return true;
			}

			if (args.Player.IsBouncerThrottled() ||
				!args.Player.HasPaintPermission(x, y) ||
				!args.Player.IsInRange(x, y))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePaintWall rejected throttle/permission/range {0}", args.Player.Name));
				args.Player.SendData(PacketTypes.PaintWall, "", x, y, Main.tile[x, y].wallColor());
				return true;
			}

			if (!args.Player.HasPermission(Permissions.ignorepaintdetection))
			{
				args.Player.PaintThreshold++;
			}
			return false;
		}

		private static bool HandleTeleport(GetDataHandlerArgs args)
		{
			BitsByte flag = (BitsByte)args.Data.ReadByte();
			short id = args.Data.ReadInt16();
			var x = args.Data.ReadSingle();
			var y = args.Data.ReadSingle();
			byte style = args.Data.ReadInt8();

			int type = 0;
			bool isNPC = type == 1;
			int extraInfo = -1;
			bool getPositionFromTarget = false;

			if (flag[0])
			{
				type = 1;
			}
			if (flag[1])
			{
				type = 2;
			}
			if (flag[2])
			{
				getPositionFromTarget = true;
			}
			if (flag[3])
			{
				extraInfo = args.Data.ReadInt32();
			}

			if (OnTeleport(args.Player, args.Data, id, flag, x, y, style, extraInfo))
				return true;

			//Rod of Discord teleport (usually (may be used by modded clients to teleport))
			if (type == 0 && !args.Player.HasPermission(Permissions.rod))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleport rejected rod type {0} {1}", args.Player.Name, type));
				args.Player.SendErrorMessage(GetString("You do not have permission to teleport using items.")); // Was going to write using RoD but Hook of Disonnance and Potion of Return both use the same teleport packet as RoD. 
				args.Player.Teleport(args.TPlayer.position.X, args.TPlayer.position.Y); // Suggest renaming rod permission unless someone plans to add separate perms for the other 2 tp items.
				return true;
			}

			//NPC teleport
			if (type == 1 && id >= Main.maxNPCs)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleport rejected npc teleport {0} {1}", args.Player.Name, type));
				return true;
			}

			//Player to player teleport (wormhole potion, usually (may be used by modded clients to teleport))
			if (type == 2)
			{
				if (id >= Main.maxPlayers || Main.player[id] == null || TShock.Players[id] == null)
				{
					TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleport rejected p2p extents {0} {1}", args.Player.Name, type));
					return true;
				}

				if (!args.Player.HasPermission(Permissions.wormhole))
				{
					TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleport rejected p2p wormhole permission {0} {1}", args.Player.Name, type));
					args.Player.SendErrorMessage(GetString("You do not have permission to teleport using Wormhole Potions."));
					args.Player.Teleport(args.TPlayer.position.X, args.TPlayer.position.Y);
					return true;
				}
			}

			return false;
		}

		private static bool HandleHealOther(GetDataHandlerArgs args)
		{
			byte plr = args.Data.ReadInt8();
			short amount = args.Data.ReadInt16();

			if (OnHealOtherPlayer(args.Player, args.Data, plr, amount))
				return true;

			return false;
		}

		private static bool HandleCatchNpc(GetDataHandlerArgs args)
		{
			var npcID = args.Data.ReadInt16();
			var who = args.Data.ReadByte();

			if (Main.npc[npcID]?.catchItem == 0)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleCatchNpc catch zero {0}", args.Player.Name));
				Main.npc[npcID].active = true;
				NetMessage.SendData((int)PacketTypes.NpcUpdate, -1, -1, NetworkText.Empty, npcID);
				return true;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleCatchNpc rejected catch npc {0}", args.Player.Name));
				return true;
			}

			return false;
		}

		private static bool HandleReleaseNpc(GetDataHandlerArgs args)
		{
			var x = args.Data.ReadInt32();
			var y = args.Data.ReadInt32();
			var type = args.Data.ReadInt16();
			var style = args.Data.ReadInt8();

			if (OnReleaseNpc(args.Player, args.Data, x, y, type, style))
			{
				return true;
			}

			return false;
		}

		private static bool HandleTeleportationPotion(GetDataHandlerArgs args)
		{
			var type = args.Data.ReadByte();

			void Fail(string tpItem)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleportationPotion rejected permissions {0} {1}", args.Player.Name, type));
				args.Player.SendErrorMessage(GetString("You do not have permission to teleport using {0}.", tpItem));
			}

			switch (type)
			{
				case 0: // Teleportation Potion
					if (args.Player.ItemInHand.type != ItemID.TeleportationPotion &&
						args.Player.SelectedItem.type != ItemID.TeleportationPotion)
					{
						TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleportationPotion rejected not holding the correct item {0} {1}", args.Player.Name, type));
						return true;
					}

					if (!args.Player.HasPermission(Permissions.tppotion))
					{
						Fail("Teleportation Potions");
						return true;
					}
					break;
				case 1: // Magic Conch or Shellphone (Ocean)
					if (args.Player.ItemInHand.type != ItemID.MagicConch &&
						args.Player.SelectedItem.type != ItemID.MagicConch &&
						args.Player.ItemInHand.type != ItemID.ShellphoneOcean &&
						args.Player.SelectedItem.type != ItemID.ShellphoneOcean)
					{
						TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleportationPotion rejected not holding the correct item {0} {1}", args.Player.Name, type));
						return true;
					}

					if (!args.Player.HasPermission(Permissions.magicconch))
					{
						if (args.Player.ItemInHand.type == ItemID.ShellphoneOcean || args.Player.SelectedItem.type == ItemID.ShellphoneOcean)
						{
							Fail("the Shellphone (Ocean)");
						}
						else
						{
							Fail("the Magic Conch");
						}
						return true;
					}
					break;
				case 2: // Demon Conch or Shellphone (Underworld)
					if (args.Player.ItemInHand.type != ItemID.DemonConch &&
						args.Player.SelectedItem.type != ItemID.DemonConch &&
						args.Player.ItemInHand.type != ItemID.ShellphoneHell &&
						args.Player.SelectedItem.type != ItemID.ShellphoneHell)
					{
						TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleportationPotion rejected not holding the correct item {0} {1}", args.Player.Name, type));
						return true;
					}

					if (!args.Player.HasPermission(Permissions.demonconch))
					{
						if (args.Player.ItemInHand.type == ItemID.ShellphoneHell || args.Player.SelectedItem.type == ItemID.ShellphoneHell)
						{
							Fail("the Shellphone (Underworld)");
						}
						else
						{
							Fail("the Demon Conch");
						}
						return true;
					}
					break;
				case 3: // Shellphone (Spawn)
					if (args.Player.ItemInHand.type != ItemID.ShellphoneSpawn && args.Player.SelectedItem.type != ItemID.ShellphoneSpawn)
					{
						TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleTeleportationPotion rejected not holding the correct item {0} {1}", args.Player.Name, type));
						return true;
					}
					break;
			}

			return false;
		}

		private static bool HandleCompleteAnglerQuest(GetDataHandlerArgs args)
		{
			// Since packet 76 is NEVER sent to us, we actually have to rely on this to get the true count
			args.TPlayer.anglerQuestsFinished++;
			return false;
		}

		private static bool HandleNumberOfAnglerQuestsCompleted(GetDataHandlerArgs args)
		{
			// Never sent by vanilla client, ignore this
			TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleNumberOfAnglerQuestsCompleted surprise packet! Someone tell the TShock team! {0}", args.Player.Name));
			return true;
		}

		private static bool HandlePlaceObject(GetDataHandlerArgs args)
		{
			short x = args.Data.ReadInt16();
			short y = args.Data.ReadInt16();
			short type = args.Data.ReadInt16();
			short style = args.Data.ReadInt16();
			byte alternate = args.Data.ReadInt8();
			sbyte random = (sbyte)args.Data.ReadInt8();
			bool direction = args.Data.ReadBoolean();

			if (OnPlaceObject(args.Player, args.Data, x, y, type, style, alternate, random, direction))
				return true;

			return false;
		}

		private static bool HandleLoadNetModule(GetDataHandlerArgs args)
		{
			short moduleId = args.Data.ReadInt16();

			if (OnReadNetModule(args.Player, args.Data, (NetModuleType)moduleId))
			{
				return true;
			}

			return false;
		}

		private static bool HandlePlaceTileEntity(GetDataHandlerArgs args)
		{
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();
			var type = (byte)args.Data.ReadByte();

			if (OnPlaceTileEntity(args.Player, args.Data, x, y, type))
			{
				return true;
			}

			// ItemBan subsystem

			if (TShock.TileBans.TileIsBanned((short)TileID.LogicSensor, args.Player))
			{
				args.Player.SendTileSquareCentered(x, y, 1);
				args.Player.SendErrorMessage(GetString("You do not have permission to place Logic Sensors."));
				return true;
			}

			return false;
		}

		private static bool HandlePlaceItemFrame(GetDataHandlerArgs args)
		{
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();
			var itemID = args.Data.ReadInt16();
			var prefix = args.Data.ReadInt8();
			var stack = args.Data.ReadInt16();
			var itemFrame = (TEItemFrame)TileEntity.ByID[TEItemFrame.Find(x, y)];

			if (OnPlaceItemFrame(args.Player, args.Data, x, y, itemID, prefix, stack, itemFrame))
			{
				return true;
			}

			return false;
		}

		private static bool HandleSyncExtraValue(GetDataHandlerArgs args)
		{
			var npcIndex = args.Data.ReadInt16();
			var extraValue = args.Data.ReadInt32();
			var position = new Vector2(args.Data.ReadSingle(), args.Data.ReadSingle());

			if (position.X < 0 || position.X >= (Main.maxTilesX * 16.0f) || position.Y < 0 || position.Y >= (Main.maxTilesY * 16.0f))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSyncExtraValue rejected extents check {0}", args.Player.Name));
				return true;
			}

			if (!Main.expertMode && !Main.masterMode)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSyncExtraValue rejected expert/master mode check {0}", args.Player.Name));
				return true;
			}

			if (npcIndex < 0 || npcIndex >= Main.npc.Length)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSyncExtraValue rejected npc id out of bounds check - NPC ID: {0}", npcIndex));
				return true;
			}

			var npc = Main.npc[npcIndex];
			if (npc == null)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSyncExtraValue rejected npc is null - NPC ID: {0}", npcIndex));
				return true;
			}

			var distanceFromCoinPacketToNpc = Utils.Distance(position, npc.position);
			if (distanceFromCoinPacketToNpc >= (5 * 16f)) //5 tile range
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSyncExtraValue rejected range check {0},{1} vs {2},{3} which is {4}", npc.position.X, npc.position.Y, position.X, position.Y, distanceFromCoinPacketToNpc));
				return true;
			}

			return false;
		}

		private static bool HandleKillPortal(GetDataHandlerArgs args)
		{
			short projectileIndex = args.Data.ReadInt16();
			args.Data.ReadInt8(); // Read byte projectile AI

			Projectile projectile = Main.projectile[projectileIndex];
			if (projectile != null && projectile.active)
			{
				if (projectile.owner != args.TPlayer.whoAmI)
				{
					TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleKillPortal rejected owner mismatch check {0}", args.Player.Name));
					return true;
				}
			}

			return false;
		}

		private static bool HandlePlayerPortalTeleport(GetDataHandlerArgs args)
		{
			byte plr = args.Data.ReadInt8();
			short portalColorIndex = args.Data.ReadInt16();
			float newPositionX = args.Data.ReadSingle();
			float newPositionY = args.Data.ReadSingle();
			float newVelocityX = args.Data.ReadSingle();
			float newVelocityY = args.Data.ReadSingle();

			return OnPlayerTeleportThroughPortal(
				args.Player,
				plr,
				args.Data,
				new Vector2(newPositionX, newPositionY),
				new Vector2(newVelocityX, newVelocityY),
				portalColorIndex
			);
		}

		private static bool HandleNpcTeleportPortal(GetDataHandlerArgs args)
		{
			var npcIndex = args.Data.ReadUInt16();
			var portalColorIndex = args.Data.ReadInt16();
			var newPosition = new Vector2(args.Data.ReadSingle(), args.Data.ReadSingle());
			var velocity = new Vector2(args.Data.ReadSingle(), args.Data.ReadSingle());
			var projectile = Main.projectile.FirstOrDefault(p => p.position.X == newPosition.X && p.position.Y == newPosition.Y); // Check for projectiles at this location

			if (projectile == null || !projectile.active)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleNpcTeleportPortal rejected null check {0}", args.Player.Name));
				NetMessage.SendData((int)PacketTypes.NpcUpdate, -1, -1, NetworkText.Empty, npcIndex);
				return true;
			}

			if (projectile.type != ProjectileID.PortalGunGate)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleNpcTeleportPortal rejected not thinking with portals {0}", args.Player.Name));
				NetMessage.SendData((int)PacketTypes.NpcUpdate, -1, -1, NetworkText.Empty, npcIndex);
				return true;
			}

			return false;
		}

		private static bool HandleGemLockToggle(GetDataHandlerArgs args)
		{
			var x = args.Data.ReadInt16();
			var y = args.Data.ReadInt16();
			var on = args.Data.ReadBoolean();

			if (OnGemLockToggle(args.Player, args.Data, x, y, on))
			{
				return true;
			}

			return false;
		}

		private static bool HandleMassWireOperation(GetDataHandlerArgs args)
		{
			short startX = args.Data.ReadInt16();
			short startY = args.Data.ReadInt16();
			short endX = args.Data.ReadInt16();
			short endY = args.Data.ReadInt16();
			byte toolMode = (byte)args.Data.ReadByte();

			if (OnMassWireOperation(args.Player, args.Data, startX, startY, endX, endY, toolMode))
				return true;

			return false;
		}

		private static bool HandleToggleParty(GetDataHandlerArgs args)
		{
			if (args.Player != null && !args.Player.HasPermission(Permissions.toggleparty))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleToggleParty rejected no party {0}", args.Player.Name));
				args.Player.SendErrorMessage(GetString("You do not have permission to start a party."));
				return true;
			}

			return false;
		}

		private static bool HandleOldOnesArmy(GetDataHandlerArgs args)
		{
			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleOldOnesArmy rejected throttled {0}", args.Player.Name));
				return true;
			}

			if (!args.Player.HasPermission(Permissions.startdd2))
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleOldOnesArmy rejected permissions {0}", args.Player.Name));
				args.Player.SendErrorMessage(GetString("You do not have permission to start the Old One's Army."));
				return true;
			}

			if (TShock.Config.Settings.AnonymousBossInvasions)
				TShock.Utils.SendLogs(GetString("{0} started the Old One's Army event!", args.Player.Name), Color.PaleVioletRed, args.Player);
			else
				TShock.Utils.Broadcast(GetString("{0} started the Old One's Army event!", args.Player.Name), 175, 75, 255);
			return false;
		}

		private static bool HandlePlayerDamageV2(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt8();
			PlayerDeathReason playerDeathReason = PlayerDeathReason.FromReader(new BinaryReader(args.Data));
			var dmg = args.Data.ReadInt16();
			var direction = (byte)(args.Data.ReadInt8() - 1);
			var bits = (BitsByte)(args.Data.ReadByte());
			var crit = bits[0];
			var pvp = bits[1];
			var cooldownCounter = (sbyte)args.Data.ReadInt8();

			if (OnPlayerDamage(args.Player, args.Data, id, direction, dmg, pvp, crit, cooldownCounter, playerDeathReason))
				return true;

			return false;
		}

		private static bool HandlePlayerKillMeV2(GetDataHandlerArgs args)
		{
			var id = args.Data.ReadInt8();
			PlayerDeathReason playerDeathReason = PlayerDeathReason.FromReader(new BinaryReader(args.Data));
			var dmg = args.Data.ReadInt16();
			var direction = (byte)(args.Data.ReadInt8() - 1);
			BitsByte bits = (BitsByte)args.Data.ReadByte();
			bool pvp = bits[0];

			if (OnKillMe(args.Player, args.Data, id, direction, dmg, pvp, playerDeathReason))
				return true;

			args.Player.Dead = true;
			args.Player.RespawnTimer = TShock.Config.Settings.RespawnSeconds;

			foreach (NPC npc in Main.npc)
			{
				if (npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&
					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f)
				{
					args.Player.RespawnTimer = TShock.Config.Settings.RespawnBossSeconds;
					break;
				}
			}

			// Handle kicks/bans on mediumcore/hardcore deaths.
			if (args.TPlayer.difficulty == 1 || args.TPlayer.difficulty == 2) // Player is not softcore
			{
				bool mediumcore = args.TPlayer.difficulty == 1;
				bool shouldBan = mediumcore ? TShock.Config.Settings.BanOnMediumcoreDeath : TShock.Config.Settings.BanOnHardcoreDeath;
				bool shouldKick = mediumcore ? TShock.Config.Settings.KickOnMediumcoreDeath : TShock.Config.Settings.KickOnHardcoreDeath;
				string banReason = mediumcore ? TShock.Config.Settings.MediumcoreBanReason : TShock.Config.Settings.HardcoreBanReason;
				string kickReason = mediumcore ? TShock.Config.Settings.MediumcoreKickReason : TShock.Config.Settings.HardcoreKickReason;

				if (shouldBan)
				{
					if (!args.Player.Ban(banReason, "TShock"))
					{
						TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerKillMeV2 kicked with difficulty {0} {1}", args.Player.Name, args.TPlayer.difficulty));
						args.Player.Kick(GetString("You died! Normally, you'd be banned."), true, true);
					}
				}
				else if (shouldKick)
				{
					TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerKillMeV2 kicked with difficulty {0} {1}", args.Player.Name, args.TPlayer.difficulty));
					args.Player.Kick(kickReason, true, true, null, false);
				}
			}

			if (args.TPlayer.difficulty == 2 && Main.ServerSideCharacter && args.Player.IsLoggedIn)
			{
				if (TShock.CharacterDB.RemovePlayer(args.Player.Account.ID))
				{
					TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandlePlayerKillMeV2 ssc delete {0} {1}", args.Player.Name, args.TPlayer.difficulty));
					args.Player.SendErrorMessage(GetString("You have fallen in hardcore mode, and your items have been lost forever."));
					TShock.CharacterDB.SeedInitialData(args.Player.Account);
				}
			}

			return false;
		}

		private static bool HandleEmoji(GetDataHandlerArgs args)
		{
			byte playerIndex = args.Data.ReadInt8();
			byte emojiID = args.Data.ReadInt8();

			if (OnEmoji(args.Player, args.Data, playerIndex, emojiID))
				return true;

			return false;
		}

		private static bool HandleTileEntityDisplayDollItemSync(GetDataHandlerArgs args)
		{
			byte playerIndex = args.Data.ReadInt8();
			int tileEntityID = args.Data.ReadInt32();
			int slot = args.Data.ReadByte();
			bool isDye = false;
			if (slot >= 8)
			{
				isDye = true;
				slot -= 8;
			}

			Item newItem = new Item();
			Item oldItem = new Item();

			if (!TileEntity.ByID.TryGetValue(tileEntityID, out TileEntity tileEntity))
				return false;

			TEDisplayDoll displayDoll = tileEntity as TEDisplayDoll;
			if (displayDoll != null)
			{
				oldItem = displayDoll._items[slot];
				if (isDye)
					oldItem = displayDoll._dyes[slot];

				ushort itemType = args.Data.ReadUInt16();
				ushort stack = args.Data.ReadUInt16();
				int prefix = args.Data.ReadByte();

				if (oldItem.type == 0 && newItem.type == 0)
					return false;

				newItem.SetDefaults(itemType);
				newItem.stack = stack;
				newItem.Prefix(prefix);

				if (OnDisplayDollItemSync(args.Player, args.Data, playerIndex, tileEntityID, displayDoll, slot, isDye, oldItem, newItem))
					return true;
			}
			return false;
		}

		private static bool HandleRequestTileEntityInteraction(GetDataHandlerArgs args)
		{
			int tileEntityID = args.Data.ReadInt32();
			byte playerIndex = args.Data.ReadInt8();

			if (!TileEntity.ByID.TryGetValue(tileEntityID, out TileEntity tileEntity))
				return false;

			if (OnRequestTileEntityInteraction(args.Player, args.Data, tileEntity, playerIndex))
				return true;

			return false;
		}

		private static bool HandleSyncTilePicking(GetDataHandlerArgs args)
		{
			byte playerIndex = args.Data.ReadInt8();
			short tileX = args.Data.ReadInt16();
			short tileY = args.Data.ReadInt16();
			byte damage = args.Data.ReadInt8();

			if (OnSyncTilePicking(args.Player, args.Data, playerIndex, tileX, tileY, damage))
				return true;

			return false;
		}

		private static bool HandleSyncRevengeMarker(GetDataHandlerArgs args)
		{
			int uniqueID = args.Data.ReadInt32();
			Vector2 location = args.Data.ReadVector2();
			int netId = args.Data.ReadInt32();
			float npcHpPercent = args.Data.ReadSingle();
			int npcTypeAgainstDiscouragement = args.Data.ReadInt32(); //tfw the argument is Type Against Discouragement
			int npcAiStyleAgainstDiscouragement = args.Data.ReadInt32(); //see ^
			int coinsValue = args.Data.ReadInt32();
			float baseValue = args.Data.ReadSingle();
			bool spawnedFromStatus = args.Data.ReadBoolean();

			return false;
		}

		private static bool HandleLandGolfBallInCup(GetDataHandlerArgs args)
		{
			byte playerIndex = args.Data.ReadInt8();
			ushort tileX = args.Data.ReadUInt16();
			ushort tileY = args.Data.ReadUInt16();
			ushort hits = args.Data.ReadUInt16();
			ushort projectileType = args.Data.ReadUInt16();

			if (OnLandGolfBallInCup(args.Player, args.Data, playerIndex, tileX, tileY, hits, projectileType))
				return true;

			return false;
		}

		private static bool HandleFishOutNPC(GetDataHandlerArgs args)
		{
			ushort tileX = args.Data.ReadUInt16();
			ushort tileY = args.Data.ReadUInt16();
			short npcType = args.Data.ReadInt16();

			if (OnFishOutNPC(args.Player, args.Data, tileX, tileY, npcType))
				return true;

			return false;
		}

		private static bool HandleFoodPlatterTryPlacing(GetDataHandlerArgs args)
		{
			short tileX = args.Data.ReadInt16();
			short tileY = args.Data.ReadInt16();
			short itemID = args.Data.ReadInt16();
			byte prefix = args.Data.ReadInt8();
			short stack = args.Data.ReadInt16();

			if (OnFoodPlatterTryPlacing(args.Player, args.Data, tileX, tileY, itemID, prefix, stack))
				return true;

			return false;
		}

		private static bool HandleSyncCavernMonsterType(GetDataHandlerArgs args)
		{
			args.Player.Kick(GetString("Exploit attempt detected!"));
			TShock.Log.ConsoleDebug(GetString($"HandleSyncCavernMonsterType: Player is trying to modify NPC cavernMonsterType; this is a crafted packet! - From {args.Player.Name}"));
			return true;
		}

		private static bool HandleSyncLoadout(GetDataHandlerArgs args)
		{
			var playerIndex = args.Data.ReadInt8();
			var loadoutIndex = args.Data.ReadInt8();

			// When syncing a player's own loadout index, they then sync it back to us...
			// So let's only care if the index has actually changed, otherwise we might end up in a loop...
			if (loadoutIndex == args.TPlayer.CurrentLoadoutIndex)
				return false;

			if (loadoutIndex >= args.TPlayer.Loadouts.Length)
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSyncLoadout rejected loadout index sync out of bounds {0}",
					args.Player.Name));
				NetMessage.SendData((int)PacketTypes.SyncLoadout, number: args.Player.Index, number2: args.TPlayer.CurrentLoadoutIndex);

				return true;
			}

			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString("GetDataHandlers / HandleSyncLoadout rejected loadout index sync {0}", args.Player.Name));
				NetMessage.SendData((int)PacketTypes.SyncLoadout, number: args.Player.Index, number2: args.TPlayer.CurrentLoadoutIndex);

				return true;
			}

			// Don't modify the player data if it isn't there.
			// This is the case whilst the player is connecting, as we receive the SyncLoadout packet before the ContinueConnecting2 packet.
			if (args.Player.PlayerData == null)
				return false;

			// The client does not sync slot changes when changing loadouts, it only tells the server the loadout index changed,
			// and the server will replicate the changes the client did. This means that PlayerData.StoreSlot is never called, so we need to
			// swap around the PlayerData items ourself.

			Tuple<int, int> GetArmorSlotsForLoadoutIndex(int index)
			{
				return index switch
				{
					0 => NetItem.Loadout1Armor,
					1 => NetItem.Loadout2Armor,
					2 => NetItem.Loadout3Armor
				};
			}

			Tuple<int, int> GetDyeSlotsForLoadoutIndex(int index)
			{
				return index switch
				{
					0 => NetItem.Loadout1Dye,
					1 => NetItem.Loadout2Dye,
					2 => NetItem.Loadout3Dye
				};
			}

			var (currentLoadoutArmorSlotStartIndex, _) = GetArmorSlotsForLoadoutIndex(args.TPlayer.CurrentLoadoutIndex);
			var (currentLoadoutDyeSlotStartIndex, _) = GetDyeSlotsForLoadoutIndex(args.TPlayer.CurrentLoadoutIndex);

			var (switchedLoadoutArmorSlotStartIndex, _) = GetArmorSlotsForLoadoutIndex(loadoutIndex);
			var (switchedLoadoutDyeSlotStartIndex, _) = GetDyeSlotsForLoadoutIndex(loadoutIndex);

			// Emulate what is seen in Player.TrySwitchingLoadout:
			// - Swap the current loadout items with the player's equipment
			// - Swap the switching loadout items with the player's equipment

			// At the end of all of this:
			// - The current loadout will contain the player's original equipment
			// - The switched loadout will contain the current loadout's items
			// - The player's equipment will contain the switched loadout's item

			for (var i = 0; i < NetItem.LoadoutArmorSlots; i++)
				Terraria.Utils.Swap(ref args.Player.PlayerData.inventory[currentLoadoutArmorSlotStartIndex + i],
					ref args.Player.PlayerData.inventory[NetItem.ArmorIndex.Item1 + i]);
			for (var i = 0; i < NetItem.LoadoutDyeSlots; i++)
				Terraria.Utils.Swap(ref args.Player.PlayerData.inventory[currentLoadoutDyeSlotStartIndex + i],
					ref args.Player.PlayerData.inventory[NetItem.DyeIndex.Item1 + i]);

			for (var i = 0; i < NetItem.LoadoutArmorSlots; i++)
				Terraria.Utils.Swap(ref args.Player.PlayerData.inventory[switchedLoadoutArmorSlotStartIndex + i],
					ref args.Player.PlayerData.inventory[NetItem.ArmorIndex.Item1 + i]);
			for (var i = 0; i < NetItem.LoadoutDyeSlots; i++)
				Terraria.Utils.Swap(ref args.Player.PlayerData.inventory[switchedLoadoutDyeSlotStartIndex + i],
					ref args.Player.PlayerData.inventory[NetItem.DyeIndex.Item1 + i]);

			return false;
		}

		public enum DoorAction
		{
			OpenDoor = 0,
			CloseDoor,
			OpenTrapdoor,
			CloseTrapdoor,
			OpenTallGate,
			CloseTallGate
		}

		public enum EditAction
		{
			KillTile = 0,
			PlaceTile,
			KillWall,
			PlaceWall,
			KillTileNoItem,
			PlaceWire,
			KillWire,
			PoundTile,
			PlaceActuator,
			KillActuator,
			PlaceWire2,
			KillWire2,
			PlaceWire3,
			KillWire3,
			SlopeTile,
			FrameTrack,
			PlaceWire4,
			KillWire4,
			PokeLogicGate,
			Acutate,
			TryKillTile,
			ReplaceTile,
			ReplaceWall,
			SlopePoundTile
		}
		public enum EditType
		{
			Fail = 0,
			Type,
			Slope,
		}
		/// <summary>
		/// The maximum place styles for each tile.
		/// </summary>
		public static Dictionary<int, int> MaxPlaceStyles = new Dictionary<int, int>();

		/// <summary>
		/// Tiles that can be broken without any pickaxes/etc.
		/// </summary>
		internal static int[] breakableTiles = new int[]
		{
			TileID.Books,
			TileID.Bottles,
			TileID.BreakableIce,
			TileID.Candles,
			TileID.CorruptGrass,
			TileID.Dirt,
			TileID.CrimsonGrass,
			TileID.Grass,
			TileID.HallowedGrass,
			TileID.MagicalIceBlock,
			TileID.Mannequin,
			TileID.Torches,
			TileID.WaterCandle,
			TileID.Womannequin,
		};

		/// <summary>
		/// List of Fishing rod item IDs.
		/// </summary>
		internal static readonly List<int> FishingRodItemIDs = new List<int>()
		{
			ItemID.WoodFishingPole,
			ItemID.ReinforcedFishingPole,
			ItemID.FiberglassFishingPole,
			ItemID.FisherofSouls,
			ItemID.GoldenFishingRod,
			ItemID.MechanicsRod,
			ItemID.SittingDucksFishingRod,
			ItemID.Fleshcatcher,
			ItemID.HotlineFishingHook,
			ItemID.BloodFishingRod,
			ItemID.ScarabFishingRod
		};

		/// <summary>
		/// List of NPC IDs that can be fished out by the player.
		/// </summary>
		internal static readonly List<int> FishableNpcIDs = new List<int>()
		{
			NPCID.EyeballFlyingFish,
			NPCID.ZombieMerman,
			NPCID.GoblinShark,
			NPCID.BloodEelHead,
			NPCID.BloodEelBody,
			NPCID.BloodEelTail,
			NPCID.BloodNautilus,
			NPCID.DukeFishron,
			NPCID.TownSlimeRed
		};

		/// <summary>
		/// These projectiles create tiles on death.
		/// </summary>
		internal static Dictionary<int, int> projectileCreatesTile = new Dictionary<int, int>
		{
			{ ProjectileID.DirtBall, TileID.Dirt },
			{ ProjectileID.SandBallGun, TileID.Sand },
			{ ProjectileID.EbonsandBallGun, TileID.Ebonsand },
			{ ProjectileID.PearlSandBallGun, TileID.Pearlsand },
			{ ProjectileID.CrimsandBallGun, TileID.Crimsand },
			{ ProjectileID.MysticSnakeCoil, TileID.MysticSnakeRope },
			{ ProjectileID.RopeCoil, TileID.Rope },
			{ ProjectileID.SilkRopeCoil, TileID.SilkRope },
			{ ProjectileID.VineRopeCoil, TileID.VineRope },
			{ ProjectileID.WebRopeCoil, TileID.WebRope }
		};

		internal static List<int> CoilTileIds = new List<int>()
		{
			TileID.MysticSnakeRope,
			TileID.Rope,
			TileID.SilkRope,
			TileID.VineRope,
			TileID.WebRope
		};

		internal static Dictionary<int, LiquidType> projectileCreatesLiquid = new Dictionary<int, LiquidType>
		{
			{ProjectileID.LavaBomb, LiquidType.Lava},
			{ProjectileID.LavaRocket, LiquidType.Lava },
			{ProjectileID.LavaGrenade, LiquidType.Lava },
			{ProjectileID.LavaMine, LiquidType.Lava },
			//{ProjectileID.LavaSnowmanRocket, LiquidType.Lava }, //these require additional checks.
			{ProjectileID.WetBomb, LiquidType.Water},
			{ProjectileID.WetRocket, LiquidType.Water },
			{ProjectileID.WetGrenade, LiquidType.Water},
			{ProjectileID.WetMine, LiquidType.Water},
			//{ProjectileID.WetSnowmanRocket, LiquidType.Water}, //these require additional checks.
			{ProjectileID.HoneyBomb, LiquidType.Honey},
			{ProjectileID.HoneyRocket, LiquidType.Honey },
			{ProjectileID.HoneyGrenade, LiquidType.Honey },
			{ProjectileID.HoneyMine, LiquidType.Honey },
			//{ProjectileID.HoneySnowmanRocket, LiquidType.Honey }, //these require additional checks.
			{ProjectileID.DryBomb, LiquidType.Removal },
			{ProjectileID.DryRocket, LiquidType.Removal },
			{ProjectileID.DryGrenade, LiquidType.Removal },
			{ProjectileID.DryMine, LiquidType.Removal },
			//{ProjectileID.DrySnowmanRocket, LiquidType.Removal } //these require additional checks.
		};

		internal static Dictionary<int, int> ropeCoilPlacements = new Dictionary<int, int>
		{
			{ItemID.RopeCoil, TileID.Rope},
			{ItemID.SilkRopeCoil, TileID.SilkRope},
			{ItemID.VineRopeCoil, TileID.VineRope},
			{ItemID.WebRopeCoil, TileID.WebRope}
		};

		/// <summary>
		/// Extra place style limits for strange hardcoded values in Terraria
		/// </summary>
		internal static Dictionary<int, int> ExtraneousPlaceStyles = new Dictionary<int, int>
		{
			{TileID.Presents, 6},
			{TileID.Explosives, 1},
			{TileID.MagicalIceBlock, 0},
			{TileID.Crystals, 17},
			{TileID.MinecartTrack, 3}
		};

		/// <summary>
		/// Contains brief information about a projectile
		/// </summary>
		public struct ProjectileStruct
		{
			/// <summary>
			/// Index inside Main.projectile
			/// </summary>
			public int Index { get; set; }
			/// <summary>
			/// Projectile's type ID
			/// </summary>
			public short Type { get; set; }
			/// <summary>
			/// Time at which the projectile was created
			/// </summary>
			public DateTime CreatedAt { get; set; }
			/// <summary>
			/// Whether or not the projectile has been killed
			/// </summary>
			public bool Killed { get; internal set; }
		}

		public enum NetModuleType
		{
			Liquid,
			Text,
			Ping,
			Ambience,
			Bestiary,
			CreativeUnlocks,
			CreativePowers,
			CreativeUnlocksPlayerReport,
			TeleportPylon,
			Particles,
			CreativePowerPermissions
		}

		public enum CreativePowerTypes
		{
			FreezeTime,
			SetDawn,
			SetNoon,
			SetDusk,
			SetMidnight,
			Godmode,
			WindStrength,
			RainStrength,
			TimeSpeed,
			RainFreeze,
			WindFreeze,
			IncreasePlacementRange,
			WorldDifficulty,
			BiomeSpreadFreeze,
			SetSpawnRate
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Group.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Linq;
using System.Collections.Generic;

using Microsoft.Xna.Framework;

namespace TShockAPI
{
	/// <summary>
	/// A class used to group multiple users' permissions and settings.
	/// </summary>
	public class Group
	{
		// NOTE: Using a const still suffers from needing to recompile to change the default
		// ideally we would use a static but this means it can't be used for the default parameter :(
		/// <summary>
		/// Default chat color.
		/// </summary>
		public const string defaultChatColor = "255,255,255";

		/// <summary>
		/// List of permissions available to the group.
		/// </summary>
		public readonly List<string> permissions = new List<string>();

		/// <summary>
		/// List of permissions that the group is explicitly barred from.
		/// </summary>
		public readonly List<string> negatedpermissions = new List<string>();

		/// <summary>
		/// The group's name.
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// The group that this group inherits permissions from.
		/// </summary>
		public virtual Group Parent { get; set; }

		/// <summary>
		/// The chat prefix for this group.
		/// </summary>
		public virtual string Prefix { get; set; }

		/// <summary>
		/// The chat suffix for this group.
		/// </summary>
		public virtual string Suffix { get; set; }

		/// <summary>
		/// The name of the parent, not particularly sure why this is here.
		/// We can use group.Parent.Name and not have this second reference. 
		/// This was added for rest, so a discussion with Shank is necessary.
		/// </summary>
		public string ParentName { get { return (null == Parent) ? "" : Parent.Name; } }

		/// <summary>
		/// The chat color of the group.
		/// Returns "255,255,255", sets "255,255,255"
		/// </summary>
		public string ChatColor
		{
			get { return string.Format("{0},{1},{2}", R.ToString("D3"), G.ToString("D3"), B.ToString("D3")); }
			set
			{
				if (null != value)
				{
					string[] parts = value.Split(',');
					if (3 == parts.Length)
					{
						byte r, g, b;
						if (byte.TryParse(parts[0], out r) && byte.TryParse(parts[1], out g) && byte.TryParse(parts[2], out b))
						{
							R = r;
							G = g;
							B = b;
							return;
						}
					}
				}
			}
		}

		/// <summary>
		/// The permissions of the user in string form.
		/// </summary>
		public string Permissions
		{
			get
			{
				List<string> all = new List<string>(permissions);
				negatedpermissions.ForEach(p => all.Add("!" + p));
				return string.Join(",", all);
			}
			set
			{
				permissions.Clear();
				negatedpermissions.Clear();
				if (null != value)
					value.Split(',').ForEach(p => AddPermission(p.Trim()));
			}
		}

		/// <summary>
		/// The permissions of this group and all that it inherits from.
		/// </summary>
		public virtual List<string> TotalPermissions
		{
			get
			{
				var cur = this;
				var traversed = new List<Group>();
				HashSet<string> all = new HashSet<string>();
				while (cur != null)
				{
					foreach (var perm in cur.permissions)
					{
						all.Add(perm);
					}

					foreach (var perm in cur.negatedpermissions)
					{
						all.Remove(perm);
					}

					if (traversed.Contains(cur))
					{
						throw new Exception("Infinite group parenting ({0})".SFormat(cur.Name));
					}
					traversed.Add(cur);
					cur = cur.Parent;
				}
				return all.ToList();
			}
		}

		/// <summary>
		/// The group's chat color red byte.
		/// </summary>
		public byte R = 255;
		/// <summary>
		/// The group's chat color green byte.
		/// </summary>
		public byte G = 255;
		/// <summary>
		/// The group's chat color blue byte.
		/// </summary>
		public byte B = 255;

		/// <summary>
		/// Simplifies work with the <see cref="R"/>, <see cref="G"/>, <see cref="B"/> properties.
		/// </summary>
		public virtual Color Color
		{
			get => new Color(R, G, B);
			set
			{
				R = value.R;
				G = value.G;
				B = value.B;
			}
		}

		/// <summary>
		/// The default group attributed to unregistered users.
		/// </summary>
		public static Group DefaultGroup = null;

		/// <summary>
		/// Initializes a new instance of the group class.
		/// </summary>
		/// <param name="groupname">The name of the group.</param>
		/// <param name="parentgroup">The parent group, if any.</param>
		/// <param name="chatcolor">The chat color, in "RRR,GGG,BBB" format.</param>
		/// <param name="permissions">The list of permissions associated with this group, separated by commas.</param>
		public Group(string groupname, Group parentgroup = null, string chatcolor = "255,255,255", string permissions = null)
		{
			Name = groupname;
			Parent = parentgroup;
			ChatColor = chatcolor;
			Permissions = permissions;
		}

		/// <summary>
		/// Checks to see if a group has a specified permission.
		/// </summary>
		/// <param name="permission">The permission to check.</param>
		/// <returns>True if the group has that permission.</returns>
		public virtual bool HasPermission(string permission)
		{
			bool negated = false;
			if (String.IsNullOrEmpty(permission) || (RealHasPermission(permission, ref negated) && !negated))
			{
				return true;
			}

			if (negated)
				return false;

			string[] nodes = permission.Split('.');
			for (int i = nodes.Length - 1; i >= 0; i--)
			{
				nodes[i] = "*";
				if (RealHasPermission(String.Join(".", nodes, 0, i + 1), ref negated))
				{
					return !negated;
				}
			}
			return false;
		}
		private bool RealHasPermission(string permission, ref bool negated)
		{
			negated = false;
			if (string.IsNullOrEmpty(permission))
				return true;

			var cur = this;
			var traversed = new List<Group>();
			while (cur != null)
			{
				if (cur.negatedpermissions.Contains(permission))
				{
					negated = true;
					return false;
				}
				if (cur.permissions.Contains(permission))
					return true;
				if (traversed.Contains(cur))
				{
					throw new InvalidOperationException("Infinite group parenting ({0})".SFormat(cur.Name));
				}
				traversed.Add(cur);
				cur = cur.Parent;
			}
			return false;
		}

		/// <summary>
		/// Adds a permission to the list of negated permissions.
		/// </summary>
		/// <param name="permission">The permission to negate.</param>
		public virtual void NegatePermission(string permission)
		{
			// Avoid duplicates
			if (!negatedpermissions.Contains(permission))
			{
				negatedpermissions.Add(permission);
				permissions.Remove(permission); // Ensure we don't have conflicting definitions for a permissions
			}
		}

		/// <summary>
		/// Adds a permission to the list of permissions.
		/// </summary>
		/// <param name="permission">The permission to add.</param>
		public virtual void AddPermission(string permission)
		{
			if (permission.StartsWith("!"))
			{
				NegatePermission(permission.Substring(1));
				return;
			}
			// Avoid duplicates
			if (!permissions.Contains(permission))
			{
				permissions.Add(permission);
				negatedpermissions.Remove(permission); // Ensure we don't have conflicting definitions for a permissions
			}
		}

		/// <summary>
		/// Clears the permission list and sets it to the list provided, 
		/// will parse "!permission" and add it to the negated permissions.
		/// </summary>
		/// <param name="permission">The new list of permissions to associate with the group.</param>
		public virtual void SetPermission(List<string> permission)
		{
			permissions.Clear();
			negatedpermissions.Clear();
			permission.ForEach(p => AddPermission(p));
		}

		/// <summary>
		/// Will remove a permission from the respective list,
		/// where "!permission" will remove a negated permission.
		/// </summary>
		/// <param name="permission"></param>
		public virtual void RemovePermission(string permission)
		{
			if (permission.StartsWith("!"))
			{
				negatedpermissions.Remove(permission.Substring(1));
				return;
			}
			permissions.Remove(permission);
		}

		/// <summary>
		/// Assigns all fields of this instance to another.
		/// </summary>
		/// <param name="otherGroup">The other instance.</param>
		public virtual void AssignTo(Group otherGroup)
		{
			otherGroup.Name = Name;
			otherGroup.Parent = Parent;
			otherGroup.Prefix = Prefix;
			otherGroup.Suffix = Suffix;
			otherGroup.R = R;
			otherGroup.G = G;
			otherGroup.B = B;
			otherGroup.Permissions = Permissions;
		}

		public override string ToString()
		{
			return this.Name;
		}
	}

	/// <summary>
	/// This class is the SuperAdminGroup, which has access to everything.
	/// </summary>
	public class SuperAdminGroup : Group
	{
		/// <summary>
		/// The superadmin class has every permission, represented by '*'.
		/// </summary>
		public override List<string> TotalPermissions
		{
			get { return new List<string> { "*" }; }
		}

		/// <summary>
		/// Initializes a new instance of the SuperAdminGroup class with the configured parameters.
		/// Those can be changed in the config file.
		/// </summary>
		public SuperAdminGroup()
			: base("superadmin")
		{
			R = (byte)TShock.Config.Settings.SuperAdminChatRGB[0];
			G = (byte)TShock.Config.Settings.SuperAdminChatRGB[1];
			B = (byte)TShock.Config.Settings.SuperAdminChatRGB[2];
			Prefix = TShock.Config.Settings.SuperAdminChatPrefix;
			Suffix = TShock.Config.Settings.SuperAdminChatSuffix;
		}

		/// <summary>
		/// Override to allow access to everything.
		/// </summary>
		/// <param name="permission">The permission</param>
		/// <returns>True</returns>
		public override bool HasPermission(string permission)
		{
			return true;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/HandlerList.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;

namespace TShockAPI
{
	public class HandlerList : HandlerList<EventArgs>
	{
	}
	public class HandlerList<T> where T : EventArgs
	{
		public class HandlerItem
		{
			public EventHandler<T> Handler { get; set; }
			public HandlerPriority Priority { get; set; }
			public bool GetHandled { get; set; }
		}

		protected object HandlerLock = new object();
		protected List<HandlerItem> Handlers { get; set; }
		public HandlerList()
		{
			Handlers = new List<HandlerItem>();
		}

		/// <summary>
		/// Register a handler
		/// </summary>
		/// <param name="handler">Delegate to be called</param>
		/// <param name="priority">Priority of the delegate</param>
		/// <param name="gethandled">Should the handler receive a call even if it has been handled</param>
		public void Register(EventHandler<T> handler, HandlerPriority priority = HandlerPriority.Normal, bool gethandled = false)
		{
			Register(Create(handler, priority, gethandled));
		}

		public void Register(HandlerItem obj)
		{
			lock (HandlerLock)
			{
				Handlers.Add(obj);
				Handlers = Handlers.OrderBy(h => (int)h.Priority).ToList();
			}
		}

		public void UnRegister(EventHandler<T> handler)
		{
			lock (HandlerLock)
			{
				Handlers.RemoveAll(h => h.Handler.Equals(handler));
			}
		}

		public void Invoke(object sender, T e)
		{
			List<HandlerItem> handlers;
			lock (HandlerLock)
			{
				//Copy the list for invoking as to not keep it locked during the invokes
				handlers = new List<HandlerItem>(Handlers);
			}

			var hargs = e as HandledEventArgs;
			for (int i = 0; i < handlers.Count; i++)
			{
				if (hargs == null || !hargs.Handled || (hargs.Handled && handlers[i].GetHandled))
				{
					handlers[i].Handler(sender, e);
				}
			}
		}

		public static HandlerItem Create(EventHandler<T> handler, HandlerPriority priority = HandlerPriority.Normal, bool gethandled = false)
		{
			return new HandlerItem { Handler = handler, Priority = priority, GetHandled = gethandled };
		}
		public static HandlerList<T> operator +(HandlerList<T> hand, HandlerItem obj)
		{
			if (hand == null)
				hand = new HandlerList<T>();

			hand.Register(obj);
			return hand;
		}
		public static HandlerList<T> operator +(HandlerList<T> hand, EventHandler<T> handler)
		{
			if (hand == null)
				hand = new HandlerList<T>();

			hand.Register(Create(handler));
			return hand;
		}
		public static HandlerList<T> operator -(HandlerList<T> hand, HandlerItem obj)
		{
			return hand - obj.Handler;
		}
		public static HandlerList<T> operator -(HandlerList<T> hand, EventHandler<T> handler)
		{
			if (hand == null)
				return null;

			hand.UnRegister(handler);
			return hand;
		}
	}

	public enum HandlerPriority
	{
		Highest = 1,
		High = 2,
		Normal = 3,
		Low = 4,
		Lowest = 5,
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Handlers`
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/DisplayDollItemSyncHandler.cs`
```
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static TShockAPI.GetDataHandlers;

namespace TShockAPI.Handlers
{
	/// <summary>
	/// Handles the TileEntityDisplayDollItemSync packets and checks for permissions.
	/// </summary>
	public class DisplayDollItemSyncHandler : IPacketHandler<DisplayDollItemSyncEventArgs>
	{
		public void OnReceive(object sender, DisplayDollItemSyncEventArgs args)
		{
			/// If the player has no building permissions means that they couldn't even see the content of the doll in the first place.
			/// Thus, they would not be able to modify its content. This means that a hacker attempted to send this packet directly, or through raw bytes to tamper with the DisplayDoll. This is why I do not bother with making sure the player gets their item back.
			if (!args.Player.HasBuildPermission(args.DisplayDollEntity.Position.X, args.DisplayDollEntity.Position.Y, false))
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to modify a Mannequin in a protected area!"));
				args.Handled = true;
				return;
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/EmojiHandler.cs`
```
﻿using static TShockAPI.GetDataHandlers;

namespace TShockAPI.Handlers
{
	/// <summary>
	/// Handles emoji packets and checks for permissions
	/// </summary>
	public class EmojiHandler : IPacketHandler<EmojiEventArgs>
	{
		/// <summary>
		/// Invoked when an emoji is sent in chat. Rejects the emoji packet if the player does not have emoji permissions
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		public void OnReceive(object sender, EmojiEventArgs args)
		{
			if (!args.Player.HasPermission(Permissions.sendemoji))
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to send emotes!"));
				args.Handled = true;
				return;
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/IPacketHandler.cs`
```
﻿namespace TShockAPI.Handlers
{
	/// <summary>
	/// Describes a packet handler that receives a packet from a GetDataHandler
	/// </summary>
	/// <typeparam name="TEventArgs"></typeparam>
	public interface IPacketHandler<TEventArgs> where TEventArgs : GetDataHandledEventArgs
	{
		/// <summary>
		/// Invoked when the packet is received
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		void OnReceive(object sender, TEventArgs args);
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Handlers/IllegalPerSe`
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/IllegalPerSe/EmojiPlayerMismatch.cs`
```
using static TShockAPI.GetDataHandlers;

namespace TShockAPI.Handlers.IllegalPerSe
{
	/// <summary>
	/// Rejects emoji packets with mismatched identifiers
	/// </summary>
	public class EmojiPlayerMismatch : IPacketHandler<EmojiEventArgs>
	{
		/// <summary>
		/// Invoked on emoji send. Rejects packets that are impossible.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		public void OnReceive(object sender, EmojiEventArgs args)
		{
			if (args.PlayerIndex != args.Player.Index)
			{
				TShock.Log.ConsoleError(GetString($"IllegalPerSe: Emoji packet rejected for ID spoofing. Expected {args.Player.Index}, received {args.PlayerIndex} from {args.Player.Name}."));
				args.Handled = true;
				return;
			}
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Handlers`
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/LandGolfBallInCupHandler.cs`
```
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria;
using Terraria.ID;
using static TShockAPI.GetDataHandlers;

namespace TShockAPI.Handlers
{
	/// <summary>
	/// Handles client side exploits of LandGolfBallInCup packet.
	/// </summary>
	public class LandGolfBallInCupHandler : IPacketHandler<LandGolfBallInCupEventArgs>
	{
		/// <summary>
		/// List of golf ball projectile IDs.
		/// </summary>
		public static readonly List<int> GolfBallProjectileIDs = new List<int>()
		{
			ProjectileID.DirtGolfBall,
			ProjectileID.GolfBallDyedBlack,
			ProjectileID.GolfBallDyedBlue,
			ProjectileID.GolfBallDyedBrown,
			ProjectileID.GolfBallDyedCyan,
			ProjectileID.GolfBallDyedGreen,
			ProjectileID.GolfBallDyedLimeGreen,
			ProjectileID.GolfBallDyedOrange,
			ProjectileID.GolfBallDyedPink,
			ProjectileID.GolfBallDyedPurple,
			ProjectileID.GolfBallDyedRed,
			ProjectileID.GolfBallDyedSkyBlue,
			ProjectileID.GolfBallDyedTeal,
			ProjectileID.GolfBallDyedViolet,
			ProjectileID.GolfBallDyedYellow
		};

		/// <summary>
		/// List of golf club item IDs
		/// </summary>
		public static readonly List<int> GolfClubItemIDs = new List<int>()
		{
			ItemID.GolfClubChlorophyteDriver,
			ItemID.GolfClubDiamondWedge,
			ItemID.GolfClubShroomitePutter,
			ItemID.Fake_BambooChest,
			ItemID.GolfClubTitaniumIron,
			ItemID.GolfClubGoldWedge,
			ItemID.GolfClubLeadPutter,
			ItemID.GolfClubMythrilIron,
			ItemID.GolfClubWoodDriver,
			ItemID.GolfClubBronzeWedge,
			ItemID.GolfClubRustyPutter,
			ItemID.GolfClubStoneIron,
			ItemID.GolfClubPearlwoodDriver,
			ItemID.GolfClubIron,
			ItemID.GolfClubDriver,
			ItemID.GolfClubWedge,
			ItemID.GolfClubPutter
		};
		/// <summary>
		/// List of golf ball item IDs.
		/// </summary>
		public static readonly List<int> GolfBallItemIDs = new List<int>()
		{
			ItemID.GolfBall,
			ItemID.GolfBallDyedBlack,
			ItemID.GolfBallDyedBlue,
			ItemID.GolfBallDyedBrown,
			ItemID.GolfBallDyedCyan,
			ItemID.GolfBallDyedGreen,
			ItemID.GolfBallDyedLimeGreen,
			ItemID.GolfBallDyedOrange,
			ItemID.GolfBallDyedPink,
			ItemID.GolfBallDyedPurple,
			ItemID.GolfBallDyedRed,
			ItemID.GolfBallDyedSkyBlue,
			ItemID.GolfBallDyedTeal,
			ItemID.GolfBallDyedViolet
		};

		/// <summary>
		/// Invoked when a player lands a golf ball in a cup.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		public void OnReceive(object sender, LandGolfBallInCupEventArgs args)
		{
			if (args.PlayerIndex != args.Player.Index)
			{
				TShock.Log.ConsoleDebug(GetString($"LandGolfBallInCupHandler: Packet rejected for ID spoofing. Expected {args.Player.Index}, received {args.PlayerIndex} from {args.Player.Name}."));
				args.Handled = true;
				return;
			}

			if (args.TileX > Main.maxTilesX || args.TileX < 0
			   || args.TileY > Main.maxTilesY || args.TileY < 0)
			{
				TShock.Log.ConsoleDebug(GetString($"LandGolfBallInCupHandler: X and Y position is out of world bounds! - From {args.Player.Name}"));
				args.Handled = true;
				return;
			}

			if (!Main.tile[args.TileX, args.TileY].active() && Main.tile[args.TileX, args.TileY].type != TileID.GolfHole)
			{
				TShock.Log.ConsoleDebug(GetString($"LandGolfBallInCupHandler: Tile at packet position X:{args.TileX} Y:{args.TileY} is not a golf hole! - From {args.Player.Name}"));
				args.Handled = true;
				return;
			}

			if (!GolfBallProjectileIDs.Contains(args.ProjectileType))
			{
				TShock.Log.ConsoleDebug(GetString($"LandGolfBallInCupHandler: Invalid golf ball projectile ID {args.ProjectileType}! - From {args.Player.Name}"));
				args.Handled = true;
				return;
			}

			var usedGolfBall = args.Player.RecentlyCreatedProjectiles.Any(e => GolfBallProjectileIDs.Contains(e.Type));
			var usedGolfClub = args.Player.RecentlyCreatedProjectiles.Any(e => e.Type == ProjectileID.GolfClubHelper);
			if (!usedGolfClub && !usedGolfBall)
			{
				TShock.Log.ConsoleDebug(GetString($"GolfPacketHandler: Player did not have create a golf club projectile the last 5 seconds! - From {args.Player.Name}"));
				args.Handled = true;
				return;
			}

			if (!GolfClubItemIDs.Contains(args.Player.SelectedItem.type))
			{
				TShock.Log.ConsoleDebug(GetString($"LandGolfBallInCupHandler: Item selected is not a golf club! - From {args.Player.Name}"));
				args.Handled = true;
				return;
			}
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules`
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules/AmbienceHandler.cs`
```
﻿using System.IO;

namespace TShockAPI.Handlers.NetModules
{
	/// <summary>
	/// Rejects ambience new modules from clients
	/// </summary>
	public class AmbienceHandler : INetModuleHandler
	{
		/// <summary>
		/// No deserialization needed. This should never be received by the server
		/// </summary>
		/// <param name="data"></param>
		public void Deserialize(MemoryStream data)
		{
		}

		/// <summary>
		/// This should never be received by the server
		/// </summary>
		/// <param name="player"></param>
		/// <param name="rejectPacket"></param>
		public void HandlePacket(TSPlayer player, out bool rejectPacket)
		{
			rejectPacket = true;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules/BestiaryHandler.cs`
```
﻿using System.IO;

namespace TShockAPI.Handlers.NetModules
{
	/// <summary>
	/// Rejects client->server bestiary net modules as the client should never send this to the server
	/// </summary>
	public class BestiaryHandler : INetModuleHandler
	{
		/// <summary>
		/// No deserialization needed. This should never be received by the server
		/// </summary>
		/// <param name="data"></param>
		public void Deserialize(MemoryStream data)
		{
		}

		/// <summary>
		/// This should never be received by the server
		/// </summary>
		/// <param name="player"></param>
		/// <param name="rejectPacket"></param>
		public void HandlePacket(TSPlayer player, out bool rejectPacket)
		{
			rejectPacket = true;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules/CreativePowerHandler.cs`
```
﻿using System.Collections.Generic;
using System.IO;
using System.IO.Streams;
using static TShockAPI.GetDataHandlers;

namespace TShockAPI.Handlers.NetModules
{
	/// <summary>
	/// Provides handling for the Creative Power net module. Checks permissions on all creative powers
	/// </summary>
	public class CreativePowerHandler : INetModuleHandler
	{
		/// <summary>
		/// The power type being activated
		/// </summary>
		public CreativePowerTypes PowerType { get; set; }

		/// <summary>
		/// Reads the power type from the stream
		/// </summary>
		/// <param name="data"></param>
		public void Deserialize(MemoryStream data)
		{
			PowerType = (CreativePowerTypes)data.ReadInt16();
		}

		/// <summary>
		/// Determines if the player has permission to use the power type
		/// </summary>
		/// <param name="player"></param>
		/// <param name="rejectPacket"></param>
		public void HandlePacket(TSPlayer player, out bool rejectPacket)
		{
			if (!HasPermission(PowerType, player))
			{
				rejectPacket = true;
				return;
			}

			rejectPacket = false;
		}

		/// <summary>
		/// Determines if a player has permission to use a specific creative power
		/// </summary>
		/// <param name="powerType"></param>
		/// <param name="player"></param>
		/// <returns></returns>
		public static bool HasPermission(CreativePowerTypes powerType, TSPlayer player)
		{
			if (!PowerToPermissionMap.ContainsKey(powerType))
			{
				TShock.Log.ConsoleDebug(GetString("CreativePowerHandler received permission check request for unknown creative power"));
				return false;
			}

			string permission = PowerToPermissionMap[powerType];

			//prevent being told about the spawnrate permission on join until relogic fixes
			if (!player.HasReceivedNPCPermissionError && powerType == CreativePowerTypes.SetSpawnRate)
			{
				player.HasReceivedNPCPermissionError = true;
				return false;
			}

			if (!player.HasPermission(permission))
			{
				player.SendErrorMessage(PermissionToDescriptionMap[permission]);
				return false;
			}

			return true;
		}


		/// <summary>
		/// Maps creative powers to permission nodes
		/// </summary>
		public static Dictionary<CreativePowerTypes, string> PowerToPermissionMap = new Dictionary<CreativePowerTypes, string>
		{
			{ CreativePowerTypes.FreezeTime,              Permissions.journey_timefreeze		},
			{ CreativePowerTypes.SetDawn,                 Permissions.journey_timeset			},
			{ CreativePowerTypes.SetNoon,                 Permissions.journey_timeset			},
			{ CreativePowerTypes.SetDusk,                 Permissions.journey_timeset			},
			{ CreativePowerTypes.SetMidnight,             Permissions.journey_timeset			},
			{ CreativePowerTypes.Godmode,                 Permissions.journey_godmode			},
			{ CreativePowerTypes.WindStrength,            Permissions.journey_windstrength		},
			{ CreativePowerTypes.RainStrength,            Permissions.journey_rainstrength		},
			{ CreativePowerTypes.TimeSpeed,               Permissions.journey_timespeed			},
			{ CreativePowerTypes.RainFreeze,              Permissions.journey_rainfreeze		},
			{ CreativePowerTypes.WindFreeze,              Permissions.journey_windfreeze		},
			{ CreativePowerTypes.IncreasePlacementRange,  Permissions.journey_placementrange	},
			{ CreativePowerTypes.WorldDifficulty,         Permissions.journey_setdifficulty		},
			{ CreativePowerTypes.BiomeSpreadFreeze,       Permissions.journey_biomespreadfreeze },
			{ CreativePowerTypes.SetSpawnRate,            Permissions.journey_setspawnrate		},
		};

		/// <summary>
		/// Maps journey mode permission nodes to descriptions of what the permission allows
		/// </summary>
		public static Dictionary<string, string> PermissionToDescriptionMap = new Dictionary<string, string>
		{
			{ Permissions.journey_timefreeze,			GetString("You do not have permission to freeze the time of the server.")						},
			{ Permissions.journey_timeset,				GetString("You do not have permission to modify the time of the server.")						},
			{ Permissions.journey_godmode,				GetString("You do not have permission to toggle godmode.")										},
			{ Permissions.journey_windstrength,			GetString("You do not have permission to modify the wind strength of the server.")				},
			{ Permissions.journey_rainstrength,			GetString("You do not have permission to modify the rain strength of the server.")				},
			{ Permissions.journey_timespeed,			GetString("You do not have permission to modify the time speed of the server.")					},
			{ Permissions.journey_rainfreeze,			GetString("You do not have permission to freeze the rain strength of the server.")				},
			{ Permissions.journey_windfreeze,			GetString("You do not have permission to freeze the wind strength of the server.")				},
			{ Permissions.journey_placementrange,		GetString("You do not have permission to modify the tile placement range of your character.") 	},
			{ Permissions.journey_setdifficulty,		GetString("You do not have permission to modify the world difficulty of the server.")			},
			{ Permissions.journey_biomespreadfreeze,	GetString("You do not have permission to freeze the biome spread of the server.")				},
			{ Permissions.journey_setspawnrate,			GetString("You do not have permission to modify the NPC spawn rate of the server.")				},
		};
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs`
```
﻿using System.IO;
using System.IO.Streams;
using Terraria;
using Terraria.GameContent.NetModules;
using Terraria.Net;

namespace TShockAPI.Handlers.NetModules
{
	/// <summary>
	/// Handles creative unlock requests
	/// </summary>
	public class CreativeUnlocksHandler : INetModuleHandler
	{
		/// <summary>
		/// An unknown field. If this does not have a value of '0' the packet should be rejected.
		/// </summary>
		public byte UnknownField { get; set; }
		/// <summary>
		/// ID of the item being sacrificed
		/// </summary>
		public ushort ItemId { get; set; }
		/// <summary>
		/// Stack size of the item being sacrificed
		/// </summary>
		public ushort Amount { get; set; }

		/// <summary>
		/// Reads the unlock data from the stream
		/// </summary>
		/// <param name="data"></param>
		public void Deserialize(MemoryStream data)
		{
			// For whatever reason Terraria writes '0' to the stream at the beginning of this packet.
			// If this value is not 0 then its been crafted by a non-vanilla client.
			// We don't actually know why the 0 is written, so we're just going to call this UnknownField for now
			UnknownField = data.ReadInt8();
			if (UnknownField == 0)
			{
				ItemId = data.ReadUInt16();
				Amount = data.ReadUInt16();
			}
		}

		/// <summary>
		/// Determines if the unlock is valid and the player has permission to perform the unlock.
		/// Syncs unlock status if the packet is accepted
		/// </summary>
		/// <param name="player"></param>
		/// <param name="rejectPacket"></param>
		public void HandlePacket(TSPlayer player, out bool rejectPacket)
		{
			if (!Main.GameModeInfo.IsJourneyMode)
			{
				TShock.Log.ConsoleDebug(
					GetString($"NetModuleHandler received attempt to unlock sacrifice while not in journey mode from {player.Name}")
				);

				rejectPacket = true;
				return;
			}

			if (UnknownField != 0)
			{
				TShock.Log.ConsoleDebug(
					GetString($"CreativeUnlocksHandler received non-vanilla unlock request. Random field value: {UnknownField} but should be 0 from {player.Name}")
				);

				rejectPacket = true;
				return;
			}

			if (!player.HasPermission(Permissions.journey_contributeresearch))
			{
				player.SendErrorMessage(GetString("You do not have permission to contribute research."));
				rejectPacket = true;
				return;
			}

			var totalSacrificed = TShock.ResearchDatastore.SacrificeItem(ItemId, Amount, player);

			var response = NetCreativeUnlocksModule.SerializeItemSacrifice(ItemId, totalSacrificed);
			NetManager.Instance.Broadcast(response);

			rejectPacket = false;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules/INetModuleHandler.cs`
```
﻿using System.IO;

namespace TShockAPI.Handlers.NetModules
{
	/// <summary>
	/// Describes a handler for a net module
	/// </summary>
	public interface INetModuleHandler
	{
		/// <summary>
		/// Reads the net module's data from the given stream
		/// </summary>
		/// <param name="data"></param>
		void Deserialize(MemoryStream data);

		/// <summary>
		/// Provides handling for the packet and determines if it should be accepted or rejected
		/// </summary>
		/// <param name="player"></param>
		/// <param name="rejectPacket"></param>
		void HandlePacket(TSPlayer player, out bool rejectPacket);
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules/LiquidHandler.cs`
```
﻿using System.IO;

namespace TShockAPI.Handlers.NetModules
{
	/// <summary>
	/// Handles the NetLiquidModule. Rejects all incoming net liquid requests, as clients should never send them
	/// </summary>
	public class LiquidHandler : INetModuleHandler
	{
		/// <summary>
		/// Does nothing. We should not deserialize this data
		/// </summary>
		/// <param name="data"></param>
		public void Deserialize(MemoryStream data)
		{
			// No need to deserialize
		}

		/// <summary>
		/// Rejects the packet. Clients should not send this to us
		/// </summary>
		/// <param name="player"></param>
		/// <param name="rejectPacket"></param>
		public void HandlePacket(TSPlayer player, out bool rejectPacket)
		{
			rejectPacket = true;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules/NetModulePacketHandler.cs`
```
﻿using System;
using System.Collections.Generic;
using Terraria;
using static TShockAPI.GetDataHandlers;

namespace TShockAPI.Handlers.NetModules
{
	/// <summary>
	/// Handles packet 82 - Load Net Module packets
	/// </summary>
	public class NetModulePacketHandler : IPacketHandler<ReadNetModuleEventArgs>
	{
		/// <summary>
		/// Maps net module types to handlers for the net module type. Add to or edit this dictionary to customise handling
		/// </summary>
		public static Dictionary<NetModuleType, Type> NetModulesToHandlersMap = new Dictionary<NetModuleType, Type>
		{
			{ NetModuleType.CreativePowers,               typeof(CreativePowerHandler)    },
			{ NetModuleType.CreativeUnlocksPlayerReport,  typeof(CreativeUnlocksHandler)  },
			{ NetModuleType.TeleportPylon,                typeof(PylonHandler)            },
			{ NetModuleType.Liquid,                       typeof(LiquidHandler)           },
			{ NetModuleType.Bestiary,                     typeof(BestiaryHandler)         },
			{ NetModuleType.Ambience,                     typeof(AmbienceHandler)         }
		};

		/// <summary>
		/// Invoked when a load net module packet is received. This method picks a <see cref="INetModuleHandler"/> based on the
		/// net module type being loaded, then forwards the data to the chosen handler to process
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		public void OnReceive(object sender, ReadNetModuleEventArgs args)
		{
			INetModuleHandler handler;

			if (NetModulesToHandlersMap.ContainsKey(args.ModuleType))
			{
				handler = (INetModuleHandler)Activator.CreateInstance(NetModulesToHandlersMap[args.ModuleType]);
			}
			else
			{
				// We don't have handlers for NetModuleType.Ping and NetModuleType.Particles.
				// These net modules are fairly innocuous and can be processed normally by the game
				args.Handled = false;
				return;
			}

			handler.Deserialize(args.Data);
			handler.HandlePacket(args.Player, out bool rejectPacket);

			args.Handled = rejectPacket;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/NetModules/PylonHandler.cs`
```
﻿using System.IO;
using System.IO.Streams;
using Terraria.GameContent;
using static Terraria.GameContent.NetModules.NetTeleportPylonModule;

namespace TShockAPI.Handlers.NetModules
{
	/// <summary>
	/// Handles a pylon net module
	/// </summary>
	public class PylonHandler : INetModuleHandler
	{
		/// <summary>
		/// Event occurring
		/// </summary>
		public SubPacketType PylonEventType { get; set; }
		/// <summary>
		/// Tile X coordinate of the pylon
		/// </summary>
		public short TileX { get; set; }
		/// <summary>
		/// Tile Y coordinate of the pylon
		/// </summary>
		public short TileY { get; set; }
		/// <summary>
		/// Type of Pylon
		/// </summary>
		public TeleportPylonType PylonType { get; set; }

		/// <summary>
		/// Reads the pylon data from the net module
		/// </summary>
		/// <param name="data"></param>
		public void Deserialize(MemoryStream data)
		{
			PylonEventType = (SubPacketType)data.ReadInt8();
			TileX = data.ReadInt16();
			TileY = data.ReadInt16();
			PylonType = (TeleportPylonType)data.ReadInt8();
		}

		/// <summary>
		/// Rejects a pylon teleport request if the player does not have permission
		/// </summary>
		/// <param name="player"></param>
		/// <param name="rejectPacket"></param>
		public void HandlePacket(TSPlayer player, out bool rejectPacket)
		{
			if (PylonEventType == SubPacketType.PlayerRequestsTeleport)
			{
				if (!player.HasPermission(Permissions.pylon))
				{
					rejectPacket = true;
					player.SendErrorMessage(GetString("You do not have permission to teleport using pylons."));
					return;
				}
			}

			rejectPacket = false;
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Handlers`
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs`
```
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria;
using Terraria.DataStructures;
using Terraria.GameContent.Tile_Entities;
using static TShockAPI.GetDataHandlers;

namespace TShockAPI.Handlers
{
	/// <summary>
	///
	/// </summary>
	public class RequestTileEntityInteractionHandler : IPacketHandler<RequestTileEntityInteractionEventArgs>
	{
		public void OnReceive(object sender, RequestTileEntityInteractionEventArgs args)
		{
			if (args.TileEntity is TEHatRack && !args.Player.HasBuildPermissionForTileObject(args.TileEntity.Position.X, args.TileEntity.Position.Y, TEHatRack.entityTileWidth, TEHatRack.entityTileHeight, false))
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to modify a Hat Rack in a protected area!"));
				args.Handled = true;
				return;
			}
			else if (args.TileEntity is TEDisplayDoll && !args.Player.HasBuildPermissionForTileObject(args.TileEntity.Position.X, args.TileEntity.Position.Y, TEDisplayDoll.entityTileWidth, TEDisplayDoll.entityTileHeight, false))
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to modify a Mannequin in a protected area!"));
				args.Handled = true;
				return;
			}
			else if (!args.Player.HasBuildPermission(args.TileEntity.Position.X, args.TileEntity.Position.Y, false))
			{
				args.Player.SendErrorMessage(GetString("You do not have permission to modify a TileEntity in a protected area!"));
				TShock.Log.ConsoleDebug(GetString($"RequestTileEntityInteractionHandler: Rejected packet due to lack of building permissions! - From {args.Player.Name} | Position X:{args.TileEntity.Position.X} Y:{args.TileEntity.Position.Y}, TileEntity type: {args.TileEntity.type}, Tile type: {Main.tile[args.TileEntity.Position.X, args.TileEntity.Position.Y].type}"));
				args.Handled = true;
				return;
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/SendTileRectHandler.cs`
```
﻿using System.Collections.Generic;
using System.IO;

using Terraria;
using Terraria.ID;

using TShockAPI.Net;

namespace TShockAPI.Handlers
{
	/// <summary>
	/// Provides processors for handling tile rect packets.
	/// This required many hours of reverse engineering work, and is kindly provided to TShock for free by @punchready.
	/// </summary>
	public sealed class SendTileRectHandler : IPacketHandler<GetDataHandlers.SendTileRectEventArgs>
	{
		/// <summary>
		/// Represents a tile rectangle sent through the packet.
		/// </summary>
		private sealed class TileRect
		{
			private readonly NetTile[,] _tiles;
			public readonly int X;
			public readonly int Y;
			public readonly int Width;
			public readonly int Height;

			/// <summary>
			/// Accesses the tiles contained in this rect.
			/// </summary>
			/// <param name="x">The X coordinate within the rect.</param>
			/// <param name="y">The Y coordinate within the rect.</param>
			/// <returns>The tile at the given position within the rect.</returns>
			public NetTile this[int x, int y] => _tiles[x, y];

			/// <summary>
			/// Constructs a new tile rect based on the given information.
			/// </summary>
			public TileRect(NetTile[,] tiles, int x, int y, int width, int height)
			{
				_tiles = tiles;
				X = x;
				Y = y;
				Width = width;
				Height = height;
			}

			/// <summary>
			/// Reads a tile rect from the given stream.
			/// </summary>
			/// <returns>The resulting tile rect.</returns>
			public static TileRect Read(MemoryStream stream, int tileX, int tileY, int width, int height)
			{
				NetTile[,] tiles = new NetTile[width, height];
				for (int x = 0; x < width; x++)
				{
					for (int y = 0; y < height; y++)
					{
						tiles[x, y] = new NetTile();
						tiles[x, y].Unpack(stream); // explicit > implicit
					}
				}
				return new TileRect(tiles, tileX, tileY, width, height);
			}
		}

		/// <summary>
		/// Represents a common tile rect operation (Placement, State Change, Removal).
		/// </summary>
		private readonly struct TileRectMatch
		{
			private const short IGNORE_FRAME = -1;

			private enum MatchType
			{
				Placement,
				StateChange,
				Removal,
			}

			public enum MatchResult
			{
				NotMatched,
				RejectChanges,
				BroadcastChanges,
			}

			private readonly int Width;
			private readonly int Height;

			private readonly ushort TileType;
			private readonly short MaxFrameX;
			private readonly short MaxFrameY;
			private readonly short FrameXStep;
			private readonly short FrameYStep;

			private readonly MatchType Type;

			private TileRectMatch(MatchType type, int width, int height, ushort tileType, short maxFrameX, short maxFrameY, short frameXStep, short frameYStep)
			{
				Type = type;
				Width = width;
				Height = height;
				TileType = tileType;
				MaxFrameX = maxFrameX;
				MaxFrameY = maxFrameY;
				FrameXStep = frameXStep;
				FrameYStep = frameYStep;
			}

			/// <summary>
			/// Creates a new placement operation.
			/// </summary>
			/// <param name="width">The width of the placement.</param>
			/// <param name="height">The height of the placement.</param>
			/// <param name="tileType">The tile type of the placement.</param>
			/// <param name="maxFrameX">The maximum allowed frameX of the placement.</param>
			/// <param name="maxFrameY">The maximum allowed frameY of the placement.</param>
			/// <param name="frameXStep">The step size in which frameX changes for this placement, or <c>1</c> if any value is allowed.</param>
			/// <param name="frameYStep">The step size in which frameX changes for this placement, or <c>1</c> if any value is allowed.</param>
			/// <returns>The resulting operation match.</returns>
			public static TileRectMatch Placement(int width, int height, ushort tileType, short maxFrameX, short maxFrameY, short frameXStep, short frameYStep)
			{
				return new TileRectMatch(MatchType.Placement, width, height, tileType, maxFrameX, maxFrameY, frameXStep, frameYStep);
			}

			/// <summary>
			/// Creates a new state change operation.
			/// </summary>
			/// <param name="width">The width of the state change.</param>
			/// <param name="height">The height of the state change.</param>
			/// <param name="tileType">The target tile type of the state change.</param>
			/// <param name="maxFrameX">The maximum allowed frameX of the state change.</param>
			/// <param name="maxFrameY">The maximum allowed frameY of the state change.</param>
			/// <param name="frameXStep">The step size in which frameX changes for this placement, or <c>1</c> if any value is allowed.</param>
			/// <param name="frameYStep">The step size in which frameY changes for this placement, or <c>1</c> if any value is allowed.</param>
			/// <returns>The resulting operation match.</returns>
			public static TileRectMatch StateChange(int width, int height, ushort tileType, short maxFrameX, short maxFrameY, short frameXStep, short frameYStep)
			{
				return new TileRectMatch(MatchType.StateChange, width, height, tileType, maxFrameX, maxFrameY, frameXStep, frameYStep);
			}

			/// <summary>
			/// Creates a new state change operation which only changes frameX.
			/// </summary>
			/// <param name="width">The width of the state change.</param>
			/// <param name="height">The height of the state change.</param>
			/// <param name="tileType">The target tile type of the state change.</param>
			/// <param name="maxFrame">The maximum allowed frameX of the state change.</param>
			/// <param name="frameStep">The step size in which frameX changes for this placement, or <c>1</c> if any value is allowed.</param>
			/// <returns>The resulting operation match.</returns>
			public static TileRectMatch StateChangeX(int width, int height, ushort tileType, short maxFrame, short frameStep)
			{
				return new TileRectMatch(MatchType.StateChange, width, height, tileType, maxFrame, IGNORE_FRAME, frameStep, 0);
			}

			/// <summary>
			/// Creates a new state change operation which only changes frameY.
			/// </summary>
			/// <param name="width">The width of the state change.</param>
			/// <param name="height">The height of the state change.</param>
			/// <param name="tileType">The target tile type of the state change.</param>
			/// <param name="maxFrame">The maximum allowed frameY of the state change.</param>
			/// <param name="frameStep">The step size in which frameY changes for this placement, or <c>1</c> if any value is allowed.</param>
			/// <returns>The resulting operation match.</returns>
			public static TileRectMatch StateChangeY(int width, int height, ushort tileType, short maxFrame, short frameStep)
			{
				return new TileRectMatch(MatchType.StateChange, width, height, tileType, IGNORE_FRAME, maxFrame, 0, frameStep);
			}

			/// <summary>
			/// Creates a new removal operation.
			/// </summary>
			/// <param name="width">The width of the removal.</param>
			/// <param name="height">The height of the removal.</param>
			/// <param name="tileType">The target tile type of the removal.</param>
			/// <returns>The resulting operation match.</returns>
			public static TileRectMatch Removal(int width, int height, ushort tileType)
			{
				return new TileRectMatch(MatchType.Removal, width, height, tileType, 0, 0, 0, 0);
			}

			/// <summary>
			/// Determines whether the given tile rectangle matches this operation, and if so, applies it to the world.
			/// </summary>
			/// <param name="player">The player the operation originates from.</param>
			/// <param name="rect">The tile rectangle of the operation.</param>
			/// <returns><see langword="true"/>, if the rect matches this operation and the changes have been applied, otherwise <see langword="false"/>.</returns>
			public MatchResult Matches(TSPlayer player, TileRect rect)
			{
				if (rect.Width != Width || rect.Height != Height)
				{
					return MatchResult.NotMatched;
				}

				for (int x = 0; x < rect.Width; x++)
				{
					for (int y = 0; y < rect.Height; y++)
					{
						NetTile tile = rect[x, y];
						if (Type is MatchType.Placement or MatchType.StateChange)
						{
							if (tile.Type != TileType)
							{
								return MatchResult.NotMatched;
							}
						}
						if (Type is MatchType.Placement or MatchType.StateChange)
						{
							if (MaxFrameX != IGNORE_FRAME)
							{
								if (tile.FrameX < 0 || tile.FrameX > MaxFrameX || tile.FrameX % FrameXStep != 0)
								{
									return MatchResult.NotMatched;
								}
							}
							if (MaxFrameY != IGNORE_FRAME)
							{
								if (tile.FrameY < 0 || tile.FrameY > MaxFrameY || tile.FrameY % FrameYStep != 0)
								{
									// this is the only tile type sent in a tile rect where the frame have a different pattern (56, 74, 92 instead of 54, 72, 90)
									if (!(TileType == TileID.LunarMonolith && tile.FrameY % FrameYStep == 2))
									{
										return MatchResult.NotMatched;
									}
								}
							}
						}
						if (Type == MatchType.Removal)
						{
							if (tile.Active)
							{
								return MatchResult.NotMatched;
							}
						}
					}
				}

				for (int x = rect.X; x < rect.X + rect.Width; x++)
				{
					for (int y = rect.Y; y < rect.Y + rect.Height; y++)
					{
						if (!player.HasBuildPermission(x, y))
						{
							// for simplicity, let's pretend that the edit was valid, but do not execute it
							return MatchResult.RejectChanges;
						}
					}
				}

				switch (Type)
				{
					case MatchType.Placement:
						{
							return MatchPlacement(player, rect);
						}
					case MatchType.StateChange:
						{
							return MatchStateChange(player, rect);
						}
					case MatchType.Removal:
						{
							return MatchRemoval(player, rect);
						}
				}

				return MatchResult.NotMatched;
			}

			private MatchResult MatchPlacement(TSPlayer player, TileRect rect)
			{
				for (int x = rect.X; x < rect.X + rect.Width; x++)
				{
					for (int y = rect.Y; y < rect.Y + rect.Height; y++)
					{
						if (Main.tile[x, y].active()) // the client will kill tiles that auto break before placing the object
						{
							return MatchResult.NotMatched;
						}
					}
				}

				// let's hope tile types never go out of short range (they use ushort in terraria's code)
				if (TShock.TileBans.TileIsBanned((short)TileType, player))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return MatchResult.RejectChanges;
				}

				for (int x = 0; x < rect.Width; x++)
				{
					for (int y = 0; y < rect.Height; y++)
					{
						Main.tile[x + rect.X, y + rect.Y].active(active: true);
						Main.tile[x + rect.X, y + rect.Y].type = rect[x, y].Type;
						Main.tile[x + rect.X, y + rect.Y].frameX = rect[x, y].FrameX;
						Main.tile[x + rect.X, y + rect.Y].frameY = rect[x, y].FrameY;
					}
				}

				return MatchResult.BroadcastChanges;
			}

			private MatchResult MatchStateChange(TSPlayer player, TileRect rect)
			{
				for (int x = rect.X; x < rect.X + rect.Width; x++)
				{
					for (int y = rect.Y; y < rect.Y + rect.Height; y++)
					{
						if (!Main.tile[x, y].active() || Main.tile[x, y].type != TileType)
						{
							return MatchResult.NotMatched;
						}
					}
				}

				for (int x = 0; x < rect.Width; x++)
				{
					for (int y = 0; y < rect.Height; y++)
					{
						if (MaxFrameX != IGNORE_FRAME)
						{
							Main.tile[x + rect.X, y + rect.Y].frameX = rect[x, y].FrameX;
						}
						if (MaxFrameY != IGNORE_FRAME)
						{
							Main.tile[x + rect.X, y + rect.Y].frameY = rect[x, y].FrameY;
						}
					}
				}

				return MatchResult.BroadcastChanges;
			}

			private MatchResult MatchRemoval(TSPlayer player, TileRect rect)
			{
				for (int x = rect.X; x < rect.X + rect.Width; x++)
				{
					for (int y = rect.Y; y < rect.Y + rect.Height; y++)
					{
						if (!Main.tile[x, y].active() || Main.tile[x, y].type != TileType)
						{
							return MatchResult.NotMatched;
						}
					}
				}

				for (int x = 0; x < rect.Width; x++)
				{
					for (int y = 0; y < rect.Height; y++)
					{
						Main.tile[x + rect.X, y + rect.Y].active(active: false);
						Main.tile[x + rect.X, y + rect.Y].frameX = -1;
						Main.tile[x + rect.X, y + rect.Y].frameY = -1;
					}
				}

				return MatchResult.BroadcastChanges;
			}
		}

		/// <summary>
		/// Contains the complete list of valid tile rect operations the game currently performs.
		/// </summary>
		// The matches restrict the tile rects to only place one kind of tile, and only with the given maximum values and step sizes for frameX and frameY. This performs pretty much perfect checks on the data, allowing only valid placements.
		// For TileID.MinecartTrack, the data is taken from `Minecart._trackSwitchOptions`, allowing any framing value in this array (currently 0-36).
		// For TileID.Plants, it is taken from `ItemID.Sets.flowerPacketInfo[n].stylesOnPurity`, allowing every style multiplied by 18.
		// The other operations are based on code analysis and manual observation.
		private static readonly TileRectMatch[] Matches = new TileRectMatch[]
		{
			TileRectMatch.Placement(2, 3, TileID.TargetDummy, 54, 36, 18, 18),
			TileRectMatch.Placement(3, 4, TileID.TeleportationPylon, 468, 54, 18, 18),
			TileRectMatch.Placement(2, 3, TileID.DisplayDoll, 126, 36, 18, 18),
			TileRectMatch.Placement(3, 4, TileID.HatRack, 90, 54, 18, 18),
			TileRectMatch.Placement(2, 2, TileID.ItemFrame, 162, 18, 18, 18),
			TileRectMatch.Placement(3, 3, TileID.WeaponsRack2, 90, 36, 18, 18),
			TileRectMatch.Placement(1, 1, TileID.FoodPlatter, 18, 0, 18, 18),
			TileRectMatch.Placement(1, 1, TileID.LogicSensor, 108, 0, 18, 18),

			TileRectMatch.StateChangeY(3, 2, TileID.Campfire, 54, 18),
			TileRectMatch.StateChangeY(4, 3, TileID.Cannon, 468, 18),
			TileRectMatch.StateChangeY(2, 2, TileID.ArrowSign, 270, 18),
			TileRectMatch.StateChangeY(2, 2, TileID.PaintedArrowSign, 270, 18),

			TileRectMatch.StateChangeX(2, 2, TileID.MusicBoxes, 54, 18),

			TileRectMatch.StateChangeY(2, 3, TileID.LunarMonolith, 92, 18),
			TileRectMatch.StateChangeY(2, 3, TileID.BloodMoonMonolith, 90, 18),
			TileRectMatch.StateChangeY(2, 3, TileID.VoidMonolith, 90, 18),
			TileRectMatch.StateChangeY(2, 3, TileID.EchoMonolith, 90, 18),
			TileRectMatch.StateChangeY(2, 3, TileID.ShimmerMonolith, 144, 18),
			TileRectMatch.StateChangeY(2, 4, TileID.WaterFountain, 126, 18),

			TileRectMatch.StateChangeX(1, 1, TileID.Candles, 18, 18),
			TileRectMatch.StateChangeX(1, 1, TileID.PeaceCandle, 18, 18),
			TileRectMatch.StateChangeX(1, 1, TileID.WaterCandle, 18, 18),
			TileRectMatch.StateChangeX(1, 1, TileID.PlatinumCandle, 18, 18),
			TileRectMatch.StateChangeX(1, 1, TileID.ShadowCandle, 18, 18),

			TileRectMatch.StateChange(1, 1, TileID.Traps, 90, 90, 18, 18),

			TileRectMatch.StateChangeX(1, 1, TileID.WirePipe, 36, 18),
			TileRectMatch.StateChangeX(1, 1, TileID.ProjectilePressurePad, 66, 22),
			TileRectMatch.StateChangeX(1, 1, TileID.Plants, 792, 18),
			TileRectMatch.StateChangeX(1, 1, TileID.MinecartTrack, 36, 1),

			TileRectMatch.Removal(1, 2, TileID.Firework),
			TileRectMatch.Removal(1, 1, TileID.LandMine),
		};


		/// <summary>
		/// Handles a packet receive event.
		/// </summary>
		public void OnReceive(object sender, GetDataHandlers.SendTileRectEventArgs args)
		{
			// this permission bypasses all checks for direct access to the world
			if (args.Player.HasPermission(Permissions.allowclientsideworldedit))
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect accepted clientside world edit from {args.Player.Name}"));

				// use vanilla handling
				args.Handled = false;
				return;
			}

			// this handler handles the entire logic of this packet
			args.Handled = true;

			// as of 1.4 this is the biggest size the client will send in any case, determined by full code analysis
			// see default matches above and special cases below
			if (args.Width > 4 || args.Length > 4)
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect rejected from size from {args.Player.Name}"));

				// definitely invalid; do not send any correcting data
				return;
			}

			// player throttled?
			if (args.Player.IsBouncerThrottled())
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect rejected from throttle from {args.Player.Name}"));

				// send correcting data
				args.Player.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
				return;
			}

			// player disabled?
			if (args.Player.IsBeingDisabled())
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect rejected from being disabled from {args.Player.Name}"));

				// send correcting data
				args.Player.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
				return;
			}

			// read the tile rectangle
			TileRect rect = TileRect.Read(args.Data, args.TileX, args.TileY, args.Width, args.Length);

			// check if the positioning is valid
			if (!IsRectPositionValid(args.Player, rect))
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect rejected from out of bounds / build permission from {args.Player.Name}"));

				// send nothing due to out of bounds
				return;
			}

			// a very special case, due to the clentaminator having a larger range than TSPlayer.IsInRange() allows
			if (MatchesConversionSpread(args.Player, rect))
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect reimplemented from {args.Player.Name}"));

				// send correcting data
				args.Player.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
				return;
			}

			// check if the distance is valid
			if (!IsRectDistanceValid(args.Player, rect))
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect rejected from out of range from {args.Player.Name}"));

				// send correcting data
				args.Player.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
				return;
			}

			// a very special case, due to the flower seed check otherwise hijacking this
			if (MatchesFlowerBoots(args.Player, rect))
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect reimplemented from {args.Player.Name}"));

				// send correcting data
				args.Player.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
				return;
			}

			// check if the rect matches any valid operation
			foreach (TileRectMatch match in Matches)
			{
				var result = match.Matches(args.Player, rect);
				if (result != TileRectMatch.MatchResult.NotMatched)
				{
					TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect reimplemented from {args.Player.Name}"));

					// send correcting data
					if (result == TileRectMatch.MatchResult.RejectChanges)
						args.Player.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
					if (result == TileRectMatch.MatchResult.BroadcastChanges)
						TSPlayer.All.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
					return;
				}
			}

			// a few special cases
			if (MatchesGrassMow(args.Player, rect) || MatchesChristmasTree(args.Player, rect))
			{
				TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect reimplemented from {args.Player.Name}"));

				// send correcting data
				args.Player.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
				return;
			}

			TShock.Log.ConsoleDebug(GetString($"Bouncer / SendTileRect rejected from matches from {args.Player.Name}"));

			// send correcting data
			args.Player.SendTileRect(args.TileX, args.TileY, args.Width, args.Length);
			return;
		}

		/// <summary>
		/// Checks whether the tile rect is at a valid position for the given player.
		/// </summary>
		/// <param name="player">The player the operation originates from.</param>
		/// <param name="rect">The tile rectangle of the operation.</param>
		/// <returns><see langword="true"/>, if the rect at a valid position, otherwise <see langword="false"/>.</returns>
		private static bool IsRectPositionValid(TSPlayer player, TileRect rect)
		{
			for (int x = 0; x < rect.Width; x++)
			{
				for (int y = 0; y < rect.Height; y++)
				{
					int realX = rect.X + x;
					int realY = rect.Y + y;

					if (realX < 0 || realX >= Main.maxTilesX || realY < 0 || realY >= Main.maxTilesY)
					{
						return false;
					}
				}
			}

			return true;
		}

		/// <summary>
		/// Checks whether the tile rect is at a valid distance to the given player.
		/// </summary>
		/// <param name="player">The player the operation originates from.</param>
		/// <param name="rect">The tile rectangle of the operation.</param>
		/// <returns><see langword="true"/>, if the rect at a valid distance, otherwise <see langword="false"/>.</returns>
		private static bool IsRectDistanceValid(TSPlayer player, TileRect rect)
		{
			for (int x = 0; x < rect.Width; x++)
			{
				for (int y = 0; y < rect.Height; y++)
				{
					int realX = rect.X + x;
					int realY = rect.Y + y;

					if (!player.IsInRange(realX, realY))
					{
						return false;
					}
				}
			}

			return true;
		}


		/// <summary>
		/// Checks whether the tile rect is a valid conversion spread (Clentaminator, Powders, etc.).
		/// </summary>
		/// <param name="player">The player the operation originates from.</param>
		/// <param name="rect">The tile rectangle of the operation.</param>
		/// <returns><see langword="true"/>, if the rect matches a conversion spread operation, otherwise <see langword="false"/>.</returns>
		private static bool MatchesConversionSpread(TSPlayer player, TileRect rect)
		{
			if (rect.Width != 1 || rect.Height != 1)
			{
				return false;
			}

			ITile oldTile = Main.tile[rect.X, rect.Y];
			NetTile newTile = rect[0, 0];

			WorldGenMock.SimulateConversionChange(rect.X, rect.Y, out HashSet<ushort> validTiles, out HashSet<ushort> validWalls);

			if (newTile.Type != oldTile.type && validTiles.Contains(newTile.Type))
			{
				if (TShock.TileBans.TileIsBanned((short)newTile.Type, player))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return true;
				}
				else if (!player.HasBuildPermission(rect.X, rect.Y))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return true;
				}
				else
				{
					Main.tile[rect.X, rect.Y].type = newTile.Type;
					Main.tile[rect.X, rect.Y].frameX = newTile.FrameX;
					Main.tile[rect.X, rect.Y].frameY = newTile.FrameY;

					return true;
				}
			}

			if (newTile.Wall != oldTile.wall && validWalls.Contains(newTile.Wall))
			{
				// wallbans when?

				if (!player.HasBuildPermission(rect.X, rect.Y))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return true;
				}
				else
				{
					Main.tile[rect.X, rect.Y].wall = newTile.Wall;

					return true;
				}
			}

			return false;
		}


		private static readonly Dictionary<ushort, HashSet<ushort>> PlantToGrassMap = new Dictionary<ushort, HashSet<ushort>>
		{
			{ TileID.Plants, new HashSet<ushort>()
			{
				TileID.Grass, TileID.GolfGrass
			} },
			{ TileID.HallowedPlants, new HashSet<ushort>()
			{
				TileID.HallowedGrass, TileID.GolfGrassHallowed
			} },
			{ TileID.HallowedPlants2, new HashSet<ushort>()
			{
				TileID.HallowedGrass, TileID.GolfGrassHallowed
			} },
			{ TileID.JunglePlants2, new HashSet<ushort>()
			{
				TileID.JungleGrass
			} },
			{ TileID.AshPlants, new HashSet<ushort>()
			{
				TileID.AshGrass
			} },
		};

		private static readonly Dictionary<ushort, HashSet<ushort>> GrassToStyleMap = new Dictionary<ushort, HashSet<ushort>>()
		{
			{ TileID.Plants, new HashSet<ushort>()
			{
				6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42,
				22, 23, 25, 26, 28, 29, 31, 32, 34, 35, 37, 38, 40, 41, 43, 44,
			} },
			{ TileID.HallowedPlants, new HashSet<ushort>()
			{
				4, 6,
			} },
			{ TileID.HallowedPlants2, new HashSet<ushort>()
			{
				2, 3, 4, 6, 7,
			} },
			{ TileID.JunglePlants2, new HashSet<ushort>()
			{
				9, 10, 11, 12, 13, 14, 15, 16,
			} },
			{ TileID.AshPlants, new HashSet<ushort>()
			{
				6, 7, 8, 9, 10,
			} },
		};

		/// <summary>
		/// Checks whether the tile rect is a valid Flower Boots placement.
		/// </summary>
		/// <param name="player">The player the operation originates from.</param>
		/// <param name="rect">The tile rectangle of the operation.</param>
		/// <returns><see langword="true"/>, if the rect matches a Flower Boots placement, otherwise <see langword="false"/>.</returns>
		private static bool MatchesFlowerBoots(TSPlayer player, TileRect rect)
		{
			if (rect.Width != 1 || rect.Height != 1)
			{
				return false;
			}

			if (!player.TPlayer.flowerBoots)
			{
				return false;
			}

			ITile oldTile = Main.tile[rect.X, rect.Y];
			NetTile newTile = rect[0, 0];

			if (
				PlantToGrassMap.TryGetValue(newTile.Type, out HashSet<ushort> grassTiles) &&
				!oldTile.active() && grassTiles.Contains(Main.tile[rect.X, rect.Y + 1].type) &&
				GrassToStyleMap[newTile.Type].Contains((ushort)(newTile.FrameX / 18))
			)
			{
				if (TShock.TileBans.TileIsBanned((short)newTile.Type, player))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return true;
				}

				if (!player.HasBuildPermission(rect.X, rect.Y))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return true;
				}

				Main.tile[rect.X, rect.Y].active(active: true);
				Main.tile[rect.X, rect.Y].type = newTile.Type;
				Main.tile[rect.X, rect.Y].frameX = newTile.FrameX;
				Main.tile[rect.X, rect.Y].frameY = 0;

				return true;
			}

			return false;
		}


		private static readonly Dictionary<ushort, ushort> GrassToMowedMap = new Dictionary<ushort, ushort>
		{
			{ TileID.Grass, TileID.GolfGrass },
			{ TileID.HallowedGrass, TileID.GolfGrassHallowed },
		};

		/// <summary>
		/// Checks whether the tile rect is a valid grass mow.
		/// </summary>
		/// <param name="player">The player the operation originates from.</param>
		/// <param name="rect">The tile rectangle of the operation.</param>
		/// <returns><see langword="true"/>, if the rect matches a grass mowing operation, otherwise <see langword="false"/>.</returns>
		private static bool MatchesGrassMow(TSPlayer player, TileRect rect)
		{
			if (rect.Width != 1 || rect.Height != 1)
			{
				return false;
			}

			ITile oldTile = Main.tile[rect.X, rect.Y];
			NetTile newTile = rect[0, 0];

			if (GrassToMowedMap.TryGetValue(oldTile.type, out ushort mowed) && newTile.Type == mowed)
			{
				if (TShock.TileBans.TileIsBanned((short)newTile.Type, player))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return true;
				}

				if (!player.HasBuildPermission(rect.X, rect.Y))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return true;
				}

				Main.tile[rect.X, rect.Y].type = newTile.Type;
				if (!newTile.FrameImportant)
				{
					Main.tile[rect.X, rect.Y].frameX = -1;
					Main.tile[rect.X, rect.Y].frameY = -1;
				}

				// prevent a common crash when the game checks all vines in an unlimited horizontal length
				if (TileID.Sets.IsVine[Main.tile[rect.X, rect.Y + 1].type])
				{
					WorldGen.KillTile(rect.X, rect.Y + 1);
				}

				return true;
			}

			return false;
		}


		/// <summary>
		/// Checks whether the tile rect is a valid christmas tree modification.
		/// This also required significant reverse engineering effort.
		/// </summary>
		/// <param name="player">The player the operation originates from.</param>
		/// <param name="rect">The tile rectangle of the operation.</param>
		/// <returns><see langword="true"/>, if the rect matches a christmas tree operation, otherwise <see langword="false"/>.</returns>
		private static bool MatchesChristmasTree(TSPlayer player, TileRect rect)
		{
			if (rect.Width != 1 || rect.Height != 1)
			{
				return false;
			}

			ITile oldTile = Main.tile[rect.X, rect.Y];
			NetTile newTile = rect[0, 0];

			if (oldTile.type == TileID.ChristmasTree && newTile.Type == TileID.ChristmasTree)
			{
				if (newTile.FrameX != 10)
				{
					return false;
				}

				int obj_0 = (newTile.FrameY & 0b0000000000000111);
				int obj_1 = (newTile.FrameY & 0b0000000000111000) >> 3;
				int obj_2 = (newTile.FrameY & 0b0000001111000000) >> 6;
				int obj_3 = (newTile.FrameY & 0b0011110000000000) >> 10;
				int obj_x = (newTile.FrameY & 0b1100000000000000) >> 14;

				if (obj_x != 0)
				{
					return false;
				}

				if (obj_0 is < 0 or > 4 || obj_1 is < 0 or > 6 || obj_2 is < 0 or > 11 || obj_3 is < 0 or > 11)
				{
					return false;
				}

				if (!player.HasBuildPermission(rect.X, rect.Y))
				{
					// for simplicity, let's pretend that the edit was valid, but do not execute it
					return true;
				}

				Main.tile[rect.X, rect.Y].frameY = newTile.FrameY;

				return true;
			}

			return false;
		}
	}

	/// <summary>
	/// This helper class allows simulating a `WorldGen.Convert` call and retrieving all valid changes for a given tile.
	/// </summary>
	internal static class WorldGenMock
	{
		/// <summary>
		/// This is a mock tile which collects all possible changes the `WorldGen.Convert` code could make in its property setters.
		/// </summary>
		private sealed class MockTile
		{
			private readonly HashSet<ushort> _setTypes;
			private readonly HashSet<ushort> _setWalls;

			private ushort _type;
			private ushort _wall;

			public MockTile(ushort type, ushort wall, HashSet<ushort> setTypes, HashSet<ushort> setWalls)
			{
				_setTypes = setTypes;
				_setWalls = setWalls;
				_type = type;
				_wall = wall;
			}

#pragma warning disable IDE1006

			public ushort type
			{
				get => _type;
				set
				{
					_setTypes.Add(value);
					_type = value;
				}
			}

			public ushort wall
			{
				get => _wall;
				set
				{
					_setWalls.Add(value);
					_wall = value;
				}
			}

#pragma warning restore IDE1006
		}

		/// <summary>
		/// Simulates what would happen if `WorldGen.Convert` was called on the given coordinates and returns two sets with the possible tile type and wall types that the conversion could change the tile to.
		/// </summary>
		public static void SimulateConversionChange(int x, int y, out HashSet<ushort> validTiles, out HashSet<ushort> validWalls)
		{
			validTiles = new HashSet<ushort>();
			validWalls = new HashSet<ushort>();

			// all the conversion types used in the code, most apparent in Projectile ai 31
			foreach (int conversionType in new int[] { 0, 1, 2, 3, 4, 5, 6, 7 })
			{
				MockTile mock = new(Main.tile[x, y].type, Main.tile[x, y].wall, validTiles, validWalls);
				Convert(mock, x, y, conversionType);
			}
		}

		/*
		 * This is a copy of the `WorldGen.Convert` method with the following precise changes:
		 *  - Added a `MockTile tile` parameter
		 *  - Changed the `i` and `j` parameters to `k` and `l`
		 *  - Removed the size parameter
		 *  - Removed the area loop and `Tile tile = Main.tile[k, l]` access in favor of using the tile parameter
		 *  - Removed all calls to `WorldGen.SquareWallFrame`, `NetMessage.SendTileSquare`, `WorldGen.TryKillingTreesAboveIfTheyWouldBecomeInvalid`
		 *  - Changed all `continue` statements to `break` statements
		 *  - Removed the ifs checking the bounds of the tile and wall types
		 *  - Removed branches that would call `WorldGen.KillTile`
		 *  - Changed branches depending on randomness to instead set the property to both values after one another
		 *
		 * This overall leads to a method that can be called on a MockTile and real-world coordinates and will spit out the proper conversion changes into the MockTile.
		 */

		private static void Convert(MockTile tile, int k, int l, int conversionType)
		{
			int type = tile.type;
			int wall = tile.wall;
			switch (conversionType)
			{
				case 4:
					if (WallID.Sets.Conversion.Grass[wall] && wall != 81)
					{
						tile.wall = 81;
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall != 83)
					{
						tile.wall = 83;
					}
					else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 218)
					{
						tile.wall = 218;
					}
					else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 221)
					{
						tile.wall = 221;
					}
					else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 192)
					{
						tile.wall = 192;
					}
					else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 193)
					{
						tile.wall = 193;
					}
					else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 194)
					{
						tile.wall = 194;
					}
					else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 195)
					{
						tile.wall = 195;
					}
					if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 203)
					{
						tile.type = 203;
					}
					else if (TileID.Sets.Conversion.JungleGrass[type] && type != 662)
					{
						tile.type = 662;
					}
					else if (TileID.Sets.Conversion.Grass[type] && type != 199)
					{
						tile.type = 199;
					}
					else if (TileID.Sets.Conversion.Ice[type] && type != 200)
					{
						tile.type = 200;
					}
					else if (TileID.Sets.Conversion.Sand[type] && type != 234)
					{
						tile.type = 234;
					}
					else if (TileID.Sets.Conversion.HardenedSand[type] && type != 399)
					{
						tile.type = 399;
					}
					else if (TileID.Sets.Conversion.Sandstone[type] && type != 401)
					{
						tile.type = 401;
					}
					else if (TileID.Sets.Conversion.Thorn[type] && type != 352)
					{
						tile.type = 352;
					}
					break;
				case 2:
					if (WallID.Sets.Conversion.Grass[wall] && wall != 70)
					{
						tile.wall = 70;
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall != 28)
					{
						tile.wall = 28;
					}
					else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 219)
					{
						tile.wall = 219;
					}
					else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 222)
					{
						tile.wall = 222;
					}
					else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 200)
					{
						tile.wall = 200;
					}
					else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 201)
					{
						tile.wall = 201;
					}
					else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 202)
					{
						tile.wall = 202;
					}
					else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 203)
					{
						tile.wall = 203;
					}
					if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 117)
					{
						tile.type = 117;
					}
					else if (TileID.Sets.Conversion.GolfGrass[type] && type != 492)
					{
						tile.type = 492;
					}
					else if (TileID.Sets.Conversion.Grass[type] && type != 109 && type != 492)
					{
						tile.type = 109;
					}
					else if (TileID.Sets.Conversion.Ice[type] && type != 164)
					{
						tile.type = 164;
					}
					else if (TileID.Sets.Conversion.Sand[type] && type != 116)
					{
						tile.type = 116;
					}
					else if (TileID.Sets.Conversion.HardenedSand[type] && type != 402)
					{
						tile.type = 402;
					}
					else if (TileID.Sets.Conversion.Sandstone[type] && type != 403)
					{
						tile.type = 403;
					}
					if (type == 59 && (Main.tile[k - 1, l].type == 109 || Main.tile[k + 1, l].type == 109 || Main.tile[k, l - 1].type == 109 || Main.tile[k, l + 1].type == 109))
					{
						tile.type = 0;
					}
					break;
				case 1:
					if (WallID.Sets.Conversion.Grass[wall] && wall != 69)
					{
						tile.wall = 69;
					}
					else if (TileID.Sets.Conversion.JungleGrass[type] && type != 661)
					{
						tile.type = 661;
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall != 3)
					{
						tile.wall = 3;
					}
					else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 217)
					{
						tile.wall = 217;
					}
					else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 220)
					{
						tile.wall = 220;
					}
					else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 188)
					{
						tile.wall = 188;
					}
					else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 189)
					{
						tile.wall = 189;
					}
					else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 190)
					{
						tile.wall = 190;
					}
					else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 191)
					{
						tile.wall = 191;
					}
					if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 25)
					{
						tile.type = 25;
					}
					else if (TileID.Sets.Conversion.Grass[type] && type != 23)
					{
						tile.type = 23;
					}
					else if (TileID.Sets.Conversion.Ice[type] && type != 163)
					{
						tile.type = 163;
					}
					else if (TileID.Sets.Conversion.Sand[type] && type != 112)
					{
						tile.type = 112;
					}
					else if (TileID.Sets.Conversion.HardenedSand[type] && type != 398)
					{
						tile.type = 398;
					}
					else if (TileID.Sets.Conversion.Sandstone[type] && type != 400)
					{
						tile.type = 400;
					}
					else if (TileID.Sets.Conversion.Thorn[type] && type != 32)
					{
						tile.type = 32;
					}
					break;
				case 3:
					if (WallID.Sets.CanBeConvertedToGlowingMushroom[wall])
					{
						tile.wall = 80;
					}
					if (tile.type == 60)
					{
						tile.type = 70;
					}
					break;
				case 5:
					if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 187)
					{
						tile.wall = 187;
					}
					else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 216)
					{
						tile.wall = 216;
					}
					if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 53)
					{
						int num = 53;
						if (WorldGen.BlockBelowMakesSandConvertIntoHardenedSand(k, l))
						{
							num = 397;
						}
						tile.type = (ushort)num;
					}
					else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
					{
						tile.type = 397;
					}
					else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 396)
					{
						tile.type = 396;
					}
					break;
				case 6:
					if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 71)
					{
						tile.wall = 71;
					}
					else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 40)
					{
						tile.wall = 40;
					}
					if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 147)
					{
						tile.type = 147;
					}
					else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 161)
					{
						tile.type = 161;
					}
					break;
				case 7:
					if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 1)
					{
						tile.wall = 1;
					}
					else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Snow[wall] || WallID.Sets.Conversion.Dirt[wall]) && wall != 2)
					{
						tile.wall = 2;
					}
					else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 196)
					{
						tile.wall = 196;
					}
					else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 197)
					{
						tile.wall = 197;
					}
					else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 198)
					{
						tile.wall = 198;
					}
					else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 199)
					{
						tile.wall = 199;
					}
					if ((TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 1)
					{
						tile.type = 1;
					}
					else if (TileID.Sets.Conversion.GolfGrass[type] && type != 477)
					{
						tile.type = 477;
					}
					else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
					{
						tile.type = 2;
					}
					else if ((TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 0)
					{
						int num2 = 0;
						if (WorldGen.TileIsExposedToAir(k, l))
						{
							num2 = 2;
						}
						tile.type = (ushort)num2;
					}
					break;
			}
			if (tile.wall == 69 || tile.wall == 70 || tile.wall == 81)
			{
				if (l < Main.worldSurface)
				{
					tile.wall = 65;
					tile.wall = 63;
				}
				else
				{
					tile.wall = 64;
				}
			}
			else if (WallID.Sets.Conversion.Stone[wall] && wall != 1 && wall != 262 && wall != 274 && wall != 61 && wall != 185)
			{
				tile.wall = 1;
			}
			else if (WallID.Sets.Conversion.Stone[wall] && wall == 262)
			{
				tile.wall = 61;
			}
			else if (WallID.Sets.Conversion.Stone[wall] && wall == 274)
			{
				tile.wall = 185;
			}
			if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
			{
				tile.wall = 212;
			}
			else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
			{
				tile.wall = 213;
			}
			else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
			{
				tile.wall = 214;
			}
			else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
			{
				tile.wall = 215;
			}
			else if (tile.wall == 80)
			{
				tile.wall = 15;
				tile.wall = 64;
			}
			else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216)
			{
				tile.wall = 216;
			}
			else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187)
			{
				tile.wall = 187;
			}
			if (tile.type == 492)
			{
				tile.type = 477;
			}
			else if (TileID.Sets.Conversion.JungleGrass[type] && type != 60)
			{
				tile.type = 60;
			}
			else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
			{
				tile.type = 2;
			}
			else if (TileID.Sets.Conversion.Stone[type] && type != 1)
			{
				tile.type = 1;
			}
			else if (TileID.Sets.Conversion.Sand[type] && type != 53)
			{
				tile.type = 53;
			}
			else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
			{
				tile.type = 397;
			}
			else if (TileID.Sets.Conversion.Sandstone[type] && type != 396)
			{
				tile.type = 396;
			}
			else if (TileID.Sets.Conversion.Ice[type] && type != 161)
			{
				tile.type = 161;
			}
			else if (TileID.Sets.Conversion.MushroomGrass[type])
			{
				tile.type = 60;
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Handlers/SyncTilePickingHandler.cs`
```
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria;
using static TShockAPI.GetDataHandlers;

namespace TShockAPI.Handlers
{
	class SyncTilePickingHandler : IPacketHandler<SyncTilePickingEventArgs>
	{
		/// <summary>
		/// Invoked when player damages a tile. Rejects the packet if its out of world bounds.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		public void OnReceive(object sender, SyncTilePickingEventArgs args)
		{
			if (args.TileX > Main.maxTilesX || args.TileX < 0
			   || args.TileY > Main.maxTilesY || args.TileY < 0)
			{
				TShock.Log.ConsoleDebug(GetString($"SyncTilePickingHandler: X and Y position is out of world bounds! - From {args.Player.Name}"));
				args.Handled = true;
				return;
			}
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Hooks`
#### File: `temp_TShock-5.2.4/TShockAPI/Hooks/AccountHooks.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.ComponentModel;
using TShockAPI.DB;
namespace TShockAPI.Hooks
{
	public class AccountDeleteEventArgs
	{
		public UserAccount Account { get; private set; }

		public AccountDeleteEventArgs(UserAccount account)
		{
			this.Account = account;
		}
	}

	public class AccountCreateEventArgs
	{
		public UserAccount Account { get; private set; }

		public AccountCreateEventArgs(UserAccount account)
		{
			this.Account = account;
		}
	}

	public class AccountGroupUpdateEventArgs : HandledEventArgs
	{
		public string AccountName { get; private set; }
		public Group Group { get; set; }

		public AccountGroupUpdateEventArgs(string accountName, Group group)
		{
			this.AccountName = accountName;
			this.Group = group;
		}
	}

	public class AccountGroupUpdateByPlayerEventArgs : AccountGroupUpdateEventArgs
	{
		/// <summary>
		/// The player who updated the user's group
		/// </summary>
		public TSPlayer Player { get; private set; }

		public AccountGroupUpdateByPlayerEventArgs(TSPlayer player, string accountName, Group group) : base(accountName, group)
		{
			this.Player = player;
		}
	}

	public class AccountHooks
	{
		public delegate void AccountCreateD(AccountCreateEventArgs e);
		public static event AccountCreateD AccountCreate;

		public static void OnAccountCreate(UserAccount u)
		{
			if (AccountCreate == null)
				return;

			AccountCreate(new AccountCreateEventArgs(u));
		}

		public delegate void AccountDeleteD(AccountDeleteEventArgs e);
		public static event AccountDeleteD AccountDelete;

		public static void OnAccountDelete(UserAccount u)
		{
			if (AccountDelete == null)
				return;

			AccountDelete(new AccountDeleteEventArgs(u));
		}

		public delegate void AccountGroupUpdateD(AccountGroupUpdateEventArgs e);
		public static event AccountGroupUpdateD AccountGroupUpdate;

		public static bool OnAccountGroupUpdate(UserAccount account, TSPlayer author, ref Group group)
		{
			AccountGroupUpdateEventArgs args = new AccountGroupUpdateByPlayerEventArgs(author, account.Name, group);
			AccountGroupUpdate?.Invoke(args);
			group = args.Group;

			return args.Handled;
		}
		public static bool OnAccountGroupUpdate(UserAccount account, ref Group group)
		{
			AccountGroupUpdateEventArgs args = new AccountGroupUpdateEventArgs(account.Name, group);
			AccountGroupUpdate?.Invoke(args);
			group = args.Group;

			return args.Handled;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Hooks/GeneralHooks.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

namespace TShockAPI.Hooks
{
    public class ReloadEventArgs
    {
        public TSPlayer Player { get; set; }
        public ReloadEventArgs(TSPlayer ply)
        {
            Player = ply;
        }
    }

    public class GeneralHooks
    {
        public delegate void ReloadEventD(ReloadEventArgs e);
        public static event ReloadEventD ReloadEvent;

        public static void OnReloadEvent(TSPlayer ply)
        {
            if(ReloadEvent == null)
                return;

            ReloadEvent(new ReloadEventArgs(ply));
        }
    }
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Hooks/PlayerHooks.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using TShockAPI.DB;

namespace TShockAPI.Hooks
{
	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerPostLogin"/> event.
	/// </summary>
	public class PlayerPostLoginEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// Initializes a new instance of the PlayerPostLoginEventArgs class.
		/// </summary>
		/// <param name="ply">The player who fired the event.</param>
		public PlayerPostLoginEventArgs(TSPlayer ply)
		{
			Player = ply;
		}
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerPreLogin"/> event.
	/// </summary>
	public class PlayerPreLoginEventArgs : HandledEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// The player's login name.
		/// </summary>
		public string LoginName { get; set; }

		/// <summary>
		/// The player's raw password.
		/// </summary>
		public string Password { get; set; }
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerLogout"/> event.
	/// </summary>
	public class PlayerLogoutEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// Initializes a new instance of the PlayerLogoutEventArgs class.
		/// </summary>
		/// <param name="player">The player who fired the event.</param>
		public PlayerLogoutEventArgs(TSPlayer player)
		{
			Player = player;
		}
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerCommand"/> event.
	/// </summary>
	public class PlayerCommandEventArgs : HandledEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// The command's name that follows the <see cref="Commands.Specifier"/>.
		/// </summary>
		public string CommandName { get; set; }

		/// <summary>
		/// The command's full text.
		/// </summary>
		public string CommandText { get; set; }

		/// <summary>
		/// The command's parameters extracted from <see cref="CommandText"/>.
		/// </summary>
		public List<string> Parameters { get; set; }

		/// <summary>
		/// The full list of server commands.
		/// </summary>
		public IEnumerable<Command> CommandList { get; set; }

		/// <summary>
		/// The prefix used to send the command (either <see cref="Commands.Specifier"/> or <see cref="Commands.SilentSpecifier"/>).
		/// </summary>
		public string CommandPrefix { get; set; }
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PrePlayerCommand"/> event.
	/// </summary>
	public class PrePlayerCommandEventArgs : HandledEventArgs
	{
		/// <summary>
		/// The command entered by the player.
		/// </summary>
		public Command Command { get; }
		/// <summary>
		/// Command arguments.
		/// </summary>
		public CommandArgs Arguments { get; set; }

		public PrePlayerCommandEventArgs(Command command, CommandArgs args)
		{
			Command = command;
			Arguments = args;
		}
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PostPlayerCommand"/> event.
	/// </summary>
	public class PostPlayerCommandEventArgs : HandledEventArgs
	{
		/// <summary>
		/// The command entered by the player.
		/// </summary>
		public Command Command { get; }
		/// <summary>
		/// Command arguments.
		/// </summary>
		public CommandArgs Arguments { get; }

		public PostPlayerCommandEventArgs(Command command, CommandArgs arguments, bool handled)
		{
			Command = command;
			Arguments = arguments;
			Handled = handled;
		}
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerChat"/> event.
	/// </summary>
	public class PlayerChatEventArgs : HandledEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// The raw chat text as received by the server.
		/// </summary>
		public string RawText { get; set; }

		/// <summary>
		/// The <see cref="RawText"/> string after being formatted by TShock as specified in the config file.
		/// </summary>
		public string TShockFormattedText { get; set; }
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerPermission"/> event.
	/// </summary>
	public class PlayerPermissionEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// The permission being checked.
		/// </summary>
		public string Permission { get; set; }

		/// <summary>
		/// <see cref="PermissionHookResult"/> of the hook.
		/// </summary>
		public PermissionHookResult Result { get; set; }

		/// <summary>
		/// Initializes a new instance of the PlayerPermissionEventArgs class.
		/// </summary>
		/// <param name="player">The player who fired the event.</param>
		/// <param name="permission">The permission being checked.</param>
		public PlayerPermissionEventArgs(TSPlayer player, string permission)
		{
			Player = player;
			Permission = permission;
			Result = PermissionHookResult.Unhandled;
		}
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerItembanPermission"/> event.
	/// </summary>
	public class PlayerItembanPermissionEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// The banned item being checked.
		/// </summary>
		public ItemBan BannedItem { get; set; }

		/// <summary>
		/// <see cref="PermissionHookResult"/> of the hook.
		/// </summary>
		public PermissionHookResult Result { get; set; }

		/// <summary>
		/// Initializes a new instance of the PlayerItembanPermissionEventArgs class.
		/// </summary>
		/// <param name="player">The player who fired the event.</param>
		/// <param name="bannedItem">The banned item being checked.</param>
		public PlayerItembanPermissionEventArgs(TSPlayer player, ItemBan bannedItem)
		{
			Player = player;
			BannedItem = bannedItem;
			Result = PermissionHookResult.Unhandled;
		}
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerProjbanPermission"/> event.
	/// </summary>
	public class PlayerProjbanPermissionEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// The banned projectile being checked.
		/// </summary>
		public ProjectileBan BannedProjectile { get; set; }

		/// <summary>
		/// <see cref="PermissionHookResult"/> of the hook.
		/// </summary>
		public PermissionHookResult Result { get; set; }

		/// <summary>
		/// Initializes a new instance of the PlayerProjbanPermissionEventArgs class.
		/// </summary>
		/// <param name="player">The player who fired the event.</param>
		/// <param name="checkedProjectile">The banned projectile being checked.</param>
		public PlayerProjbanPermissionEventArgs(TSPlayer player, ProjectileBan checkedProjectile)
		{
			Player = player;
			BannedProjectile = checkedProjectile;
			Result = PermissionHookResult.Unhandled;
		}
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerTilebanPermission"/> event.
	/// </summary>
	public class PlayerTilebanPermissionEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// The banned tile being checked.
		/// </summary>
		public TileBan BannedTile { get; set; }

		/// <summary>
		/// <see cref="PermissionHookResult"/> of the hook.
		/// </summary>
		public PermissionHookResult Result { get; set; }

		/// <summary>
		/// Initializes a new instance of the PlayerTilebanPermissionEventArgs class.
		/// </summary>
		/// <param name="player">The player who fired the event.</param>
		/// <param name="checkedTile">The banned tile being checked.</param>
		public PlayerTilebanPermissionEventArgs(TSPlayer player, TileBan checkedTile)
		{
			Player = player;
			BannedTile = checkedTile;
			Result = PermissionHookResult.Unhandled;
		}
	}

	/// <summary>
	/// EventArgs used for the <see cref="PlayerHooks.PlayerHasBuildPermission"/> event.
	/// </summary>
	public class PlayerHasBuildPermissionEventArgs
	{
		/// <summary>
		/// The player who fired the event.
		/// </summary>
		public TSPlayer Player { get; set; }

		/// <summary>
		/// The X coordinate being checked.
		/// </summary>
		public int X { get; set; }

		/// <summary>
		/// The Y coordinate being checked.
		/// </summary>
		public int Y { get; set; }

		/// <summary>
		/// <see cref="PermissionHookResult"/> of the hook.
		/// </summary>
		public PermissionHookResult Result { get; set; }
	}

	/// <summary>
	/// A collection of events fired by players that can be hooked to.
	/// </summary>
	public static class PlayerHooks
	{
		/// <summary>
		/// The delegate of the <see cref="PlayerPostLogin"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerPostLoginD(PlayerPostLoginEventArgs e);
		/// <summary>
		/// Fired by players after they've successfully logged in to a user account.
		/// </summary>
		public static event PlayerPostLoginD PlayerPostLogin;

		/// <summary>
		/// The delegate of the <see cref="PlayerPreLogin"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerPreLoginD(PlayerPreLoginEventArgs e);
		/// <summary>
		/// Fired by players when sending login credentials to the server.
		/// </summary>
		public static event PlayerPreLoginD PlayerPreLogin;

		/// <summary>
		/// The delegate of the <see cref="PlayerLogout"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerLogoutD(PlayerLogoutEventArgs e);
		/// <summary>
		/// Fired by players upon logging out from a user account.
		/// </summary>
		public static event PlayerLogoutD PlayerLogout;

		/// <summary>
		/// The delegate of the <see cref="PlayerCommand"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerCommandD(PlayerCommandEventArgs e);
		/// <summary>
		/// Fired by players when using a command.
		/// </summary>
		public static event PlayerCommandD PlayerCommand;

		/// <summary>
		/// The delegate of the <see cref="PrePlayerCommand"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PrePlayerCommandD(PrePlayerCommandEventArgs e);
		/// <summary>
		/// Fired before a command is run.
		/// </summary>
		public static event PrePlayerCommandD PrePlayerCommand;

		/// <summary>
		/// The delegate of the <see cref="PostPlayerCommand"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PostPlayerCommandD(PostPlayerCommandEventArgs e);
		/// <summary>
		/// Fired after a command is run.
		/// </summary>
		public static event PostPlayerCommandD PostPlayerCommand;

		/// <summary>
		/// The delegate of the <see cref="PlayerChat"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerChatD(PlayerChatEventArgs e);
		/// <summary>
		/// Fired by players when they send a chat message packet to the server
		/// and before it is transmitted to the rest of the players.
		/// </summary>
		public static event PlayerChatD PlayerChat;

		/// <summary>
		/// The delegate of the <see cref="PlayerPermission"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerPermissionD(PlayerPermissionEventArgs e);
		/// <summary>
		/// Fired by players every time a permission check involving them occurs.
		/// </summary>
		public static event PlayerPermissionD PlayerPermission;

		/// <summary>
		/// The delegate of the <see cref="PlayerItembanPermission"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerItembanPermissionD(PlayerItembanPermissionEventArgs e);
		/// <summary>
		/// Fired by players every time a permission check on banned items involving them occurs.
		/// </summary>
		public static event PlayerItembanPermissionD PlayerItembanPermission;

		/// <summary>
		/// The delegate of the <see cref="PlayerProjbanPermission"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerProjbanPermissionD(PlayerProjbanPermissionEventArgs e);
		/// <summary>
		/// Fired by players every time a permission check on banned projectiles involving them occurs.
		/// </summary>
		public static event PlayerProjbanPermissionD PlayerProjbanPermission;

		/// <summary>
		/// The delegate of the <see cref="PlayerTilebanPermission"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerTilebanPermissionD(PlayerTilebanPermissionEventArgs e);
		/// <summary>
		/// Fired by players every time a permission check on banned tiles involving them occurs.
		/// </summary>
		public static event PlayerTilebanPermissionD PlayerTilebanPermission;

		/// <summary>
		/// The delegate of the <see cref="PlayerHasBuildPermission"/> event.
		/// </summary>
		/// <param name="e">The EventArgs for this event.</param>
		public delegate void PlayerHasBuildPermissionD(PlayerHasBuildPermissionEventArgs e);
		/// <summary>
		/// Fired by players every time a build permission check occurs.
		/// </summary>
		public static event PlayerHasBuildPermissionD PlayerHasBuildPermission;


		/// <summary>
		/// Fires the <see cref="PlayerPostLogin"/> event.
		/// </summary>
		/// <param name="ply">The player firing the event.</param>
		public static void OnPlayerPostLogin(TSPlayer ply)
		{
			if (PlayerPostLogin == null)
			{
					return;
			}

			PlayerPostLoginEventArgs args = new PlayerPostLoginEventArgs(ply);
			PlayerPostLogin(args);
		}

		/// <summary>
		/// Fires the <see cref="PlayerCommand"/> event.
		/// </summary>
		/// <param name="player">The player firing the event.</param>
		/// <param name="cmdName">The command name.</param>
		/// <param name="cmdText">The raw command text.</param>
		/// <param name="args">The command args extracted from the command text.</param>
		/// <param name="commands">The list of commands.</param>
		/// <param name="cmdPrefix">The command specifier used.</param>
		/// <returns>True if the event has been handled.</returns>
		public static bool OnPlayerCommand(TSPlayer player, string cmdName, string cmdText, List<string> args, ref IEnumerable<Command> commands, string cmdPrefix)
		{
			if (PlayerCommand == null)
			{
				return false;
			}
			PlayerCommandEventArgs playerCommandEventArgs = new PlayerCommandEventArgs()
			{
				Player = player,
				CommandName = cmdName,
				CommandText = cmdText,
				Parameters = args,
				CommandList = commands,
				CommandPrefix = cmdPrefix,
			};
			PlayerCommand(playerCommandEventArgs);
			return playerCommandEventArgs.Handled;
		}

		/// <summary>
		/// Fires the <see cref="PrePlayerCommand"/> event.
		/// </summary>
		/// <param name="cmd">Command to be executed</param>
		/// <param name="arguments">Command arguments</param>
		/// <returns>True if the event has been handled.</returns>
		public static bool OnPrePlayerCommand(Command cmd, ref CommandArgs arguments)
		{
			if (PrePlayerCommand == null)
				return false;

			PrePlayerCommandEventArgs args = new PrePlayerCommandEventArgs(cmd, arguments);

			PrePlayerCommand(args);

			arguments = args.Arguments;
			return args.Handled;
		}

		/// <summary>
		/// Fires the <see cref="PostPlayerCommand"/> event.
		/// </summary>
		/// <param name="cmd">Executed command.</param>
		/// <param name="arguments">Command arguments.</param>
		/// <param name="handled">Is the command executed.</param>
		public static void OnPostPlayerCommand(Command cmd, CommandArgs arguments, bool handled)
		{
			if (PostPlayerCommand == null)
				return;

			PostPlayerCommandEventArgs args = new PostPlayerCommandEventArgs(cmd, arguments, handled);
			PostPlayerCommand(args);
		}

		/// <summary>
		/// Fires the <see cref="PlayerPreLogin"/> event.
		/// </summary>
		/// <param name="ply">The player firing the event.</param>
		/// <param name="name">The user name.</param>
		/// <param name="pass">The password.</param>
		/// <returns>True if the event has been handled.</returns>
		public static bool OnPlayerPreLogin(TSPlayer ply, string name, string pass)
		{
			if (PlayerPreLogin == null)
				return false;

			var args = new PlayerPreLoginEventArgs {Player = ply, LoginName = name, Password = pass};
			PlayerPreLogin(args);
			return args.Handled;
		}

		/// <summary>
		/// Fires the <see cref="PlayerLogout"/> event.
		/// </summary>
		/// <param name="ply">The player firing the event.</param>
		public static void OnPlayerLogout(TSPlayer ply)
		{
			if (PlayerLogout == null)
				return;

			var args = new PlayerLogoutEventArgs(ply);
			PlayerLogout(args);
		}

		/// <summary>
		/// Fires the <see cref="PlayerChat"/> event.
		/// </summary>
		/// <param name="ply">The player firing the event.</param>
		/// <param name="rawtext">The raw chat text sent by the player.</param>
		/// <param name="tshockText">The chat text after being formatted.</param>
		public static bool OnPlayerChat(TSPlayer ply, string rawtext, ref string tshockText)
		{
			if (PlayerChat == null)
				return false;

			var args = new PlayerChatEventArgs {Player = ply, RawText = rawtext, TShockFormattedText = tshockText};
			PlayerChat(args);
			tshockText = args.TShockFormattedText;

			return args.Handled;
		}

		/// <summary>
		/// Fires the <see cref="PlayerPermission"/> event.
		/// </summary>
		/// <param name="player">The player firing the event.</param>
		/// <returns>Event result if the event has been handled, otherwise <see cref="PermissionHookResult.Unhandled"/>.</returns>
		public static PermissionHookResult OnPlayerPermission(TSPlayer player, string permission)
		{
			if (PlayerPermission == null)
				return PermissionHookResult.Unhandled;

			var args = new PlayerPermissionEventArgs(player, permission);
			PlayerPermission(args);

			return args.Result;
		}

		/// <summary>
		/// Fires the <see cref="PlayerItembanPermission"/> event.
		/// </summary>
		/// <param name="player">The player firing the event.</param>
		/// <returns>Event result if the event has been handled, otherwise <see cref="PermissionHookResult.Unhandled"/>.</returns>
		public static PermissionHookResult OnPlayerItembanPermission(TSPlayer player, ItemBan bannedItem)
		{
			if (PlayerItembanPermission == null)
				return PermissionHookResult.Unhandled;

			var args = new PlayerItembanPermissionEventArgs(player, bannedItem);
			PlayerItembanPermission(args);

			return args.Result;
		}

		/// <summary>
		/// Fires the <see cref="PlayerProjbanPermission"/> event.
		/// </summary>
		/// <param name="player">The player firing the event.</param>
		/// <returns>Event result if the event has been handled, otherwise <see cref="PermissionHookResult.Unhandled"/>.</returns>
		public static PermissionHookResult OnPlayerProjbanPermission(TSPlayer player, ProjectileBan bannedProj)
		{
			if (PlayerProjbanPermission == null)
				return PermissionHookResult.Unhandled;

			var args = new PlayerProjbanPermissionEventArgs(player, bannedProj);
			PlayerProjbanPermission(args);

			return args.Result;
		}

		/// <summary>
		/// Fires the <see cref="PlayerTilebanPermission"/> event.
		/// </summary>
		/// <param name="player">The player firing the event.</param>
		/// <returns>Event result if the event has been handled, otherwise <see cref="PermissionHookResult.Unhandled"/>.</returns>
		public static PermissionHookResult OnPlayerTilebanPermission(TSPlayer player, TileBan bannedTile)
		{
			if (PlayerTilebanPermission == null)
				return PermissionHookResult.Unhandled;

			var args = new PlayerTilebanPermissionEventArgs(player, bannedTile);
			PlayerTilebanPermission(args);

			return args.Result;
		}

		/// <summary>
		/// Fires the <see cref="PlayerHasBuildPermission"/> event.
		/// </summary>
		/// <param name="player">The player firing the event.</param>
		/// <returns>Event result if the event has been handled, otherwise <see cref="PermissionHookResult.Unhandled"/>.</returns>
		public static PermissionHookResult OnPlayerHasBuildPermission(TSPlayer player, int x, int y)
		{
			if (PlayerHasBuildPermission == null)
				return PermissionHookResult.Unhandled;

			var args = new PlayerHasBuildPermissionEventArgs {Player = player, X = x, Y = y};
			PlayerHasBuildPermission(args);

			return args.Result;
		}

	}

	/// <summary>
	/// Defines the possible outcomes of <see cref="PlayerHooks.PlayerPermission"/> handlers.
	/// </summary>
	public enum PermissionHookResult
	{
		/// <summary>Hook doesn't return a result on the permission check.</summary>
		Unhandled,
		/// <summary>Permission is explicitly denied by a hook.</summary>
		Denied,
		/// <summary>Permission is explicitly granted by a hook.</summary>
		Granted
	}

}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Hooks/RegionHooks.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using TShockAPI.DB;

namespace TShockAPI.Hooks
{
	public class RegionHooks
	{
		public class RegionEnteredEventArgs
		{
			public TSPlayer Player { get; private set; }

			public Region Region { get; private set; }

			public RegionEnteredEventArgs(TSPlayer ply, Region region)
			{
				Player = ply;
				Region = region;
			}
		}

		public delegate void RegionEnteredD(RegionEnteredEventArgs args);
		public static event RegionEnteredD RegionEntered;
		public static void OnRegionEntered(TSPlayer player, Region region)
		{
			if (RegionEntered == null)
			{
				return;
			}

			RegionEntered(new RegionEnteredEventArgs(player, region));
		}

		public class RegionLeftEventArgs
		{
			public TSPlayer Player { get; private set; }
			public Region Region { get; private set; }

			public RegionLeftEventArgs(TSPlayer ply, Region region)
			{
				Player = ply;
				Region = region;
			}
		}

		public delegate void RegionLeftD(RegionLeftEventArgs args);
		public static event RegionLeftD RegionLeft;
		public static void OnRegionLeft(TSPlayer player, Region region)
		{
			if (RegionLeft == null)
			{
				return;
			}

			RegionLeft(new RegionLeftEventArgs(player, region));
		}

		public class RegionCreatedEventArgs
		{
			public Region Region { get; private set; }

			public RegionCreatedEventArgs(Region region)
			{
				Region = region;
			}
		}

		public delegate void RegionCreatedD(RegionCreatedEventArgs args);
		public static event RegionCreatedD RegionCreated;
		public static void OnRegionCreated(Region region)
		{
			if (RegionCreated == null)
				return;

			RegionCreated(new RegionCreatedEventArgs(region));
		}

		public class RegionDeletedEventArgs
		{
			public Region Region { get; private set; }

			public RegionDeletedEventArgs(Region region)
			{
				Region = region;
			}
		}

		public delegate void RegionDeletedD(RegionDeletedEventArgs args);
		public static event RegionDeletedD RegionDeleted;
		public static void OnRegionDeleted(Region region)
		{
			if (RegionDeleted == null)
				return;

			RegionDeleted(new RegionDeletedEventArgs(region));
		}
		
		public class RegionRenamedEventArgs
		{
			public Region Region { get; private set; }
			public string OldName { get; private set; }
			public string NewName { get; private set; }

			public RegionRenamedEventArgs(Region region, string oldName, string newName)
			{
				Region = region;
				OldName = oldName;
				NewName = newName;
			}
		}

		public delegate void RegionRenamedD(RegionRenamedEventArgs args);
		public static event RegionRenamedD RegionRenamed;
		public static void OnRegionRenamed(Region region, string oldName, string newName)
		{
			if (RegionRenamed == null)
				return;

			RegionRenamed(new RegionRenamedEventArgs(region, oldName, newName));
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI`
#### File: `temp_TShock-5.2.4/TShockAPI/I18n.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2022 Janet Blackquill

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

global using static TShockAPI.I18n;

using System;
using System.Globalization;
using System.IO;
using System.Linq;
using GetText;
using Terraria.Initializers;
using Terraria.Localization;

namespace TShockAPI
{
	static class I18n
	{
		static string TranslationsDirectory => Path.Combine(AppContext.BaseDirectory, "i18n");
		static CultureInfo TranslationCultureInfo
		{
			get {
				// cross-platform mapping of cultureinfos can be a bit screwy, so give our users
				// the chance to explicitly spell out which translation they would like to use.
				// this is an environment variable instead of a flag because this needs to be
				// valid whether the passed flags are in a sane state or not.
				if (Environment.GetEnvironmentVariable("TSHOCK_LANGUAGE") is string overrideLang)
				{
					return new CultureInfo(overrideLang);
				}

				static CultureInfo Redirect(CultureInfo cultureInfo)
					=> cultureInfo.Name == "zh-Hans" ? new CultureInfo("zh-CN") : cultureInfo;

				if (Terraria.Program.LaunchParameters.TryGetValue("-lang", out var langArg)
				    && int.TryParse(langArg, out var langId)) {
					if (GameCulture._legacyCultures.TryGetValue(langId, out var culture)) {
						return Redirect(culture.CultureInfo);
					}
				}

				if (Terraria.Program.LaunchParameters.TryGetValue("-language", out var languageArg)) {
					var culture = GameCulture._legacyCultures.Values.SingleOrDefault(c => c.Name == languageArg);
					if (culture != null) {
						return Redirect(culture.CultureInfo);
					}
				}

				if (LanguageManager.Instance.ActiveCulture == GameCulture.DefaultCulture)
				{
					var bf = System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static;
					// LanguageManager.SetLanguage will change this so we need to reset it back to null
					typeof(CultureInfo).GetField("s_currentThreadUICulture", bf)?.SetValue(null, null);
				}
				return CultureInfo.CurrentUICulture;
			}
		}
		/// <value>Instance of a <c>GetText.Catalog</c> loaded with TShockAPI translations for user's specified language</value>
		public static Catalog C = new Catalog("TShockAPI", TranslationsDirectory, TranslationCultureInfo);

		#region ICatalog forwarding methods
		/// <summary>
		/// Returns <paramref name="text"/> translated into the selected language.
		/// Similar to <c>gettext</c> function.
		/// </summary>
		/// <param name="text">Text to translate.</param>
		/// <returns>Translated text.</returns>
		static string GetString(FormattableStringAdapter text)
		{
			return C.GetString(text);
		}

		/// <summary>
		/// Returns <paramref name="text"/> translated into the selected language.
		/// Similar to <c>gettext</c> function.
		/// </summary>
		/// <param name="text">Text to translate.</param>
		/// <returns>Translated text.</returns>
		public static string GetString(FormattableString text)
		{
			return C.GetString(text);
		}

		/// <summary>
		/// Returns <paramref name="text"/> translated into the selected language.
		/// Similar to <c>gettext</c> function.
		/// </summary>
		/// <param name="text">Text to translate.</param>
		/// <param name="args">Optional arguments for <see cref="string.Format(string, object[])"/> method.</param>
		/// <returns>Translated text.</returns>
		public static string GetString(FormattableStringAdapter text, params object[] args)
		{
			return C.GetString(text, args);
		}

		/// <summary>
		/// Returns the plural form for <paramref name="n"/> of the translation of <paramref name="text"/>.
		/// Similar to <c>gettext</c> function.
		/// </summary>
		/// <param name="text">Singular form of message to translate.</param>
		/// <param name="pluralText">Plural form of message to translate.</param>
		/// <param name="n">Value that determines the plural form.</param>
		/// <returns>Translated text.</returns>
		public static string GetPluralString(FormattableStringAdapter text, FormattableStringAdapter pluralText, long n)
		{
			return C.GetPluralString(text, pluralText, n);
		}

		/// <summary>
		/// Returns the plural form for <paramref name="n"/> of the translation of <paramref name="text"/>.
		/// Similar to <c>gettext</c> function.
		/// </summary>
		/// <param name="text">Singular form of message to translate.</param>
		/// <param name="pluralText">Plural form of message to translate.</param>
		/// <param name="n">Value that determines the plural form.</param>
		/// <returns>Translated text.</returns>
		public static string GetPluralString(FormattableString text, FormattableString pluralText, long n)
		{
			return C.GetPluralString(text, pluralText, n);
		}

		/// <summary>
		/// Returns the plural form for <paramref name="n"/> of the translation of <paramref name="text"/>.
		/// Similar to <c>gettext</c> function.
		/// </summary>
		/// <param name="text">Singular form of message to translate.</param>
		/// <param name="pluralText">Plural form of message to translate.</param>
		/// <param name="n">Value that determines the plural form.</param>
		/// <param name="args">Optional arguments for <see cref="string.Format(string, object[])"/> method.</param>
		/// <returns>Translated text.</returns>
		public static string GetPluralString(FormattableStringAdapter text, FormattableStringAdapter pluralText, long n, params object[] args)
		{
			return C.GetPluralString(text, pluralText, n, args);
		}

		/// <summary>
		/// Returns <paramref name="text"/> translated into the selected language using given <paramref name="context"/>.
		/// Similar to <c>pgettext</c> function.
		/// </summary>
		/// <param name="context">Context.</param>
		/// <param name="text">Text to translate.</param>
		/// <returns>Translated text.</returns>
		public static string GetParticularString(string context, FormattableStringAdapter text)
		{
			return C.GetParticularString(context, text);
		}

		/// <summary>
		/// Returns <paramref name="text"/> translated into the selected language using given <paramref name="context"/>.
		/// Similar to <c>pgettext</c> function.
		/// </summary>
		/// <param name="context">Context.</param>
		/// <param name="text">Text to translate.</param>
		/// <returns>Translated text.</returns>
		public static string GetParticularString(string context, FormattableString text)
		{
			return C.GetParticularString(context, text);
		}

		/// <summary>
		/// Returns <paramref name="text"/> translated into the selected language using given <paramref name="context"/>.
		/// Similar to <c>pgettext</c> function.
		/// </summary>
		/// <param name="context">Context.</param>
		/// <param name="text">Text to translate.</param>
		/// <param name="args">Optional arguments for <see cref="string.Format(string, object[])"/> method.</param>
		/// <returns>Translated text.</returns>
		public static string GetParticularString(string context, FormattableStringAdapter text, params object[] args)
		{
			return C.GetParticularString(context, text, args);
		}

		/// <summary>
		/// Returns the plural form for <paramref name="n"/> of the translation of <paramref name="text"/> using given <paramref name="context"/>.
		/// Similar to <c>npgettext</c> function.
		/// </summary>
		/// <param name="context">Context.</param>
		/// <param name="text">Singular form of message to translate.</param>
		/// <param name="pluralText">Plural form of message to translate.</param>
		/// <param name="n">Value that determines the plural form.</param>
		/// <returns>Translated text.</returns>
		public static string GetParticularPluralString(string context, FormattableStringAdapter text, FormattableStringAdapter pluralText, long n)
		{
			return C.GetParticularPluralString(context, text, pluralText, n);
		}

		/// <summary>
		/// Returns the plural form for <paramref name="n"/> of the translation of <paramref name="text"/> using given <paramref name="context"/>.
		/// Similar to <c>npgettext</c> function.
		/// </summary>
		/// <param name="context">Context.</param>
		/// <param name="text">Singular form of message to translate.</param>
		/// <param name="pluralText">Plural form of message to translate.</param>
		/// <param name="n">Value that determines the plural form.</param>
		/// <returns>Translated text.</returns>
		public static string GetParticularPluralString(string context, FormattableString text, FormattableString pluralText, long n)
		{
			return C.GetParticularPluralString(context, text, pluralText, n);
		}

		/// <summary>
		/// Returns the plural form for <paramref name="n"/> of the translation of <paramref name="text"/> using given <paramref name="context"/>.
		/// Similar to <c>npgettext</c> function.
		/// </summary>
		/// <param name="context">Context.</param>
		/// <param name="text">Singular form of message to translate.</param>
		/// <param name="pluralText">Plural form of message to translate.</param>
		/// <param name="n">Value that determines the plural form.</param>
		/// <param name="args">Optional arguments for <see cref="string.Format(string, object[])"/> method.</param>
		/// <returns>Translated text.</returns>
		public static string GetParticularPluralString(string context, FormattableStringAdapter text, FormattableStringAdapter pluralText, long n, params object[] args)
		{
			return C.GetParticularPluralString(context, text, pluralText, n, args);
		}
		#endregion
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/ILog.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Diagnostics;

namespace TShockAPI
{
	/// <summary>
	/// Logging interface
	/// </summary>
	public interface ILog
	{
		/// <summary>
		/// Log file name
		/// </summary>
		string FileName { get; set; }

		/// <summary>
		/// Checks whether the log level contains the specified flag.
		/// </summary>
		/// <param name="type">The <see cref="TraceLevel" /> value to check.</param>
		bool MayWriteType(TraceLevel type);

		/// <summary>
		/// Writes an informative string to the log and to the console.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void ConsoleInfo(string message);

		/// <summary>
		/// Writes an informative string to the log and to the console.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		void ConsoleInfo(string format, params object[] args);

		/// <summary>
		/// Writes a warning message to the log and to the console.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void ConsoleWarn(string message);

		/// <summary>
		/// Writes a warning message to the log and to the console.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		void ConsoleWarn(string format, params object[] args);

		/// <summary>
		/// Writes an error message to the log and to the console.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void ConsoleError(string message);

		/// <summary>
		/// Writes an error message to the log and to the console.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		void ConsoleError(string format, params object[] args);

		/// <summary>
		/// Writes a warning to the log.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void Warn(string message);

		/// <summary>
		/// Writes a warning to the log.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		void Warn(string format, params object[] args);

		/// <summary>
		/// Writes an error to the log.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void Error(string message);

		/// <summary>
		/// Writes an error to the log.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		void Error(string format, params object[] args);

		/// <summary>
		/// Writes an informative string to the log.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void Info(string message);

		/// <summary>
		/// Writes an informative string to the log.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		void Info(string format, params object[] args);

		/// <summary>
		/// Writes data to the log.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void Data(string message);

		/// <summary>
		/// Writes data to the log.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		void Data(string format, params object[] args);

		/// <summary>
		/// Writes a message to the log
		/// </summary>
		/// <param name="message">Message to write</param>
		/// <param name="level">LogLevel associated with the message</param>
		void Write(string message, TraceLevel level);

		/// <summary>
		/// Writes a debug string to the log file and console. Only works if the DebugLogs config option is set to true.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void ConsoleDebug(string message);

		/// <summary>
		/// Writes a debug string to the log file. Only works if the DebugLogs config option is set to true.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void ConsoleDebug(string message, params object[] args);

		/// <summary>
		/// Writes a debug string to the log file. Only works if the DebugLogs config option is set to true.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		void Debug(string message);

		/// <summary>
		/// Writes a debug string to the log file. Only works if the DebugLogs config option is set to true.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		void Debug(string format, params object[] args);

		/// <summary>
		/// Dispose the Log
		/// </summary>
		void Dispose();
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/IPackable.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.IO;

namespace TShockAPI
{
	/// <summary>
	/// Derived objects can be written to and read from streams.
	/// </summary>
	public interface IPackable
	{
		/// <summary>
		/// Writes object information to the stream
		/// </summary>
		/// <param name="stream">Stream to write to</param>
		void Pack(Stream stream);

		/// <summary>
		/// Reads object information from the stream
		/// </summary>
		/// <param name="stream">Stream to read from</param>
		void Unpack(Stream stream);
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/ItemBans.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2018 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
using System;
using System.Collections.Generic;
using System.Linq;
using Terraria.ID;
using TShockAPI.DB;
using TShockAPI.Net;
using Terraria;
using Microsoft.Xna.Framework;
using TShockAPI.Localization;
using static TShockAPI.GetDataHandlers;
using TerrariaApi.Server;
using Terraria.ObjectData;
using Terraria.DataStructures;
using Terraria.Localization;
using System.Data;

namespace TShockAPI
{
	/// <summary>The TShock item ban subsystem. It handles keeping things out of people's inventories.</summary>
	public sealed class ItemBans
	{

		/// <summary>The database connection layer to for the item ban subsystem.</summary>
		public ItemManager DataModel;

		/// <summary>The last time the second update process was run. Used to throttle task execution.</summary>
		private DateTime LastTimelyRun = DateTime.UtcNow;

		/// <summary>A reference to the TShock plugin so we can register events.</summary>
		private TShock Plugin;

		/// <summary>Creates an ItemBan system given a plugin to register events to and a database.</summary>
		/// <param name="plugin">The executing plugin.</param>
		/// <param name="database">The database the item ban information is stored in.</param>
		/// <returns>A new item ban system.</returns>
		internal ItemBans(TShock plugin, IDbConnection database)
		{
			DataModel = new ItemManager(database);
			Plugin = plugin;

			ServerApi.Hooks.GameUpdate.Register(plugin, OnGameUpdate);
			GetDataHandlers.PlayerUpdate += OnPlayerUpdate;
			GetDataHandlers.ChestItemChange += OnChestItemChange;
			GetDataHandlers.TileEdit += OnTileEdit;
		}

		/// <summary>Called on the game update loop (the XNA tickrate).</summary>
		/// <param name="args">The standard event arguments.</param>
		internal void OnGameUpdate(EventArgs args)
		{
			if ((DateTime.UtcNow - LastTimelyRun).TotalSeconds >= 1)
			{
				OnSecondlyUpdate(args);
			}
		}

		/// <summary>Called by OnGameUpdate once per second to execute tasks regularly but not too often.</summary>
		/// <param name="args">The standard event arguments.</param>
		internal void OnSecondlyUpdate(EventArgs args)
		{
			DisableFlags disableFlags = TShock.Config.Settings.DisableSecondUpdateLogs ? DisableFlags.WriteToConsole : DisableFlags.WriteToLogAndConsole;

			foreach (TSPlayer player in TShock.Players)
			{
				if (player == null || !player.Active)
				{
					continue;
				}

				// Untaint now, re-taint if they fail the check.
				UnTaint(player);

				// No matter the player type, we do a check when a player is holding an item that's banned.
				if (DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID), player))
				{
					string itemName = player.TPlayer.inventory[player.TPlayer.selectedItem].Name;
					player.Disable(GetString($"holding banned item: {itemName}"), disableFlags);
					SendCorrectiveMessage(player, itemName);
				}

				// If SSC isn't enabled OR if SSC is enabled and the player is logged in
				// In a case like this, we do the full check too.
				if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))
				{
					// The Terraria inventory is composed of a multicultural set of arrays
					// with various different contents and beliefs

					// Armor ban checks
					foreach (Item item in player.TPlayer.armor)
					{
						if (DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type), player))
						{
							Taint(player);
							SendCorrectiveMessage(player, item.Name);
						}
					}

					// Dye ban checks
					foreach (Item item in player.TPlayer.dye)
					{
						if (DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type), player))
						{
							Taint(player);
							SendCorrectiveMessage(player, item.Name);
						}
					}

					// Misc equip ban checks
					foreach (Item item in player.TPlayer.miscEquips)
					{
						if (DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type), player))
						{
							Taint(player);
							SendCorrectiveMessage(player, item.Name);
						}
					}

					// Misc dye ban checks
					foreach (Item item in player.TPlayer.miscDyes)
					{
						if (DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type), player))
						{
							Taint(player);
							SendCorrectiveMessage(player, item.Name);
						}
					}
				}
			}

			// Set the update time to now, so that we know when to execute next.
			// We do this at the end so that the task can't re-execute faster than we expected.
			// (If we did this at the start of the method, the method execution would count towards the timer.)
			LastTimelyRun = DateTime.UtcNow;
		}

		internal void OnPlayerUpdate(object sender, PlayerUpdateEventArgs args)
		{
			DisableFlags disableFlags = TShock.Config.Settings.DisableSecondUpdateLogs ? DisableFlags.WriteToConsole : DisableFlags.WriteToLogAndConsole;
			bool useItem = args.Control.IsUsingItem;
			TSPlayer player = args.Player;
			string itemName = player.TPlayer.inventory[args.SelectedItem].Name;

			if (DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[args.SelectedItem].netID), args.Player))
			{
				player.TPlayer.controlUseItem = false;
				player.Disable(GetString($"holding banned item: {itemName}"), disableFlags);

				SendCorrectiveMessage(player, itemName);

				player.TPlayer.Update(player.TPlayer.whoAmI);
				NetMessage.SendData((int)PacketTypes.PlayerUpdate, -1, player.Index, NetworkText.Empty, player.Index);

				args.Handled = true;
				return;
			}

			args.Handled = false;
			return;
		}

		internal void OnChestItemChange(object sender, ChestItemEventArgs args)
		{
			Item item = new Item();
			item.netDefaults(args.Type);


			if (DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type), args.Player))
			{
				SendCorrectiveMessage(args.Player, item.Name);
				args.Handled = true;
				return;
			}

			args.Handled = false;
			return;
		}

		internal void OnTileEdit(object sender, TileEditEventArgs args)
		{
			if (args.Action == EditAction.PlaceTile || args.Action == EditAction.PlaceWall)
			{
				if (args.Player.TPlayer.autoActuator && DataModel.ItemIsBanned("Actuator", args.Player))
				{
					args.Player.SendTileSquareCentered(args.X, args.Y, 1);
					args.Player.SendErrorMessage(GetString("You do not have permission to place actuators."));
					args.Handled = true;
					return;
				}

				if (DataModel.ItemIsBanned(EnglishLanguage.GetItemNameById(args.Player.SelectedItem.netID), args.Player))
				{
					args.Player.SendTileSquareCentered(args.X, args.Y, 4);
					args.Handled = true;
					return;
				}
			}
		}

		private void UnTaint(TSPlayer player)
		{
			player.IsDisabledForBannedWearable = false;
		}

		private void Taint(TSPlayer player)
		{
			// Arbitrarily does things to the player
			player.SetBuff(BuffID.Frozen, 330, true);
			player.SetBuff(BuffID.Stoned, 330, true);
			player.SetBuff(BuffID.Webbed, 330, true);

			// Marks them as a target for future disables
			player.IsDisabledForBannedWearable = true;
		}

		private void SendCorrectiveMessage(TSPlayer player, string itemName)
		{
			player.SendErrorMessage(GetString("{0} is banned! Remove it!", itemName));
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Localization`
#### File: `temp_TShock-5.2.4/TShockAPI/Localization/EnglishLanguage.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using Terraria;
using Terraria.Initializers;
using Terraria.Localization;
using Terraria.UI.Chat;

namespace TShockAPI.Localization
{
	/// <summary>
	/// Provides a series of methods that give English texts
	/// </summary>
	public static class EnglishLanguage
	{
		private static readonly Dictionary<int, string> ItemNames = new Dictionary<int, string>();

		private static readonly Dictionary<int, string> NpcNames = new Dictionary<int, string>();

		private static readonly Dictionary<int, string> Prefixs = new Dictionary<int, string>();

		private static readonly Dictionary<int, string> Buffs = new Dictionary<int, string>();

		private static readonly Dictionary<string,string> VanillaCommandsPrefixs = new Dictionary<string, string>();

		internal static void Initialize()
		{
			var culture = Language.ActiveCulture;

			var skip = culture == GameCulture.FromCultureName(GameCulture.CultureName.English);

			try
			{
				if (!skip)
				{
					LanguageManager.Instance.SetLanguage(GameCulture.FromCultureName(GameCulture.CultureName.English));
				}

				for (var i = -48; i < Terraria.ID.ItemID.Count; i++)
				{
					ItemNames.Add(i, Lang.GetItemNameValue(i));
				}

				for (var i = -17; i < Terraria.ID.NPCID.Count; i++)
				{
					NpcNames.Add(i, Lang.GetNPCNameValue(i));
				}

				for (var i = 0; i < Terraria.ID.BuffID.Count; i++)
				{
					Buffs.Add(i, Lang.GetBuffName(i));
				}

				foreach (var field in typeof(Main).Assembly.GetType("Terraria.ID.PrefixID")
							.GetFields().Where(f => !f.Name.Equals("Count", StringComparison.Ordinal)))
				{
					var i = (int)field.GetValue(null);
					Prefixs.Add(i, Lang.prefix[i].Value);
				}

				ChatInitializer.Load();
				foreach (var command in ChatManager.Commands._localizedCommands)
				{
					if (VanillaCommandsPrefixs.ContainsKey(command.Value._name))
						continue;
					VanillaCommandsPrefixs.Add(command.Value._name,command.Key.Value);
				}
				ChatManager.Commands._localizedCommands.Clear();
			}
			finally
			{
				if (!skip)
				{
					LanguageManager.Instance.SetLanguage(culture);
				}
			}
		}

		/// <summary>
		/// Get the english name of an item
		/// </summary>
		/// <param name="id">Id of the item</param>
		/// <returns>Item name in English</returns>
		public static string GetItemNameById(int id)
		{
			string itemName;
			if (ItemNames.TryGetValue(id, out itemName))
				return itemName;

			return null;
		}

		/// <summary>
		/// Get the english name of a npc
		/// </summary>
		/// <param name="id">Id of the npc</param>
		/// <returns>Npc name in English</returns>
		public static string GetNpcNameById(int id)
		{
			string npcName;
			if (NpcNames.TryGetValue(id, out npcName))
				return npcName;

			return null;
		}

		/// <summary>
		/// Get prefix in English
		/// </summary>
		/// <param name="id">Prefix Id</param>
		/// <returns>Prefix in English</returns>
		public static string GetPrefixById(int id)
		{
			string prefix;
			if (Prefixs.TryGetValue(id, out prefix))
				return prefix;

			return null;
		}

		/// <summary>
		/// Get buff name in English
		/// </summary>
		/// <param name="id">Buff Id</param>
		/// <returns>Buff name in English</returns>
		public static string GetBuffNameById(int id)
		{
			string buff;
			if (Buffs.TryGetValue(id, out buff))
				return buff;

			return null;
		}

		/// <summary>
		/// Get vanilla command prefix in English
		/// </summary>
		/// <param name="name">vanilla command name</param>
		/// <returns>vanilla command prefix in English</returns>
		public static string GetCommandPrefixByName(string name)
		{
			string commandText;
			if (VanillaCommandsPrefixs.TryGetValue(name, out commandText))
				return commandText;
			return null;
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Models/PlayerUpdate`
#### File: `temp_TShock-5.2.4/TShockAPI/Models/PlayerUpdate/ControlSet.cs`
```
﻿using Terraria;

namespace TShockAPI.Models.PlayerUpdate
{

	/// <summary>
	/// Model for a control event sent with a player update packet
	/// </summary>
	public struct ControlSet
	{
		/// <summary>
		/// Backing BitsByte field
		/// </summary>
		public BitsByte bitsbyte;

		/// <summary>
		/// Gets or Sets the Up flag on the backing field
		/// </summary>
		public bool MoveUp
		{
			get => bitsbyte[0];
			set => bitsbyte[0] = value;
		}

		/// <summary>
		/// Gets or Sets the Down flag on the backing field
		/// </summary>
		public bool MoveDown
		{
			get => bitsbyte[1];
			set => bitsbyte[1] = value;
		}

		/// <summary>
		/// Gets or Sets the Left flag on the backing field
		/// </summary>
		public bool MoveLeft
		{
			get => bitsbyte[2];
			set => bitsbyte[2] = value;
		}

		/// <summary>
		/// Gets or Sets the Right flag on the backing field
		/// </summary>
		public bool MoveRight
		{
			get => bitsbyte[3];
			set => bitsbyte[3] = value;
		}

		/// <summary>
		/// Gets or Sets the Jump flag on the backing field
		/// </summary>
		public bool Jump
		{
			get => bitsbyte[4];
			set => bitsbyte[4] = value;
		}

		/// <summary>
		/// Gets or Sets the ControlUseItem flag on the backing field
		/// </summary>
		public bool IsUsingItem
		{
			get => bitsbyte[5];
			set => bitsbyte[5] = value;
		}

		/// <summary>
		/// Gets or Sets the Direction flag on the backing field. True = 1, false  = -1
		/// </summary>
		public bool FaceDirection
		{
			get => bitsbyte[6];
			set => bitsbyte[6] = value;
		}

		/// <summary>
		/// Constructs a new instance of ControlsModel with the given backing bitsbyte
		/// </summary>
		/// <param name="bitsbyte"></param>
		public ControlSet(BitsByte bitsbyte)
		{
			this.bitsbyte = bitsbyte;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Models/PlayerUpdate/MiscDataSet1.cs`
```
﻿using Terraria;

namespace TShockAPI.Models.PlayerUpdate
{
	/// <summary>
	/// Model for the first set of misc data sent with a player update packet
	/// </summary>
	public struct MiscDataSet1
	{
		/// <summary>
		/// Backing BitsByte field
		/// </summary>
		public BitsByte bitsbyte;

		/// <summary>
		/// Gets or Sets the Pulley flag on the backing field
		/// </summary>
		public bool IsUsingPulley
		{
			get => bitsbyte[0];
			set => bitsbyte[0] = value;
		}

		/// <summary>
		/// Gets or Sets the Pulley Direction flag on the backing field. True = 2, false = 1
		/// </summary>
		public bool PulleyDirection
		{
			get => bitsbyte[1];
			set => bitsbyte[1] = value;
		}

		/// <summary>
		/// Gets or Sets the Velocity > 0 flag on the backing field
		/// </summary>
		public bool HasVelocity
		{
			get => bitsbyte[2];
			set => bitsbyte[2] = value;
		}

		/// <summary>
		/// Gets or Sets the Vortex Stealth flag on the backing field
		/// </summary>
		public bool IsVortexStealthActive
		{
			get => bitsbyte[3];
			set => bitsbyte[3] = value;
		}

		/// <summary>
		/// Gets or Sets the Gravity Direction flag on the backing field. True = 1, False = -1
		/// </summary>
		public bool GravityDirection
		{
			get => bitsbyte[4];
			set => bitsbyte[4] = value;
		}

		/// <summary>
		/// Gets or Sets the Shield Raised flag on the backing field
		/// </summary>
		public bool IsShieldRaised
		{
			get => bitsbyte[5];
			set => bitsbyte[5] = value;
		}

		/// <summary>
		/// Gets or Sets the Ghost flag on the backing field
		/// </summary>
		public bool IsGhosted
		{
			get => bitsbyte[6];
			set => bitsbyte[6] = value;
		}

		/// <summary>
		/// Constructs a new instance of MiscDataSet1 with the given backing BitsByte
		/// </summary>
		/// <param name="bitsbyte"></param>
		public MiscDataSet1(BitsByte bitsbyte)
		{
			this.bitsbyte = bitsbyte;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Models/PlayerUpdate/MiscDataSet2.cs`
```
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria;

namespace TShockAPI.Models.PlayerUpdate
{
	/// <summary>
	/// Model for the second set of misc data sent with a player update packet
	/// </summary>
	public struct MiscDataSet2
	{
		/// <summary>
		/// Backing BitsByte field
		/// </summary>
		public BitsByte bitsbyte;

		/// <summary>
		/// Gets or Sets the keepTryingHoverUp flag on the backing field
		/// </summary>
		public bool TryHoveringUp
		{
			get => bitsbyte[0];
			set => bitsbyte[0] = value;
		}

		/// <summary>
		/// Gets or Sets the Void Vault Enabled flag on the backing field
		/// </summary>
		public bool IsVoidVaultEnabled
		{
			get => bitsbyte[1];
			set => bitsbyte[1] = value;
		}

		/// <summary>
		/// Gets or Sets the Sitting flag on the backing field
		/// </summary>
		public bool IsSitting
		{
			get => bitsbyte[2];
			set => bitsbyte[2] = value;
		}

		/// <summary>
		/// Gets or Sets the Downed DD2 Event (any difficulty) flag on the backing field
		/// </summary>
		public bool HasDownedDd2Event
		{
			get => bitsbyte[3];
			set => bitsbyte[3] = value;
		}

		/// <summary>
		/// Gets or Sets the Petting Animal flag on the backing field
		/// </summary>
		public bool IsPettingAnimal
		{
			get => bitsbyte[4];
			set => bitsbyte[4] = value;
		}

		/// <summary>
		/// Gets or Sets the Is Petted Animal Small flag on the backing field
		/// </summary>
		public bool IsPettedAnimalSmall
		{
			get => bitsbyte[5];
			set => bitsbyte[5] = value;
		}

		/// <summary>
		/// Gets or Sets the Can Return with Potion of Return flag on the backing field
		/// </summary>
		public bool CanReturnWithPotionOfReturn
		{
			get => bitsbyte[6];
			set => bitsbyte[6] = value;
		}

		/// <summary>
		/// Gets or Sets the keepTryingHoverDown flag on the backing field
		/// </summary>
		public bool TryHoveringDown
		{
			get => bitsbyte[7];
			set => bitsbyte[7] = value;
		}

		/// <summary>
		/// Constructs a new instance of MiscDataSet2 with the given backing BitsByte
		/// </summary>
		/// <param name="bitsbyte"></param>
		public MiscDataSet2(BitsByte bitsbyte)
		{
			this.bitsbyte = bitsbyte;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Models/PlayerUpdate/MiscDataSet3.cs`
```
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria;

namespace TShockAPI.Models.PlayerUpdate
{
	/// <summary>
	/// Model for the third set of misc data sent with a player update packet
	/// </summary>
	public struct MiscDataSet3
	{
		public BitsByte bitsbyte;

		/// <summary>
		/// Gets or Sets the Sleeping flag on the backing field
		/// </summary>
		public bool IsSleeping
		{
			get => bitsbyte[0];
			set => bitsbyte[0] = value;
		}

		/// <summary>
		/// Constructs a new instance of MiscDataSet3 with the given backing BitsByte
		/// </summary>
		/// <param name="bitsbyte"></param>
		public MiscDataSet3(BitsByte bitsbyte)
		{
			this.bitsbyte = bitsbyte;
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Models/Projectiles`
#### File: `temp_TShock-5.2.4/TShockAPI/Models/Projectiles/NewProjectileData.cs`
```
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria;

namespace TShockAPI.Models.Projectiles
{
	/// <summary>
	/// Model for the data sent with a new projectile packet
	/// </summary>
	public struct NewProjectileData
	{
		public BitsByte bitsbyte;

		/// <summary>
		/// Gets or Sets the keepTryingHoverDown flag on the backing field
		/// </summary>
		public bool[] AI
		{
			get
			{
				bool[] arr = new bool[Projectile.maxAI];
				for (int i = 0; i < Projectile.maxAI; i++)
				{
					arr[i] = bitsbyte[i];
				}

				return arr;
			}
			set
			{
				for (int i = 0; i < Projectile.maxAI; i++)
				{
					bitsbyte[i] = value[i];
				}
			}
		}

		public bool HasBannerIdToRespondTo
		{
			get => bitsbyte[3];
			set => bitsbyte[3] = value;
		}

		/// <summary>
		/// Gets or Sets the Damage flag on the backing field
		/// </summary>
		public bool HasDamage
		{
			get => bitsbyte[4];
			set => bitsbyte[4] = value;
		}

		/// <summary>
		/// Gets or Sets the Knockback flag on the backing field
		/// </summary>
		public bool HasKnockback
		{
			get => bitsbyte[5];
			set => bitsbyte[5] = value;
		}

		/// <summary>
		/// Gets or Sets the Original Damage flag on the backing field
		/// </summary>
		public bool HasOriginalDamage
		{
			get => bitsbyte[6];
			set => bitsbyte[6] = value;
		}

		/// <summary>
		/// Gets or Sets the UUID flag on the backing field
		/// </summary>
		public bool HasUUUID
		{
			get => bitsbyte[7];
			set => bitsbyte[7] = value;
		}

		/// <summary>
		/// Constructs a new instance of NewProjectileData with the given backing BitsByte
		/// </summary>
		/// <param name="bitsbyte"></param>
		public NewProjectileData(BitsByte bitsbyte)
		{
			this.bitsbyte = bitsbyte;
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Modules`
#### File: `temp_TShock-5.2.4/TShockAPI/Modules/Module.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
using System;
namespace TShockAPI.Modules
{
	public abstract class Module : IDisposable
	{
		/// <summary>
		/// Entry point of the module
		/// </summary>
		public abstract void Initialise();

		/// <summary>
		/// Resource cleanup, e.g. hooks and events
		/// </summary>
		public virtual void Dispose() { }
	}
}


```
#### File: `temp_TShock-5.2.4/TShockAPI/Modules/ModuleManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace TShockAPI.Modules
{
	public class ModuleManager : IDisposable
	{
		private List<Module> _modules = new();

		/// <summary>
		/// Discovers <see cref="Module"/> derived classes from across the assembly
		/// </summary>
		/// <returns>Type definitions of the modules that can be created</returns>
		IEnumerable<Type> CollectModules() => Assembly.GetExecutingAssembly()
				.GetTypes()
				.Where(t => typeof(Module).IsAssignableFrom(t) && !t.IsAbstract)
		;

		/// <summary>
		/// Initialises <see cref="Module"/> derived classes defined across the assembly
		/// </summary>
		/// <param name="parameters">Additional constructor arguments allowed for modules</param>
		public void Initialise(object[] parameters)
		{
			foreach (var moduleType in CollectModules())
				InitialiseModule(moduleType, parameters);
		}

		/// <summary>
		/// Initialises a module by its type definition
		/// </summary>
		/// <param name="moduleType">The type of the module</param>
		/// <param name="parameters">Additional constructor arguments allowed for modules</param>
		public void InitialiseModule(Type moduleType, object[] parameters)
		{
			if (!typeof(Module).IsAssignableFrom(moduleType))
				throw new NotSupportedException(GetString($"Cannot load module {moduleType.FullName} as it does not derive from {typeof(Module).FullName}"));

			var args = new List<object>();
			ConstructorInfo constructor = null;

			foreach (var ctor in moduleType.GetConstructors())
			{
				args.Clear();
				var ctorParams = ctor.GetParameters();

				foreach (var prm in ctorParams)
				{
					var matching_objects = parameters.Where(p => prm.ParameterType.IsAssignableFrom(p.GetType()));
					if (matching_objects.Count() == 1)
						args.Add(matching_objects.Single());
					else
					{
						// skip this ctor since we cannot find a suitable parameter for it.
						break;
					}
				}

				if (args.Count() == ctorParams.Length)
					constructor = ctor;
			}

			if (constructor is not null)
			{
				var module = (Module)constructor.Invoke(args.ToArray());
				_modules.Add(module);
				module.Initialise();
			}
		}

		/// <summary>
		/// Disposes of the module and the manager instance
		/// </summary>
		public void Dispose()
		{
			foreach (var module in _modules)
				module.Dispose();
			_modules.Clear();
		}
	}
}


```
#### File: `temp_TShock-5.2.4/TShockAPI/Modules/ReduceConsoleSpam.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
using System;
using Terraria.Localization;

namespace TShockAPI.Modules;

public class ReduceConsoleSpam : Module
{
	public override void Initialise() =>
		OTAPI.Hooks.Main.StatusTextChange += OnMainStatusTextChange;

	public override void Dispose() =>
		OTAPI.Hooks.Main.StatusTextChange -= OnMainStatusTextChange;

	/// <summary>
	/// Holds the last status text value, to determine if there is a suitable change to report.
	/// </summary>
	private string _lastStatusText = null;

	private readonly string _resettingObjectText = LanguageManager.Instance.GetTextValue("LegacyWorldGen.47");
	private readonly string _loadingText = LanguageManager.Instance.GetTextValue("LegacyWorldGen.51");
	private readonly string _settlingText = LanguageManager.Instance.GetTextValue("LegacyWorldGen.27");
	private readonly string _savingText = LanguageManager.Instance.GetTextValue("LegacyWorldGen.49");
	private readonly string _validatingText = LanguageManager.Instance.GetTextValue("LegacyWorldGen.73");
	private readonly string _finalizingText = LanguageManager.Instance.GetTextValue("LegacyWorldGen.87");

	/// <summary>
	/// Aims to reduce the amount of console spam by filtering out load/save progress
	/// </summary>
	/// <param name="sender"></param>
	/// <param name="e">OTAPI event</param>
	private void OnMainStatusTextChange(object sender, OTAPI.Hooks.Main.StatusTextChangeArgs e)
	{
		void WriteIfChange(string text)
		{
			if (_lastStatusText != text)
			{
				Console.WriteLine(text); // write it manually instead of terraria which causes double writes
				_lastStatusText = text;
			}
		}
		bool replace(string text)
		{
			if (e.Value.StartsWith(text))
			{
				var segment = e.Value.Substring(0, text.Length);
				WriteIfChange(segment);
				e.Value = "";
				return true;
			}
			return false;
		}

		if (replace(_resettingObjectText)
			|| replace(_settlingText)
			|| replace(_loadingText)
			|| replace(_savingText)
			|| replace(_validatingText))
			return;

		// try parsing % - [text] - %
		const string FindMaster = "% - ";
		const string FindSub = " - ";
		var master = e.Value.IndexOf(FindMaster);
		if (master > -1)
		{
			var sub = e.Value.LastIndexOf(FindSub);
			if (master > -1 && sub > master)
			{
				var mprogress = e.Value.Substring(0, master + 1/*%*/);
				var sprogress = e.Value.Substring(sub + FindSub.Length);
				if (mprogress.EndsWith("%") && sprogress.EndsWith("%"))
				{
					var text = e.Value.Substring(master + FindMaster.Length, sub - master - FindMaster.Length).Trim();

					if (text.Length > 0 && !(
						// relogic has made a mess of this
						(
							_lastStatusText != _validatingText
							|| _lastStatusText != _savingText
						)
						&& text == _finalizingText
					))
						WriteIfChange(text);

					e.Value = "";
				}
			}
		}
	}

}


```
### Folder: `temp_TShock-5.2.4/TShockAPI/Net`
#### File: `temp_TShock-5.2.4/TShockAPI/Net/BaseMsg.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.IO.Streams;

namespace TShockAPI.Net
{
	public class BaseMsg : IPackable
	{
		public virtual PacketTypes ID
		{
			get { throw new NotImplementedException(GetString("Msg ID not implemented")); }
		}

		public void PackFull(Stream stream)
		{
			long start = stream.Position;
			stream.WriteInt16(0);
			stream.WriteInt8((byte) ID);
			Pack(stream);
			long end = stream.Position;
			stream.Position = start;
			stream.WriteInt16((short)end);
			stream.Position = end;
		}

		public virtual void Unpack(Stream stream)
		{
			throw new NotImplementedException();
		}

		public virtual void Pack(Stream stream)
		{
			throw new NotImplementedException();
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Net/DisconnectMsg.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.IO;
using System.IO.Streams;
using System.Text;

namespace TShockAPI.Net
{
	internal class DisconnectMsg : BaseMsg
	{
		public override PacketTypes ID
		{
			get { return PacketTypes.Disconnect; }
		}

		public string Reason { get; set; }

		public override void Pack(Stream stream)
		{
			stream.WriteString(Reason);
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/Net/NetTile.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.IO.Streams;
using Terraria;

namespace TShockAPI.Net
{
	public class NetTile : IPackable
	{
		public bool Active { get; set; }
		public ushort Type { get; set; }
		public short FrameX { get; set; }
		public short FrameY { get; set; }
		public bool Lighted { get; set; }
		public ushort Wall { get; set; }
		public byte Liquid { get; set; }
		public byte LiquidType { get; set; }
		public bool Wire { get; set; }
		public bool Wire2 { get; set; }
		public bool Wire3 { get; set; }
		public bool Wire4 { get; set; }
		public bool Inactive { get; set; }
		public bool IsHalf { get; set; }
		public bool IsActuator { get; set; }
		public byte TileColor { get; set; }
		public byte WallColor { get; set; }
		public bool Slope1 { get; set; }
		public bool Slope2 { get; set; }
		public bool Slope3 { get; set; }
		public bool FullbrightBlock { get; set; }
		public bool FullbrightWall { get; set; }
		public bool InvisibleBlock { get; set; }
		public bool InvisibleWall { get; set; }

		public byte Slope
		{
			get
			{
				byte sl = 0;

				if (Slope1)
					sl += 1;

				if (Slope2)
					sl += 2;

				if (Slope3)
					sl += 4;

				return sl;
			}
		}

	public bool HasColor
		{
			get { return TileColor > 0; }
		}

		public bool HasWallColor
		{
			get { return WallColor > 0; }
		}

		public bool HasWall
		{
			get { return Wall > 0; }
		}

		public bool HasLiquid
		{
			get { return Liquid > 0; }
		}

		public bool FrameImportant
		{
			get { return Main.tileFrameImportant[Type]; }
		}

		public NetTile()
		{
			Active = false;
			Type = 0;
			FrameX = -1;
			FrameY = -1;
			Wall = 0;
			Liquid = 0;
			Wire = false;
			Wire2 = false;
			Wire3 = false;
			Wire4 = false;
			Inactive = false;
			TileColor = 0;
			WallColor = 0;
			Lighted = false;
			Slope1 = false;
			Slope2 = false;
			Slope3 = false;
		}

		public NetTile(Stream stream)
			: this()
		{
			Unpack(stream);
		}

		public void Pack(Stream stream)
		{
			var bits = new BitsByte();

			if ((Active) && (!Inactive))
				bits[0] = true;

			if (HasWall)
				bits[2] = true;

			if (HasLiquid)
				bits[3] = true;

			if (Wire)
				bits[4] = true;
			
			if (IsHalf)
				bits[5] = true;

			if (IsActuator)
				bits[6] = true;

			if (Inactive)
				bits[7] = true;

			stream.WriteInt8((byte) bits);

			bits = new BitsByte();

			if ((Wire2))
				bits[0] = true;

			if (Wire3)
				bits[1] = true;

			if (HasColor)
				bits[2] = true;

			if (HasWallColor)
				bits[3] = true;

			if (Slope1)
				bits[4] = true;

			if (Slope2)
				bits[5] = true;

			if (Slope3)
				bits[6] = true;

			if (Wire4)
				bits[7] = true;

			stream.WriteByte(bits);

			bits = new BitsByte();

			if (FullbrightBlock)
				bits[0] = true;

			if (FullbrightWall)
				bits[1] = true;

			if (InvisibleBlock)
				bits[2] = true;

			if (InvisibleWall)
				bits[3] = true;

			stream.WriteByte(bits);

			if (HasColor)
			{
				stream.WriteByte(TileColor);
			}

			if (HasWallColor)
			{
				stream.WriteByte(WallColor);
			}

			if (Active)
			{
				stream.WriteInt16((short)Type);
				if (FrameImportant)
				{
					stream.WriteInt16(FrameX);
					stream.WriteInt16(FrameY);
				}
			}

			if (HasWall)
				stream.WriteInt16((short)Wall);

			if (HasLiquid)
			{
				stream.WriteInt8(Liquid);
				stream.WriteInt8(LiquidType);
			}
		}

		public void Unpack(Stream stream)
		{
			var flags = (BitsByte) stream.ReadInt8();
			var flags2 = (BitsByte)stream.ReadInt8();
			var flags3 = (BitsByte)stream.ReadInt8();

			Wire2 = flags2[0];
			Wire3 = flags2[1];
			Slope1 = flags2[4];
			Slope2 = flags2[5];
			Slope3 = flags2[6];
			Wire4 = flags2[7];

			FullbrightBlock = flags3[0];
			FullbrightWall = flags3[1];
			InvisibleBlock = flags3[2];
			InvisibleWall = flags3[3];

			if (flags2[2])
			{
				TileColor = stream.ReadInt8();
			}

			if (flags2[3])
			{
				WallColor = stream.ReadInt8();
			}

			Active = flags[0];
			if (Active)
			{
				Type = stream.ReadUInt16();
				if (FrameImportant)
				{
					FrameX = stream.ReadInt16();
					FrameY = stream.ReadInt16();
				}
			}

			if (flags[2])
			{
				Wall = stream.ReadUInt16();
			}

			if (flags[3])
			{
				Liquid = stream.ReadInt8();
				LiquidType = stream.ReadInt8();
			}

			if (flags[4])
				Wire = true;

			if (flags[5])
				IsHalf = true;
			
			if (flags[6])
				IsActuator = true;

			if (flags[7])
			{
				Inactive = true;
				Active = false;
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Net/ProjectileRemoveMsg.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.IO;
using System.IO.Streams;

namespace TShockAPI.Net
{
	public class ProjectileRemoveMsg : BaseMsg
	{
		public override PacketTypes ID
		{
			get{ return PacketTypes.ProjectileNew; }
		}

		public short Index { get; set; }
		public byte Owner { get; set; }

		public override void Pack(Stream stream)
		{
			stream.WriteInt16(Index);
			stream.WriteSingle(-1);
			stream.WriteSingle(-1);
			stream.WriteSingle(0);
			stream.WriteSingle(0);
			stream.WriteSingle(0);
			stream.WriteInt16(0);
			stream.WriteByte(Owner);
			stream.WriteInt16(0);
			stream.WriteSingle(0);
			stream.WriteSingle(0);
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/Net/SpawnMsg.cs`
```
﻿﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.IO;
using System.IO.Streams;
using Terraria;

namespace TShockAPI.Net
{
	public class SpawnMsg : BaseMsg
	{
		public override PacketTypes ID
		{
			get { return PacketTypes.PlayerSpawn; }
		}

		public byte PlayerIndex { get; set; }
		public short TileX { get; set; }
		public short TileY { get; set; }
		public int RespawnTimer { get; set; }
		public short NumberOfDeathsPVE { get; set; }
		public short NumberOfDeathsPVP { get; set; }
		public PlayerSpawnContext PlayerSpawnContext { get; set; }

		public override void Pack(Stream stream)
		{
			stream.WriteInt8(PlayerIndex);
			stream.WriteInt16(TileX);
			stream.WriteInt16(TileY);
			stream.WriteInt32(RespawnTimer);
			stream.WriteInt16(NumberOfDeathsPVE);
			stream.WriteInt16(NumberOfDeathsPVP);
			stream.WriteByte((byte) PlayerSpawnContext);
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Net/WorldInfoMsg.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.IO;
using System.IO.Streams;
using System.Text;
using Terraria;

namespace TShockAPI.Net
{
	[Flags]
	public enum BossFlags : byte
	{
		None = 0,
		OrbSmashed = 1,
		DownedBoss1 = 2,
		DownedBoss2 = 4,
		DownedBoss3 = 8,
		HardMode = 16,
		DownedClown = 32,
		ServerSideCharacter = 64,
		DownedPlantBoss = 128
	}

	[Flags]
	public enum BossFlags2 : byte
	{
		None = 0,
		DownedMechBoss1 = 1,
		DownedMechBoss2 = 2,
		DownedMechBoss3 = 4,
		DownedMechBossAny = 8,
		CloudBg = 16,
		Crimson = 32,
		PumpkinMoon = 64,
		SnowMoon = 128
	}

	[Flags]
	public enum BossFlags3 : byte
	{
		None = 0,
		ExpertMode = 1,
		FastForwardTime = 2,
		SlimeRain = 4,
		DownedKingSlime = 8,
		DownedQueenBee = 16,
		DownedFishron = 32,
		DownedMartians = 64,
		DownedAncientCultist = 128
	}

	[Flags]
	public enum BossFlags4 : byte
	{
		None = 0,
		DownedMoonLord = 1,
		DownedHalloweenKing = 2,
		DownedHalloweenTree = 4,
		DownedChristmasIceQueen = 8,
		DownedChristmasSantank = 16,
		DownedChristmasTree = 32
	}

	public class WorldInfoMsg : BaseMsg
	{
		public int Time { get; set; }
		public bool DayTime { get; set; }
		public byte MoonPhase { get; set; }
		public bool BloodMoon { get; set; }
		public bool Eclipse { get; set; }
		public short MaxTilesX { get; set; }
		public short MaxTilesY { get; set; }
		public short SpawnX { get; set; }
		public short SpawnY { get; set; }
		public short WorldSurface { get; set; }
		public short RockLayer { get; set; }
		public int WorldID { get; set; }
		public byte MoonType { get; set; }
		public int TreeX0 { get; set; }
		public int TreeX1 { get; set; }
		public int TreeX2 { get; set; }
		public byte TreeStyle0 { get; set; }
		public byte TreeStyle1 { get; set; }
		public byte TreeStyle2 { get; set; }
		public byte TreeStyle3 { get; set; }
		public int CaveBackX0 { get; set; }
		public int CaveBackX1 { get; set; }
		public int CaveBackX2 { get; set; }
		public byte CaveBackStyle0 { get; set; }
		public byte CaveBackStyle1 { get; set; }
		public byte CaveBackStyle2 { get; set; }
		public byte CaveBackStyle3 { get; set; }
		public byte SetBG0 { get; set; }
		public byte SetBG1 { get; set; }
		public byte SetBG2 { get; set; }
		public byte SetBG3 { get; set; }
		public byte SetBG4 { get; set; }
		public byte SetBG5 { get; set; }
		public byte SetBG6 { get; set; }
		public byte SetBG7 { get; set; }
		public byte IceBackStyle { get; set; }
		public byte JungleBackStyle { get; set; }
		public byte HellBackStyle { get; set; }
		public float WindSpeed { get; set; }
		public byte NumberOfClouds { get; set; }
		public BossFlags BossFlags { get; set; }
		public BossFlags2 BossFlags2 { get; set; }
		public BossFlags3 BossFlags3 { get; set; }
		public BossFlags4 BossFlags4 { get; set; }
		public float Rain { get; set; }
		public string WorldName { get; set; }

		public override PacketTypes ID
		{
			get { return PacketTypes.WorldInfo; }
		}

		public override void Pack(Stream stream)
		{
			BinaryWriter writer = new BinaryWriter(stream);
			writer.Write(Time);
			BitsByte worldinfo = new BitsByte(DayTime, BloodMoon, Eclipse);
			writer.Write(worldinfo);
			writer.Write(MoonPhase);
			writer.Write(MaxTilesX);
			writer.Write(MaxTilesY);
			writer.Write(SpawnX);
			writer.Write(SpawnY);
			writer.Write(WorldSurface);
			writer.Write(RockLayer);
			writer.Write(WorldID);
			writer.Write(WorldName);
			writer.Write(MoonType);

			writer.Write(SetBG0);
			writer.Write(SetBG1);
			writer.Write(SetBG2);
			writer.Write(SetBG3);
			writer.Write(SetBG4);
			writer.Write(SetBG5);
			writer.Write(SetBG6);
			writer.Write(SetBG7);
			writer.Write(IceBackStyle);
			writer.Write(JungleBackStyle);
			writer.Write(HellBackStyle);
			writer.Write(WindSpeed);
			writer.Write(NumberOfClouds);

			writer.Write(TreeX0);
			writer.Write(TreeX1);
			writer.Write(TreeX2);
			writer.Write(TreeStyle0);
			writer.Write(TreeStyle1);
			writer.Write(TreeStyle2);
			writer.Write(TreeStyle3);
			writer.Write(CaveBackX0);
			writer.Write(CaveBackX1);
			writer.Write(CaveBackX2);
			writer.Write(CaveBackStyle0);
			writer.Write(CaveBackStyle1);
			writer.Write(CaveBackStyle2);
			writer.Write(CaveBackStyle3);

			writer.Write(Rain);

			BitsByte bosses1 = new BitsByte((BossFlags & BossFlags.OrbSmashed) == BossFlags.OrbSmashed,
				(BossFlags & BossFlags.DownedBoss1) == BossFlags.DownedBoss1,
				(BossFlags & BossFlags.DownedBoss2) == BossFlags.DownedBoss2,
				(BossFlags & BossFlags.DownedBoss3) == BossFlags.DownedBoss3,
				(BossFlags & BossFlags.HardMode) == BossFlags.HardMode,
				(BossFlags & BossFlags.DownedClown) == BossFlags.DownedClown,
				(BossFlags & BossFlags.ServerSideCharacter) == BossFlags.ServerSideCharacter,
				(BossFlags & BossFlags.DownedPlantBoss) == BossFlags.DownedPlantBoss);
			writer.Write(bosses1);

			BitsByte bosses2 = new BitsByte((BossFlags2 & BossFlags2.DownedMechBoss1) == BossFlags2.DownedMechBoss1,
				(BossFlags2 & BossFlags2.DownedMechBoss2) == BossFlags2.DownedMechBoss2,
				(BossFlags2 & BossFlags2.DownedMechBoss3) == BossFlags2.DownedMechBoss3,
				(BossFlags2 & BossFlags2.DownedMechBossAny) == BossFlags2.DownedMechBossAny,
				(BossFlags2 & BossFlags2.CloudBg) == BossFlags2.CloudBg,
				(BossFlags2 & BossFlags2.Crimson) == BossFlags2.Crimson,
				(BossFlags2 & BossFlags2.PumpkinMoon) == BossFlags2.PumpkinMoon,
				(BossFlags2 & BossFlags2.SnowMoon) == BossFlags2.SnowMoon);
			writer.Write(bosses2);

			BitsByte bosses3 = new BitsByte((BossFlags3 & BossFlags3.ExpertMode) == BossFlags3.ExpertMode,
				(BossFlags3 & BossFlags3.FastForwardTime) == BossFlags3.FastForwardTime,
				(BossFlags3 & BossFlags3.SlimeRain) == BossFlags3.SlimeRain,
				(BossFlags3 & BossFlags3.DownedKingSlime) == BossFlags3.DownedKingSlime,
				(BossFlags3 & BossFlags3.DownedQueenBee) == BossFlags3.DownedQueenBee,
				(BossFlags3 & BossFlags3.DownedFishron) == BossFlags3.DownedFishron,
				(BossFlags3 & BossFlags3.DownedMartians) == BossFlags3.DownedMartians,
				(BossFlags3 & BossFlags3.DownedAncientCultist) == BossFlags3.DownedAncientCultist);
			writer.Write(bosses3);

			BitsByte bosses4 = new BitsByte((BossFlags4 & BossFlags4.DownedMoonLord) == BossFlags4.DownedMoonLord,
				(BossFlags4 & BossFlags4.DownedHalloweenKing) == BossFlags4.DownedHalloweenKing,
				(BossFlags4 & BossFlags4.DownedHalloweenTree) == BossFlags4.DownedHalloweenTree,
				(BossFlags4 & BossFlags4.DownedChristmasIceQueen) == BossFlags4.DownedChristmasIceQueen,
				(BossFlags4 & BossFlags4.DownedChristmasSantank) == BossFlags4.DownedChristmasSantank,
				(BossFlags4 & BossFlags4.DownedChristmasTree) == BossFlags4.DownedChristmasTree);
			writer.Write(bosses4);

			writer.Write((sbyte)Main.invasionType);
			writer.Write(Main.LobbyId);
		}
	}
}
```
### Folder: `temp_TShock-5.2.4/TShockAPI`
#### File: `temp_TShock-5.2.4/TShockAPI/NetItem.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Terraria;

namespace TShockAPI
{
	/// <summary>
	/// Represents an item.
	/// </summary>
	[JsonObject(MemberSerialization.OptIn)]
	public struct NetItem
	{
		/// <summary>
		/// 40 - The number of slots in a piggy bank
		/// </summary>
		public static readonly int PiggySlots = 40;

		/// <summary>
		/// 40 - The number of slots in a safe
		/// </summary>
		public static readonly int SafeSlots = PiggySlots;

		/// <summary>
		/// 40 - The number of slots in a forge
		/// </summary>
		public static readonly int ForgeSlots = SafeSlots;

		/// <summary>
		/// 40 - The number of slots in a void vault
		/// </summary>
		public static readonly int VoidSlots = ForgeSlots;

		/// <summary>
		/// 59 - The size of the player's inventory (inventory, coins, ammo, held item)
		/// </summary>
		public static readonly int InventorySlots = 59;

		/// <summary>
		/// 20 - The number of armor slots.
		/// </summary>
		public static readonly int ArmorSlots = 20;

		/// <summary>
		/// 5 - The number of other equippable items
		/// </summary>
		public static readonly int MiscEquipSlots = 5;

		/// <summary>
		/// 10 - The number of dye slots.
		/// </summary>
		public static readonly int DyeSlots = 10;

		/// <summary>
		/// 5 - The number of other dye slots (for <see cref="MiscEquipSlots"/>)
		/// </summary>
		public static readonly int MiscDyeSlots = MiscEquipSlots;

		/// <summary>
		/// 1 - The number of trash can slots.
		/// </summary>
		public static readonly int TrashSlots = 1;

		/// <summary>
		/// The number of armor slots in a loadout.
		/// </summary>
		public static readonly int LoadoutArmorSlots = ArmorSlots;

		/// <summary>
		/// The number of dye slots in a loadout.
		/// </summary>
		public static readonly int LoadoutDyeSlots = DyeSlots;

		/// <summary>
		/// 180 - The inventory size (inventory, held item, armour, dies, coins, ammo, piggy, safe, and trash)
		/// </summary>
		public static readonly int MaxInventory = InventorySlots + ArmorSlots + DyeSlots + MiscEquipSlots + MiscDyeSlots + PiggySlots +
		                                          SafeSlots + ForgeSlots + VoidSlots + TrashSlots + (LoadoutArmorSlots * 3) +
		                                          (LoadoutDyeSlots * 3);

		public static readonly Tuple<int, int> InventoryIndex = new Tuple<int, int>(0, InventorySlots);
		public static readonly Tuple<int, int> ArmorIndex = new Tuple<int, int>(InventoryIndex.Item2, InventoryIndex.Item2 + ArmorSlots);
		public static readonly Tuple<int, int> DyeIndex = new Tuple<int, int>(ArmorIndex.Item2, ArmorIndex.Item2 + DyeSlots);
		public static readonly Tuple<int, int> MiscEquipIndex = new Tuple<int, int>(DyeIndex.Item2, DyeIndex.Item2 + MiscEquipSlots);
		public static readonly Tuple<int, int> MiscDyeIndex = new Tuple<int, int>(MiscEquipIndex.Item2, MiscEquipIndex.Item2 + MiscDyeSlots);
		public static readonly Tuple<int, int> PiggyIndex = new Tuple<int, int>(MiscDyeIndex.Item2, MiscDyeIndex.Item2 + PiggySlots);
		public static readonly Tuple<int, int> SafeIndex = new Tuple<int, int>(PiggyIndex.Item2, PiggyIndex.Item2 + SafeSlots);
		public static readonly Tuple<int, int> TrashIndex = new Tuple<int, int>(SafeIndex.Item2, SafeIndex.Item2 + TrashSlots);
		public static readonly Tuple<int, int> ForgeIndex = new Tuple<int, int>(TrashIndex.Item2, TrashIndex.Item2 + ForgeSlots);
		public static readonly Tuple<int, int> VoidIndex = new Tuple<int, int>(ForgeIndex.Item2, ForgeIndex.Item2 + VoidSlots);

		public static readonly Tuple<int, int> Loadout1Armor = new Tuple<int, int>(VoidIndex.Item2, VoidIndex.Item2 + LoadoutArmorSlots);
		public static readonly Tuple<int, int> Loadout1Dye = new Tuple<int, int>(Loadout1Armor.Item2, Loadout1Armor.Item2 + LoadoutDyeSlots);

		public static readonly Tuple<int, int> Loadout2Armor = new Tuple<int, int>(Loadout1Dye.Item2, Loadout1Dye.Item2 + LoadoutArmorSlots);
		public static readonly Tuple<int, int> Loadout2Dye = new Tuple<int, int>(Loadout2Armor.Item2, Loadout2Armor.Item2 + LoadoutDyeSlots);

		public static readonly Tuple<int, int> Loadout3Armor = new Tuple<int, int>(Loadout2Dye.Item2, Loadout2Dye.Item2 + LoadoutArmorSlots);
		public static readonly Tuple<int, int> Loadout3Dye = new Tuple<int, int>(Loadout3Armor.Item2, Loadout3Armor.Item2 + LoadoutDyeSlots);

		[JsonProperty("netID")]
		private int _netId;
		[JsonProperty("prefix")]
		private byte _prefixId;
		[JsonProperty("stack")]
		private int _stack;

		/// <summary>
		/// Gets the net ID.
		/// </summary>
		public int NetId
		{
			get { return _netId; }
		}

		/// <summary>
		/// Gets the prefix.
		/// </summary>
		public byte PrefixId
		{
			get { return _prefixId; }
		}

		/// <summary>
		/// Gets the stack.
		/// </summary>
		public int Stack
		{
			get { return _stack; }
		}

		/// <summary>
		/// Creates a new <see cref="NetItem"/>.
		/// </summary>
		/// <param name="netId">The net ID.</param>
		/// <param name="stack">The stack.</param>
		/// <param name="prefixId">The prefix ID.</param>
		public NetItem(int netId, int stack = 1, byte prefixId = 0)
		{
			_netId = netId;
			_stack = stack;
			_prefixId = prefixId;
		}

		/// <summary>
		/// Creates a new <see cref="NetItem"/>.
		/// </summary>
		/// <param name="item">Item in the game.</param>
		public NetItem(Item item)
		{
			_netId = item.netID;
			_stack = item.stack;
			_prefixId = item.prefix;
		}

		/// <summary>
		/// Creates <see cref="Terraria.Item"/> based on data from this structure.
		/// </summary>
		/// <returns>A copy of the item.</returns>
		public Item ToItem()
		{
			Item item = new Item();

			item.netDefaults(_netId);
			item.stack = _stack;
			item.prefix = _prefixId;

			return item;
		}

		/// <summary>
		/// Converts the <see cref="NetItem"/> to a string.
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return String.Format("{0},{1},{2}", _netId, _stack, _prefixId);
		}

		/// <summary>
		/// Converts a string into a <see cref="NetItem"/>.
		/// </summary>
		/// <param name="str">The string.</param>
		/// <exception cref="ArgumentNullException"/>
		/// <exception cref="FormatException"/>
		/// <returns></returns>
		public static NetItem Parse(string str)
		{
			if (str == null)
				throw new ArgumentNullException("str");

			string[] comp = str.Split(',');
			if (comp.Length != 3)
				throw new FormatException("String does not contain three sections.");

			int netId = Int32.Parse(comp[0]);
			int stack = Int32.Parse(comp[1]);
			byte prefixId = Byte.Parse(comp[2]);

			return new NetItem(netId, stack, prefixId);
		}

		/// <summary>
		/// Converts an <see cref="Item"/> into a <see cref="NetItem"/>.
		/// </summary>
		/// <param name="item">The <see cref="Item"/>.</param>
		/// <returns></returns>
		public static explicit operator NetItem(Item item)
		{
			return item == null
				? new NetItem()
				: new NetItem(item.netID, item.stack, item.prefix);
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/PaginationTools.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using Microsoft.Xna.Framework;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace TShockAPI
{
	/// <summary>
	/// Provides tools for sending paginated output.
	/// </summary>
	public static class PaginationTools
	{
		public delegate Tuple<string, Color> LineFormatterDelegate(object lineData, int lineIndex, int pageNumber);

		#region [Nested: Settings Class]
		public class Settings
		{
			public bool IncludeHeader { get; set; }

			private string headerFormat;
			public string HeaderFormat
			{
				get { return this.headerFormat; }
				set
				{
					if (value == null)
						throw new ArgumentNullException();

					this.headerFormat = value;
				}
			}

			public Color HeaderTextColor { get; set; }
			public bool IncludeFooter { get; set; }

			private string footerFormat;
			public string FooterFormat
			{
				get { return this.footerFormat; }
				set
				{
					if (value == null)
						throw new ArgumentNullException();

					this.footerFormat = value;
				}
			}

			public Color FooterTextColor { get; set; }
			public string NothingToDisplayString { get; set; }
			public LineFormatterDelegate LineFormatter { get; set; }
			public Color LineTextColor { get; set; }

			private int maxLinesPerPage;

			public int MaxLinesPerPage
			{
				get { return this.maxLinesPerPage; }
				set
				{
					if (value <= 0)
						throw new ArgumentException(GetString("The value has to be greater than zero."));

					this.maxLinesPerPage = value;
				}
			}

			private int pageLimit;

			public int PageLimit
			{
				get { return this.pageLimit; }
				set
				{
					if (value < 0)
						throw new ArgumentException(GetString("The value has to be greater than or equal to zero."));

					this.pageLimit = value;
				}
			}


			public Settings()
			{
				this.IncludeHeader = true;
				this.headerFormat = GetString("Page {{0}} of {{1}}");
				this.HeaderTextColor = Color.Green;
				this.IncludeFooter = true;
				this.footerFormat = GetString("Type /<command> {{0}} for more.");
				this.FooterTextColor = Color.Yellow;
				this.NothingToDisplayString = null;
				this.LineFormatter = null;
				this.LineTextColor = Color.Yellow;
				this.maxLinesPerPage = 4;
				this.pageLimit = 0;
			}
		}
		#endregion

		public static void SendPage(
		  TSPlayer player, int pageNumber, IEnumerable dataToPaginate, int dataToPaginateCount, Settings settings = null)
		{
			if (settings == null)
				settings = new Settings();

			if (dataToPaginateCount == 0)
			{
				if (settings.NothingToDisplayString != null)
				{
					if (!player.RealPlayer)
						player.SendSuccessMessage(settings.NothingToDisplayString);
					else
						player.SendMessage(settings.NothingToDisplayString, settings.HeaderTextColor);
				}
				return;
			}

			int pageCount = ((dataToPaginateCount - 1) / settings.MaxLinesPerPage) + 1;
			if (settings.PageLimit > 0 && pageCount > settings.PageLimit)
				pageCount = settings.PageLimit;
			if (pageNumber > pageCount)
				pageNumber = pageCount;

			if (settings.IncludeHeader)
			{
				if (!player.RealPlayer)
					player.SendSuccessMessage(string.Format(settings.HeaderFormat, pageNumber, pageCount));
				else
					player.SendMessage(string.Format(settings.HeaderFormat, pageNumber, pageCount), settings.HeaderTextColor);
			}

			int listOffset = (pageNumber - 1) * settings.MaxLinesPerPage;
			int offsetCounter = 0;
			int lineCounter = 0;
			foreach (object lineData in dataToPaginate)
			{
				if (lineData == null)
					continue;
				if (offsetCounter++ < listOffset)
					continue;
				if (lineCounter++ == settings.MaxLinesPerPage)
					break;

				string lineMessage;
				Color lineColor = settings.LineTextColor;
				if (lineData is Tuple<string, Color>)
				{
					var lineFormat = (Tuple<string, Color>)lineData;
					lineMessage = lineFormat.Item1;
					lineColor = lineFormat.Item2;
				}
				else if (settings.LineFormatter != null)
				{
					try
					{
						Tuple<string, Color> lineFormat = settings.LineFormatter(lineData, offsetCounter, pageNumber);
						if (lineFormat == null)
							continue;

						lineMessage = lineFormat.Item1;
						lineColor = lineFormat.Item2;
					}
					catch (Exception ex)
					{
						throw new InvalidOperationException(
						  GetString("The method referenced by LineFormatter has thrown an exception. See inner exception for details."), ex);
					}
				}
				else
				{
					lineMessage = lineData.ToString();
				}

				if (lineMessage != null)
				{
					if (!player.RealPlayer)
						player.SendInfoMessage(lineMessage);
					else
						player.SendMessage(lineMessage, lineColor);
				}
			}

			if (lineCounter == 0)
			{
				if (settings.NothingToDisplayString != null)
				{
					if (!player.RealPlayer)
						player.SendSuccessMessage(settings.NothingToDisplayString);
					else
						player.SendMessage(settings.NothingToDisplayString, settings.HeaderTextColor);
				}
			}
			else if (settings.IncludeFooter && pageNumber + 1 <= pageCount)
			{
				if (!player.RealPlayer)
					player.SendInfoMessage(string.Format(settings.FooterFormat, pageNumber + 1, pageNumber, pageCount));
				else
					player.SendMessage(string.Format(settings.FooterFormat, pageNumber + 1, pageNumber, pageCount), settings.FooterTextColor);
			}
		}

		public static void SendPage(TSPlayer player, int pageNumber, IList dataToPaginate, Settings settings = null)
		{
			PaginationTools.SendPage(player, pageNumber, dataToPaginate, dataToPaginate.Count, settings);
		}

		public static List<string> BuildLinesFromTerms(IEnumerable terms, Func<object, string> termFormatter = null, string separator = ", ", int maxCharsPerLine = 80)
		{
			List<string> lines = new List<string>();
			StringBuilder lineBuilder = new StringBuilder();

			foreach (object term in terms)
			{
				if (term == null && termFormatter == null)
					continue;

				string termString;
				if (termFormatter != null)
				{
					try
					{
						if ((termString = termFormatter(term)) == null)
							continue;
					}
					catch (Exception ex)
					{
						throw new ArgumentException(
						  GetString("The method represented by termFormatter has thrown an exception. See inner exception for details."), ex);
					}
				}
				else
				{
					termString = term.ToString();
				}

				if (lineBuilder.Length + termString.Length + separator.Length < maxCharsPerLine)
				{
					lineBuilder.Append(termString).Append(separator);
				}
				else
				{
					lines.Add(lineBuilder.ToString());
					lineBuilder.Clear().Append(termString).Append(separator);
				}
			}

			if (lineBuilder.Length > 0)
			{
				lines.Add(lineBuilder.ToString().Substring(0, lineBuilder.Length - separator.Length));
			}
			return lines;
		}

		public static bool TryParsePageNumber(List<string> commandParameters, int expectedParameterIndex, TSPlayer errorMessageReceiver, out int pageNumber)
		{
			pageNumber = 1;
			if (commandParameters.Count <= expectedParameterIndex)
				return true;

			string pageNumberRaw = commandParameters[expectedParameterIndex];
			if (!int.TryParse(pageNumberRaw, out pageNumber) || pageNumber < 1)
			{
				if (errorMessageReceiver != null)
					errorMessageReceiver.SendErrorMessage(GetString("\"{0}\" is not a valid page number.", pageNumberRaw));

				pageNumber = 1;
				return false;
			}

			return true;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Permissions.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;

// Since the permission nodes have annotations that say what they are, we don't need XML comments.
#pragma warning disable 1591

namespace TShockAPI
{
	/// <summary>Contains the permission nodes used in TShock.</summary>
	public static class Permissions
	{
		#region tshock.account nodes
		[Description("User can register account in game.")]
		public static readonly string canregister = "tshock.account.register";

		[Description("User can login in game.")]
		public static readonly string canlogin = "tshock.account.login";

		[Description("User can logout in game.")]
		public static readonly string canlogout = "tshock.account.logout";

		[Description("User can change password in game.")]
		public static readonly string canchangepassword = "tshock.account.changepassword";
		#endregion

		#region tshock.admin nodes
		[Description("User can set build protection status.")]
		public static readonly string antibuild = "tshock.admin.antibuild";

		[Description("Prevents you from being kicked.")]
		public static readonly string immunetokick = "tshock.admin.nokick";

		[Obsolete("Ban immunity is no longer available.")]
		[Description("Prevents you from being banned.")]
		public static readonly string immunetoban = "tshock.admin.noban";

		[Description("Specific log messages are sent to users with this permission.")]
		public static readonly string logs = "tshock.admin.viewlogs";

		[Description("User can kick others.")]
		public static readonly string kick = "tshock.admin.kick";

		[Description("User can ban others.")]
		public static readonly string ban = "tshock.admin.ban";

		[Description("User can manage warps.")]
		public static readonly string managewarp = "tshock.admin.warp";

		[Description("User can manage item bans.")]
		public static readonly string manageitem = "tshock.admin.itemban";

		[Description("User can manage projectile bans.")]
		public static readonly string manageprojectile = "tshock.admin.projectileban";

		[Description("User can manage tile bans.")]
		public static readonly string managetile = "tshock.admin.tileban";

		[Description("User can manage groups.")]
		public static readonly string managegroup = "tshock.admin.group";

		[Description("User can manage regions.")]
		public static readonly string manageregion = "tshock.admin.region";

		[Description("User can mute and unmute users.")]
		public static readonly string mute = "tshock.admin.mute";

		[Description("User can see the id of players with /who.")]
		public static readonly string seeids = "tshock.admin.seeplayerids";

		[Description("User can save all the players SSI (server side character) state.")]
		public static readonly string savessc = "tshock.admin.savessi";

		[Description("User can upload their joined character data as SSC data.")]
		public static readonly string uploaddata = "tshock.ssc.upload";

		[Description("User can upload other players join data to the SSC database.")]
		public static readonly string uploadothersdata = "tshock.ssc.upload.others";

		[Description("User can elevate other users' groups temporarily.")]
		public static readonly string settempgroup = "tshock.admin.tempgroup";

		[Description("User can broadcast messages.")]
		public static readonly string broadcast = "tshock.admin.broadcast";

		[Description("User can get other users' info.")]
		public static readonly string userinfo = "tshock.admin.userinfo";
		#endregion

		#region tshock.buff nodes
		[Description("User can buff self.")]
		public static readonly string buff = "tshock.buff.self";

		[Description("User can buff other players.")]
		public static readonly string buffplayer = "tshock.buff.others";
		#endregion

		#region tshock.cfg nodes
		[Description("User is notified when an update is available, user can turn off / restart the server.")]
		public static readonly string maintenance = "tshock.cfg.maintenance";

		[Description("User can modify the whitelist.")]
		public static readonly string whitelist = "tshock.cfg.whitelist";

		[Description("User can edit the server password.")]
		public static readonly string cfgpassword = "tshock.cfg.password";

		[Description("User can reload the configurations file.")]
		public static readonly string cfgreload = "tshock.cfg.reload";

		[Description("User can create reference files of Terraria IDs and the permission matrix in the server folder.")]
		public static readonly string createdumps = "tshock.cfg.createdumps";
		#endregion

		#region tshock.ignore nodes
		[Description("Prevents you from being reverted by kill tile abuse detection.")]
		public static readonly string ignorekilltiledetection = "tshock.ignore.removetile";

		[Description("Prevents you from being reverted by place tile abuse detection.")]
		public static readonly string ignoreplacetiledetection = "tshock.ignore.placetile";

		[Description("Prevents you from being disabled by liquid set abuse detection.")]
		public static readonly string ignoreliquidsetdetection = "tshock.ignore.liquid";

		[Description("Prevents you from being disabled by projectile abuse detection.")]
		public static readonly string ignoreprojectiledetection = "tshock.ignore.projectile";

		[Description("Prevents you from being disabled by paint abuse detection.")]
		public static readonly string ignorepaintdetection = "tshock.ignore.paint";

		[Description("Prevents you from being disabled by stack hack detection.")]
		public static readonly string ignorestackhackdetection = "tshock.ignore.itemstack";

		[Description("Prevents your actions from being ignored if damage is too high.")]
		public static readonly string ignoredamagecap = "tshock.ignore.damage";

		[Description("Prevents your from being kicked by npc buff hack detection.")]
		public static readonly string ignorenpcbuffdetection = "tshock.ignore.npcbuff";

		[Description("Bypass server side character checks.")]
		public static readonly string bypassssc = "tshock.ignore.ssc";

		[Description("Allow unrestricted SendTileSquare usage, for client side world editing.")]
		public static readonly string allowclientsideworldedit = "tshock.ignore.sendtilesquare";

		[Description("Allow dropping banned items without the item being eaten.")]
		public static readonly string allowdroppingbanneditems = "tshock.ignore.dropbanneditem";

		[Description("Prevents you from being disabled by abnormal HP.")]
		public static readonly string ignorehp = "tshock.ignore.hp";

		[Description("Prevents you from being disabled by abnormal MP.")]
		public static readonly string ignoremp = "tshock.ignore.mp";
		#endregion

		#region tshock.item nodes
		[Description("User can give items.")]
		public static readonly string give = "tshock.item.give";

		[Description("User can spawn items.")]
		public static readonly string item = "tshock.item.spawn";

		[Description("Allows you to use banned items.")]
		public static readonly string usebanneditem = "tshock.item.usebanned";
		#endregion

		#region tshock.npc nodes
		[Description("User can edit the max spawns.")]
		public static readonly string maxspawns = "tshock.npc.maxspawns";

		[Description("User can edit the spawnrate.")]
		public static readonly string spawnrate = "tshock.npc.spawnrate";

		[Description("User can start an invasion. Warning: high network use. Easy to abuse.")]
		public static readonly string invade = "tshock.npc.invade";

		[Description("User can hurt town NPCs.")]
		public static readonly string hurttownnpc = "tshock.npc.hurttown";

		[Description("User can spawn bosses.")]
		public static readonly string spawnboss = "tshock.npc.spawnboss";

		[Description("User can spawn pets. Warning: high network use. Easy to abuse.")]
		public static readonly string spawnpets = "tshock.npc.spawnpets";

		[Description("User can rename NPCs.")]
		public static readonly string renamenpc = "tshock.npc.rename";

		[Description("User can spawn npcs.")]
		public static readonly string spawnmob = "tshock.npc.spawnmob";

		[Description("User can kill all enemy npcs.")]
		public static readonly string butcher = "tshock.npc.butcher";

		[Description("User can summon bosses using items.")]
		public static readonly string summonboss = "tshock.npc.summonboss";

		[Description("User can start invasions (Goblin/Snow Legion) using items.")]
		public static readonly string startinvasion = "tshock.npc.startinvasion";

		[Description("User can start the dd2 event.")]
		public static readonly string startdd2 = "tshock.npc.startdd2";

		[Description("User can clear the list of users who have completed an angler quest that day.")]
		public static readonly string clearangler = "tshock.npc.clearanglerquests";

		[Description("Meant for super admins only.")]
		public static readonly string user = "tshock.superadmin.user";

		[Description("Allows a user to elevate to superadmin for 10 minutes.")]
		public static readonly string su = "tshock.su";
		#endregion

		#region tshock.tp nodes
		[Description("User can teleport *everyone* to them.")]
		public static readonly string tpallothers = "tshock.tp.allothers";

		[Description("User can teleport to others.")]
		public static readonly string tp = "tshock.tp.self";

		[Description("User can teleport other people.")]
		public static readonly string tpothers = "tshock.tp.others";

		[Description("User can teleport to tile positions.")]
		public static readonly string tppos = "tshock.tp.pos";

		[Description("User can get the position of players.")]
		public static readonly string getpos = "tshock.tp.getpos";

		[Description("User can teleport to an NPC.")]
		public static readonly string tpnpc = "tshock.tp.npc";

		[Description("Users can stop people from teleporting.")]
		public static readonly string tpallow = "tshock.tp.block";

		[Description("Users can override teleport blocks.")]
		public static readonly string tpoverride = "tshock.tp.override";

		[Description("Users can teleport to people without showing a notice")]
		public static readonly string tpsilent = "tshock.tp.silent";

		[Description("User can use /home.")]
		public static readonly string home = "tshock.tp.home";

		[Description("User can use /spawn.")]
		public static readonly string spawn = "tshock.tp.spawn";

		[Description("User can use the Rod of Discord.")]
		public static readonly string rod = "tshock.tp.rod";

		[Description("User can use wormhole potions.")]
		public static readonly string wormhole = "tshock.tp.wormhole";

		[Description("User can use pylons to teleport")]
		public static readonly string pylon = "tshock.tp.pylon";

		[Description("User can use Teleportation Potions.")]
		public static readonly string tppotion = "tshock.tp.tppotion";

		[Description("User can use the Magic Conch.")]
		public static readonly string magicconch = "tshock.tp.magicconch";

		[Description("User can use the Demon Conch.")]
		public static readonly string demonconch = "tshock.tp.demonconch";
		#endregion

		#region tshock.world nodes
		[Description("User can use the 'worldevent' command")]
		public static readonly string manageevents = "tshock.world.events";

		[Description("User can use the 'bloodmoon' subcommand of the 'worldevent' command")]
		public static readonly string managebloodmoonevent = "tshock.world.events.bloodmoon";

		[Description("User can use the 'fullmoon' subcommand of the 'worldevent' command")]
		public static readonly string managefullmoonevent = "tshock.world.events.fullmoon";

		[Description("User can use the 'invasion' subcommand of the 'worldevent' command")]
		public static readonly string manageinvasionevent = "tshock.world.events.invasion";

		[Description("User can use the 'meteor' subcommand of the 'worldevent' command")]
		public static readonly string managemeteorevent = "tshock.world.events.meteor";

		[Description("User can use the 'eclipse' subcommand of the 'worldevent' command")]
		public static readonly string manageeclipseevent = "tshock.world.events.eclipse";

		[Description("User can use the 'sandstorm' subcommand of the 'worldevent' command")]
		public static readonly string managesandstormevent = "tshock.world.events.sandstorm";

		[Description("User can use the 'rain' subcommand of the 'worldevent' command")]
		public static readonly string managerainevent = "tshock.world.events.rain";

		[Description("User can use the 'lanternsnight' subcommand of the 'worldevent' command")]
		public static readonly string managelanternsnightevent = "tshock.world.events.lanternsnight";

		[Description("User can change expert state.")]
		public static readonly string toggleexpert = "tshock.world.toggleexpert";

		[Description("Allows you to edit the spawn.")]
		public static readonly string editspawn = "tshock.world.editspawn";

		[Description("Allows you to edit regions.")]
		public static readonly string editregion = "tshock.world.editregion";

		[Description("User can force a blood moon.")]
		public static readonly string bloodmoon = "tshock.world.time.bloodmoon";

		[Description("User can set the time.")]
		public static readonly string time = "tshock.world.time.set";

		[Description("Player can use the Enchanted Sundial item.")]
		public static readonly string usesundial = "tshock.world.time.usesundial";

		[Description("Player can use the Enchanted Moondial item.")]
		public static readonly string usemoondial = "tshock.world.time.usemoondial";

		[Description("User can grow plants.")]
		public static readonly string grow = "tshock.world.grow";

		[Description("User can grow evil biome plants.")]
		public static readonly string growevil = "tshock.world.growevil";

		[Description("User can change hardmode state.")]
		public static readonly string hardmode = "tshock.world.hardmode";

		[Description("User can change the homes of NPCs.")]
		public static readonly string movenpc = "tshock.world.movenpc";

		[Obsolete("Feature no longer available.")]
		[Description("User can convert hallow into corruption and vice-versa.")]
		public static readonly string converthardmode = "tshock.world.converthardmode";

		[Description("User can use world-based permanent boosters like Advanced Combat Techniques")]
		public static readonly string worldupgrades = "tshock.world.worldupgrades";

		[Description("User can force the server to Halloween mode.")]
		public static readonly string halloween = "tshock.world.sethalloween";

		[Description("User can force the server to Christmas mode.")]
		public static readonly string xmas = "tshock.world.setxmas";

		[Description("User can save the world.")]
		public static readonly string worldsave = "tshock.world.save";

		[Description("User can settle liquids.")]
		public static readonly string worldsettle = "tshock.world.settleliquids";

		[Description("User can get the world info.")]
		public static readonly string worldinfo = "tshock.world.info";

		[Description("User can set the world spawn.")]
		public static readonly string worldspawn = "tshock.world.setspawn";

		[Description("User can set the dungeon's location.")]
		public static readonly string dungeonposition = "tshock.world.setdungeon";

		[Description("User can drop a meteor.")]
		public static readonly string dropmeteor = "tshock.world.time.dropmeteor";

		[Description("User can force an eclipse.")]
		public static readonly string eclipse = "tshock.world.time.eclipse";

		[Description("User can force a full moon.")]
		public static readonly string fullmoon = "tshock.world.time.fullmoon";

		[Description("User can modify the world.")]
		public static readonly string canbuild = "tshock.world.modify";

		[Description("User can paint tiles.")]
		public static readonly string canpaint = "tshock.world.paint";

		[Description("User can turn on or off sandstorms.")]
		public static readonly string sandstorm = "tshock.world.sandstorm";

		[Description("User can turn on or off the rain.")]
		public static readonly string rain = "tshock.world.rain";

		[Description("User can modify the wind.")]
		public static readonly string wind = "tshock.world.wind";

		[Description("Player can toggle party event.")]
		public static readonly string toggleparty = "tshock.world.toggleparty";
		#endregion

		#region tshock.journey nodes
		[Description("User can use Creative UI freeze time.")]
		public static readonly string journey_timefreeze = "tshock.journey.time.freeze";

		[Description("User can use Creative UI to set world time.")]
		public static readonly string journey_timeset = "tshock.journey.time.set";

		[Description("User can use Creative UI to set world time speed.")]
		public static readonly string journey_timespeed = "tshock.journey.time.setspeed";

		[Description("User can use Creative UI to toggle character godmode.")]
		public static readonly string journey_godmode = "tshock.journey.godmode";

		[Description("User can use Creative UI to set world wind strength/seed.")]
		public static readonly string journey_windstrength = "tshock.journey.wind.strength";

		[Description("User can use Creative UI to stop the world wind strength from changing.")]
		public static readonly string journey_windfreeze = "tshock.journey.wind.freeze";

		[Description("User can use Creative UI to set world rain strength/seed.")]
		public static readonly string journey_rainstrength = "tshock.journey.rain.strength";

		[Description("User can use Creative UI to stop the world rain strength from changing.")]
		public static readonly string journey_rainfreeze = "tshock.journey.rain.freeze";

		[Description("User can use Creative UI to toggle increased placement range.")]
		public static readonly string journey_placementrange = "tshock.journey.placementrange";

		[Description("User can use Creative UI to set world difficulty/mode.")]
		public static readonly string journey_setdifficulty = "tshock.journey.setdifficulty";

		[Description("User can use Creative UI to stop the biome spread of the world.")]
		public static readonly string journey_biomespreadfreeze = "tshock.journey.biomespreadfreeze";

		[Description("User can use Creative UI to set the NPC spawn rate of the world.")]
		public static readonly string journey_setspawnrate = "tshock.journey.setspawnrate";

		[Description("User can contribute research by sacrificing items")]
		public static readonly string journey_contributeresearch = "tshock.journey.research";
		#endregion

		#region Non-grouped
		[Description("User can clear items or projectiles.")]
		public static readonly string clear = "tshock.clear";

		[Description("User can kill others.")]
		public static readonly string kill = "tshock.kill";

		[Description("Player can respawn themselves.")]
		public static readonly string respawn = "tshock.respawn";

		[Description("Player can respawn others.")]
		public static readonly string respawnother = "tshock.respawn.other";

		[Description("Allows you to bypass the max slots for up to 5 slots above your max.")]
		public static readonly string reservedslot = "tshock.reservedslot";

		[Description("User can use warps.")]
		public static readonly string warp = "tshock.warp";

		[Description("User can slap others.")]
		public static readonly string slap = "tshock.slap";

		[Description("User can whisper to others.")]
		public static readonly string whisper = "tshock.whisper";

		[Description("User can annoy others.")]
		public static readonly string annoy = "tshock.annoy";

		[Description("User can heal players.")]
		public static readonly string heal = "tshock.heal";

		[Description("User can use party chat in game.")]
		public static readonly string canpartychat = "tshock.partychat";

		[Description("User can talk in third person.")]
		public static readonly string cantalkinthird = "tshock.thirdperson";

		[Description("User can get the server info.")]
		public static readonly string serverinfo = "tshock.info";

		[Description("Player recovers health as damage is taken.  Can be one shotted.")]
		public static readonly string godmode = "tshock.godmode";

		[Description("User can godmode other players.")]
		public static readonly string godmodeother = "tshock.godmode.other";

		[Description("Player can chat.")]
		public static readonly string canchat = "tshock.canchat";

		[Description("Player can use banned projectiles.")]
		public static readonly string canusebannedprojectiles = "tshock.projectiles.usebanned";

		[Description("Player can place banned tiles.")]
		public static readonly string canusebannedtiles = "tshock.tiles.usebanned";

		[Description("Player can check if a username is registered and see its last login time.")]
		public static readonly string checkaccountinfo = "tshock.accountinfo.check";

		[Description("Player can see advanced information about any user account.")]
		public static readonly string advaccountinfo = "tshock.accountinfo.details";

		[Description("Player can resync themselves with server state.")]
		public static readonly string synclocalarea = "tshock.synclocalarea";

		[Description("Player can send emotes.")]
		public static readonly string sendemoji = "tshock.sendemoji";
		#endregion
		/// <summary>
		/// Lists all commands associated with a given permission
		/// </summary>
		/// <param name="perm">string permission - the permission to get information on</param>
		/// <returns>List of commands</returns>
		private static List<Command> GetCommands(string perm)
		{
			if (Commands.ChatCommands.Count < 1)
				Commands.InitCommands();
			return Commands.ChatCommands.Where(c => c.Permissions.Contains(perm)).ToList();
		}

		/// <summary>
		/// Dumps the descriptions of each permission to a file in Markdown format.
		/// </summary>
		public static void DumpDescriptions()
		{
			var sb = new StringBuilder();
			foreach (var field in typeof(Permissions).GetFields().OrderBy(f => f.Name))
			{
				var name = (string)field.GetValue(null);

				var descattr =
					field.GetCustomAttributes(false).FirstOrDefault(o => o is DescriptionAttribute) as DescriptionAttribute;
				var desc = descattr != null && !string.IsNullOrWhiteSpace(descattr.Description) ? descattr.Description : GetString("No description available.");

				var strs = GetCommands(name).Select(c => c.Names.Count > 1
					? $"/{c.Name} (/{string.Join(" /", c.Names.Skip(1))})"
					: $"/{c.Name}");

				sb.AppendLine($"## {name}");
				sb.AppendLine($"{desc}");
				sb.AppendLine(GetString("* **Commands**: `{0}`", strs.Count() > 0 ? string.Join(", ", strs) : GetString("No associated commands.")));
				sb.AppendLine();
			}

			File.WriteAllText("docs/permission-descriptions.md", sb.ToString());
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/PlayerData.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using Microsoft.Xna.Framework;
using Terraria;
using TShockAPI;
using Terraria.Localization;
using Terraria.GameContent.NetModules;
using Terraria.Net;
using Terraria.ID;
using System;

namespace TShockAPI
{
	public class PlayerData
	{
		public NetItem[] inventory = new NetItem[NetItem.MaxInventory];
		public int health = TShock.ServerSideCharacterConfig.Settings.StartingHealth;
		public int maxHealth = TShock.ServerSideCharacterConfig.Settings.StartingHealth;
		public int mana = TShock.ServerSideCharacterConfig.Settings.StartingMana;
		public int maxMana = TShock.ServerSideCharacterConfig.Settings.StartingMana;
		public bool exists;
		public int spawnX = -1;
		public int spawnY = -1;
		public int? extraSlot;
		public int? skinVariant;
		public int? hair;
		public byte hairDye;
		public Color? hairColor;
		public Color? pantsColor;
		public Color? shirtColor;
		public Color? underShirtColor;
		public Color? shoeColor;
		public Color? skinColor;
		public Color? eyeColor;
		public bool[] hideVisuals;
		public int questsCompleted;
		public int usingBiomeTorches;
		public int happyFunTorchTime;
		public int unlockedBiomeTorches;
		public int currentLoadoutIndex;
		public int ateArtisanBread;
		public int usedAegisCrystal;
		public int usedAegisFruit;
		public int usedArcaneCrystal;
		public int usedGalaxyPearl;
		public int usedGummyWorm;
		public int usedAmbrosia;
		public int unlockedSuperCart;
		public int enabledSuperCart;

		/// <summary>
		/// Sets the default values for the inventory.
		/// </summary>
		[Obsolete("The player argument is not used.")]
		public PlayerData(TSPlayer player) : this(true) { }

		/// <summary>
		/// Sets the default values for the inventory.
		/// </summary>
		/// <param name="includingStarterInventory">Is it necessary to load items from TShock's config</param>
		public PlayerData(bool includingStarterInventory = true)
		{
			for (int i = 0; i < NetItem.MaxInventory; i++)
				this.inventory[i] = new NetItem();

			if (includingStarterInventory)
				for (int i = 0; i < TShock.ServerSideCharacterConfig.Settings.StartingInventory.Count; i++)
				{
					var item = TShock.ServerSideCharacterConfig.Settings.StartingInventory[i];
					StoreSlot(i, item.NetId, item.PrefixId, item.Stack);
				}
		}

		/// <summary>
		/// Stores an item at the specific storage slot
		/// </summary>
		/// <param name="slot"></param>
		/// <param name="netID"></param>
		/// <param name="prefix"></param>
		/// <param name="stack"></param>
		public void StoreSlot(int slot, int netID, byte prefix, int stack)
		{
			StoreSlot(slot, new NetItem(netID, stack, prefix));
		}

		/// <summary>
		/// Stores an item at the specific storage slot
		/// </summary>
		/// <param name="slot"></param>
		/// <param name="item"></param>
		public void StoreSlot(int slot, NetItem item)
		{
			if (slot > (this.inventory.Length - 1) || slot < 0) //if the slot is out of range then dont save
			{
				return;
			}

			this.inventory[slot] = item;
		}

		/// <summary>
		/// Copies a characters data to this object
		/// </summary>
		/// <param name="player"></param>
		public void CopyCharacter(TSPlayer player)
		{
			this.health = player.TPlayer.statLife > 0 ? player.TPlayer.statLife : 1;
			this.maxHealth = player.TPlayer.statLifeMax;
			this.mana = player.TPlayer.statMana;
			this.maxMana = player.TPlayer.statManaMax;
			this.spawnX = player.TPlayer.SpawnX;
			this.spawnY = player.TPlayer.SpawnY;
			extraSlot = player.TPlayer.extraAccessory ? 1 : 0;
			this.skinVariant = player.TPlayer.skinVariant;
			this.hair = player.TPlayer.hair;
			this.hairDye = player.TPlayer.hairDye;
			this.hairColor = player.TPlayer.hairColor;
			this.pantsColor = player.TPlayer.pantsColor;
			this.shirtColor = player.TPlayer.shirtColor;
			this.underShirtColor = player.TPlayer.underShirtColor;
			this.shoeColor = player.TPlayer.shoeColor;
			this.hideVisuals = player.TPlayer.hideVisibleAccessory;
			this.skinColor = player.TPlayer.skinColor;
			this.eyeColor = player.TPlayer.eyeColor;
			this.questsCompleted = player.TPlayer.anglerQuestsFinished;
			this.usingBiomeTorches = player.TPlayer.UsingBiomeTorches ? 1 : 0;
			this.happyFunTorchTime = player.TPlayer.happyFunTorchTime ? 1 : 0;
			this.unlockedBiomeTorches = player.TPlayer.unlockedBiomeTorches ? 1 : 0;
			this.currentLoadoutIndex = player.TPlayer.CurrentLoadoutIndex;
			this.ateArtisanBread = player.TPlayer.ateArtisanBread ? 1 : 0;
			this.usedAegisCrystal = player.TPlayer.usedAegisCrystal ? 1 : 0;
			this.usedAegisFruit = player.TPlayer.usedAegisFruit ? 1 : 0;
			this.usedArcaneCrystal = player.TPlayer.usedArcaneCrystal ? 1 : 0;
			this.usedGalaxyPearl = player.TPlayer.usedGalaxyPearl ? 1 : 0;
			this.usedGummyWorm = player.TPlayer.usedGummyWorm ? 1 : 0;
			this.usedAmbrosia = player.TPlayer.usedAmbrosia ? 1 : 0;
			this.unlockedSuperCart = player.TPlayer.unlockedSuperCart ? 1 : 0;
			this.enabledSuperCart = player.TPlayer.enabledSuperCart ? 1 : 0;

			Item[] inventory = player.TPlayer.inventory;
			Item[] armor = player.TPlayer.armor;
			Item[] dye = player.TPlayer.dye;
			Item[] miscEqups = player.TPlayer.miscEquips;
			Item[] miscDyes = player.TPlayer.miscDyes;
			Item[] piggy = player.TPlayer.bank.item;
			Item[] safe = player.TPlayer.bank2.item;
			Item[] forge = player.TPlayer.bank3.item;
			Item[] voidVault = player.TPlayer.bank4.item;
			Item trash = player.TPlayer.trashItem;
			Item[] loadout1Armor = player.TPlayer.Loadouts[0].Armor;
			Item[] loadout1Dye = player.TPlayer.Loadouts[0].Dye;
			Item[] loadout2Armor = player.TPlayer.Loadouts[1].Armor;
			Item[] loadout2Dye = player.TPlayer.Loadouts[1].Dye;
			Item[] loadout3Armor = player.TPlayer.Loadouts[2].Armor;
			Item[] loadout3Dye = player.TPlayer.Loadouts[2].Dye;

			for (int i = 0; i < NetItem.MaxInventory; i++)
			{
				if (i < NetItem.InventoryIndex.Item2)
				{
					//0-58
					this.inventory[i] = (NetItem)inventory[i];
				}
				else if (i < NetItem.ArmorIndex.Item2)
				{
					//59-78
					var index = i - NetItem.ArmorIndex.Item1;
					this.inventory[i] = (NetItem)armor[index];
				}
				else if (i < NetItem.DyeIndex.Item2)
				{
					//79-88
					var index = i - NetItem.DyeIndex.Item1;
					this.inventory[i] = (NetItem)dye[index];
				}
				else if (i < NetItem.MiscEquipIndex.Item2)
				{
					//89-93
					var index = i - NetItem.MiscEquipIndex.Item1;
					this.inventory[i] = (NetItem)miscEqups[index];
				}
				else if (i < NetItem.MiscDyeIndex.Item2)
				{
					//93-98
					var index = i - NetItem.MiscDyeIndex.Item1;
					this.inventory[i] = (NetItem)miscDyes[index];
				}
				else if (i < NetItem.PiggyIndex.Item2)
				{
					//98-138
					var index = i - NetItem.PiggyIndex.Item1;
					this.inventory[i] = (NetItem)piggy[index];
				}
				else if (i < NetItem.SafeIndex.Item2)
				{
					//138-178
					var index = i - NetItem.SafeIndex.Item1;
					this.inventory[i] = (NetItem)safe[index];
				}
				else if (i < NetItem.TrashIndex.Item2)
				{
					//179-219
					this.inventory[i] = (NetItem)trash;
				}
				else if (i < NetItem.ForgeIndex.Item2)
				{
					//220
					var index = i - NetItem.ForgeIndex.Item1;
					this.inventory[i] = (NetItem)forge[index];
				}
				else if(i < NetItem.VoidIndex.Item2)
				{
					//220
					var index = i - NetItem.VoidIndex.Item1;
					this.inventory[i] = (NetItem)voidVault[index];
				}
				else if(i < NetItem.Loadout1Armor.Item2)
				{
					var index = i - NetItem.Loadout1Armor.Item1;
					this.inventory[i] = (NetItem)loadout1Armor[index];
				}
				else if(i < NetItem.Loadout1Dye.Item2)
				{
					var index = i - NetItem.Loadout1Dye.Item1;
					this.inventory[i] = (NetItem)loadout1Dye[index];
				}
				else if(i < NetItem.Loadout2Armor.Item2)
				{
					var index = i - NetItem.Loadout2Armor.Item1;
					this.inventory[i] = (NetItem)loadout2Armor[index];
				}
				else if(i < NetItem.Loadout2Dye.Item2)
				{
					var index = i - NetItem.Loadout2Dye.Item1;
					this.inventory[i] = (NetItem)loadout2Dye[index];
				}
				else if(i < NetItem.Loadout3Armor.Item2)
				{
					var index = i - NetItem.Loadout3Armor.Item1;
					this.inventory[i] = (NetItem)loadout3Armor[index];
				}
				else if(i < NetItem.Loadout3Dye.Item2)
				{
					var index = i - NetItem.Loadout3Dye.Item1;
					this.inventory[i] = (NetItem)loadout3Dye[index];
				}
			}
		}

		/// <summary>
		/// Restores a player's character to the state stored in the database
		/// </summary>
		/// <param name="player"></param>
		public void RestoreCharacter(TSPlayer player)
		{
			// Start ignoring SSC-related packets! This is critical so that we don't send or receive dirty data!
			player.IgnoreSSCPackets = true;

			player.TPlayer.statLife = this.health;
			player.TPlayer.statLifeMax = this.maxHealth;
			player.TPlayer.statMana = this.maxMana;
			player.TPlayer.statManaMax = this.maxMana;
			player.TPlayer.SpawnX = this.spawnX;
			player.TPlayer.SpawnY = this.spawnY;
			player.TPlayer.hairDye = this.hairDye;
			player.TPlayer.anglerQuestsFinished = this.questsCompleted;
			player.TPlayer.UsingBiomeTorches = this.usingBiomeTorches == 1;
			player.TPlayer.happyFunTorchTime = this.happyFunTorchTime == 1;
			player.TPlayer.unlockedBiomeTorches = this.unlockedBiomeTorches == 1;
			player.TPlayer.CurrentLoadoutIndex = this.currentLoadoutIndex;
			player.TPlayer.ateArtisanBread = this.ateArtisanBread == 1;
			player.TPlayer.usedAegisCrystal = this.usedAegisCrystal == 1;
			player.TPlayer.usedAegisFruit = this.usedAegisFruit == 1;
			player.TPlayer.usedArcaneCrystal = this.usedArcaneCrystal == 1;
			player.TPlayer.usedGalaxyPearl = this.usedGalaxyPearl == 1;
			player.TPlayer.usedGummyWorm = this.usedGummyWorm == 1;
			player.TPlayer.usedAmbrosia = this.usedAmbrosia == 1;
			player.TPlayer.unlockedSuperCart = this.unlockedSuperCart == 1;
			player.TPlayer.enabledSuperCart = this.enabledSuperCart == 1;

			if (extraSlot != null)
				player.TPlayer.extraAccessory = extraSlot.Value == 1 ? true : false;
			if (this.skinVariant != null)
				player.TPlayer.skinVariant = this.skinVariant.Value;
			if (this.hair != null)
				player.TPlayer.hair = this.hair.Value;
			if (this.hairColor != null)
				player.TPlayer.hairColor = this.hairColor.Value;
			if (this.pantsColor != null)
				player.TPlayer.pantsColor = this.pantsColor.Value;
			if (this.shirtColor != null)
				player.TPlayer.shirtColor = this.shirtColor.Value;
			if (this.underShirtColor != null)
				player.TPlayer.underShirtColor = this.underShirtColor.Value;
			if (this.shoeColor != null)
				player.TPlayer.shoeColor = this.shoeColor.Value;
			if (this.skinColor != null)
				player.TPlayer.skinColor = this.skinColor.Value;
			if (this.eyeColor != null)
				player.TPlayer.eyeColor = this.eyeColor.Value;

			if (this.hideVisuals != null)
				player.TPlayer.hideVisibleAccessory = this.hideVisuals;
			else
				player.TPlayer.hideVisibleAccessory = new bool[player.TPlayer.hideVisibleAccessory.Length];

			for (int i = 0; i < NetItem.MaxInventory; i++)
			{
				if (i < NetItem.InventoryIndex.Item2)
				{
					//0-58
					player.TPlayer.inventory[i].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.inventory[i].netID != 0)
					{
						player.TPlayer.inventory[i].stack = this.inventory[i].Stack;
						player.TPlayer.inventory[i].prefix = this.inventory[i].PrefixId;
					}
				}
				else if (i < NetItem.ArmorIndex.Item2)
				{
					//59-78
					var index = i - NetItem.ArmorIndex.Item1;
					player.TPlayer.armor[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.armor[index].netID != 0)
					{
						player.TPlayer.armor[index].stack = this.inventory[i].Stack;
						player.TPlayer.armor[index].prefix = (byte)this.inventory[i].PrefixId;
					}
				}
				else if (i < NetItem.DyeIndex.Item2)
				{
					//79-88
					var index = i - NetItem.DyeIndex.Item1;
					player.TPlayer.dye[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.dye[index].netID != 0)
					{
						player.TPlayer.dye[index].stack = this.inventory[i].Stack;
						player.TPlayer.dye[index].prefix = (byte)this.inventory[i].PrefixId;
					}
				}
				else if (i < NetItem.MiscEquipIndex.Item2)
				{
					//89-93
					var index = i - NetItem.MiscEquipIndex.Item1;
					player.TPlayer.miscEquips[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.miscEquips[index].netID != 0)
					{
						player.TPlayer.miscEquips[index].stack = this.inventory[i].Stack;
						player.TPlayer.miscEquips[index].prefix = (byte)this.inventory[i].PrefixId;
					}
				}
				else if (i < NetItem.MiscDyeIndex.Item2)
				{
					//93-98
					var index = i - NetItem.MiscDyeIndex.Item1;
					player.TPlayer.miscDyes[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.miscDyes[index].netID != 0)
					{
						player.TPlayer.miscDyes[index].stack = this.inventory[i].Stack;
						player.TPlayer.miscDyes[index].prefix = (byte)this.inventory[i].PrefixId;
					}
				}
				else if (i < NetItem.PiggyIndex.Item2)
				{
					//98-138
					var index = i - NetItem.PiggyIndex.Item1;
					player.TPlayer.bank.item[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.bank.item[index].netID != 0)
					{
						player.TPlayer.bank.item[index].stack = this.inventory[i].Stack;
						player.TPlayer.bank.item[index].prefix = (byte)this.inventory[i].PrefixId;
					}
				}
				else if (i < NetItem.SafeIndex.Item2)
				{
					//138-178
					var index = i - NetItem.SafeIndex.Item1;
					player.TPlayer.bank2.item[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.bank2.item[index].netID != 0)
					{
						player.TPlayer.bank2.item[index].stack = this.inventory[i].Stack;
						player.TPlayer.bank2.item[index].prefix = (byte)this.inventory[i].PrefixId;
					}
				}
				else if (i < NetItem.TrashIndex.Item2)
				{
					//179-219
					var index = i - NetItem.TrashIndex.Item1;
					player.TPlayer.trashItem.netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.trashItem.netID != 0)
					{
						player.TPlayer.trashItem.stack = this.inventory[i].Stack;
						player.TPlayer.trashItem.prefix = (byte)this.inventory[i].PrefixId;
					}
				}
				else if (i < NetItem.ForgeIndex.Item2)
				{
					//220
					var index = i - NetItem.ForgeIndex.Item1;
					player.TPlayer.bank3.item[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.bank3.item[index].netID != 0)
					{
						player.TPlayer.bank3.item[index].stack = this.inventory[i].Stack;
						player.TPlayer.bank3.item[index].Prefix((byte)this.inventory[i].PrefixId);
					}
				}
				else if (i < NetItem.VoidIndex.Item2)
				{
					//260
					var index = i - NetItem.VoidIndex.Item1;
					player.TPlayer.bank4.item[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.bank4.item[index].netID != 0)
					{
						player.TPlayer.bank4.item[index].stack = this.inventory[i].Stack;
						player.TPlayer.bank4.item[index].Prefix((byte)this.inventory[i].PrefixId);
					}
				}
				else if (i < NetItem.Loadout1Armor.Item2)
				{
					var index = i - NetItem.Loadout1Armor.Item1;
					player.TPlayer.Loadouts[0].Armor[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.Loadouts[0].Armor[index].netID != 0)
					{
						player.TPlayer.Loadouts[0].Armor[index].stack = this.inventory[i].Stack;
						player.TPlayer.Loadouts[0].Armor[index].Prefix((byte)this.inventory[i].PrefixId);
					}
				}
				else if (i < NetItem.Loadout1Dye.Item2)
				{
					var index = i - NetItem.Loadout1Dye.Item1;
					player.TPlayer.Loadouts[0].Dye[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.Loadouts[0].Dye[index].netID != 0)
					{
						player.TPlayer.Loadouts[0].Dye[index].stack = this.inventory[i].Stack;
						player.TPlayer.Loadouts[0].Dye[index].Prefix((byte)this.inventory[i].PrefixId);
					}
				}
				else if (i < NetItem.Loadout2Armor.Item2)
				{
					var index = i - NetItem.Loadout2Armor.Item1;
					player.TPlayer.Loadouts[1].Armor[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.Loadouts[1].Armor[index].netID != 0)
					{
						player.TPlayer.Loadouts[1].Armor[index].stack = this.inventory[i].Stack;
						player.TPlayer.Loadouts[1].Armor[index].Prefix((byte)this.inventory[i].PrefixId);
					}
				}
				else if (i < NetItem.Loadout2Dye.Item2)
				{
					var index = i - NetItem.Loadout2Dye.Item1;
					player.TPlayer.Loadouts[1].Dye[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.Loadouts[1].Dye[index].netID != 0)
					{
						player.TPlayer.Loadouts[1].Dye[index].stack = this.inventory[i].Stack;
						player.TPlayer.Loadouts[1].Dye[index].Prefix((byte)this.inventory[i].PrefixId);
					}
				}
				else if (i < NetItem.Loadout3Armor.Item2)
				{
					var index = i - NetItem.Loadout3Armor.Item1;
					player.TPlayer.Loadouts[2].Armor[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.Loadouts[2].Armor[index].netID != 0)
					{
						player.TPlayer.Loadouts[2].Armor[index].stack = this.inventory[i].Stack;
						player.TPlayer.Loadouts[2].Armor[index].Prefix((byte)this.inventory[i].PrefixId);
					}
				}
				else if (i < NetItem.Loadout3Dye.Item2)
				{
					var index = i - NetItem.Loadout3Dye.Item1;
					player.TPlayer.Loadouts[2].Dye[index].netDefaults(this.inventory[i].NetId);

					if (player.TPlayer.Loadouts[2].Dye[index].netID != 0)
					{
						player.TPlayer.Loadouts[2].Dye[index].stack = this.inventory[i].Stack;
						player.TPlayer.Loadouts[2].Dye[index].Prefix((byte)this.inventory[i].PrefixId);
					}
				}
			}

			// Just like in MessageBuffer when the client receives a ContinueConnecting, let's sync the CurrentLoadoutIndex _before_ any of
			// the items.
			// This is sent to everyone BUT this player, and then ONLY this player. When using UUID login, it is too soon for the server to
			// broadcast packets to this client.
			NetMessage.SendData((int)PacketTypes.SyncLoadout, remoteClient: player.Index, number: player.Index, number2: player.TPlayer.CurrentLoadoutIndex);
			NetMessage.SendData((int)PacketTypes.SyncLoadout, ignoreClient: player.Index, number: player.Index, number2: player.TPlayer.CurrentLoadoutIndex);

			float slot = 0f;
			for (int k = 0; k < NetItem.InventorySlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name), player.Index, slot, (float)Main.player[player.Index].inventory[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.ArmorSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name), player.Index, slot, (float)Main.player[player.Index].armor[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.DyeSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name), player.Index, slot, (float)Main.player[player.Index].dye[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.MiscEquipSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name), player.Index, slot, (float)Main.player[player.Index].miscEquips[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.MiscDyeSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name), player.Index, slot, (float)Main.player[player.Index].miscDyes[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.PiggySlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name), player.Index, slot, (float)Main.player[player.Index].bank.item[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.SafeSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name), player.Index, slot, (float)Main.player[player.Index].bank2.item[k].prefix);
				slot++;
			}
			NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name), player.Index, slot++, (float)Main.player[player.Index].trashItem.prefix);
			for (int k = 0; k < NetItem.ForgeSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name), player.Index, slot, (float)Main.player[player.Index].bank3.item[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.VoidSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].bank4.item[k].Name), player.Index, slot, (float)Main.player[player.Index].bank4.item[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutArmorSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[0].Armor[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[0].Armor[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutDyeSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[0].Dye[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[0].Dye[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutArmorSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[1].Armor[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[1].Armor[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutDyeSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[1].Dye[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[1].Dye[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutArmorSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[2].Armor[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[2].Armor[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutDyeSlots; k++)
			{
				NetMessage.SendData(5, -1, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[1].Dye[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[2].Dye[k].prefix);
				slot++;
			}


			NetMessage.SendData(4, -1, -1, NetworkText.FromLiteral(player.Name), player.Index, 0f, 0f, 0f, 0);
			NetMessage.SendData(42, -1, -1, NetworkText.Empty, player.Index, 0f, 0f, 0f, 0);
			NetMessage.SendData(16, -1, -1, NetworkText.Empty, player.Index, 0f, 0f, 0f, 0);

			slot = 0f;
			for (int k = 0; k < NetItem.InventorySlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name), player.Index, slot, (float)Main.player[player.Index].inventory[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.ArmorSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name), player.Index, slot, (float)Main.player[player.Index].armor[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.DyeSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name), player.Index, slot, (float)Main.player[player.Index].dye[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.MiscEquipSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name), player.Index, slot, (float)Main.player[player.Index].miscEquips[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.MiscDyeSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name), player.Index, slot, (float)Main.player[player.Index].miscDyes[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.PiggySlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name), player.Index, slot, (float)Main.player[player.Index].bank.item[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.SafeSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name), player.Index, slot, (float)Main.player[player.Index].bank2.item[k].prefix);
				slot++;
			}
			NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name), player.Index, slot++, (float)Main.player[player.Index].trashItem.prefix);
			for (int k = 0; k < NetItem.ForgeSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name), player.Index, slot, (float)Main.player[player.Index].bank3.item[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.VoidSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].bank4.item[k].Name), player.Index, slot, (float)Main.player[player.Index].bank4.item[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutArmorSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[0].Armor[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[0].Armor[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutDyeSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[0].Dye[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[0].Dye[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutArmorSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[1].Armor[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[1].Armor[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutDyeSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[1].Dye[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[1].Dye[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutArmorSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[2].Armor[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[2].Armor[k].prefix);
				slot++;
			}
			for (int k = 0; k < NetItem.LoadoutDyeSlots; k++)
			{
				NetMessage.SendData(5, player.Index, -1, NetworkText.FromLiteral(Main.player[player.Index].Loadouts[2].Dye[k].Name), player.Index, slot, (float)Main.player[player.Index].Loadouts[2].Dye[k].prefix);
				slot++;
			}



			NetMessage.SendData(4, player.Index, -1, NetworkText.FromLiteral(player.Name), player.Index, 0f, 0f, 0f, 0);
			NetMessage.SendData(42, player.Index, -1, NetworkText.Empty, player.Index, 0f, 0f, 0f, 0);
			NetMessage.SendData(16, player.Index, -1, NetworkText.Empty, player.Index, 0f, 0f, 0f, 0);

			for (int k = 0; k < Player.maxBuffs; k++)
			{
				player.TPlayer.buffType[k] = 0;
			}

			/*
			 * The following packets are sent twice because the server will not send a packet to a client
			 * if they have not spawned yet if the remoteclient is -1
			 * This is for when players login via uuid or serverpassword instead of via
			 * the login command.
			 */
			NetMessage.SendData(50, -1, -1, NetworkText.Empty, player.Index, 0f, 0f, 0f, 0);
			NetMessage.SendData(50, player.Index, -1, NetworkText.Empty, player.Index, 0f, 0f, 0f, 0);

			NetMessage.SendData(76, player.Index, -1, NetworkText.Empty, player.Index);
			NetMessage.SendData(76, -1, -1, NetworkText.Empty, player.Index);

			NetMessage.SendData(39, player.Index, -1, NetworkText.Empty, 400);

			if (Main.GameModeInfo.IsJourneyMode)
			{
				var sacrificedItems = TShock.ResearchDatastore.GetSacrificedItems();
				for(int i = 0; i < ItemID.Count; i++)
				{
					var amount = 0;
					if (sacrificedItems.ContainsKey(i))
					{
						amount = sacrificedItems[i];
					}

					var response = NetCreativeUnlocksModule.SerializeItemSacrifice(i, amount);
					NetManager.Instance.SendToClient(response, player.Index);
				}
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/RegionHandler.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using TShockAPI.DB;
using TShockAPI.Hooks;

namespace TShockAPI
{
	/// <summary>
	/// Represents TShock's Region subsystem. This subsystem is in charge of executing region related logic, such as
	/// setting temp points or invoking region events.
	/// </summary>
	internal sealed class RegionHandler : IDisposable
	{
		private readonly RegionManager _regionManager;

		/// <summary>
		/// Initializes a new instance of the <see cref="RegionHandler"/> class with the specified <see cref="RegionManager"/> instance.
		/// </summary>
		/// <param name="regionManager">The <see cref="RegionManager"/> instance.</param>
		public RegionHandler(RegionManager regionManager)
		{
			_regionManager = regionManager;

			GetDataHandlers.GemLockToggle += OnGemLockToggle;
			GetDataHandlers.PlayerUpdate += OnPlayerUpdate;
			GetDataHandlers.TileEdit += OnTileEdit;
		}

		/// <summary>
		/// Disposes the region handler.
		/// </summary>
		public void Dispose()
		{
			GetDataHandlers.GemLockToggle -= OnGemLockToggle;
			GetDataHandlers.PlayerUpdate -= OnPlayerUpdate;
			GetDataHandlers.TileEdit -= OnTileEdit;
		}

		private void OnGemLockToggle(object sender, GetDataHandlers.GemLockToggleEventArgs e)
		{
			if (TShock.Config.Settings.RegionProtectGemLocks)
			{
				if (!_regionManager.CanBuild(e.X, e.Y, e.Player))
				{
					e.Handled = true;
				}
			}
		}

		private void OnPlayerUpdate(object sender, GetDataHandlers.PlayerUpdateEventArgs e)
		{
			var player = e.Player;

			// Store the player's last known region and update the current based on known regions at their coordinates.
			var oldRegion = player.CurrentRegion;
			player.CurrentRegion = _regionManager.GetTopRegion(_regionManager.InAreaRegion(player.TileX, player.TileY));

			// Do not fire any hooks if the player has not left and/or entered a region.
			if (player.CurrentRegion == oldRegion)
			{
				return;
			}

			// Ensure that the player has left a region before invoking the RegionLeft event
			if (oldRegion != null)
			{
				RegionHooks.OnRegionLeft(player, oldRegion);
			}

			// Ensure that the player has entered a valid region before invoking the RegionEntered event 
			if (player.CurrentRegion != null)
			{
				RegionHooks.OnRegionEntered(player, player.CurrentRegion);
			}
		}

		private void OnTileEdit(object sender, GetDataHandlers.TileEditEventArgs e)
		{
			var player = e.Player;

			#region Region Information Display

			if (player.AwaitingName)
			{
				bool includeUnprotected = false;
				bool includeZIndexes = false;
				bool persistentMode = false;

				foreach (string nameParameter in player.AwaitingNameParameters)
				{
					// If this flag is passed the final output will include unprotected regions, i.e regions
					// that have the DisableBuild flag set to false
					if (nameParameter.Equals("-u", StringComparison.InvariantCultureIgnoreCase))
					{
						includeUnprotected = true;
					}

					// If this flag is passed the final output will include a region's Z index
					if (nameParameter.Equals("-z", StringComparison.InvariantCultureIgnoreCase))
					{
						includeZIndexes = true;
					}

					// If this flag is passed the player will continue to receive region information upon editing tiles
					if (nameParameter.Equals("-p", StringComparison.InvariantCultureIgnoreCase))
					{
						persistentMode = true;
					}
				}

				var output = new List<string>();
				foreach (Region region in _regionManager.Regions.OrderBy(r => r.Z).Reverse())
				{
					// Ensure that the specified tile is region protected
					if (e.X < region.Area.Left || e.X > region.Area.Right)
					{
						continue;
					}

					if (e.Y < region.Area.Top || e.Y > region.Area.Bottom)
					{
						continue;
					}

					// Do not include the current region if it has not been protected and the includeUnprotected flag has not been set
					if (!region.DisableBuild && !includeUnprotected)
					{
						continue;
					}

					output.Add($"{region.Name} {(includeZIndexes ? $"(Z:{region.Z}" : string.Empty)}");
				}

				if (output.Count == 0)
				{
					player.SendInfoMessage(includeUnprotected
						? GetString("There are no regions at this point.")
						: GetString("There are no regions at this point, or they are not protected."));
				}
				else
				{
					player.SendInfoMessage(includeUnprotected ? GetString("Regions at this point: ") : GetString("Protected regions at this point: "));

					foreach (string line in PaginationTools.BuildLinesFromTerms(output))
					{
						player.SendMessage(line, Color.White);
					}
				}

				if (!persistentMode)
				{
					player.AwaitingName = false;
					player.AwaitingNameParameters = null;
				}

				// Revert all tile changes and handle the event
				player.SendTileSquareCentered(e.X, e.Y, 4);
				e.Handled = true;
			}

			#endregion

			#region TempPoints Setup

			if (player.AwaitingTempPoint != 0)
			{
				// Set temp point coordinates to current tile coordinates
				player.TempPoints[player.AwaitingTempPoint - 1].X = e.X;
				player.TempPoints[player.AwaitingTempPoint - 1].Y = e.Y;
				player.SendInfoMessage(GetString($"Set temp point {player.AwaitingTempPoint}."));

				// Reset the awaiting temp point
				player.AwaitingTempPoint = 0;

				// Revert all tile changes and handle the event
				player.SendTileSquareCentered(e.X, e.Y, 4);
				e.Handled = true;
			}

			#endregion
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Rest`
#### File: `temp_TShock-5.2.4/TShockAPI/Rest/Rest.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Reflection;
using HttpServer;
using HttpServer.Headers;
using Newtonsoft.Json;
using TShockAPI;
using HttpListener = HttpServer.HttpListener;
using System.Collections;

namespace Rests
{
	/// <summary>
	/// Wraps an <see cref="IParameter"/>, providing URI-unescaping for its value
	/// </summary>
	public class EscapedParameter
	{
		private IParameter _parameter;

		/// <summary>
		/// Name of the parameter
		/// </summary>
		public string Name => _parameter.Name;
		/// <summary>
		/// URI-unescaped value of the parameter
		/// </summary>
		public string Value => Uri.UnescapeDataString(_parameter.Value);

		/// <summary>
		/// Constructs a new EscapedParameter wrapping the given <see cref="IParameter"/>
		/// </summary>
		/// <param name="parameter"></param>
		public EscapedParameter(IParameter parameter)
		{
			_parameter = parameter;
		}
	}

	/// <summary>
	/// Wraps an <see cref="IParameterCollection"/>, providing URI-unescaping for the parameters in the collection
	/// </summary>
	public class EscapedParameterCollection : IEnumerable<EscapedParameter>
	{
		private readonly IParameterCollection _collection;

		/// <summary>
		/// Retrieve a parameter by name, returning the URI-unescaped value
		/// </summary>
		/// <param name="key"></param>
		/// <returns></returns>
		public string this[string key]
		{
			get
			{
				string value = _collection[key];
				return value == null ? value : Uri.UnescapeDataString(value);
			}
		}

		/// <summary>
		/// Constructs a new EscapedParameterCollection wrapping the given <see cref="IParameterCollection"/>
		/// </summary>
		/// <param name="collection"></param>
		public EscapedParameterCollection(IParameterCollection collection)
		{
			_collection = collection;
		}

		/// <summary>
		/// Returns an enumerator that can be used to iterate over this collection
		/// </summary>
		/// <returns></returns>
		public IEnumerator<EscapedParameter> GetEnumerator()
		{
			foreach (IParameter param in _collection)
			{
				yield return new EscapedParameter(param);
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
	}

	/// <summary>
	/// Rest command delegate
	/// </summary>
	/// <param name="args"><see cref="RestRequestArgs"/> object containing Verbs, Parameters, Request, and TokenData</param>
	/// <returns>Response object or null to not handle request</returns>
	public delegate object RestCommandD(RestRequestArgs args);

	/// <summary>
	/// Describes the data contained in a REST request
	/// </summary>
	public class RestRequestArgs
	{
		/// <summary>
		/// Verbs sent in the request
		/// </summary>
		public RestVerbs Verbs { get; private set; }
		/// <summary>
		/// Parameters sent in the request
		/// </summary>
		public EscapedParameterCollection Parameters { get; private set; }
		/// <summary>
		/// The HTTP request
		/// </summary>
		public IRequest Request { get; private set; }
		/// <summary>
		/// Token data used by the request
		/// </summary>
		public SecureRest.TokenData TokenData { get; private set; }
		/// <summary>
		/// <see cref="IHttpContext"/> used by the request
		/// </summary>
		public IHttpContext Context { get; private set; }

		/// <summary>
		/// Creates a new instance of <see cref="RestRequestArgs"/> with the given verbs, parameters, request, and context.
		/// No token data is used
		/// </summary>
		/// <param name="verbs">Verbs used in the request</param>
		/// <param name="param">Parameters used in the request</param>
		/// <param name="request">The HTTP request</param>
		/// <param name="context">The HTTP context</param>
		public RestRequestArgs(RestVerbs verbs, IParameterCollection param, IRequest request, IHttpContext context)
			: this(verbs, param, request, SecureRest.TokenData.None, context)
		{
		}

		/// <summary>
		/// Creates a new instance of <see cref="RestRequestArgs"/> with the given verbs, parameters, request, token data, and context.
		/// </summary>
		/// <param name="verbs">Verbs used in the request</param>
		/// <param name="param">Parameters used in the request</param>
		/// <param name="request">The HTTP request</param>
		/// <param name="tokenData">Token data used in the request</param>
		/// <param name="context">The HTTP context</param>
		public RestRequestArgs(RestVerbs verbs, IParameterCollection param, IRequest request, SecureRest.TokenData tokenData, IHttpContext context)
			: this(verbs, new EscapedParameterCollection(param), request, tokenData, context)
		{
		}

		/// <summary>
		/// Creates a new instance of <see cref="RestRequestArgs"/> with the given verbs, escaped parameters, request, token data, and context.
		/// </summary>
		/// <param name="verbs"></param>
		/// <param name="param"></param>
		/// <param name="request"></param>
		/// <param name="tokenData"></param>
		/// <param name="context"></param>
		public RestRequestArgs(RestVerbs verbs, EscapedParameterCollection param, IRequest request, SecureRest.TokenData tokenData, IHttpContext context)
		{
			Verbs = verbs;
			Parameters = param;
			Request = request;
			TokenData = tokenData;
			Context = context;
		}
	}

	/// <summary>
	/// A RESTful API service
	/// </summary>
	public class Rest : IDisposable
	{
		private readonly List<RestCommand> commands = new List<RestCommand>();
		/// <summary>
		/// Contains redirect URIs. The key is the base URI. The first item of the tuple is the redirect URI.
		/// The second item of the tuple is an optional "upgrade" URI which will be added to the REST response.
		/// </summary>
		private Dictionary<string, Tuple<string, string>> redirects = new Dictionary<string, Tuple<string, string>>();
		private HttpListener listener;
		private StringHeader serverHeader;
		private Timer tokenBucketTimer;
		/// <summary>
		/// Contains tokens used to manage REST authentication
		/// </summary>
		public Dictionary<string, int> tokenBucket = new Dictionary<string, int>();
		/// <summary>
		/// <see cref="IPAddress"/> the REST service is listening on
		/// </summary>
		public IPAddress Ip { get; set; }
		/// <summary>
		/// Port the REST service is listening on
		/// </summary>
		public int Port { get; set; }

		/// <summary>
		/// Creates a new instance of <see cref="Rest"/> listening on the given IP and port
		/// </summary>
		/// <param name="ip"><see cref="IPAddress"/> to listen on</param>
		/// <param name="port">Port to listen on</param>
		public Rest(IPAddress ip, int port)
		{
			Ip = ip;
			Port = port;
			AssemblyName assembly = this.GetType().Assembly.GetName();
			serverHeader = new StringHeader("Server", String.Format("{0}/{1}", assembly.Name, assembly.Version));
		}

		/// <summary>
		/// Starts the RESTful API service
		/// </summary>
		public virtual void Start()
		{
			try
			{
				listener = HttpListener.Create(Ip, Port);
				listener.RequestReceived += OnRequest;
				listener.Start(int.MaxValue);
				tokenBucketTimer = new Timer((e) =>
				{
					DegradeBucket();
				}, null, TimeSpan.Zero, TimeSpan.FromMinutes(Math.Max(TShock.Config.Settings.RESTRequestBucketDecreaseIntervalMinutes, 1)));

			}
			catch (Exception ex)
			{
				TShock.Log.Error(GetString("Fatal Startup Exception"));
				TShock.Log.Error(ex.ToString());
				TShock.Log.ConsoleError(GetString("Invalid REST configuration: \nYou may already have a REST service bound to port {0}. \nPlease adjust your configuration and restart the server. \nPress any key to exit.", Port));
				Console.ReadLine();
				Environment.Exit(1);
			}
		}

		/// <summary>
		/// Starts the RESTful API service using the given <see cref="IPAddress"/> and port
		/// </summary>
		/// <param name="ip"><see cref="IPAddress"/> to listen on</param>
		/// <param name="port">Port to listen on</param>
		public void Start(IPAddress ip, int port)
		{
			Ip = ip;
			Port = port;
			Start();
		}

		/// <summary>
		/// Stops the RESTful API service
		/// </summary>
		public virtual void Stop()
		{
			listener.Stop();
		}

		/// <summary>
		/// Registers a command using the given route
		/// </summary>
		/// <param name="path">URL route</param>
		/// <param name="callback">Command callback</param>
		public void Register(string path, RestCommandD callback)
		{
			AddCommand(new RestCommand(path, callback));
		}

		/// <summary>
		/// Registers a <see cref="RestCommand"/>
		/// </summary>
		/// <param name="com"><see cref="RestCommand"/> to register</param>
		public void Register(RestCommand com)
		{
			AddCommand(com);
		}

		/// <summary>
		/// Registers a redirection from a given REST route to a target REST route, with an optional upgrade URI
		/// </summary>
		/// <param name="baseRoute">The base URI that will be requested</param>
		/// <param name="targetRoute">The target URI to redirect to from the base URI</param>
		/// <param name="upgradeRoute">The upgrade route that will be added as an object to the <see cref="RestObject"/> response of the target route</param>
		/// <param name="parameterized">Whether the route uses parameterized querying or not.</param>
		public void RegisterRedirect(string baseRoute, string targetRoute, string upgradeRoute = null, bool parameterized = true)
		{
			if (redirects.ContainsKey(baseRoute))
			{
				redirects.Add(baseRoute, Tuple.Create(targetRoute, upgradeRoute));
			}
			else
			{
				redirects[baseRoute] = Tuple.Create(targetRoute, upgradeRoute);
			}
		}

		/// <summary>
		/// Adds a <see cref="RestCommand"/> to the service's command list
		/// </summary>
		/// <param name="com"><see cref="RestCommand"/> to add</param>
		protected void AddCommand(RestCommand com)
		{
			commands.Add(com);
		}

		private void DegradeBucket()
		{
			var _bucket = new List<string>(tokenBucket.Keys); // Duplicate the keys so we can modify tokenBucket whilst iterating
			foreach(string key in _bucket)
			{
				int tokens = tokenBucket[key];
				if(tokens > 0)
				{
					tokenBucket[key] -= 1;
				}
				if(tokens <= 0)
				{
					tokenBucket.Remove(key);
				}
			}
		}

		/// <summary>
		/// Called when the <see cref="HttpListener"/> receives a request
		/// </summary>
		/// <param name="sender">Sender of the request</param>
		/// <param name="e">RequestEventArgs received</param>
		protected virtual void OnRequest(object sender, RequestEventArgs e)
		{
			var obj = ProcessRequest(sender, e);
			if (obj == null)
				throw new NullReferenceException("obj");

			var str = JsonConvert.SerializeObject(obj, Formatting.Indented);
			var jsonp = e.Request.Parameters["jsonp"];
			if (!string.IsNullOrWhiteSpace(jsonp))
			{
				str = string.Format("{0}({1});", jsonp, str);
			}
			e.Response.ContentType = new ContentTypeHeader("application/json; charset=utf-8");
			e.Response.Add(serverHeader);
			var bytes = Encoding.UTF8.GetBytes(str);
			e.Response.Body.Write(bytes, 0, bytes.Length);

			e.Response.Status = HttpStatusCode.OK;

			if (obj is RestObject rObj && Enum.TryParse(rObj.Status, out HttpStatusCode status))
			{
				e.Response.Status = status;
			}
		}

		/// <summary>
		/// Attempts to process a request received by the <see cref="HttpListener"/>
		/// </summary>
		/// <param name="sender">Sender of the request</param>
		/// <param name="e">RequestEventArgs received</param>
		/// <returns>A <see cref="RestObject"/> describing the state of the request</returns>
		protected virtual object ProcessRequest(object sender, RequestEventArgs e)
		{
			try
			{
				var uri = e.Request.Uri.AbsolutePath;
				uri = uri.TrimEnd('/');
				string upgrade = null;

				if (redirects.ContainsKey(uri))
				{
					upgrade = redirects[uri].Item2;
					uri = redirects[uri].Item1;
				}

				foreach (var com in commands)
				{
					var verbs = new RestVerbs();
					if (com.HasVerbs)
					{
						var match = Regex.Match(uri, com.UriVerbMatch);
						if (!match.Success)
							continue;
						if ((match.Groups.Count - 1) != com.UriVerbs.Length)
							continue;

						for (int i = 0; i < com.UriVerbs.Length; i++)
							verbs.Add(com.UriVerbs[i], match.Groups[i + 1].Value);
					}
					else if (com.UriTemplate.ToLower() != uri.ToLower())
					{
						continue;
					}

					var obj = ExecuteCommand(com, verbs, e.Request.Parameters, e.Request, e.Context);
					if (obj != null)
					{
						if (!string.IsNullOrWhiteSpace(upgrade) && obj is RestObject)
						{
							if (!(obj as RestObject).ContainsKey("upgrade"))
							{
								(obj as RestObject).Add("upgrade", upgrade);
							}
						}

						return obj;
					}
				}
			}
			catch (Exception exception)
			{
				return new RestObject("500")
				{
					{"error", GetString("Internal server error.") },
					{"errormsg", exception.Message},
					{"stacktrace", exception.StackTrace},
				};
			}
			return new RestObject("404")
			{
				{"error", GetString("Specified API endpoint doesn't exist. Refer to the documentation for a list of valid endpoints.") }
			};
		}

		/// <summary>
		/// Executes a <see cref="RestCommand"/> using the provided verbs, parameters, request, and context objects
		/// </summary>
		/// <param name="cmd">The REST command to execute</param>
		/// <param name="verbs">The REST verbs used in the command</param>
		/// <param name="parms">The REST parameters used in the command</param>
		/// <param name="request">The HTTP request object associated with the command</param>
		/// <param name="context">The HTTP context associated with the command</param>
		/// <returns></returns>
		protected virtual object ExecuteCommand(RestCommand cmd, RestVerbs verbs, IParameterCollection parms, IRequest request, IHttpContext context)
		{
			object result = cmd.Execute(verbs, parms, request, context);
			if (cmd.DoLog && TShock.Config.Settings.LogRest)
			{
				var endpoint = BuildRequestUri(cmd, verbs, parms, false);
				TShock.Log.ConsoleInfo(GetString($"Anonymous requested REST endpoint: {endpoint}"));
			}

			return result;
		}

		/// <summary>
		/// Builds a request URI from the parameters, verbs, and URI template of a <see cref="RestCommand"/>
		/// </summary>
		/// <param name="cmd">The REST command to take the URI template from</param>
		/// <param name="verbs">Verbs used in building the URI string</param>
		/// <param name="parms">Parameters used in building the URI string</param>
		/// <param name="includeToken">Whether or not to include a token in the URI</param>
		/// <returns></returns>
		protected virtual string BuildRequestUri(
			RestCommand cmd, RestVerbs verbs, IParameterCollection parms, bool includeToken = true
		) {
			StringBuilder requestBuilder = new StringBuilder(cmd.UriTemplate);
			char separator = '?';
			foreach (IParameter paramImpl in parms)
			{
				Parameter param = (paramImpl as Parameter);
				if (param == null || (!includeToken && param.Name.Equals("token", StringComparison.InvariantCultureIgnoreCase)))
					continue;

				requestBuilder.Append(separator);
				requestBuilder.Append(param.Name);
				requestBuilder.Append('=');
				requestBuilder.Append(param.Value);
				separator = '&';
			}

			return requestBuilder.ToString();
		}

		#region Dispose

		/// <summary>
		/// Disposes the RESTful API service
		/// </summary>
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Disposes the RESTful API service
		/// </summary>
		/// <param name="disposing"></param>
		protected virtual void Dispose(bool disposing)
		{
			if (disposing)
			{
				if (listener != null)
				{
					listener.Stop();
					listener = null;
				}
			}
		}

		/// <summary>
		/// Destructor
		/// </summary>
		~Rest()
		{
			Dispose(false);
		}

		#endregion
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Rest/RestCommand.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Linq;
using System.Text.RegularExpressions;
using HttpServer;

namespace Rests
{
	public class RestCommand
	{
		public string Name { get; protected set; }
		public string UriTemplate { get; protected set; }
		public string UriVerbMatch { get; protected set; }
		public string[] UriVerbs { get; protected set; }
		public virtual bool RequiresToken { get { return false; } }
		public bool DoLog { get; set; }

		private RestCommandD callback;

		/// <summary>
		/// Creates a new <see cref="RestCommand"/> used with the REST API
		/// </summary>
		/// <param name="name">Used for identification</param>
		/// <param name="uritemplate">Url template</param>
		/// <param name="callback">Rest Command callback</param>
		public RestCommand(string name, string uritemplate, RestCommandD callback)
		{
			Name = name;
			UriTemplate = uritemplate;
			UriVerbMatch = string.Format("^{0}$", string.Join("([^/]*)", Regex.Split(uritemplate, "\\{[^\\{\\}]*\\}")));
			var matches = Regex.Matches(uritemplate, "\\{([^\\{\\}]*)\\}");
			UriVerbs = (from Match match in matches select match.Groups[1].Value).ToArray();
			this.callback = callback;
			DoLog = true;
		}

		/// <summary>
		/// Creates a new <see cref="RestCommand"/> used with the REST API
		/// </summary>
		/// <param name="uritemplate">Url template</param>
		/// <param name="callback">Rest Command callback</param>
		public RestCommand(string uritemplate, RestCommandD callback)
			: this(string.Empty, uritemplate, callback)
		{
		}

		public bool HasVerbs
		{
			get { return UriVerbs.Length > 0; }
		}

		public virtual object Execute(RestVerbs verbs, IParameterCollection parameters, IRequest request, IHttpContext context)
		{
			return callback(new RestRequestArgs(verbs, parameters, request, context));
		}
	}

	public class SecureRestCommand: RestCommand
	{
		public override bool RequiresToken { get { return true; } }
		public string[] Permissions { get; set; }

		private RestCommandD callback;

		public SecureRestCommand(string name, string uritemplate, RestCommandD callback, params string[] permissions)
			: base(name, uritemplate, null)
		{
			this.callback = callback;
			Permissions = permissions;
		}

		public SecureRestCommand(string uritemplate, RestCommandD callback, params string[] permissions)
			: this(string.Empty, uritemplate, callback, permissions)
		{
		}

		public override object Execute(RestVerbs verbs, IParameterCollection parameters, IRequest request, IHttpContext context)
		{
			return new RestObject("401") { Error = GetString("Not authorized. The specified API endpoint requires a token.") };
		}

		public object Execute(RestVerbs verbs, IParameterCollection parameters, SecureRest.TokenData tokenData, IRequest request, IHttpContext context)
		{
			if (tokenData.Equals(SecureRest.TokenData.None))
				return new RestObject("401") { Error = GetString("Not authorized. The specified API endpoint requires a token.") };

			return callback(new RestRequestArgs(verbs, parameters, request, tokenData, context));
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Rest/RestManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using HttpServer;
using Rests;
using Terraria;
using TShockAPI.DB;
using Newtonsoft.Json;

namespace TShockAPI
{
	/// <summary>
	/// Describes the permission required to use an API route
	/// </summary>
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
	public class Permission : Attribute
	{
		/// <summary>
		/// Name of the permission
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// Creates a new instance of <see cref="Permission"/> with the given name
		/// </summary>
		/// <param name="name">Permission required</param>
		public Permission(string name)
		{
			Name = name;
		}
	}

	/// <summary>
	/// Describes the route of a REST API call
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class RouteAttribute : Attribute
	{
		/// <summary>
		/// The route used to call the API
		/// </summary>
		public string Route { get; set; }

		/// <summary>
		/// Creates a new instance of <see cref="RouteAttribute"/> with the given route
		/// </summary>
		/// <param name="route">Route used to call the API</param>
		public RouteAttribute(string route)
		{
			Route = route;
		}
	}

	/// <summary>
	/// Describes a parameter in a REST route
	/// </summary>
	public class ParameterAttribute : Attribute
	{
		/// <summary>
		/// The parameter's name
		/// </summary>
		public string Name { get; set; }
		/// <summary>
		/// Whether the parameter is required or not
		/// </summary>
		public bool Required { get; set; }
		/// <summary>
		/// The parameter's description
		/// </summary>
		public string Description { get; set; }
		/// <summary>
		/// The parameter's System Type
		/// </summary>
		public Type ArgumentType { get; set; }

		/// <summary>
		/// Creates a new instance of <see cref="ParameterAttribute"/> with the given name, description, and type.
		/// A ParameterAttribute may be optional or required.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="req"></param>
		/// <param name="desc"></param>
		/// <param name="type"></param>
		public ParameterAttribute(string name, bool req, string desc, Type type)
		{
			Name = name;
			Required = req;
			Description = desc;
			ArgumentType = type;
		}
	}

	/// <summary>
	/// Describes a parameter in a REST route
	/// </summary>
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
	public class Noun : ParameterAttribute
	{
		/// <summary>
		/// Creates a new instance of <see cref="Noun"/> with the given name, description, and type.
		/// Nouns may be optional or required. A required Noun is akin to a <see cref="Verb"/>
		/// </summary>
		/// <param name="name">Name of the noun</param>
		/// <param name="req">Whether the noun is required or not</param>
		/// <param name="desc">Decription of the noun</param>
		/// <param name="type">System Type of the noun</param>
		public Noun(string name, bool req, string desc, Type type) : base(name, req, desc, type) { }
	}

	/// <summary>
	/// Describes a parameter in a REST route
	/// </summary>
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
	public class Verb : ParameterAttribute
	{
		/// <summary>
		/// Creates a new instance of <see cref="Verb"/> with the given name, description, and type.
		/// Verbs are required arguments.
		/// </summary>
		/// <param name="name">Name of the verb</param>
		/// <param name="desc">Description of the verb</param>
		/// <param name="type">System Type of the verb</param>
		public Verb(string name, string desc, Type type) : base(name, true, desc, type) { }
	}

	/// <summary>
	/// Describes a REST authentication token
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class Token : Noun
	{
		/// <summary>
		/// Creates a new instance of <see cref="Token"/>
		/// </summary>
		public Token() : base("token", true, GetString("The REST authentication token."), typeof(String)) { }
	}

	/// <summary>
	/// Manages a <see cref="Rests.Rest"/> instance
	/// </summary>
	public class RestManager
	{
		/// <summary>
		/// The RESTful API service that handles API requests
		/// </summary>
		private Rest Rest;

		/// <summary>
		/// Creates a new instance of <see cref="RestManager"/> using the provided <see cref="Rest"/> object
		/// </summary>
		/// <param name="rest"></param>
		public RestManager(Rest rest)
		{
			Rest = rest;
		}

		/// <summary>
		/// Registers default TShock REST commands
		/// </summary>
		public void RegisterRestfulCommands()
		{
			// Server Commands
			if (TShock.Config.Settings.EnableTokenEndpointAuthentication)
			{
				Rest.Register(new SecureRestCommand("/v2/server/status", ServerStatusV2));
				Rest.Register(new SecureRestCommand("/v3/server/motd", ServerMotd));
				Rest.Register(new SecureRestCommand("/v3/server/rules", ServerRules));
			}
			else
			{
				Rest.Register(new RestCommand("/v2/server/status", (a) => ServerStatusV2(new RestRequestArgs(a.Verbs, a.Parameters, a.Request, SecureRest.TokenData.None, a.Context))));
				Rest.Register(new RestCommand("/v3/server/motd", (a) => ServerMotd(new RestRequestArgs(a.Verbs, a.Parameters, a.Request, SecureRest.TokenData.None, a.Context))));
				Rest.Register(new RestCommand("/v3/server/rules", (a) => ServerRules(new RestRequestArgs(a.Verbs, a.Parameters, a.Request, SecureRest.TokenData.None, a.Context))));
			}

			Rest.RegisterRedirect("/status", "/v2/server/status");
			Rest.RegisterRedirect("/token/create", "/v2/token/create");

			//server commands
			Rest.RegisterRedirect("/server/motd", "/v3/server/motd");
			Rest.RegisterRedirect("/server/rules", "/v3/server/rules");
			Rest.RegisterRedirect("/server/broadcast", "/v2/server/broadcast");
			Rest.RegisterRedirect("/server/reload", "/v2/server/reload");
			Rest.RegisterRedirect("/server/off", "/v2/server/off");
			Rest.RegisterRedirect("/server/rawcmd", "/v3/server/rawcmd");

			//user commands
			Rest.RegisterRedirect("/users/activelist", "/v2/users/activelist");
			Rest.RegisterRedirect("/users/create", "/v2/users/create");
			Rest.RegisterRedirect("/users/list", "/v2/users/list");
			Rest.RegisterRedirect("/users/read", "/v2/users/read");
			Rest.RegisterRedirect("/users/destroy", "/v2/users/destroy");
			Rest.RegisterRedirect("/users/update", "/v2/users/update");

			//ban commands
			Rest.RegisterRedirect("/bans/create", "/v3/bans/create");
			Rest.RegisterRedirect("/bans/list", "/v3/bans/list");
			Rest.RegisterRedirect("/bans/read", "/v3/bans/read");
			Rest.RegisterRedirect("/bans/destroy", "/v3/bans/destroy");
			Rest.RegisterRedirect("/v2/bans/list", "/v3/bans/list");
			Rest.RegisterRedirect("/v2/bans/read", "/v3/bans/read");
			Rest.RegisterRedirect("/v2/bans/destroy", "/v3/bans/destroy");

			//world commands
			Rest.RegisterRedirect("/world/bloodmoon", "v3/world/bloodmoon");
			Rest.RegisterRedirect("/world/save", "/v2/world/save");
			Rest.RegisterRedirect("/world/autosave", "/v3/world/autosave");

			//player commands
			Rest.RegisterRedirect("/lists/players", "/lists/players", "/v2/players/list");
			Rest.RegisterRedirect("/players/list", "/v2/players/list");
			Rest.RegisterRedirect("/players/read", "/v3/players/read", "v4/players/read");
			Rest.RegisterRedirect("/players/kick", "/v2/players/kick");
			Rest.RegisterRedirect("/players/ban", "/v2/players/ban");
			Rest.RegisterRedirect("/players/kill", "/v2/players/kill");
			Rest.RegisterRedirect("/players/mute", "/v2/players/mute");
			Rest.RegisterRedirect("/players/unmute", "/v2/players/unmute");

			//group commands
			Rest.RegisterRedirect("/groups/list", "/v2/groups/list");
			Rest.RegisterRedirect("/groups/read", "/v2/groups/read");
			Rest.RegisterRedirect("/groups/destroy", "/v2/groups/destroy");
			Rest.RegisterRedirect("/groups/create", "/v2/groups/create");
			Rest.RegisterRedirect("/groups/update", "/v2/groups/update");


			Rest.Register(new SecureRestCommand("/v2/server/broadcast", ServerBroadcast, RestPermissions.restbroadcast));
			Rest.Register(new SecureRestCommand("/v3/server/reload", ServerReload, RestPermissions.restcfg));
			Rest.Register(new SecureRestCommand("/v2/server/off", ServerOff, RestPermissions.restmaintenance));
			Rest.Register(new SecureRestCommand("/v3/server/rawcmd", ServerCommandV3, RestPermissions.restrawcommand));
			Rest.Register(new SecureRestCommand("/tokentest", ServerTokenTest));

			// User Commands
			Rest.Register(new SecureRestCommand("/v2/users/activelist", UserActiveListV2, RestPermissions.restviewusers));
			Rest.Register(new SecureRestCommand("/v2/users/create", UserCreateV2, RestPermissions.restmanageusers) { DoLog = false });
			Rest.Register(new SecureRestCommand("/v2/users/list", UserListV2, RestPermissions.restviewusers));
			Rest.Register(new SecureRestCommand("/v2/users/read", UserInfoV2, RestPermissions.restviewusers));
			Rest.Register(new SecureRestCommand("/v2/users/destroy", UserDestroyV2, RestPermissions.restmanageusers));
			Rest.Register(new SecureRestCommand("/v2/users/update", UserUpdateV2, RestPermissions.restmanageusers) { DoLog = false });

			// Ban Commands
			Rest.Register(new SecureRestCommand("/v3/bans/create", BanCreateV3, RestPermissions.restban, RestPermissions.restmanagebans));
			Rest.Register(new SecureRestCommand("/v3/bans/list", BanListV3, RestPermissions.restviewbans));
			Rest.Register(new SecureRestCommand("/v3/bans/read", BanInfoV3, RestPermissions.restviewbans));
			Rest.Register(new SecureRestCommand("/v3/bans/destroy", BanDestroyV3, RestPermissions.restmanagebans));

			// World Commands
			Rest.Register(new SecureRestCommand("/world/read", WorldRead));
			Rest.Register(new SecureRestCommand("/world/meteor", WorldMeteor, RestPermissions.restcauseevents));
			Rest.Register(new SecureRestCommand("/world/bloodmoon/{bloodmoon}", WorldBloodmoon, RestPermissions.restcauseevents));
			Rest.Register(new SecureRestCommand("/v3/world/bloodmoon", WorldBloodmoonV3, RestPermissions.restcauseevents));
			Rest.Register(new SecureRestCommand("/v2/world/save", WorldSave, RestPermissions.restcfg));
			Rest.Register(new SecureRestCommand("/v2/world/autosave/state/{state}", WorldChangeSaveSettings, RestPermissions.restcfg));
			Rest.Register(new SecureRestCommand("/v3/world/autosave", WorldChangeSaveSettingsV3, RestPermissions.restcfg));
			Rest.Register(new SecureRestCommand("/v2/world/butcher", WorldButcher, RestPermissions.restbutcher));

			// Player Commands
			Rest.Register(new SecureRestCommand("/lists/players", PlayerList));
			Rest.Register(new SecureRestCommand("/v2/players/list", PlayerListV2));
			Rest.Register(new SecureRestCommand("/v3/players/read", PlayerReadV3, RestPermissions.restuserinfo));
			Rest.Register(new SecureRestCommand("/v4/players/read", PlayerReadV4, RestPermissions.restuserinfo));
			Rest.Register(new SecureRestCommand("/v2/players/kick", PlayerKickV2, RestPermissions.restkick));
			Rest.Register(new SecureRestCommand("/v2/players/kill", PlayerKill, RestPermissions.restkill));
			Rest.Register(new SecureRestCommand("/v2/players/mute", PlayerMute, RestPermissions.restmute));
			Rest.Register(new SecureRestCommand("/v2/players/unmute", PlayerUnMute, RestPermissions.restmute));

			// Group Commands
			Rest.Register(new SecureRestCommand("/v2/groups/list", GroupList, RestPermissions.restviewgroups));
			Rest.Register(new SecureRestCommand("/v2/groups/read", GroupInfo, RestPermissions.restviewgroups));
			Rest.Register(new SecureRestCommand("/v2/groups/destroy", GroupDestroy, RestPermissions.restmanagegroups));
			Rest.Register(new SecureRestCommand("/v2/groups/create", GroupCreate, RestPermissions.restmanagegroups));
			Rest.Register(new SecureRestCommand("/v2/groups/update", GroupUpdate, RestPermissions.restmanagegroups));
		}

		#region Rest Server Methods

		[Description("Executes a remote command on the server, and returns the output of the command.")]
		[RouteAttribute("/v3/server/rawcmd")]
		[Permission(RestPermissions.restrawcommand)]
		[Noun("cmd", true, "The command and arguments to execute.", typeof(String))]
		[Token]
		private object ServerCommandV3(RestRequestArgs args)
		{
			if (string.IsNullOrWhiteSpace(args.Parameters["cmd"]))
				return RestMissingParam("cmd");

			Group restPlayerGroup = TShock.Groups.GetGroupByName(args.TokenData.UserGroupName);

			TSRestPlayer tr = new TSRestPlayer(args.TokenData.Username, restPlayerGroup);
			Commands.HandleCommand(tr, args.Parameters["cmd"]);
			return new RestObject()
			{
				{"response", tr.GetCommandOutput()}
			};
		}

		[Description("Turn the server off.")]
		[Route("/v2/server/off")]
		[Permission(RestPermissions.restmaintenance)]
		[Noun("confirm", true, "Required to confirm that actually want to turn the server off.", typeof(bool))]
		[Noun("message", false, "The shutdown message.", typeof(String))]
		[Noun("nosave", false, "Shutdown without saving.", typeof(bool))]
		[Token]
		private object ServerOff(RestRequestArgs args)
		{
			if (!GetBool(args.Parameters["confirm"], false))
				return RestInvalidParam("confirm");

			// Inform players the server is shutting down
			var reason = string.IsNullOrWhiteSpace(args.Parameters["message"]) ? "Server is shutting down" : args.Parameters["message"];
			TShock.Utils.StopServer(!GetBool(args.Parameters["nosave"], false), reason);

			return RestResponse("The server is shutting down");
		}

		[Description("Reload config files for the server.")]
		[Route("/v3/server/reload")]
		[Permission(RestPermissions.restcfg)]
		[Token]
		private object ServerReload(RestRequestArgs args)
		{
			TShock.Utils.Reload();
			Hooks.GeneralHooks.OnReloadEvent(new TSRestPlayer(args.TokenData.Username, TShock.Groups.GetGroupByName(args.TokenData.UserGroupName)));

			return RestResponse("Configuration, permissions, and regions reload complete. Some changes may require a server restart.");
		}

		[Description("Broadcast a server wide message.")]
		[Route("/v2/server/broadcast")]
		[Noun("msg", true, "The message to broadcast.", typeof(String))]
		[Token]
		private object ServerBroadcast(RestRequestArgs args)
		{
			var msg = args.Parameters["msg"];
			if (string.IsNullOrWhiteSpace(msg))
				return RestMissingParam("msg");
			TSPlayer.All.SendInfoMessage(msg);
			return RestResponse("The message was broadcasted successfully");
		}

		[Description("Returns the motd, if it exists.")]
		[Route("/v3/server/motd")]
		[Token]
		private object ServerMotd(RestRequestArgs args)
		{
			string motdFilePath = FileTools.MotdPath;
			if (!File.Exists(motdFilePath))
				return this.RestError("The motd.txt was not found.", "500");

			return new RestObject()
			{
				{"motd", File.ReadAllLines(motdFilePath)}
			};
		}

		[Description("Returns the rules, if they exist.")]
		[Route("/v3/server/rules")]
		[Token]
		private object ServerRules(RestRequestArgs args)
		{
			string rulesFilePath = Path.Combine(TShock.SavePath, "rules.txt");
			if (!File.Exists(rulesFilePath))
				return this.RestError("The rules.txt was not found.", "500");

			return new RestObject()
			{
				{"rules", File.ReadAllLines(rulesFilePath)}
			};
		}

		[Description("Get a list of information about the current TShock server.")]
		[Route("/v2/server/status")]
		[Token]
		private object ServerStatusV2(RestRequestArgs args)
		{
			var ret = new RestObject()
			{
				{"name", TShock.Config.Settings.ServerName},
				{"serverversion", Main.versionNumber},
				{"tshockversion", TShock.VersionNum},
				{"port", TShock.Config.Settings.ServerPort},
				{"playercount", TShock.Utils.GetActivePlayerCount()},
				{"maxplayers", TShock.Config.Settings.MaxSlots},
				{"world", (TShock.Config.Settings.UseServerName ? TShock.Config.Settings.ServerName : Main.worldName)},
				{"uptime", (DateTime.Now - System.Diagnostics.Process.GetCurrentProcess().StartTime).ToString(@"d'.'hh':'mm':'ss")},
				{"serverpassword", !string.IsNullOrEmpty(TShock.Config.Settings.ServerPassword)}
			};

			if (GetBool(args.Parameters["players"], false))
			{
				var players = new ArrayList();
				foreach (TSPlayer tsPlayer in TShock.Players.Where(p => null != p))
				{
					var p = PlayerFilter(tsPlayer, args.Parameters, (!string.IsNullOrEmpty(args.TokenData.UserGroupName) && TShock.Groups.GetGroupByName(args.TokenData.UserGroupName).HasPermission(RestPermissions.viewips)));
					if (null != p)
						players.Add(p);
				}
				ret.Add("players", players);
			}

			if (GetBool(args.Parameters["rules"], false))
			{
				var rules = new Dictionary<string, object>();
				rules.Add("AutoSave", TShock.Config.Settings.AutoSave);
				rules.Add("DisableBuild", TShock.Config.Settings.DisableBuild);
				rules.Add("DisableClownBombs", TShock.Config.Settings.DisableClownBombs);
				rules.Add("DisableDungeonGuardian", TShock.Config.Settings.DisableDungeonGuardian);
				rules.Add("DisableInvisPvP", TShock.Config.Settings.DisableInvisPvP);
				rules.Add("DisableSnowBalls", TShock.Config.Settings.DisableSnowBalls);
				rules.Add("DisableTombstones", TShock.Config.Settings.DisableTombstones);
				rules.Add("EnableWhitelist", TShock.Config.Settings.EnableWhitelist);
				rules.Add("HardcoreOnly", TShock.Config.Settings.HardcoreOnly);
				rules.Add("PvPMode", TShock.Config.Settings.PvPMode);
				rules.Add("SpawnProtection", TShock.Config.Settings.SpawnProtection);
				rules.Add("SpawnProtectionRadius", TShock.Config.Settings.SpawnProtectionRadius);
				rules.Add("ServerSideInventory", Main.ServerSideCharacter);

				ret.Add("rules", rules);
			}
			return ret;
		}

		[Description("Test if a token is still valid.")]
		[Route("/tokentest")]
		[Token]
		private object ServerTokenTest(RestRequestArgs args)
		{
			return new RestObject()
			{
				{"response", "Token is valid and was passed through correctly."},
				{"associateduser", args.TokenData.Username}
			};
		}

		#endregion

		#region Rest User Methods

		[Description("Returns the list of user accounts that are currently in use on the server.")]
		[Route("/v2/users/activelist")]
		[Permission(RestPermissions.restviewusers)]
		[Token]
		private object UserActiveListV2(RestRequestArgs args)
		{
			return new RestObject() { { "activeusers", string.Join("\t", TShock.Players.Where(p => null != p && null != p.Account && p.Active).Select(p => p.Account.Name)) } };
		}

		[Description("Lists all user accounts in the TShock database.")]
		[Route("/v2/users/list")]
		[Permission(RestPermissions.restviewusers)]
		[Token]
		private object UserListV2(RestRequestArgs args)
		{
			return new RestObject() { { "users", TShock.UserAccounts.GetUserAccounts().Select(p => new Dictionary<string,object>(){
				{"name", p.Name},
				{"id", p.ID},
				{"group", p.Group},
			}) } };
		}

		[Description("Create a new TShock user account.")]
		[Route("/v2/users/create")]
		[Permission(RestPermissions.restmanageusers)]
		[Noun("user", true, "The user account name for the new account.", typeof(String))]
		[Noun("group", false, "The group the new account should be assigned.", typeof(String))]
		[Noun("password", true, "The password for the new account.", typeof(String))]
		[Token]
		private object UserCreateV2(RestRequestArgs args)
		{
			var username = args.Parameters["user"];
			if (string.IsNullOrWhiteSpace(username))
				return RestMissingParam("user");

			var group = args.Parameters["group"];
			if (string.IsNullOrWhiteSpace(group))
				group = TShock.Config.Settings.DefaultRegistrationGroupName;

			var password = args.Parameters["password"];
			if (string.IsNullOrWhiteSpace(password))
				return RestMissingParam("password");

			// NOTE: ip can be blank
			UserAccount account = new UserAccount(username, "", "", group, "", "", "");
			try
			{
				account.CreateBCryptHash(password);
				TShock.UserAccounts.AddUserAccount(account);
			}
			catch (Exception e)
			{
				return RestError(e.Message);
			}

			return RestResponse("User was successfully created");
		}

		[Description("Update a users information.")]
		[Route("/v2/users/update")]
		[Permission(RestPermissions.restmanageusers)]
		[Noun("user", true, "The search criteria (name or id of account to lookup).", typeof(String))]
		[Noun("type", true, "The search criteria type (name for name lookup, id for id lookup).", typeof(String))]
		[Noun("password", false, "The users new password, and at least this or group must be defined.", typeof(String))]
		[Noun("group", false, "The new group for the user, at least this or password must be defined.", typeof(String))]
		[Token]
		private object UserUpdateV2(RestRequestArgs args)
		{
			var ret = UserFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			var password = args.Parameters["password"];
			var group = args.Parameters["group"];
			if (string.IsNullOrWhiteSpace(group) && string.IsNullOrWhiteSpace(password))
				return RestMissingParam("group", "password");

			UserAccount account = (UserAccount)ret;
			var response = new RestObject();
			if (!string.IsNullOrWhiteSpace(password))
			{
				try
				{
					TShock.UserAccounts.SetUserAccountPassword(account, password);
					response.Add("password-response", "Password updated successfully");
				}
				catch (Exception e)
				{
					return RestError("Failed to update user password (" + e.Message + ")");
				}
			}

			if (!string.IsNullOrWhiteSpace(group))
			{
				try
				{
					TShock.UserAccounts.SetUserGroup(new TSRestPlayer(args.TokenData.Username, TShock.Groups.GetGroupByName(args.TokenData.UserGroupName)),
						account, group);
					response.Add("group-response", "Group updated successfully");
				}
				catch (Exception e)
				{
					return RestError("Failed to update user group (" + e.Message + ")");
				}
			}

			return response;
		}

		[Description("Destroy a TShock user account.")]
		[Route("/v2/users/destroy")]
		[Permission(RestPermissions.restmanageusers)]
		[Noun("user", true, "The search criteria (name or id of account to lookup).", typeof(String))]
		[Noun("type", true, "The search criteria type (name for name lookup, id for id lookup).", typeof(String))]
		[Token]
		private object UserDestroyV2(RestRequestArgs args)
		{
			var ret = UserFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			try
			{
				TShock.UserAccounts.RemoveUserAccount((UserAccount)ret);
			}
			catch (Exception e)
			{
				return RestError(e.Message);
			}

			return RestResponse("User deleted successfully");
		}

		[Description("List detailed information for a user account.")]
		[Route("/v2/users/read")]
		[Permission(RestPermissions.restviewusers)]
		[Noun("user", true, "The search criteria (name or id of account to lookup).", typeof(String))]
		[Noun("type", true, "The search criteria type (name for name lookup, id for id lookup).", typeof(String))]
		[Token]
		private object UserInfoV2(RestRequestArgs args)
		{
			var ret = UserFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			UserAccount account = (UserAccount)ret;
			return new RestObject() { { "group", account.Group }, { "id", account.ID.ToString() }, { "name", account.Name } };
		}

		#endregion

		#region Rest Ban Methods

		[Description("Create a new ban entry.")]
		[Route("/v3/bans/create")]
		[Permission(RestPermissions.restmanagebans)]
		[Noun("identifier", true, "The identifier to ban.", typeof(String))]
		[Noun("reason", false, "The reason to assign to the ban.", typeof(String))]
		[Noun("start", false, "The datetime at which the ban should start.", typeof(String))]
		[Noun("end", false, "The datetime at which the ban should end.", typeof(String))]
		[Token]
		private object BanCreateV3(RestRequestArgs args)
		{
			string identifier = args.Parameters["identifier"];
			if (string.IsNullOrWhiteSpace(identifier))
				return RestMissingParam("identifier");

			string reason = args.Parameters["reason"];
			if (string.IsNullOrWhiteSpace(reason))
				reason = "Banned";

			if (!DateTime.TryParse(args.Parameters["start"], out DateTime startDate))
				startDate = DateTime.UtcNow;

			if (!DateTime.TryParse(args.Parameters["end"], out DateTime endDate))
				endDate = DateTime.MaxValue;

			AddBanResult banResult = TShock.Bans.InsertBan(identifier, reason, args.TokenData.Username, startDate, endDate);
			if (banResult.Ban != null)
			{
				TSPlayer player = null;
				if (identifier.StartsWith(Identifier.IP.Prefix))
				{
					player = TShock.Players.FirstOrDefault(p => p.IP == identifier.Substring(Identifier.IP.Prefix.Length));
				}
				else if (identifier.StartsWith(Identifier.Name.Prefix))
				{
					//Character names may not necessarily be unique, so kick all matches
					foreach (var ply in TShock.Players.Where(p => p.Name == identifier.Substring(Identifier.Name.Prefix.Length)))
					{
						ply.Kick(reason, true);
					}
				}
				else if (identifier.StartsWith(Identifier.Account.Prefix))
				{
					player = TShock.Players.FirstOrDefault(p => p.Account?.Name == identifier.Substring(Identifier.Account.Prefix.Length));
				}
				else if (identifier.StartsWith(Identifier.UUID.Prefix))
				{
					player = TShock.Players.FirstOrDefault(p => p.UUID == identifier.Substring(Identifier.UUID.Prefix.Length));
				}

				if (player != null)
				{
					player.Kick(reason, true);
				}

				return RestResponse(GetString($"Ban added. Ticket number: {banResult.Ban.TicketNumber}"));
			}

			return RestError(GetString($"Failed to add ban. {banResult.Message}"), status: "500");
		}

		[Description("Delete an existing ban entry.")]
		[Route("/v3/bans/destroy")]
		[Permission(RestPermissions.restmanagebans)]
		[Noun("ticketNumber", true, "The ticket number of the ban to delete.", typeof(String))]
		[Noun("fullDelete", false, "Whether or not to completely remove the ban from the system.", typeof(bool))]
		[Token]
		private object BanDestroyV3(RestRequestArgs args)
		{
			string id = args.Parameters["ticketNumber"];
			if (string.IsNullOrWhiteSpace(id))
				return RestMissingParam("ticketNumber");

			if (!int.TryParse(id, out int ticketNumber))
			{
				return RestInvalidParam("ticketNumber");
			}

			bool.TryParse(args.Parameters["fullDelete"], out bool fullDelete);

			if (TShock.Bans.RemoveBan(ticketNumber, fullDelete))
			{
				return RestResponse(GetString("Ban removed."));
			}

			return RestError(GetString("Failed to remove ban."), status: "500");
		}

		[Description("View the details of a specific ban.")]
		[Route("/v3/bans/read")]
		[Permission(RestPermissions.restviewbans)]
		[Noun("ticketNumber", true, "The ticket number to search for.", typeof(String))]
		[Token]
		private object BanInfoV3(RestRequestArgs args)
		{
			string id = args.Parameters["ticketNumber"];
			if (string.IsNullOrWhiteSpace(id))
				return RestMissingParam("ticketNumber");

			if (!int.TryParse(id, out int ticketNumber))
			{
				return RestInvalidParam("ticketNumber");
			}

			Ban ban = TShock.Bans.GetBanById(ticketNumber);

			if (ban == null)
			{
				return RestResponse(GetString("No matching bans found."));
			}

			return new RestObject
			{
				{ "ticket_number", ban.TicketNumber },
				{ "identifier", ban.Identifier },
				{ "reason", ban.Reason },
				{ "banning_user", ban.BanningUser },
				{ "start_date_ticks", ban.BanDateTime.Ticks },
				{ "end_date_ticks", ban.ExpirationDateTime.Ticks },
			};
		}

		[Description("View all bans in the TShock database.")]
		[Route("/v3/bans/list")]
		[Permission(RestPermissions.restviewbans)]
		[Token]
		private object BanListV3(RestRequestArgs args)
		{
			IEnumerable<Ban> bans = TShock.Bans.Bans.Select(kvp => kvp.Value);

			var banList = new ArrayList();
			foreach (var ban in bans)
			{
				banList.Add(
					new Dictionary<string, object>
					{
						{ "ticket_number", ban.TicketNumber },
						{ "identifier", ban.Identifier },
						{ "reason", ban.Reason },
						{ "banning_user", ban.BanningUser },
						{ "start_date_ticks", ban.BanDateTime.Ticks },
						{ "end_date_ticks", ban.ExpirationDateTime.Ticks },
					}
				);
			}

			return new RestObject
			{
				{ "bans", banList }
			};
		}

		#endregion

		#region Rest World Methods

		[Route("/v2/world/autosave/state/{state}")]
		[Permission(RestPermissions.restcfg)]
		[Verb("state", "The status for autosave.", typeof(bool))]
		[Token]
		private object WorldChangeSaveSettings(RestRequestArgs args)
		{
			bool autoSave;
			if (!bool.TryParse(args.Verbs["state"], out autoSave))
				return RestInvalidParam("state");
			TShock.Config.Settings.AutoSave = autoSave;

			var resp = RestResponse($"AutoSave has been set to {autoSave}");
			resp.Add("upgrade", "/v3/world/autosave");
			return resp;
		}

		[Route("/v3/world/autosave")]
		[Permission(RestPermissions.restcfg)]
		[Parameter("state", false, "The status for autosave.", typeof(bool))]
		[Token]
		private object WorldChangeSaveSettingsV3(RestRequestArgs args)
		{
			bool autoSave;
			if (!bool.TryParse(args.Parameters["state"], out autoSave))
			{
				if (TShock.Config.Settings.AutoSave)
				{
					return RestResponse(GetString($"Autosave is currently enabled"));
				}
				else
				{
					return RestResponse(GetString($"Autosave is currently disabled"));
				}
			}
			TShock.Config.Settings.AutoSave = autoSave;

			if (TShock.Config.Settings.AutoSave)
			{
				return RestResponse(GetString($"AutoSave has been enabled"));
			}
			else
			{
				return RestResponse(GetString($"AutoSave has been disabled"));
			}
		}

		[Description("Save the world.")]
		[Route("/v2/world/save")]
		[Permission(RestPermissions.restcfg)]
		[Token]
		private object WorldSave(RestRequestArgs args)
		{
			SaveManager.Instance.SaveWorld();

			return RestResponse("World saved");
		}

		[Description("Butcher npcs.")]
		[Route("/v2/world/butcher")]
		[Permission(RestPermissions.restbutcher)]
		[Noun("killfriendly", false, "Should friendly npcs be butchered.", typeof(bool))]
		[Token]
		private object WorldButcher(RestRequestArgs args)
		{
			bool killFriendly;
			if (!bool.TryParse(args.Parameters["killfriendly"], out killFriendly))
				return RestInvalidParam("killfriendly");

			int killcount = 0;
			for (int i = 0; i < Main.npc.Length; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type != 0 && !Main.npc[i].townNPC && (!Main.npc[i].friendly || killFriendly))
				{
					TSPlayer.Server.StrikeNPC(i, 99999, 90f, 1);
					killcount++;
				}
			}

			return RestResponse(GetPluralString("{0} NPC has been killed.", "{0} NPCs have been killed.", killcount, killcount));
		}

		[Description("Get information regarding the world.")]
		[Route("/world/read")]
		[Token]
		private object WorldRead(RestRequestArgs args)
		{
			return new RestObject()
			{
				{"name", (TShock.Config.Settings.UseServerName ? TShock.Config.Settings.ServerName : Main.worldName)},
				{"size", Main.maxTilesX + "*" + Main.maxTilesY},
				{"time", Main.time},
				{"daytime", Main.dayTime},
				{"bloodmoon", Main.bloodMoon},
				{"invasionsize", Main.invasionSize}
			};
		}

		[Description("Drops a meteor on the world.")]
		[Route("/world/meteor")]
		[Permission(RestPermissions.restcauseevents)]
		[Token]
		private object WorldMeteor(RestRequestArgs args)
		{
			WorldGen.spawnMeteor = false;
			WorldGen.dropMeteor();
			return RestResponse(GetString("Meteor has been spawned"));
		}

		[Description("Toggle the status of blood moon.")]
		[Route("/world/bloodmoon/{bloodmoon}")]
		[Permission(RestPermissions.restcauseevents)]
		[Verb("bloodmoon", "State of bloodmoon.", typeof(bool))]
		[Token]
		private object WorldBloodmoon(RestRequestArgs args)
		{
			bool bloodmoon;
			if (!bool.TryParse(args.Verbs["bloodmoon"], out bloodmoon))
				return RestInvalidParam("bloodmoon");
			Main.bloodMoon = bloodmoon;

			var resp = RestResponse(GetString($"Blood Moon has been set to {bloodmoon}"));
			resp.Add("upgrade", "/v3/world/bloodmoon");
			return resp;
		}

		[Description("Toggle the status of blood moon.")]
		[Route("/v3/world/bloodmoon")]
		[Permission(RestPermissions.restcauseevents)]
		[Parameter("state", false, "Sets the state of the bloodmoon.", typeof(bool))]
		[Token]
		private object WorldBloodmoonV3(RestRequestArgs args)
		{
			bool bloodmoon;
			if (!bool.TryParse(args.Verbs["state"], out bloodmoon))
			{
				return RestResponse(GetString($"Bloodmoon state: {(Main.bloodMoon ? "Enabled" : "Disabled")}"));
			}
			Main.bloodMoon = bloodmoon;

			if (Main.bloodMoon)
			{
				return RestResponse($"Blood Moon has been enabled");
			}
			else
			{
				return RestResponse($"Blood Moon has been disabled");
			}
		}

		#endregion

		#region Rest Player Methods

		[Description("Unmute a player.")]
		[Route("/v2/players/unmute")]
		[Permission(RestPermissions.restmute)]
		[Noun("player", true, "The player to mute.", typeof(String))]
		[Token]
		private object PlayerUnMute(RestRequestArgs args)
		{
			return PlayerSetMute(args.Parameters, false);
		}

		[Description("Mute a player.")]
		[Route("/v2/players/mute")]
		[Permission(RestPermissions.restmute)]
		[Noun("player", true, "The player to mute.", typeof(String))]
		[Token]
		private object PlayerMute(RestRequestArgs args)
		{
			return PlayerSetMute(args.Parameters, true);
		}

		[Description("List all player names that are currently on the server.")]
		[Route("/lists/players")]
		[Token]
		private object PlayerList(RestRequestArgs args)
		{
			var activeplayers = TShock.Players.Where(p => null != p && p.Active).Select(p => p.Name);
			return new RestObject() { { "players", string.Join(", ", activeplayers) } };
		}

		[Description("Fetches detailed user information on all connected users, and can be filtered by specifying a key value pair filter users where the key is a field and the value is a users field value.")]
		[Route("/v2/players/list")]
		[Token]
		private object PlayerListV2(RestRequestArgs args)
		{
			var playerList = new ArrayList();
			foreach (TSPlayer tsPlayer in TShock.Players.Where(p => null != p))
			{
				var p = PlayerFilter(tsPlayer, args.Parameters);
				if (null != p)
					playerList.Add(p);
			}
			return new RestObject() { { "players", playerList } };
		}

		[Description("Get information for a user.")]
		[Route("/v3/players/read")]
		[Permission(RestPermissions.restuserinfo)]
		[Noun("player", true, "The player to lookup", typeof(String))]
		[Token]
		private object PlayerReadV3(RestRequestArgs args)
		{
			var ret = PlayerFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			TSPlayer player = (TSPlayer)ret;
			var inventory = player.TPlayer.inventory.Where(p => p.active).ToList();
			var equipment = player.TPlayer.armor.Where(p => p.active).ToList();
			var dyes = player.TPlayer.dye.Where(p => p.active).ToList();
			return new RestObject()
			{
				{"nickname", player.Name},
				{"username", player.Account?.Name},
				{"ip", player.IP},
				{"group", player.Group.Name},
				{"registered", player.Account?.Registered},
				{"muted", player.mute },
				{"position", player.TileX + "," + player.TileY},
				{"inventory", string.Join(", ", inventory.Select(p => (p.Name + ":" + p.stack)))},
				{"armor", string.Join(", ", equipment.Select(p => (p.netID + ":" + p.prefix)))},
				{"dyes", string.Join(", ", dyes.Select(p => (p.Name)))},
				{"buffs", string.Join(", ", player.TPlayer.buffType)}
			};
		}

		[Description("Get information for a user.")]
		[Route("/v4/players/read")]
		[Permission(RestPermissions.restuserinfo)]
		[Noun("player", true, "The player to lookup", typeof(String))]
		[Token]
		private object PlayerReadV4(RestRequestArgs args)
		{
			var ret = PlayerFind(args.Parameters);
			if (ret is RestObject)
			{
				return ret;
			}

			TSPlayer player = (TSPlayer)ret;

			object items = new
			{
				inventory = player.TPlayer.inventory.Where(i => i.active).Select(item => (NetItem)item),
				equipment = player.TPlayer.armor.Where(i => i.active).Select(item => (NetItem)item),
				dyes = player.TPlayer.dye.Where(i => i.active).Select(item => (NetItem)item),
				piggy = player.TPlayer.bank.item.Where(i => i.active).Select(item => (NetItem)item),
				safe = player.TPlayer.bank2.item.Where(i => i.active).Select(item => (NetItem)item),
				forge = player.TPlayer.bank3.item.Where(i => i.active).Select(item => (NetItem)item)
			};

			return new RestObject
			{
				{"nickname", player.Name},
				{"username", player.Account?.Name},
				{"ip", player.IP},
				{"group", player.Group.Name},
				{"registered", player.Account?.Registered},
				{"muted", player.mute },
				{"position", player.TileX + "," + player.TileY},
				{"items", items},
				{"buffs", string.Join(", ", player.TPlayer.buffType)}
			};
		}

		[Description("Kick a player off the server.")]
		[Route("/v2/players/kick")]
		[Permission(RestPermissions.restkick)]
		[Noun("player", true, "The player to kick.", typeof(String))]
		[Noun("reason", false, "The reason the player was kicked.", typeof(String))]
		[Token]
		private object PlayerKickV2(RestRequestArgs args)
		{
			var ret = PlayerFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			TSPlayer player = (TSPlayer)ret;
			player.Kick(null == args.Parameters["reason"] ? GetString("Kicked via web") : args.Parameters["reason"], false, true, null, true);
			return RestResponse($"Player {player.Name} was kicked");
		}

		[Description("Kill a player.")]
		[Route("/v2/players/kill")]
		[Permission(RestPermissions.restkill)]
		[Noun("player", true, "The player to kick.", typeof(String))]
		[Noun("from", false, "Who killed the player.", typeof(String))]
		[Token]
		private object PlayerKill(RestRequestArgs args)
		{
			var ret = PlayerFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			TSPlayer player = (TSPlayer)ret;
			player.DamagePlayer(999999);
			var from = string.IsNullOrWhiteSpace(args.Parameters["from"]) ? "Server Admin" : args.Parameters["from"];
			player.SendInfoMessage(GetString($"{from} just killed you!"));
			return RestResponse(GetString($"Player {player.Name} was killed"));
		}

		#endregion

		#region Rest Group Methods

		[Description("View all groups in the TShock database.")]
		[Route("/v2/groups/list")]
		[Permission(RestPermissions.restviewgroups)]
		[Token]
		private object GroupList(RestRequestArgs args)
		{
			var groups = new ArrayList();
			foreach (Group group in TShock.Groups)
			{
				groups.Add(new Dictionary<string, object> { { "name", group.Name }, { "parent", group.ParentName }, { "chatcolor", group.ChatColor } });
			}
			return new RestObject() { { "groups", groups } };
		}

		[Description("Display information of a group.")]
		[Route("/v2/groups/read")]
		[Permission(RestPermissions.restviewgroups)]
		[Noun("group", true, "The group name to get information on.", typeof(String))]
		[Token]
		private object GroupInfo(RestRequestArgs args)
		{
			var ret = GroupFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			Group group = (Group)ret;
			return new RestObject() {
				{"name", group.Name},
				{"parent", group.ParentName},
				{"chatcolor", string.Format("{0},{1},{2}", group.R, group.G, group.B)},
				{"permissions", group.permissions},
				{"negatedpermissions", group.negatedpermissions},
				{"totalpermissions", group.TotalPermissions}
			};
		}

		[Description("Delete a group.")]
		[Route("/v2/groups/destroy")]
		[Permission(RestPermissions.restmanagegroups)]
		[Noun("group", true, "The group name to delete.", typeof(String))]
		[Token]
		private object GroupDestroy(RestRequestArgs args)
		{
			var ret = GroupFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			Group group = (Group)ret;
			try
			{
				TShock.Groups.DeleteGroup(group.Name, true);
			}
			catch (Exception e)
			{
				return RestError(e.Message);
			}

			return RestResponse(GetString($"Group {group.Name} deleted successfully"));
		}

		[Description("Create a new group.")]
		[Route("/v2/groups/create")]
		[Permission(RestPermissions.restmanagegroups)]
		[Noun("group", true, "The name of the new group.", typeof(String))]
		[Noun("parent", false, "The name of the parent group.", typeof(String))]
		[Noun("permissions", false, "A comma separated list of permissions for the new group.", typeof(String))]
		[Noun("chatcolor", false, "A r,g,b string representing the color for this groups chat.", typeof(String))]
		[Token]
		private object GroupCreate(RestRequestArgs args)
		{
			var name = args.Parameters["group"];
			if (string.IsNullOrWhiteSpace(name))
				return RestMissingParam("group");
			try
			{
				TShock.Groups.AddGroup(name, args.Parameters["parent"], args.Parameters["permissions"], args.Parameters["chatcolor"]);
			}
			catch (Exception e)
			{
				return RestError(e.Message);
			}

			return RestResponse(GetString($"Group {name} created successfully"));
		}

		[Route("/v2/groups/update")]
		[Permission(RestPermissions.restmanagegroups)]
		[Noun("group", true, "The name of the group to modify.", typeof(String))]
		[Noun("parent", false, "The name of the new parent for this group.", typeof(String))]
		[Noun("chatcolor", false, "The new chat color r,g,b.", typeof(String))]
		[Noun("permissions", false, "The new comma separated list of permissions.", typeof(String))]
		[Token]
		private object GroupUpdate(RestRequestArgs args)
		{
			var ret = GroupFind(args.Parameters);
			if (ret is RestObject)
				return ret;

			Group group = (Group)ret;
			var parent = (null == args.Parameters["parent"]) ? group.ParentName : args.Parameters["parent"];
			var chatcolor = (null == args.Parameters["chatcolor"]) ? string.Format("{0}.{1}.{2}", group.R, group.G, group.B) : args.Parameters["chatcolor"];
			var permissions = (null == args.Parameters["permissions"]) ? group.Permissions : args.Parameters["permissions"];
			try
			{
				TShock.Groups.UpdateGroup(group.Name, parent, permissions, chatcolor, group.Suffix, group.Prefix);
			}
			catch (Exception e)
			{
				return RestError(e.Message);
			}

			return RestResponse(GetString($"Group {group.Name} updated successfully"));
		}

		#endregion

		#region Utility Methods

		// TODO: figure out how to localise the route descriptions
		public static void DumpDescriptions()
		{
			var sb = new StringBuilder();
			var rest = new RestManager(null);

			foreach (var method in rest.GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static).OrderBy(f => f.Name))
			{
				if (method.IsStatic)
					continue;

				var name = method.Name;

				var descattr =
					method.GetCustomAttributes(false).FirstOrDefault(o => o is DescriptionAttribute) as DescriptionAttribute;
				var routeattr =
					method.GetCustomAttributes(false).FirstOrDefault(o => o is RouteAttribute) as RouteAttribute;

				if (descattr != null && !string.IsNullOrWhiteSpace(descattr.Description) && routeattr != null && !string.IsNullOrWhiteSpace(routeattr.Route))
				{
					sb.AppendLine("## {0}".SFormat(name));
					sb.AppendLine("{0}".SFormat(descattr.Description));

					var permission = method.GetCustomAttributes(false).Where(o => o is Permission);
					if (permission.Count() > 0)
					{
						sb.AppendLine(GetString("* **Permissions**: `{0}`", String.Join(", ", permission.Select(p => ((Permission)p).Name))));
					}
					else
					{
						sb.AppendLine(GetString("No special permissions are required for this route."));
					}
					sb.AppendLine();
					var verbs = method.GetCustomAttributes(false).Where(o => o is Verb);
					if (verbs.Count() > 0)
					{
						sb.AppendLine(GetString("**Verbs**:"));
						foreach (Verb verb in verbs)
						{
							if (verb.Required)
								sb.AppendLine(GetString("* `{0}` (Required) `{1}` - {2}".SFormat(verb.Name, verb.ArgumentType.Name, verb.Description)));
							else
								sb.AppendLine(GetString("* `{0}` (Optional) `{1}` - {2}".SFormat(verb.Name, verb.ArgumentType.Name, verb.Description)));
						}
					}
					sb.AppendLine();
					var nouns = method.GetCustomAttributes(false).Where(o => o is Noun);
					if (nouns.Count() > 0)
					{
						sb.AppendLine(GetString("**Nouns**:"));
						foreach (Noun noun in nouns)
						{
							if (noun.Required)
								sb.AppendLine(GetString("* `{0}` (Required) `{1}` - {2}".SFormat(noun.Name, noun.ArgumentType.Name, noun.Description)));
							else
								sb.AppendLine(GetString("* `{0}` (Optional) `{1}` - {2}".SFormat(noun.Name, noun.ArgumentType.Name, noun.Description)));
						}
					}
					sb.AppendLine();
					sb.AppendLine(GetString("**Example Usage**: `{0}?{1}`", routeattr.Route,
						string.Join("&", nouns.Select(n => String.Format("{0}={0}", ((Noun)n).Name)))));
					sb.AppendLine();
				}
			}

			File.WriteAllText("docs/rest-fields.md", sb.ToString());
		}

		private RestObject RestError(string message, string status = "400")
		{
			return new RestObject(status) { Error = message };
		}

		private RestObject RestResponse(string message, string status = "200")
		{
			return new RestObject(status) { Response = message };
		}

		private RestObject RestMissingParam(string var)
		{
			return RestError(GetString($"Missing or empty {var} parameter"));
		}

		private RestObject RestMissingParam(params string[] vars)
		{
			return RestMissingParam(string.Join(", ", vars));
		}

		private RestObject RestInvalidParam(string var)
		{
			return RestError(GetString($"Missing or invalid {var} parameter"));
		}

		private bool GetBool(string val, bool def)
		{
			bool ret;
			return bool.TryParse(val, out ret) ? ret : def;
		}

		private object PlayerFind(EscapedParameterCollection parameters)
		{
			string name = parameters["player"];
			if (string.IsNullOrWhiteSpace(name))
				return RestMissingParam("player");

			var found = TSPlayer.FindByNameOrID(name);
			switch (found.Count)
			{
				case 1:
					return found[0];
				case 0:
					return RestError(GetString($"Player {name} was not found"));
				default:
					return RestError(GetPluralString($"Player {name} matches {found.Count} player", $"Player {name} matches {found.Count} players", found.Count));
			}
		}

		private object UserFind(EscapedParameterCollection parameters)
		{
			string name = parameters["user"];
			if (string.IsNullOrWhiteSpace(name))
				return RestMissingParam("user");

			UserAccount account;
			string type = parameters["type"];
			try
			{
				switch (type)
				{
					case null:
					case "name":
						type = "name";
						account = TShock.UserAccounts.GetUserAccountByName(name);
						break;
					case "id":
						account = TShock.UserAccounts.GetUserAccountByID(Convert.ToInt32(name));
						break;
					default:
						return RestError(GetString($"Invalid Type: '{type}'"));
				}
			}
			catch (Exception e)
			{
				return RestError(e.Message);
			}

			if (null == account)
				return RestError(GetString($"User {type} '{name}' doesn't exist"));

			return account;
		}

		private object GroupFind(EscapedParameterCollection parameters)
		{
			var name = parameters["group"];
			if (string.IsNullOrWhiteSpace(name))
				return RestMissingParam("group");

			var group = TShock.Groups.GetGroupByName(name);
			if (null == group)
				return RestError(GetString($"Group {name} doesn't exist"));

			return group;
		}

		private Dictionary<string, object> PlayerFilter(TSPlayer tsPlayer, EscapedParameterCollection parameters, bool viewips = false)
		{
			var player = new Dictionary<string, object>
				{
					{"nickname", tsPlayer.Name},
					{"username", tsPlayer.Account == null ? "" : tsPlayer.Account.Name},
					{"group", tsPlayer.Group.Name},
					{"active", tsPlayer.Active},
					{"state", tsPlayer.State},
					{"team", tsPlayer.Team},
				};

			if (viewips)
			{
				player.Add("ip", tsPlayer.IP);
			}
			foreach (EscapedParameter filter in parameters)
			{
				if (player.ContainsKey(filter.Name) && !player[filter.Name].Equals(filter.Value))
					return null;
			}
			return player;
		}

		private object PlayerSetMute(EscapedParameterCollection parameters, bool mute)
		{
			var ret = PlayerFind(parameters);
			if (ret is RestObject)
				return ret;

			TSPlayer player = (TSPlayer)ret;
			player.mute = mute;
			if (mute)
			{
				player.SendInfoMessage(GetString("You have been remotely muted"));
				return RestResponse(GetString($"Player {player.Name} has been muted"));
			}
			else
			{
				player.SendInfoMessage(GetString("You have been remotely unmmuted"));
				return RestResponse(GetString($"Player {player.Name} has been unmuted"));
			}
		}

		#endregion
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Rest/RestObject.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace Rests
{
	[Serializable]
	public class RestObject : Dictionary<string, object>
	{
		public string Status
		{
			get { return this["status"] as string; }
			set { this["status"] = value; }
		}

		public string Error
		{
			get { return this["error"] as string; }
			set { this["error"] = value; }
		}

		public string Response
		{
			get { return this["response"] as string; }
			set { this["response"] = value; }
		}

		// Parameterless constructor for deseralisation required by JavaScriptSerializer.Deserialize in TShockRestTestPlugin
		// Note: The constructor with all defaults isn't good enough :(
		public RestObject()
		{
			Status = "200";
		}

		public RestObject(string status = "200")
		{
			Status = status;
		}

		/// <summary>
		/// Gets value safely, if it does not exist, return null. Sets/Adds value safely, if null it will remove.
		/// </summary>
		/// <param name="key">the key</param>
		/// <returns>Returns null if key does not exist.</returns>
		public new object this[string key]
		{
			get
			{
				object ret;
				if (TryGetValue(key, out ret))
					return ret;
				return null;
			}
			set
			{
				if (!ContainsKey(key))
				{
					if (value == null)
						return;
					Add(key, value);
				}
				else
				{
					if (value != null)
						base[key] = value;
					else
						Remove(key);
				}
			}
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/Rest/RestPermissions.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.ComponentModel;

// Since the permission nodes have annotations that say what they are, we don't need XML comments.
#pragma warning disable 1591

namespace Rests
{
	/// <summary>Contains the REST permission nodes used in TShock.</summary>
	public static class RestPermissions
	{
		// tshock.rest.bans nodes

		[Description("REST user can list and get detailed information about bans.")]
		public const string restviewbans = "tshock.rest.bans.view";

		[Description("REST user can alter bans.")]
		public const string restmanagebans = "tshock.rest.bans.manage";

		// tshock.rest.groups nodes

		[Description("REST user can list and get detailed information about groups.")]
		public const string restviewgroups = "tshock.rest.groups.view";

		[Description("REST user can alter groups.")]
		public const string restmanagegroups = "tshock.rest.groups.manage";

		// tshock.rest.users nodes

		[Description("REST user can list and get detailed information about users.")]
		public const string restviewusers = "tshock.rest.users.view";

		[Description("REST user can alter users.")]
		public const string restmanageusers = "tshock.rest.users.manage";

		[Description("REST user can get user information.")]
		public const string restuserinfo = "tshock.rest.users.info";

		// Non-grouped nodes

		[Description("User can create REST tokens.")]
		public const string restapi = "tshock.rest.useapi";

		[Description("User or REST user can destroy all REST tokens.")]
		public const string restmanage = "tshock.rest.manage";

		[Description("REST user can turn off / restart the server.")]
		public const string restmaintenance = "tshock.rest.maintenance";

		[Description("REST user can reload configurations, save the world and set auto save settings.")]
		public const string restcfg = "tshock.rest.cfg";

		[Description("REST user can send server broadcast messages.")]
		public const string restbroadcast = "tshock.rest.broadcast";

		[Description("REST user can kick players.")]
		public const string restkick = "tshock.rest.kick";

		[Description("REST user can ban players.")]
		public const string restban = "tshock.rest.ban";

		[Description("REST user can mute and unmute players.")]
		public const string restmute = "tshock.rest.mute";

		[Description("REST user can kill players.")]
		public const string restkill = "tshock.rest.kill";

		[Description("REST user can drop meteors or change bloodmoon.")]
		public const string restcauseevents = "tshock.rest.causeevents";

		[Description("REST user can butcher npcs.")]
		public const string restbutcher = "tshock.rest.butcher";

		[Description("REST user can run raw TShock commands (the raw command permissions are also checked though).")]
		public const string restrawcommand = "tshock.rest.command";

		[Description("REST user can view the ips of players.")] 
		public const string viewips = "tshock.rest.viewips";
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Rest/RestVerbs.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;

namespace Rests
{
	/// <summary>
	/// A dictionary collection of verbs used in a REST request
	/// </summary>
	[Serializable]
	public class RestVerbs : Dictionary<string, string>
	{
		/// <summary>
		/// Gets value safely, if it does not exist, return null. Sets/Adds value safely, if null it will remove.
		/// </summary>
		/// <param name="key">the key</param>
		/// <returns>Returns null if key does not exist.</returns>
		public new string this[string key]
		{
			get
			{
				string ret;
				if (TryGetValue(key, out ret))
				{
					return Uri.UnescapeDataString(ret);
				}
				return null;
			}
			set
			{
				if (!ContainsKey(key))
				{
					if (value == null)
						return;
					Add(key, value);
				}
				else
				{
					if (value != null)
						base[key] = value;
					else
						Remove(key);
				}
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/Rest/SecureRest.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using HttpServer;
using TShockAPI;
using TShockAPI.DB;
using Microsoft.Xna.Framework;
using Terraria;
using System.Security.Cryptography;

namespace Rests
{
	public class SecureRest : Rest
	{
		public struct TokenData
		{
			public static readonly TokenData None = default(TokenData);

			public string Username { get; set; }
			public string UserGroupName { get; set; }
		}

		public Dictionary<string, TokenData> Tokens { get; protected set; }
		public Dictionary<string, TokenData> AppTokens { get; protected set; }

		private RNGCryptoServiceProvider _rng = new RNGCryptoServiceProvider();

		public SecureRest(IPAddress ip, int port)
			: base(ip, port)
		{
			Tokens = new Dictionary<string, TokenData>();
			AppTokens = new Dictionary<string, TokenData>();

			Register(new RestCommand("/v2/token/create", NewTokenV2) { DoLog = false });
			Register(new SecureRestCommand("/token/destroy/{token}", DestroyToken));
			Register(new SecureRestCommand("/v3/token/destroy/all", DestroyAllTokens, RestPermissions.restmanage));

			foreach (KeyValuePair<string, TokenData> t in TShock.RESTStartupTokens)
			{
				AppTokens.Add(t.Key, t.Value);
			}

			foreach (KeyValuePair<string, TokenData> t in TShock.Config.Settings.ApplicationRestTokens)
			{
				AppTokens.Add(t.Key, t.Value);
			}
		}

		private void AddTokenToBucket(string ip)
		{
			if (tokenBucket.ContainsKey(ip))
			{
				tokenBucket[ip] += 1;
			}
			else
			{
				tokenBucket.Add(ip, 1);
			}
		}

		private object DestroyToken(RestRequestArgs args)
		{
			var token = args.Verbs["token"];
			try
			{
				Tokens.Remove(token);
			}
			catch (Exception)
			{
				return new RestObject("400")
				{ Error = GetString("The specified token queued for destruction failed to be deleted.") };
			}
			return new RestObject()
			{ Response = GetString("Requested token was successfully destroyed.") };
		}

		private object DestroyAllTokens(RestRequestArgs args)
		{
			Tokens.Clear();

			return new RestObject()
			{ Response = "All tokens were successfully destroyed." };
		}

		private object NewTokenV2(RestRequestArgs args)
		{
			var user = Uri.UnescapeDataString(args.Parameters["username"]);
			var pass = Uri.UnescapeDataString(args.Parameters["password"]);
			var context = args.Context;

			return this.NewTokenInternal(user, pass, context);
		}

		private RestObject NewTokenInternal(string username, string password, IHttpContext context)
		{
			int tokens = 0;
			if (tokenBucket.TryGetValue(context.RemoteEndPoint.Address.ToString(), out tokens))
			{
				if (tokens >= TShock.Config.Settings.RESTMaximumRequestsPerInterval)
				{
					TShock.Log.ConsoleError(GetString("A REST login from {0} was blocked as it currently has {1} rate-limit tokens and is at the RESTMaximumRequestsPerInterval threshold.", context.RemoteEndPoint.Address.ToString(), tokens));
					tokenBucket[context.RemoteEndPoint.Address.ToString()] += 1; // Tokens over limit, increment by one and reject request
					return new RestObject("403")
					{
						Error = "Username or password may be incorrect or this account may not have sufficient privileges."
					};
				}
				tokenBucket[context.RemoteEndPoint.Address.ToString()] += 1; // Tokens under limit, increment by one and process request
			}
			else
			{
				tokenBucket.Add(context.RemoteEndPoint.Address.ToString(), 1); // First time request, set to one and process request
			}

			UserAccount userAccount = TShock.UserAccounts.GetUserAccountByName(username);
			if (userAccount == null)
			{
				AddTokenToBucket(context.RemoteEndPoint.Address.ToString());
				return new RestObject("403") { Error = GetString("Username or password may be incorrect or this account may not have sufficient privileges.") };
			}

			if (!userAccount.VerifyPassword(password))
			{
				AddTokenToBucket(context.RemoteEndPoint.Address.ToString());
				return new RestObject("403") { Error = GetString("Username or password may be incorrect or this account may not have sufficient privileges.") };
			}

			Group userGroup = TShock.Groups.GetGroupByName(userAccount.Group);
			if (!userGroup.HasPermission(RestPermissions.restapi) && userAccount.Group != "superadmin")
			{
				AddTokenToBucket(context.RemoteEndPoint.Address.ToString());
				return new RestObject("403")
				{ Error = GetString("Username or password may be incorrect or this account may not have sufficient privileges.") };
			}

			string tokenHash;
			var randbytes = new byte[32];
			do
			{
				_rng.GetBytes(randbytes);
				tokenHash = randbytes.Aggregate("", (s, b) => s + b.ToString("X2"));
			} while (Tokens.ContainsKey(tokenHash));

			Tokens.Add(tokenHash, new TokenData { Username = userAccount.Name, UserGroupName = userGroup.Name });

			AddTokenToBucket(context.RemoteEndPoint.Address.ToString());

			RestObject response = new RestObject() { Response = GetString("Successful login") };
			response["token"] = tokenHash;
			return response;
		}

		protected override object ExecuteCommand(RestCommand cmd, RestVerbs verbs, IParameterCollection parms, IRequest request, IHttpContext context)
		{
			if (!cmd.RequiresToken)
				return base.ExecuteCommand(cmd, verbs, parms, request, context);

			var token = parms["token"];
			if (token == null)
				return new RestObject("401")
				{ Error = GetString("Not authorized. The specified API endpoint requires a token.") };

			SecureRestCommand secureCmd = (SecureRestCommand)cmd;
			TokenData tokenData;
			if (!Tokens.TryGetValue(token, out tokenData) && !AppTokens.TryGetValue(token, out tokenData))
				return new RestObject("403")
				{ Error = GetString("Not authorized. The specified API endpoint requires a token, but the provided token was not valid.") };

			Group userGroup = TShock.Groups.GetGroupByName(tokenData.UserGroupName);
			if (userGroup == null)
			{
				Tokens.Remove(token);

				return new RestObject("403")
				{ Error = GetString("Not authorized. The provided token became invalid due to group changes, please create a new token.") };
			}

			if (secureCmd.Permissions.Length > 0 && secureCmd.Permissions.All(perm => !userGroup.HasPermission(perm)))
			{
				return new RestObject("403")
				{ Error = GetString("Not authorized. User \"{0}\" has no access to use the specified API endpoint.", tokenData.Username) };
			}

			//Main.rand being null can cause issues in command execution.
			//This should solve that
			if (Main.rand == null)
			{
				Main.rand = new Terraria.Utilities.UnifiedRandom();
			}

			object result = secureCmd.Execute(verbs, parms, tokenData, request, context);
			if (cmd.DoLog && TShock.Config.Settings.LogRest)
				TShock.Utils.SendLogs(GetString(
					"\"{0}\" requested REST endpoint: {1}", tokenData.Username, this.BuildRequestUri(cmd, verbs, parms, false)),
					Color.PaleVioletRed);

			return result;
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI`
#### File: `temp_TShock-5.2.4/TShockAPI/SaveManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Threading;
using Terraria;
using Terraria.IO;
using TerrariaApi.Server;

namespace TShockAPI
{
	class SaveManager : IDisposable
	{
		// Singleton
		private static readonly SaveManager instance = new SaveManager();
		private SaveManager()
		{
			_saveThread = new Thread(SaveWorker);
			_saveThread.Name = "TShock SaveManager Worker";
			_saveThread.Start();
		}
		public static SaveManager Instance { get { return instance; } }

		// Producer Consumer
		private EventWaitHandle _wh = new AutoResetEvent(false);
		private Object _saveLock = new Object();
		private Queue<SaveTask> _saveQueue = new Queue<SaveTask>();
		private Thread _saveThread;
		private int saveQueueCount { get { lock (_saveLock) return _saveQueue.Count; } }

		/// <summary>
		/// SaveWorld event handler which notifies users that the server may lag
		/// </summary>
		public void OnSaveWorld(WorldSaveEventArgs args)
		{
			if (TShock.Config.Settings.AnnounceSave)
			{
				// Protect against internal errors causing save failures
				// These can be caused by an unexpected error such as a bad or out of date plugin
				try
				{
					TShock.Utils.Broadcast(GetString("Saving world..."), Color.Yellow);
				}
				catch (Exception ex)
				{
					TShock.Log.Error("World saved notification failed");
					TShock.Log.Error(ex.ToString());
				}
			}
		}

		/// <summary>
		/// Saves the map data
		/// </summary>
		/// <param name="wait">wait for all pending saves to finish (default: true)</param>
		/// <param name="resetTime">reset the last save time counter (default: false)</param>
		/// <param name="direct">use the realsaveWorld method instead of saveWorld event (default: false)</param>
		public void SaveWorld(bool wait = true, bool resetTime = false, bool direct = false)
		{
			EnqueueTask(new SaveTask(resetTime, direct));
			if (!wait)
				return;

			// Wait for all outstanding saves to complete
			int count = saveQueueCount;
			while (0 != count)
			{
				Thread.Sleep(50);
				count = saveQueueCount;
			}
		}

		/// <summary>
		/// Processes any outstanding saves, shutsdown the save thread and returns
		/// </summary>
		public void Dispose()
		{
			EnqueueTask(null);
			_saveThread.Join();
			_wh.Close();
		}

		private void EnqueueTask(SaveTask task)
		{
			lock (_saveLock)
			{
				_saveQueue.Enqueue(task);
			}
			_wh.Set();
		}

		private void SaveWorker()
		{
			while (true)
			{
				lock (_saveLock)
				{
					// NOTE: lock for the entire process so wait works in SaveWorld
					if (_saveQueue.Count > 0)
					{
						SaveTask task = _saveQueue.Dequeue();
						if (null == task)
							return;
						else
						{
							// Ensure that save handler errors don't bubble up and cause a recursive call
							// These can be caused by an unexpected error such as a bad or out of date plugin
							try
							{
								if (task.direct)
								{
									OnSaveWorld(new WorldSaveEventArgs());
									WorldFile.SaveWorld(task.resetTime);
								}
								else
									WorldFile.SaveWorld(task.resetTime);

								if (TShock.Config.Settings.AnnounceSave)
									TShock.Utils.Broadcast(GetString("World saved."), Color.Yellow);

								TShock.Log.Info(GetString("World saved at ({0})", Main.worldPathName));
							}
							catch (Exception e)
							{
								TShock.Log.Error("World saved failed");
								TShock.Log.Error(e.ToString());
							}
						}
					}
				}
				_wh.WaitOne();
			}
		}

		class SaveTask
		{
			public bool resetTime { get; set; }
			public bool direct { get; set; }
			public SaveTask(bool resetTime, bool direct)
			{
				this.resetTime = resetTime;
				this.direct = direct;
			}

			public override string ToString()
			{
				return GetString("resetTime {0}, direct {1}", resetTime, direct);
			}
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI/Sockets`
#### File: `temp_TShock-5.2.4/TShockAPI/Sockets/LinuxTcpSocket.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Terraria;
using Terraria.Localization;
using Terraria.Net;
using Terraria.Net.Sockets;

namespace TShockAPI.Sockets
{
	public class LinuxTcpSocket : ISocket
	{
		public byte[] _packetBuffer = new byte[1024];

		public int _packetBufferLength;

		public List<object> _callbackBuffer = new List<object>();

		public int _messagesInQueue;

		public TcpClient _connection;

		public TcpListener _listener;

		public SocketConnectionAccepted _listenerCallback;

		public RemoteAddress _remoteAddress;

		public bool _isListening;

		public int MessagesInQueue
		{
			get
			{
				return this._messagesInQueue;
			}
		}

		public LinuxTcpSocket()
		{
			this._connection = new TcpClient();
			this._connection.NoDelay = true;
		}

		public LinuxTcpSocket(TcpClient tcpClient)
		{
			this._connection = tcpClient;
			this._connection.NoDelay = true;
			IPEndPoint iPEndPoint = (IPEndPoint)tcpClient.Client.RemoteEndPoint;
			this._remoteAddress = new TcpAddress(iPEndPoint.Address, iPEndPoint.Port);
		}

		void ISocket.Close()
		{
			this._remoteAddress = null;
			this._connection.Close();
		}

		bool ISocket.IsConnected()
		{
			return this._connection != null && this._connection.Client != null && this._connection.Connected;
		}

		void ISocket.Connect(RemoteAddress address)
		{
			TcpAddress tcpAddress = (TcpAddress)address;
			this._connection.Connect(tcpAddress.Address, tcpAddress.Port);
			this._remoteAddress = address;
		}

		private void ReadCallback(IAsyncResult result)
		{
			Tuple<SocketReceiveCallback, object> tuple = (Tuple<SocketReceiveCallback, object>)result.AsyncState;

			try
			{
				tuple.Item1(tuple.Item2, this._connection.GetStream().EndRead(result));
			}
			catch (InvalidOperationException)
			{
				// This is common behaviour during client disconnects
				((ISocket)this).Close();
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
		}

		private void SendCallback(IAsyncResult result)
		{
			object[] expr_0B = (object[])result.AsyncState;
			LegacyNetBufferPool.ReturnBuffer((byte[])expr_0B[1]);
			Tuple<SocketSendCallback, object> tuple = (Tuple<SocketSendCallback, object>)expr_0B[0];
			try
			{
				this._connection.GetStream().EndWrite(result);
				tuple.Item1(tuple.Item2);
			}
			catch (Exception)
			{
				((ISocket)this).Close();
			}
		}

		void ISocket.SendQueuedPackets()
		{
		}

		void ISocket.AsyncSend(byte[] data, int offset, int size, SocketSendCallback callback, object state)
		{
			byte[] array = LegacyNetBufferPool.RequestBuffer(data, offset, size);
			this._connection.GetStream().BeginWrite(array, 0, size, new AsyncCallback(this.SendCallback), new object[]
			{
				new Tuple<SocketSendCallback, object>(callback, state),
				array
			});
		}

		void ISocket.AsyncReceive(byte[] data, int offset, int size, SocketReceiveCallback callback, object state)
		{
			this._connection.GetStream().BeginRead(data, offset, size, new AsyncCallback(this.ReadCallback), new Tuple<SocketReceiveCallback, object>(callback, state));
		}

		bool ISocket.IsDataAvailable()
		{
			return this._connection.GetStream().DataAvailable;
		}

		RemoteAddress ISocket.GetRemoteAddress()
		{
			return this._remoteAddress;
		}

		bool ISocket.StartListening(SocketConnectionAccepted callback)
		{
			IPAddress any = IPAddress.Any;
			string ipString;
			if (Program.LaunchParameters.TryGetValue("-ip", out ipString) && !IPAddress.TryParse(ipString, out any))
			{
				any = IPAddress.Any;
			}
			this._isListening = true;
			this._listenerCallback = callback;
			if (this._listener == null)
			{
				this._listener = new TcpListener(any, Netplay.ListenPort);
			}
			try
			{
				this._listener.Start();
			}
			catch (Exception)
			{
				return false;
			}
			ThreadPool.QueueUserWorkItem(new WaitCallback(this.ListenLoop));
			return true;
		}

		void ISocket.StopListening()
		{
			this._isListening = false;
		}

		private void ListenLoop(object unused)
		{
			while (this._isListening && !Netplay.Disconnect)
			{
				try
				{
					ISocket socket = new LinuxTcpSocket(this._listener.AcceptTcpClient());
					Console.WriteLine(Language.GetTextValue("Net.ClientConnecting", socket.GetRemoteAddress()));
					this._listenerCallback(socket);
				}
				catch (Exception)
				{
				}
			}
			this._listener.Stop();

			// currently vanilla will stop listening when the slots are full, however it appears that this Netplay.IsListening
			// flag is still set, making the server loop believe it's still listening when it's actually not.
			// clearing this flag when we actually have stopped will allow the ServerLoop to start listening again when
			// there are enough slots available.
			Netplay.IsListening = false;
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockAPI`
#### File: `temp_TShock-5.2.4/TShockAPI/SqlLog.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using MySql.Data.MySqlClient;
using TShockAPI.DB;

namespace TShockAPI
{
	struct LogInfo
	{
		public string timestamp;
		public string message;
		public string caller;
		public TraceLevel logLevel;

		public override string ToString()
		{
			return GetString("Message: {0}: {1}: {2}",
				caller, logLevel.ToString().ToUpper(), message);
		}
	}

	/// <summary>
	/// Class inheriting ILog for writing logs to TShock's SQL database
	/// </summary>
	public class SqlLog : ILog, IDisposable
	{
		private readonly IDbConnection _database;
		private readonly TextLog _backupLog;
		private readonly List<LogInfo> _failures = new List<LogInfo>(TShock.Config.Settings.RevertToTextLogsOnSqlFailures);
		private bool _useTextLog;

		public string FileName { get; set; }

		/// <summary>
		/// Sets the database connection and the initial log level.
		/// </summary>
		/// <param name="db">Database connection</param>
		/// <param name="textlogFilepath">File path to a backup text log in case the SQL log fails</param>
		/// <param name="clearTextLog"></param>
		public SqlLog(IDbConnection db, string textlogFilepath, bool clearTextLog)
		{
			FileName = string.Format("{0}://database", db.GetSqlType());
			_database = db;
			_backupLog = new TextLog(textlogFilepath, clearTextLog);

			var table = new SqlTable("Logs",
				new SqlColumn("ID", MySqlDbType.Int32) {AutoIncrement = true, Primary = true},
				new SqlColumn("TimeStamp", MySqlDbType.Text),
				new SqlColumn("LogLevel", MySqlDbType.Int32),
				new SqlColumn("Caller", MySqlDbType.Text),
				new SqlColumn("Message", MySqlDbType.Text)
				);

			var creator = new SqlTableCreator(db,
				db.GetSqlType() == SqlType.Sqlite
					? (IQueryBuilder) new SqliteQueryCreator()
					: new MysqlQueryCreator());
			creator.EnsureTableStructure(table);
		}

		public bool MayWriteType(TraceLevel type)
		{
			return type != TraceLevel.Off;
		}

		/// <summary>
		/// Writes data to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Data(string message)
		{
			Write(message, TraceLevel.Verbose);
		}

		/// <summary>
		/// Writes data to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Data(string format, params object[] args)
		{
			Data(string.Format(format, args));
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Error(string message)
		{
			Write(message, TraceLevel.Error);
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Error(string format, params object[] args)
		{
			Error(string.Format(format, args));
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void ConsoleError(string message)
		{
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine(message);
			Console.ForegroundColor = ConsoleColor.Gray;
			Write(message, TraceLevel.Error);
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void ConsoleError(string format, params object[] args)
		{
			ConsoleError(string.Format(format, args));
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void ConsoleWarn(string message)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(message);
			Console.ForegroundColor = ConsoleColor.Gray;
			Write(message, TraceLevel.Warning);
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void ConsoleWarn(string format, params object[] args)
		{
			ConsoleWarn(string.Format(format, args));
		}

		/// <summary>
		/// Writes a warning to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Warn(string message)
		{
			Write(message, TraceLevel.Warning);
		}

		/// <summary>
		/// Writes a warning to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Warn(string format, params object[] args)
		{
			Warn(string.Format(format, args));
		}

		/// <summary>
		/// Writes an informative string to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Info(string message)
		{
			Write(message, TraceLevel.Info);
		}

		/// <summary>
		/// Writes an informative string to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Info(string format, params object[] args)
		{
			Info(string.Format(format, args));
		}

		/// <summary>
		/// Writes an informative string to the log file. Also outputs to the console.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void ConsoleInfo(string message)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(message);
			Console.ForegroundColor = ConsoleColor.Gray;
			Write(message, TraceLevel.Info);
		}

		/// <summary>
		/// Writes an informative string to the log file. Also outputs to the console.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void ConsoleInfo(string format, params object[] args)
		{
			ConsoleInfo(string.Format(format, args));
		}

		/// <summary>
		/// Writes a debug string to the log file. Also outputs to the console. Requires config TShock.DebugLogs to be true.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void ConsoleDebug(string message)
		{
			if (TShock.Config.Settings.DebugLogs)
			{
				Console.WriteLine("Debug: " + message);
				Write(message, TraceLevel.Verbose);
			}
		}

		/// <summary>
		/// Writes a debug string to the log file. Also outputs to the console. Requires config TShock.DebugLogs to be true.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void ConsoleDebug(string format, params object[] args)
		{
			ConsoleDebug(string.Format(format, args));
		}

		/// <summary>
		/// Writes a debug string to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Debug(string message)
		{
			if (TShock.Config.Settings.DebugLogs)
				Write(message, TraceLevel.Verbose);
		}

		/// <summary>
		/// Writes a debug string to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Debug(string format, params object[] args)
		{
			if (TShock.Config.Settings.DebugLogs)
				Debug(string.Format(format, args));
		}

		public void Write(string message, TraceLevel level)
		{
			if (!MayWriteType(level))
				return;

			var caller = "TShock";

			var frame = new StackTrace().GetFrame(2);
			if (frame != null)
			{
				var meth = frame.GetMethod();
				if (meth != null && meth.DeclaringType != null)
					caller = meth.DeclaringType.Name;
			}

			try
			{
				if (_useTextLog)
				{
					_backupLog.Write(message, level);
					return;
				}

				_database.Query("INSERT INTO Logs (TimeStamp, Caller, LogLevel, Message) VALUES (@0, @1, @2, @3)",
					DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture), caller, (int)level, message);

				var success = true;
				while (_failures.Count > 0 && success)
				{
					var info = _failures.First();

					try
					{
						_database.Query("INSERT INTO Logs (TimeStamp, Caller, LogLevel, Message) VALUES (@0, @1, @2, @3)",
							info.timestamp, info.caller, (int)info.logLevel, info.message);
					}
					catch (Exception ex)
					{
						success = false;
						_failures.Add(new LogInfo
						{
							caller = "TShock",
							logLevel = TraceLevel.Error,
							message = GetString("SQL Log insert query failed: {0}", ex),
							timestamp = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture)
						});
					}

					if (success)
						_failures.RemoveAt(0);
				}
			}
			catch (Exception ex)
			{
				_backupLog.ConsoleError("SQL Log insert query failed: {0}", ex);

				_failures.Add(new LogInfo
				{
					logLevel = level,
					message = message,
					caller = caller,
					timestamp = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture)
				});
			}

			if (_failures.Count >= TShock.Config.Settings.RevertToTextLogsOnSqlFailures)
			{
				_useTextLog = true;
				_backupLog.ConsoleError("SQL Logging disabled due to errors. Reverting to text logging.");

				foreach (var logInfo in _failures)
				{
					_backupLog.Write(GetString("SQL log failed at: {0}. {1}", logInfo.timestamp, logInfo),
						TraceLevel.Error);
				}
				_failures.Clear();
			}
		}

		public void Dispose()
		{
			_backupLog.Dispose();
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/TSPlayer.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2022 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using Microsoft.Xna.Framework;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Timers;
using Terraria;
using Terraria.DataStructures;
using Terraria.ID;
using Terraria.Localization;
using TShockAPI.DB;
using TShockAPI.Hooks;
using TShockAPI.Net;
using Timer = System.Timers.Timer;
using System.Linq;
using Terraria.GameContent.Creative;
namespace TShockAPI
{
	/// <summary>
	/// Bitflags used with the <see cref="Disable(string, DisableFlags)"></see> method
	/// </summary>
	[Flags]
	public enum DisableFlags
	{
		/// <summary>
		/// Disable the player and leave no messages
		/// </summary>
		None,
		/// <summary>
		/// Write the Disable message to the console
		/// </summary>
		WriteToConsole,
		/// <summary>
		/// Write the Disable message to the log
		/// </summary>
		WriteToLog,
		/// <summary>
		/// Equivalent to WriteToConsole | WriteToLog
		/// </summary>
		WriteToLogAndConsole
	}

	/// <summary>
	/// An enum based on the current client's connection state to the server.
	/// </summary>
	public enum ConnectionState : int
	{
		/// <summary>
		/// The server is password protected and the connection is pending until a password is sent by the client.
		/// </summary>
		AwaitingPassword = -1,
		/// <summary>
		/// The connection has been established, and the client must verify its version.
		/// </summary>
		AwaitingVersionCheck = 0,
		/// <summary>
		/// The server has accepted the client's password to connect and/or the server has verified the client's version string as being correct. The client is now being assigned a player slot.
		/// </summary>
		AssigningPlayerSlot = 1,
		/// <summary>
		/// The player slot has been received by the client, and the server is now waiting for the player information.
		/// </summary>
		AwaitingPlayerInfo = 2,
		/// <summary>
		/// Player information has been received, and the client is requesting world data.
		/// </summary>
		RequestingWorldData = 3,
		/// <summary>
		/// The world data is being sent to the client.
		/// </summary>
		ReceivingWorldData = 4,
		/// <summary>
		/// The world data has been received, and the client is now finalizing the load.
		/// </summary>
		FinalizingWorldLoad = 5,
		/// <summary>
		/// The client is requesting tile data.
		/// </summary>
		RequestingTileData = 6,
		/// <summary>
		/// The connection process is complete (The player has spawned), and the client has fully joined the game.
		/// </summary>
		Complete = 10
	}

	public class TSPlayer
	{
		/// <summary>
		/// This represents the server as a player.
		/// </summary>
		public static readonly TSServerPlayer Server = new TSServerPlayer();

		/// <summary>
		/// This player represents all the players.
		/// </summary>
		public static readonly TSPlayer All = new TSPlayer("All");

		/// <summary>
		/// Finds a TSPlayer based on name or ID.
		/// If the string comes with tsi: or tsn:, we'll only return a list with one element,
		/// either the player with the matching ID or name, respectively.
		/// </summary>
		/// <param name="plr">Player name or ID</param>
		/// <returns>A list of matching players</returns>
		public static List<TSPlayer> FindByNameOrID(string search)
		{
			var found = new List<TSPlayer>();

			search = search.Trim();

			// tsi: and tsn: are used to disambiguate between usernames and not
			// and are also both 3 characters to remove them from the search
			// (the goal was to pick prefixes unlikely to be used by names)
			// (and not to collide with other prefixes used by other commands)
			var exactIndexOnly = search.StartsWith("tsi:");
			var exactNameOnly = search.StartsWith("tsn:");

			if (exactNameOnly || exactIndexOnly)
				search = search.Remove(0, 4);

			// Avoid errors caused by null search
			if (search == null || search == "")
				return found;

			byte searchID;
			if (byte.TryParse(search, out searchID) && searchID < Main.maxPlayers)
			{
				TSPlayer player = TShock.Players[searchID];
				if (player != null && player.Active)
				{
					if (exactIndexOnly)
						return new List<TSPlayer> { player };
					found.Add(player);
				}
			}

			string searchLower = search.ToLower();
			foreach (TSPlayer player in TShock.Players)
			{
				if (player != null)
				{
					if ((search == player.Name) && exactNameOnly)
						return new List<TSPlayer> { player };
					if (player.Name.ToLower().StartsWith(searchLower))
						found.Add(player);
				}
			}
			return found;
		}

		/// <summary>
		/// Used in preventing players from seeing the npc spawnrate permission error on join.
		/// </summary>
		internal bool HasReceivedNPCPermissionError { get; set; }

		/// <summary>
		/// The amount of tiles that the player has killed in the last second.
		/// </summary>
		public int TileKillThreshold { get; set; }

		/// <summary>
		/// The amount of tiles the player has placed in the last second.
		/// </summary>
		public int TilePlaceThreshold { get; set; }

		/// <summary>
		/// The amount of liquid (in tiles) that the player has placed in the last second.
		/// </summary>
		public int TileLiquidThreshold { get; set; }

		/// <summary>
		/// The amount of tiles that the player has painted in the last second.
		/// </summary>
		public int PaintThreshold { get; set; }

		/// <summary>
		/// The number of projectiles created by the player in the last second.
		/// </summary>
		public int ProjectileThreshold { get; set; }

		/// <summary>
		/// The number of HealOtherPlayer packets sent by the player in the last second.
		/// </summary>
		public int HealOtherThreshold { get; set; }

		/// <summary>
		/// A timer to keep track of whether or not the player has recently thrown an explosive
		/// </summary>
		public int RecentFuse = 0;

		/// <summary>
		/// Whether to ignore packets that are SSC-relevant.
		/// </summary>
		public bool IgnoreSSCPackets { get; set; }

		/// <summary>
		/// A system to delay Remembered Position Teleports a few seconds
		/// </summary>
		public int RPPending = 0;


		public bool initialSpawn = false;
		public int initialServerSpawnX = -2;
		public int initialServerSpawnY = -2;
		public bool spawnSynced = false;
		public int initialClientSpawnX = -2;
		public int initialClientSpawnY = -2;

		/// <summary>
		/// A queue of tiles destroyed by the player for reverting.
		/// </summary>
		public Dictionary<Vector2, ITile> TilesDestroyed { get; protected set; }

		/// <summary>
		/// A queue of tiles placed by the player for reverting.
		/// </summary>
		public Dictionary<Vector2, ITile> TilesCreated { get; protected set; }

		/// <summary>
		/// The player's group.
		/// </summary>
		public Group Group
		{
			get
			{
				if (tempGroup != null)
					return tempGroup;
				return group;
			}
			set { group = value; }
		}

		/// <summary>
		/// The player's temporary group.  This overrides the user's actual group.
		/// </summary>
		public Group tempGroup = null;

		public Timer tempGroupTimer;

		private Group group = null;

		public bool ReceivedInfo { get; set; }

		/// <summary>
		/// The players index in the player array( Main.players[] ).
		/// </summary>
		public int Index { get; protected set; }

		/// <summary>
		/// The last time the player changed their team or pvp status.
		/// </summary>
		public DateTime LastPvPTeamChange;

		/// <summary>
		/// Temp points for use in regions and other plugins.
		/// </summary>
		public Point[] TempPoints = new Point[2];

		/// <summary>
		/// Whether the player is waiting to place/break a tile to set as a temp point.
		/// </summary>
		public int AwaitingTempPoint { get; set; }

		/// <summary>
		/// A list of command callbacks indexed by the command they need to do.
		/// </summary>
		public Dictionary<string, Action<object>> AwaitingResponse;

		public bool AwaitingName { get; set; }

		public string[] AwaitingNameParameters { get; set; }

		/// <summary>
		/// The last time a player broke a grief check.
		/// </summary>
		public DateTime LastThreat { get; set; }

		/// <summary>
		/// Whether the player should see logs.
		/// </summary>
		public bool DisplayLogs = true;

		/// <summary>
		/// The last player that the player whispered with (to or from).
		/// </summary>
		public TSPlayer LastWhisper;

		/// <summary>
		/// The number of unsuccessful login attempts.
		/// </summary>
		public int LoginAttempts { get; set; }

		/// <summary>
		/// Unused.
		/// </summary>
		public Vector2 TeleportCoords = new Vector2(-1, -1);

		/// <summary>
		/// The player's last known position from PlayerUpdate packet.
		/// </summary>
		public Vector2 LastNetPosition = Vector2.Zero;

		/// <summary>
		/// UserAccount object associated with the player.
		/// Set when the player logs in.
		/// </summary>
		public UserAccount Account { get; set; }

		/// <summary>
		/// Whether the player performed a valid login attempt (i.e. entered valid user name and password) but is still blocked
		/// from logging in because of SSI.
		/// </summary>
		public bool LoginFailsBySsi { get; set; }

		/// <summary>
		/// Whether the player is logged in or not.
		/// </summary>
		public bool IsLoggedIn;

		/// <summary>
		/// Whether the player has sent their whole inventory to the server while connecting.
		/// </summary>
		public bool HasSentInventory { get; set; }

		/// <summary>
		/// Whether the player has been nagged about logging in.
		/// </summary>
		public bool HasBeenNaggedAboutLoggingIn;

		/// <summary>
		/// Whether other players can teleport to the player.
		/// </summary>
		public bool TPAllow = true;

		/// <summary>
		/// Whether the player is muted or not.
		/// </summary>
		public bool mute;

		private Player FakePlayer;

		public bool RequestedSection;

		/// <summary>
		/// The player's respawn timer.
		/// </summary>
		public int RespawnTimer
		{
			get => _respawnTimer;
			set => TPlayer.respawnTimer = (_respawnTimer = value) * 60;
		}
		private int _respawnTimer;

		/// <summary>
		/// Whether the player is dead or not.
		/// </summary>
		public bool Dead;

		public string Country = "??";

		/// <summary>
		/// The players difficulty( normal[softcore], mediumcore, hardcore ).
		/// </summary>
		public int Difficulty;

		private string CacheIP;

		/// <summary>Determines if the player is disabled by the SSC subsystem for not being logged in.</summary>
		public bool IsDisabledForSSC = false;

		/// <summary>Determines if the player is disabled by Bouncer for having hacked item stacks.</summary>
		public bool IsDisabledForStackDetection = false;

		/// <summary>Determines if the player is disabled by the item bans system for having banned wearables on the server.</summary>
		public bool IsDisabledForBannedWearable = false;

		/// <summary>Determines if the player is disabled for not clearing their trash. A re-login is the only way to reset this.</summary>
		public bool IsDisabledPendingTrashRemoval;

		/// <summary>Determines if the player has finished the handshake (Sent all necessary packets for connection, such as Request World Data, Spawn Player, etc). A normal client would do all of this no problem.</summary>
		public bool FinishedHandshake = false;

		/// <summary>Checks to see if active throttling is happening on events by Bouncer. Rejects repeated events by malicious clients in a short window.</summary>
		/// <returns>If the player is currently being throttled by Bouncer, or not.</returns>
		public bool IsBouncerThrottled()
		{
			return (DateTime.UtcNow - LastThreat).TotalMilliseconds < 5000;
		}

		/// <summary>Easy check if a player has any of IsDisabledForSSC, IsDisabledForStackDetection, IsDisabledForBannedWearable, or IsDisabledPendingTrashRemoval set. Or if they're not logged in and a login is required.</summary>
		/// <returns>If any of the checks that warrant disabling are set on this player. If true, Disable() is repeatedly called on them.</returns>
		public bool IsBeingDisabled()
		{
			return IsDisabledForSSC
			|| IsDisabledForStackDetection
			|| IsDisabledForBannedWearable
			|| IsDisabledPendingTrashRemoval
			|| !IsLoggedIn && TShock.Config.Settings.RequireLogin;
		}

		/// <summary>Checks to see if a player has hacked item stacks in their inventory, and messages them as it checks.</summary>
		/// <param name="shouldWarnPlayer">If the check should send a message to the player with the results of the check.</param>
		/// <returns>True if any stacks don't conform.</returns>
		public bool HasHackedItemStacks(bool shouldWarnPlayer = false)
		{
			// Iterates through each inventory location a player has.
			// This section is sub divided into number ranges for what each range of slots corresponds to.
			bool check = false;

			Item[] inventory = TPlayer.inventory;
			Item[] armor = TPlayer.armor;
			Item[] dye = TPlayer.dye;
			Item[] miscEquips = TPlayer.miscEquips;
			Item[] miscDyes = TPlayer.miscDyes;
			Item[] piggy = TPlayer.bank.item;
			Item[] safe = TPlayer.bank2.item;
			Item[] forge = TPlayer.bank3.item;
			Item[] voidVault = TPlayer.bank4.item;
			Item[] loadout1Armor = TPlayer.Loadouts[0].Armor;
			Item[] loadout1Dye = TPlayer.Loadouts[0].Dye;
			Item[] loadout2Armor = TPlayer.Loadouts[1].Armor;
			Item[] loadout2Dye = TPlayer.Loadouts[1].Dye;
			Item[] loadout3Armor = TPlayer.Loadouts[2].Armor;
			Item[] loadout3Dye = TPlayer.Loadouts[2].Dye;

			Item trash = TPlayer.trashItem;
			for (int i = 0; i < NetItem.MaxInventory; i++)
			{
				if (i < NetItem.InventoryIndex.Item2)
				{
					// From above: this is slots 0-58 in the inventory.
					// 0-58
					Item item = new Item();
					if (inventory[i] != null && inventory[i].netID != 0)
					{
						item.netDefaults(inventory[i].netID);
						item.Prefix(inventory[i].prefix);
						item.AffixName();
						if (inventory[i].stack > item.maxStack || inventory[i].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove item {0} ({1}) and then rejoin.", item.Name, inventory[i].stack));
							}
						}
					}
				}
				else if (i < NetItem.ArmorIndex.Item2)
				{
					// 59-78
					var index = i - NetItem.ArmorIndex.Item1;
					Item item = new Item();
					if (armor[index] != null && armor[index].netID != 0)
					{
						item.netDefaults(armor[index].netID);
						item.Prefix(armor[index].prefix);
						item.AffixName();
						if (armor[index].stack > item.maxStack || armor[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove armor {0} ({1}) and then rejoin.", item.Name, armor[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.DyeIndex.Item2)
				{
					// 79-88
					var index = i - NetItem.DyeIndex.Item1;
					Item item = new Item();
					if (dye[index] != null && dye[index].netID != 0)
					{
						item.netDefaults(dye[index].netID);
						item.Prefix(dye[index].prefix);
						item.AffixName();
						if (dye[index].stack > item.maxStack || dye[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove dye {0} ({1}) and then rejoin.", item.Name, dye[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.MiscEquipIndex.Item2)
				{
					// 89-93
					var index = i - NetItem.MiscEquipIndex.Item1;
					Item item = new Item();
					if (miscEquips[index] != null && miscEquips[index].netID != 0)
					{
						item.netDefaults(miscEquips[index].netID);
						item.Prefix(miscEquips[index].prefix);
						item.AffixName();
						if (miscEquips[index].stack > item.maxStack || miscEquips[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove item {0} ({1}) and then rejoin.", item.Name, miscEquips[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.MiscDyeIndex.Item2)
				{
					// 93-98
					var index = i - NetItem.MiscDyeIndex.Item1;
					Item item = new Item();
					if (miscDyes[index] != null && miscDyes[index].netID != 0)
					{
						item.netDefaults(miscDyes[index].netID);
						item.Prefix(miscDyes[index].prefix);
						item.AffixName();
						if (miscDyes[index].stack > item.maxStack || miscDyes[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove item dye {0} ({1}) and then rejoin.", item.Name, miscDyes[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.PiggyIndex.Item2)
				{
					// 98-138
					var index = i - NetItem.PiggyIndex.Item1;
					Item item = new Item();
					if (piggy[index] != null && piggy[index].netID != 0)
					{
						item.netDefaults(piggy[index].netID);
						item.Prefix(piggy[index].prefix);
						item.AffixName();

						if (piggy[index].stack > item.maxStack || piggy[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove piggy-bank item {0} ({1}) and then rejoin.", item.Name, piggy[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.SafeIndex.Item2)
				{
					// 138-178
					var index = i - NetItem.SafeIndex.Item1;
					Item item = new Item();
					if (safe[index] != null && safe[index].netID != 0)
					{
						item.netDefaults(safe[index].netID);
						item.Prefix(safe[index].prefix);
						item.AffixName();

						if (safe[index].stack > item.maxStack || safe[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove safe item {0} ({1}) and then rejoin.", item.Name, safe[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.TrashIndex.Item2)
				{
					// 178-179
					Item item = new Item();
					if (trash != null && trash.netID != 0)
					{
						item.netDefaults(trash.netID);
						item.Prefix(trash.prefix);
						item.AffixName();

						if (trash.stack > item.maxStack)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove trash item {0} ({1}) and then rejoin.", item.Name, trash.stack));
							}
						}
					}
				}
				else if (i < NetItem.ForgeIndex.Item2)
				{
					// 179-220
					var index = i - NetItem.ForgeIndex.Item1;
					Item item = new Item();
					if (forge[index] != null && forge[index].netID != 0)
					{
						item.netDefaults(forge[index].netID);
						item.Prefix(forge[index].prefix);
						item.AffixName();

						if (forge[index].stack > item.maxStack || forge[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove Defender's Forge item {0} ({1}) and then rejoin.", item.Name, forge[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.VoidIndex.Item2)
				{
					// 220-260
					var index = i - NetItem.VoidIndex.Item1;
					Item item = new Item();
					if (voidVault[index] != null && voidVault[index].netID != 0)
					{
						item.netDefaults(voidVault[index].netID);
						item.Prefix(voidVault[index].prefix);
						item.AffixName();

						if (voidVault[index].stack > item.maxStack || voidVault[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove Void Vault item {0} ({1}) and then rejoin.", item.Name, voidVault[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.Loadout1Armor.Item2)
				{
					var index = i - NetItem.Loadout1Armor.Item1;
					Item item = new Item();
					if (loadout1Armor[index] != null && loadout1Armor[index].netID != 0)
					{
						item.netDefaults(loadout1Armor[index].netID);
						item.Prefix(loadout1Armor[index].prefix);
						item.AffixName();

						if (loadout1Armor[index].stack > item.maxStack || loadout1Armor[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove Loadout 1 item {0} ({1}) and then rejoin.", item.Name, loadout1Armor[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.Loadout1Dye.Item2)
				{
					var index = i - NetItem.Loadout1Dye.Item1;
					Item item = new Item();
					if (loadout1Dye[index] != null && loadout1Dye[index].netID != 0)
					{
						item.netDefaults(loadout1Dye[index].netID);
						item.Prefix(loadout1Dye[index].prefix);
						item.AffixName();

						if (loadout1Dye[index].stack > item.maxStack || loadout1Dye[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove Loadout 1 item {0} ({1}) and then rejoin.", item.Name, loadout1Dye[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.Loadout2Armor.Item2)
				{
					var index = i - NetItem.Loadout2Armor.Item1;
					Item item = new Item();
					if (loadout2Armor[index] != null && loadout2Armor[index].netID != 0)
					{
						item.netDefaults(loadout2Armor[index].netID);
						item.Prefix(loadout2Armor[index].prefix);
						item.AffixName();

						if (loadout2Armor[index].stack > item.maxStack || loadout2Armor[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove Loadout 2 item {0} ({1}) and then rejoin.", item.Name, loadout2Armor[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.Loadout2Dye.Item2)
				{
					var index = i - NetItem.Loadout2Dye.Item1;
					Item item = new Item();
					if (loadout2Dye[index] != null && loadout2Dye[index].netID != 0)
					{
						item.netDefaults(loadout2Dye[index].netID);
						item.Prefix(loadout2Dye[index].prefix);
						item.AffixName();

						if (loadout2Dye[index].stack > item.maxStack || loadout2Dye[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove Loadout 2 item {0} ({1}) and then rejoin.", item.Name, loadout2Dye[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.Loadout3Armor.Item2)
				{
					var index = i - NetItem.Loadout3Armor.Item1;
					Item item = new Item();
					if (loadout3Armor[index] != null && loadout3Armor[index].netID != 0)
					{
						item.netDefaults(loadout3Armor[index].netID);
						item.Prefix(loadout3Armor[index].prefix);
						item.AffixName();

						if (loadout3Armor[index].stack > item.maxStack || loadout3Armor[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove Loadout 3 item {0} ({1}) and then rejoin.", item.Name, loadout3Armor[index].stack));
							}
						}
					}
				}
				else if (i < NetItem.Loadout3Dye.Item2)
				{
					var index = i - NetItem.Loadout3Dye.Item1;
					Item item = new Item();
					if (loadout3Dye[index] != null && loadout3Dye[index].netID != 0)
					{
						item.netDefaults(loadout3Dye[index].netID);
						item.Prefix(loadout3Dye[index].prefix);
						item.AffixName();

						if (loadout3Dye[index].stack > item.maxStack || loadout3Dye[index].stack < 0)
						{
							check = true;
							if (shouldWarnPlayer)
							{
								SendErrorMessage(GetString("Stack cheat detected. Remove Loadout 3 item {0} ({1}) and then rejoin.", item.Name, loadout3Dye[index].stack));
							}
						}
					}
				}
			}

			return check;
		}

		/// <summary>
		/// The player's server side inventory data.
		/// </summary>
		public PlayerData PlayerData;

		/// <summary>
		/// Whether the player needs to specify a password upon connection( either server or user account ).
		/// </summary>
		public bool RequiresPassword;

		public bool SilentKickInProgress;

		public bool SilentJoinInProgress;

		/// <summary>
		/// Whether the player is accepting whispers from other users
		/// </summary>
		public bool AcceptingWhispers = true;

		/// <summary>Checks if a player is in range of a given tile if range checks are enabled.</summary>
		/// <param name="x"> The x coordinate of the tile.</param>
		/// <param name="y">The y coordinate of the tile.</param>
		/// <param name="range">The range to check for.</param>
		/// <returns>True if the player is in range of a tile or if range checks are off. False if not.</returns>
		public bool IsInRange(int x, int y, int range = 32)
		{
			int rgX = Math.Abs(TileX - x);
			int rgY = Math.Abs(TileY - y);
			if (TShock.Config.Settings.RangeChecks && ((rgX > range) || (rgY > range)))
			{
				TShock.Log.ConsoleDebug(GetString("Rangecheck failed for {0} ({1}, {2}) (rg: {3}/{5}, {4}/{5})", Name, x, y, rgX, rgY, range));
				return false;
			}
			return true;
		}

		private enum BuildPermissionFailPoint
		{
			GeneralBuild,
			SpawnProtect,
			Regions
		}

		/// <summary>Determines if the player can build on a given point.</summary>
		/// <param name="x">The x coordinate they want to build at.</param>
		/// <param name="y">The y coordinate they want to build at.</param>
		/// <param name="shouldWarnPlayer">Whether or not the player should be warned if their build attempt fails</param>
		/// <returns>True if the player can build at the given point from build, spawn, and region protection.</returns>
		public bool HasBuildPermission(int x, int y, bool shouldWarnPlayer = true)
		{
			PermissionHookResult hookResult = PlayerHooks.OnPlayerHasBuildPermission(this, x, y);
			if (hookResult != PermissionHookResult.Unhandled)
			{
				return hookResult == PermissionHookResult.Granted;
			}

			BuildPermissionFailPoint failure = BuildPermissionFailPoint.GeneralBuild;
			// The goal is to short circuit on easy stuff as much as possible.
			// Don't compute permissions unless needed, and don't compute taxing stuff unless needed.

			// If the player has bypass on build protection or building is enabled; continue
			// (General build protection takes precedence over spawn protection)
			if (!TShock.Config.Settings.DisableBuild || HasPermission(Permissions.antibuild))
			{
				failure = BuildPermissionFailPoint.SpawnProtect;
				// If they have spawn protect bypass, or it isn't spawn, or it isn't in spawn; continue
				// (If they have spawn protect bypass, we don't care if it's spawn or not)
				if (!TShock.Config.Settings.SpawnProtection || HasPermission(Permissions.editspawn) || !Utils.IsInSpawn(x, y))
				{
					failure = BuildPermissionFailPoint.Regions;
					// If they have build permission in this region, then they're allowed to continue
					if (TShock.Regions.CanBuild(x, y, this))
					{
						return true;
					}
				}
			}
			// If they lack build permission, they end up here.
			// If they have build permission but lack the ability to edit spawn and it's spawn, they end up here.
			// If they have build, it isn't spawn, or they can edit spawn, but they fail the region check, they end up here.

			// If they shouldn't be warned, exit early.
			if (!shouldWarnPlayer)
				return false;

			// Space out warnings by 2 seconds so that they don't get spammed.
			if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - lastPermissionWarning) < 2000)
			{
				return false;
			}

			// If they should be warned, warn them.
			if (!TShock.Config.Settings.SuppressPermissionFailureNotices)
			{
				switch (failure)
				{
					case BuildPermissionFailPoint.GeneralBuild:
						SendErrorMessage(GetString("You do not have permission to build on this server."));
						break;
					case BuildPermissionFailPoint.SpawnProtect:
						SendErrorMessage(GetString("You do not have permission to build in the spawn point."));
						break;
					case BuildPermissionFailPoint.Regions:
						SendErrorMessage(GetString("You do not have permission to build in this region."));
						break;
				}
			}
			// Set the last warning time to now.
			lastPermissionWarning = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;

			return false;
		}

		/// <summary>
		/// Determines if the player can build a multi-block tile object on a given point.
		/// Tile objects include things like Doors, Trap Doors, Item Frames, Beds, and Dressers.
		/// </summary>
		/// <param name="x">The x coordinate they want to build at.</param>
		/// <param name="y">The y coordinate they want to build at.</param>
		/// <param name="width">The width of the tile object</param>
		/// <param name="height">The height of the tile object</param>
		/// <param name="shouldWarnPlayer">Whether or not the player should be warned if their build attempt fails</param>
		/// <returns>True if the player can build at the given point from build, spawn, and region protection.</returns>
		public bool HasBuildPermissionForTileObject(int x, int y, int width, int height, bool shouldWarnPlayer = true)
		{
			for (int realx = x; realx < x + width; realx++)
			{
				for (int realy = y; realy < y + height; realy++)
				{
					if (!HasBuildPermission(realx, realy, shouldWarnPlayer))
					{
						return false;
					}
				}
			}

			return true;
		}

		/// <summary>Determines if the player can paint on a given point. Checks general build permissions, then paint.</summary>
		/// <param name="x">The x coordinate they want to paint at.</param>
		/// <param name="y">The y coordinate they want to paint at.</param>
		/// <returns>True if they can paint.</returns>
		public bool HasPaintPermission(int x, int y)
		{
			return HasBuildPermission(x, y) && HasPermission(Permissions.canpaint);
		}

		/// <summary>Checks if a player can place ice, and if they can, tracks ice placements and removals.</summary>
		/// <param name="x">The x coordinate of the suspected ice block.</param>
		/// <param name="y">The y coordinate of the suspected ice block.</param>
		/// <param name="tileType">The tile type of the suspected ice block.</param>
		/// <param name="editAction">The EditAction on the suspected ice block.</param>
		/// <returns>True if a player successfully places an ice tile or removes one of their past ice tiles.</returns>
		public bool HasModifiedIceSuccessfully(int x, int y, short tileType, GetDataHandlers.EditAction editAction)
		{
			// The goal is to short circuit ASAP.
			// A subsequent call to HasBuildPermission can figure this out if not explicitly ice.
			if (!TShock.Config.Settings.AllowIce)
			{
				return false;
			}

			// They've placed some ice. Horrible!
			if (editAction == GetDataHandlers.EditAction.PlaceTile && tileType == TileID.MagicalIceBlock)
			{
				IceTiles.Add(new Point(x, y));
				return true;
			}

			// The edit wasn't an add, so we check to see if the position matches any of the known ice tiles
			if (editAction == GetDataHandlers.EditAction.KillTile)
			{
				foreach (Point p in IceTiles)
				{
					// If they're trying to kill ice or dirt, and the tile was in the list, we allow it.
					if (p.X == x && p.Y == y && (Main.tile[p.X, p.Y].type == TileID.Dirt || Main.tile[p.X, p.Y].type == TileID.MagicalIceBlock))
					{
						IceTiles.Remove(p);
						return true;
					}
				}
			}

			// Only a small number of cases let this happen.
			return false;
		}

		/// <summary>
		/// A list of points where ice tiles have been placed.
		/// </summary>
		public List<Point> IceTiles;

		/// <summary>
		/// The last time the player was warned for build permissions.
		/// In MS, defaults to 1 (so it will warn on the first attempt).
		/// </summary>
		public long lastPermissionWarning = 1;

		/// <summary>
		/// The time in ms when the player has logged in.
		/// </summary>
		public long LoginMS;

		/// <summary>
		/// Whether the player has been harrassed about logging in due to server side inventory or forced login.
		/// </summary>
		public bool LoginHarassed = false;

		/// <summary>
		/// Controls the journey godmode
		/// </summary>
		public bool GodMode
		{
			get =>
				CreativePowerManager.Instance.GetPower<CreativePowers.GodmodePower>().IsEnabledForPlayer(Index);
			set =>
				CreativePowerManager.Instance.GetPower<CreativePowers.GodmodePower>().SetEnabledState(Index, value);
		}

		/// <summary>
		/// Players controls are inverted if using SSC
		/// </summary>
		public bool Confused = false;

		/// <summary>
		/// The last projectile type this player tried to kill.
		/// </summary>
		public int LastKilledProjectile = 0;

		/// <summary>
		/// Keeps track of recently created projectiles by this player. TShock.cs OnSecondUpdate() removes from this in an async task.
		/// Projectiles older than 5 seconds are purged from this collection as they are no longer "recent."
		/// </summary>
		public List<TShockAPI.GetDataHandlers.ProjectileStruct> RecentlyCreatedProjectiles = new List<TShockAPI.GetDataHandlers.ProjectileStruct>();

		/// <summary>
		/// The current region this player is in, or null if none.
		/// </summary>
		public Region CurrentRegion = null;

		/// <summary>
		/// Contains data stored by plugins
		/// </summary>
		protected ConcurrentDictionary<string, object> data = new ConcurrentDictionary<string, object>();

		/// <summary>
		/// Whether the player is a real, human, player on the server.
		/// </summary>
		public bool RealPlayer
		{
			get { return Index >= 0 && Index < Main.maxNetPlayers && Main.player[Index] != null; }
		}

		/// <summary>
		/// Checks if the player is active and not pending termination.
		/// </summary>
		public bool ConnectionAlive
		{
			get
			{
				return RealPlayer
					   && (Client != null && Client.IsActive && !Client.PendingTermination);
			}
		}

		/// <summary>
		/// Gets the item that the player is currently holding.
		/// </summary>
		public Item SelectedItem
		{
			get { return TPlayer.inventory[TPlayer.selectedItem]; }
		}

		/// <summary>
		/// Gets the player's Client State.
		/// </summary>
		public int State
		{
			get { return Client.State; }
			set { Client.State = value; }
		}

		/// <summary>
		/// Gets the player's UUID.
		/// </summary>
		public string UUID
		{
			get { return RealPlayer ? Client.ClientUUID : ""; }
		}

		/// <summary>
		/// Gets the player's IP.
		/// </summary>
		public string IP
		{
			get
			{
				if (string.IsNullOrEmpty(CacheIP))
					return
						CacheIP = RealPlayer ? (Client.Socket.IsConnected()
								? TShock.Utils.GetRealIP(Client.Socket.GetRemoteAddress().ToString())
								: "")
							: "127.0.0.1";
				else
					return CacheIP;
			}
		}

		/// <summary>
		/// Gets the player's inventory (first 5 rows)
		/// </summary>
		public IEnumerable<Item> Inventory
		{
			get
			{
				for (int i = 0; i < 50; i++)
					yield return TPlayer.inventory[i];
			}
		}

		/// <summary>
		/// Gets the player's accessories.
		/// </summary>
		public IEnumerable<Item> Accessories
		{
			get
			{
				for (int i = 3; i < 10; i++)
					yield return TPlayer.armor[i];
			}
		}

		/// <summary>
		/// Saves the player's inventory to SSC
		/// </summary>
		/// <returns>bool - True/false if it saved successfully</returns>
		public bool SaveServerCharacter()
		{
			if (!Main.ServerSideCharacter)
			{
				return false;
			}
			try
			{
				if (HasPermission(Permissions.bypassssc))
				{
					TShock.Log.ConsoleInfo(GetString($"Skipping SSC save (due to tshock.ignore.ssc) for {Account.Name}"));
					return true;
				}
				PlayerData.CopyCharacter(this);
				TShock.CharacterDB.InsertPlayerData(this);
				return true;
			}
			catch (Exception e)
			{
				TShock.Log.Error(e.Message);
				return false;
			}
		}

		/// <summary>
		/// Sends the players server side character to client
		/// </summary>
		/// <returns>bool - True/false if it saved successfully</returns>
		public bool SendServerCharacter()
		{
			if (!Main.ServerSideCharacter)
			{
				return false;
			}
			try
			{
				PlayerData.RestoreCharacter(this);
				return true;
			}
			catch (Exception e)
			{
				TShock.Log.Error(e.Message);
				return false;
			}

		}

		/// <summary>
		/// Player RemoteClient.
		/// </summary>
		public RemoteClient Client => Netplay.Clients[Index];

		/// <summary>
		/// Gets the Terraria Player object associated with the player.
		/// </summary>
		public Player TPlayer
		{
			get { return FakePlayer ?? Main.player[Index]; }
		}

		/// <summary>
		/// Gets the player's name.
		/// </summary>
		public string Name
		{
			get { return TPlayer.name; }
		}

		/// <summary>
		/// Gets the player's active state.
		/// </summary>
		public bool Active
		{
			get { return TPlayer != null && TPlayer.active; }
		}

		/// <summary>
		/// Gets the player's team.
		/// </summary>
		public int Team
		{
			get { return TPlayer.team; }
		}

		/// <summary>
		/// Gets PvP player mode.
		/// </summary>
		public bool Hostile => TPlayer.hostile;

		/// <summary>
		/// Gets the player's X coordinate.
		/// </summary>
		public float X
		{
			get { return RealPlayer ? TPlayer.position.X : Main.spawnTileX * 16; }
		}

		/// <summary>
		/// Gets the player's Y coordinate.
		/// </summary>
		public float Y
		{
			get { return RealPlayer ? TPlayer.position.Y : Main.spawnTileY * 16; }
		}

		/// <summary>
		/// Player X coordinate divided by 16. Supposed X world coordinate.
		/// </summary>
		public int TileX
		{
			get { return (int)(X / 16); }
		}

		/// <summary>
		/// Player Y coordinate divided by 16. Supposed Y world coordinate.
		/// </summary>
		public int TileY
		{
			get { return (int)(Y / 16); }
		}

		/// <summary>
		/// Checks if the player has any inventory slots available.
		/// </summary>
		public bool InventorySlotAvailable
		{
			get
			{
				bool flag = false;
				if (RealPlayer)
				{
					for (int i = 0; i < 50; i++) //51 is trash can, 52-55 is coins, 56-59 is ammo
					{
						if (TPlayer.inventory[i] == null || !TPlayer.inventory[i].active || TPlayer.inventory[i].Name == "")
						{
							flag = true;
							break;
						}
					}
				}
				return flag;
			}
		}

		/// <summary>
		/// This contains the character data a player has when they join the server.
		/// </summary>
		public PlayerData DataWhenJoined { get; set; }

		/// <summary>
		/// Determines whether the player's storage contains the given key.
		/// </summary>
		/// <param name="key">Key to test.</param>
		/// <returns></returns>
		public bool ContainsData(string key)
		{
			return data.ContainsKey(key);
		}

		/// <summary>
		/// Returns the stored object associated with the given key.
		/// </summary>
		/// <typeparam name="T">Type of the object being retrieved.</typeparam>
		/// <param name="key">Key with which to access the object.</param>
		/// <returns>The stored object, or default(T) if not found.</returns>
		public T GetData<T>(string key)
		{
			object obj;
			if (!data.TryGetValue(key, out obj))
			{
				return default(T);
			}

			return (T)obj;
		}

		/// <summary>
		/// Stores an object on this player, accessible with the given key.
		/// </summary>
		/// <typeparam name="T">Type of the object being stored.</typeparam>
		/// <param name="key">Key with which to access the object.</param>
		/// <param name="value">Object to store.</param>
		public void SetData<T>(string key, T value)
		{
			if (!data.TryAdd(key, value))
			{
				data.TryUpdate(key, value, data[key]);
			}
		}

		/// <summary>
		/// Removes the stored object associated with the given key.
		/// </summary>
		/// <param name="key">Key with which to access the object.</param>
		/// <returns>The removed object.	</returns>
		public object RemoveData(string key)
		{
			object rem;
			if (data.TryRemove(key, out rem))
			{
				return rem;
			}
			return null;
		}

		/// <summary>
		/// Logs the player out of an account.
		/// </summary>
		public void Logout()
		{
			PlayerHooks.OnPlayerLogout(this);
			if (Main.ServerSideCharacter)
			{
				IsDisabledForSSC = true;
				if (!IsDisabledPendingTrashRemoval && (!Dead || TPlayer.difficulty != 2))
				{
					PlayerData.CopyCharacter(this);
					TShock.CharacterDB.InsertPlayerData(this);
				}
			}

			PlayerData = new PlayerData();
			Group = TShock.Groups.GetGroupByName(TShock.Config.Settings.DefaultGuestGroupName);
			tempGroup = null;
			if (tempGroupTimer != null)
			{
				tempGroupTimer.Stop();
			}
			Account = null;
			IsLoggedIn = false;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="TSPlayer"/> class.
		/// </summary>
		/// <param name="index">The player's index in the.</param>
		public TSPlayer(int index)
		{
			TilesDestroyed = new Dictionary<Vector2, ITile>();
			TilesCreated = new Dictionary<Vector2, ITile>();
			Index = index;
			Group = Group.DefaultGroup;
			IceTiles = new List<Point>();
			AwaitingResponse = new Dictionary<string, Action<object>>();
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="TSPlayer"/> class.
		/// </summary>
		/// <param name="playerName">The player's name.</param>
		protected TSPlayer(String playerName)
		{
			TilesDestroyed = new Dictionary<Vector2, ITile>();
			TilesCreated = new Dictionary<Vector2, ITile>();
			Index = -1;
			FakePlayer = new Player { name = playerName, whoAmI = -1 };
			Group = Group.DefaultGroup;
			AwaitingResponse = new Dictionary<string, Action<object>>();

			if (playerName == "All" || playerName == "Server")
				FinishedHandshake = true; //Hot fix for the all player object not getting packets like TimeSet, etc because they have no state and finished handshake will always be false.
		}

		/// <summary>
		/// Disconnects the player from the server.
		/// </summary>
		/// <param name="reason">The reason why the player was disconnected.</param>
		public virtual void Disconnect(string reason)
		{
			SendData(PacketTypes.Disconnect, reason);
		}

		/// <summary>
		/// Fired when the player's temporary group access expires.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		public void TempGroupTimerElapsed(object sender, ElapsedEventArgs args)
		{
			SendWarningMessage(GetString("Your temporary group access has expired."));

			tempGroup = null;
			if (sender != null)
			{
				((Timer)sender).Stop();
			}
		}

		/// <summary>
		/// Teleports the player to the given coordinates in the world.
		/// </summary>
		/// <param name="x">The X coordinate.</param>
		/// <param name="y">The Y coordinate.</param>
		/// <param name="style">The teleportation style.</param>
		/// <returns>True or false.</returns>
		public bool Teleport(float x, float y, byte style = 1)
		{
			if (x > Main.rightWorld - 992)
			{
				x = Main.rightWorld - 992;
			}
			if (x < 992)
			{
				x = 992;
			}
			if (y > Main.bottomWorld - 992)
			{
				y = Main.bottomWorld - 992;
			}
			if (y < 992)
			{
				y = 992;
			}

			SendTileSquareCentered((int)(x / 16), (int)(y / 16), 15);
			TPlayer.Teleport(new Vector2(x, y), style);
			NetMessage.SendData((int)PacketTypes.Teleport, -1, -1, NetworkText.Empty, 0, TPlayer.whoAmI, x, y, style);
			return true;
		}

		/// <summary>
		/// Teleports the player to their spawnpoint. 
		/// Teleports to main spawnpoint if their bed is not active.
		/// Supports SSC.
		/// </summary>
		public bool TeleportSpawnpoint()
		{
			// NOTE: it is vanilla behaviour to not permanently override the spawnpoint if the bed spawn is broken/invalid
			int x = TPlayer.SpawnX;
			int y = TPlayer.SpawnY;
			if ((x == -1 && y == -1) || 
				!Main.tile[x, y - 1].active() || Main.tile[x, y - 1].type != TileID.Beds || !WorldGen.StartRoomCheck(x, y - 1))
			{
				x = Main.spawnTileX;
				y = Main.spawnTileY;
			}
			return Teleport(x * 16, y * 16 - 48);
		}

		/// <summary>
		/// Heals the player.
		/// </summary>
		/// <param name="health">Heal health amount.</param>
		public void Heal(int health = 600)
		{
			NetMessage.SendData((int)PacketTypes.PlayerHealOther, -1, -1, NetworkText.Empty, this.TPlayer.whoAmI, health);
		}

		/// <summary>
		/// Spawns the player at his spawn point.
		/// </summary>
		public void Spawn(PlayerSpawnContext context, int? respawnTimer = null)
		{
			Spawn(TPlayer.SpawnX, TPlayer.SpawnY, context, respawnTimer);
		}

		/// <summary>
		/// Spawns the player at the given coordinates.
		/// </summary>
		/// <param name="tilex">The X coordinate.</param>
		/// <param name="tiley">The Y coordinate.</param>
		/// <param name="context">The PlayerSpawnContext.</param>
		/// <param name="respawnTimer">The respawn timer, will be Player.respawnTimer if parameter is null.</param>
		/// <param name="numberOfDeathsPVE">The number of deaths PVE, will be TPlayer.numberOfDeathsPVE if parameter is null.</param>
		/// <param name="numberOfDeathsPVP">The number of deaths PVP, will be TPlayer.numberOfDeathsPVP if parameter is null.</param>
		public void Spawn(int tilex, int tiley, PlayerSpawnContext context, int? respawnTimer = null, short? numberOfDeathsPVE = null, short? numberOfDeathsPVP = null)
		{
			using (var ms = new MemoryStream())
			{
				var msg = new SpawnMsg
				{
					PlayerIndex = (byte)Index,
					TileX = (short)tilex,
					TileY = (short)tiley,
					RespawnTimer = respawnTimer ?? TShock.Players[Index].RespawnTimer * 60,
					NumberOfDeathsPVE = numberOfDeathsPVE ?? (short)TPlayer.numberOfDeathsPVE,
					NumberOfDeathsPVP = numberOfDeathsPVP ?? (short)TPlayer.numberOfDeathsPVP,
					PlayerSpawnContext = context,
				};
				msg.PackFull(ms);
				SendRawData(ms.ToArray());
			}
		}

		/// <summary>
		/// Removes the projectile with the given index and owner.
		/// </summary>
		/// <param name="index">The projectile's index.</param>
		/// <param name="owner">The projectile's owner.</param>
		public void RemoveProjectile(int index, int owner)
		{
			using (var ms = new MemoryStream())
			{
				var msg = new ProjectileRemoveMsg
				{
					Index = (short)index,
					Owner = (byte)owner
				};
				msg.PackFull(ms);
				SendRawData(ms.ToArray());
			}
		}

		/// <summary>Sends a tile square at a location with a given size.
		/// Typically used to revert changes by Bouncer through sending the
		/// "old" version of modified data back to a client.
		/// Prevents desync issues.
		/// </summary>
		/// <param name="x">The x coordinate to send.</param>
		/// <param name="y">The y coordinate to send.</param>
		/// <param name="size">The size square set of tiles to send.</param>
		/// <returns>true if the tile square was sent successfully, else false</returns>
		[Obsolete("This method may not send tiles the way you would expect it to. The (x,y) coordinates are the top left corner of the tile square, switch to " + nameof(SendTileSquareCentered) + " if you wish for the coordindates to be the center of the square.")]
		public virtual bool SendTileSquare(int x, int y, int size = 10)
		{
			return SendTileRect((short)x, (short)y, (byte)size, (byte)size);
		}

		/// <summary>
		/// Sends a tile square at a center location with a given size.
		/// Typically used to revert changes by Bouncer through sending the
		/// "old" version of modified data back to a client.
		/// Prevents desync issues.
		/// </summary>
		/// <param name="x">The x coordinates of the center of the square.</param>
		/// <param name="y">The y coordinates of the center of the square.</param>
		/// <param name="size">The size square set of tiles to send.</param>
		/// <returns>true if the tile square was sent successfully, else false</returns>
		public virtual bool SendTileSquareCentered(int x, int y, byte size = 10)
		{
			return SendTileRect((short)(x - (size / 2)), (short)(y - (size / 2)), size, size);
		}

		/// <summary>
		/// Sends a rectangle of tiles at a location with the given length and width.
		/// </summary>
		/// <param name="x">The x coordinate the rectangle will begin at</param>
		/// <param name="y">The y coordinate the rectangle will begin at</param>
		/// <param name="width">The width of the rectangle</param>
		/// <param name="length">The length of the rectangle</param>
		/// <param name="changeType">Optional change type. Default None</param>
		/// <returns></returns>
		public virtual bool SendTileRect(short x, short y, byte width = 10, byte length = 10, TileChangeType changeType = TileChangeType.None)
		{
			try
			{
				NetMessage.SendTileSquare(Index, x, y, width, length, changeType);
				return true;
			}
			catch (Exception ex)
			{
				TShock.Log.Error(ex.ToString());
			}
			return false;
		}

		/// <summary>
		/// Changes the values of the <see cref="RemoteClient.TileSections"/> array.
		/// </summary>
		/// <param name="rectangle">The area of the sections you want to set a value to.
		/// The minimum size should be set to 200x150. If null, then the entire map is specified.</param>
		/// <param name="isLoaded">Is the section loaded.</param>
		// The server does not send the player the whole world, it sends it in sections. To do this, it sets up visible and invisible sections.
		// If the player was not in any section(Client.TileSections[x, y] == false) then the server will send the missing section of the world.
		// This method allows you to simulate what the player has or has not seen these sections.
		// For example, we can put some number of earths blocks in some vast area, for example, for the whole world, but the player will not see the changes, because some section is already loaded for him. At this point this method can come into effect! With it we will be able to select some zone and make it both visible and invisible to the player.
		// The server will assume that the zone is not loaded on the player, and will resend the data, but with earth blocks.
		public void UpdateSection(Rectangle? rectangle = null, bool isLoaded = false)
		{
			if (rectangle.HasValue)
			{
				for (int i = Netplay.GetSectionX(rectangle.Value.X); i < Netplay.GetSectionX(rectangle.Value.X + rectangle.Value.Width) && i < Main.maxSectionsX; i++)
				{
					for (int j = Netplay.GetSectionY(rectangle.Value.Y); j < Netplay.GetSectionY(rectangle.Value.Y + rectangle.Value.Height) && j < Main.maxSectionsY; j++)
					{
						Client.TileSections[i, j] = isLoaded;
					}
				}	
			}
			else
			{
				for (int i = 0; i < Main.maxSectionsX; i++)
				{
					for (int j = 0; j < Main.maxSectionsY; j++)
					{
						Client.TileSections[i, j] = isLoaded;
					}
				}
			}
		}

		/// <summary>
		/// Gives an item to the player. Includes banned item spawn prevention to check if the player can spawn the item.
		/// </summary>
		/// <param name="type">The item ID.</param>
		/// <param name="name">The item name.</param>
		/// <param name="stack">The item stack.</param>
		/// <param name="prefix">The item prefix.</param>
		/// <returns>True or false, depending if the item passed the check or not.</returns>
		public bool GiveItemCheck(int type, string name, int stack, int prefix = 0)
		{
			if ((TShock.ItemBans.DataModel.ItemIsBanned(name) && TShock.Config.Settings.PreventBannedItemSpawn) &&
				(TShock.ItemBans.DataModel.ItemIsBanned(name, this) || !TShock.Config.Settings.AllowAllowedGroupsToSpawnBannedItems))
				return false;

			GiveItem(type, stack, prefix);
			return true;
		}

		/// <summary>
		/// Gives an item to the player.
		/// </summary>
		/// <param name="type">The item ID.</param>
		/// <param name="stack">The item stack.</param>
		/// <param name="prefix">The item prefix.</param>
		public virtual void GiveItem(int type, int stack, int prefix = 0)
		{
			if (TShock.Config.Settings.GiveItemsDirectly)
				GiveItemDirectly(type, stack, prefix);
			else
				GiveItemByDrop(type, stack, prefix);
		}

		/// <summary>
		/// Gives an item to the player.
		/// </summary>
		/// <param name="item">Item with data to be given to the player.</param>
		public virtual void GiveItem(NetItem item)
		{
			GiveItem(item.NetId, item.Stack, item.PrefixId);
		}

		private Item EmptySentinelItem = new Item();

		private bool Depleted(Item item)
			=> item.type == 0 || item.stack == 0;

		private void GiveItemDirectly(int type, int stack, int prefix)
		{
			if (ItemID.Sets.IsAPickup[type] || !Main.ServerSideCharacter || this.IsDisabledForSSC)
			{
				GiveItemByDrop(type, stack, prefix);
				return;
			}

			var item = new Item();
			item.netDefaults(type);
			item.stack = stack;
			item.prefix = (byte)prefix;

			if (item.IsACoin)
				for (int slot = -4; slot < 50; slot++)
					if (Depleted(item = GiveItemDirectly_FillIntoOccupiedSlot(item, slot < 0 ? slot + 54 : slot)))
						return;

			if (item.FitsAmmoSlot())
				if (Depleted(item = GiveItem_FillAmmo(item)))
					return;

			for (int slot = 0; slot < 50; slot++)
				if (Depleted(item = GiveItemDirectly_FillIntoOccupiedSlot(item, slot)))
					return;

			if (!item.IsACoin && item.useStyle != 0)
				for (int slot = 0; slot < 10; slot++)
					if (Depleted(item = GiveItemDirectly_FillEmptyInventorySlot(item, slot)))
						return;

			int lastSlot = item.IsACoin ? 54 : 50;
			for (int slot = lastSlot - 1; slot >= 0; slot--)
				if (Depleted(item = GiveItemDirectly_FillEmptyInventorySlot(item, slot)))
					return;

			// oh no, i can't give the rest of the items... guess i gotta spill it on the floor
			GiveItemByDrop(item.type, item.stack, item.prefix);
		}

		private void SendItemSlotPacketFor(int slot)
		{
			int prefix = this.TPlayer.inventory[slot].prefix;
			NetMessage.SendData(5, this.Index, -1, null, this.Index, slot, prefix, 0f, 0, 0, 0);
		}

		private Item GiveItem_FillAmmo(Item item)
		{
			var inv = this.TPlayer.inventory;

			for (int i = 54; i < 58; i++)
				if (Depleted(item = GiveItemDirectly_FillIntoOccupiedSlot(item, i)))
					return EmptySentinelItem;

			if (!item.CanFillEmptyAmmoSlot())
				return item;

			for (int i = 54; i < 58; i++)
				if (GiveItemDirectly_FillEmptyInventorySlot(item, i) == EmptySentinelItem)
					return EmptySentinelItem;

			return item;
		}

		private Item GiveItemDirectly_FillIntoOccupiedSlot(Item item, int slot)
		{
			var inv = this.TPlayer.inventory;
			if (inv[slot].type <= 0 || inv[slot].stack >= inv[slot].maxStack || !item.IsTheSameAs(inv[slot]))
				return item;

			if (item.stack + inv[slot].stack <= inv[slot].maxStack)
			{
				inv[slot].stack += item.stack;
				SendItemSlotPacketFor(slot);
				return EmptySentinelItem;
			}

			var newItem = item.DeepClone();
			newItem.stack -= inv[slot].maxStack - inv[slot].stack;
			inv[slot].stack = inv[slot].maxStack;
			SendItemSlotPacketFor(slot);

			return newItem;
		}

		private Item GiveItemDirectly_FillEmptyInventorySlot(Item item, int slot)
		{
			var inv = this.TPlayer.inventory;
			if (inv[slot].type != 0)
				return item;

			inv[slot] = item;
			SendItemSlotPacketFor(slot);
			return EmptySentinelItem;
		}

		private void GiveItemByDrop(int type, int stack, int prefix)
		{
			int itemIndex = Item.NewItem(new EntitySource_DebugCommand(), (int)X, (int)Y, TPlayer.width, TPlayer.height, type, stack, true, prefix, true);
			Main.item[itemIndex].playerIndexTheItemIsReservedFor = this.Index;
			SendData(PacketTypes.ItemDrop, "", itemIndex, 1);
			SendData(PacketTypes.ItemOwner, null, itemIndex);
		}

		/// <summary>
		/// Sends an information message to the player.
		/// </summary>
		/// <param name="msg">The message.</param>
		public virtual void SendInfoMessage(string msg)
		{
			SendMessage(msg, Color.Yellow);
		}

		/// <summary>
		/// Sends an information message to the player.
		/// Replaces format items in the message with the string representation of a specified object.
		/// </summary>
		/// <param name="format">The message.</param>
		/// <param name="args">An array of objects to format.</param>
		public void SendInfoMessage(string format, params object[] args)
		{
			SendInfoMessage(string.Format(format, args));
		}

		/// <summary>
		/// Sends a success message to the player.
		/// </summary>
		/// <param name="msg">The message.</param>
		public virtual void SendSuccessMessage(string msg)
		{
			SendMessage(msg, Color.LimeGreen);
		}

		/// <summary>
		/// Sends a success message to the player.
		/// Replaces format items in the message with the string representation of a specified object.
		/// </summary>
		/// <param name="format">The message.</param>
		/// <param name="args">An array of objects to format.</param>
		public void SendSuccessMessage(string format, params object[] args)
		{
			SendSuccessMessage(string.Format(format, args));
		}

		/// <summary>
		/// Sends a warning message to the player.
		/// </summary>
		/// <param name="msg">The message.</param>
		public virtual void SendWarningMessage(string msg)
		{
			SendMessage(msg, Color.OrangeRed);
		}

		/// <summary>
		/// Sends a warning message to the player.
		/// Replaces format items in the message with the string representation of a specified object.
		/// </summary>
		/// <param name="format">The message.</param>
		/// <param name="args">An array of objects to format.</param>
		public void SendWarningMessage(string format, params object[] args)
		{
			SendWarningMessage(string.Format(format, args));
		}

		/// <summary>
		/// Sends an error message to the player.
		/// </summary>
		/// <param name="msg">The message.</param>
		public virtual void SendErrorMessage(string msg)
		{
			SendMessage(msg, Color.Red);
		}

		/// <summary>
		/// Sends an error message to the player.
		/// Replaces format items in the message with the string representation of a specified object
		/// </summary>
		/// <param name="format">The message.</param>
		/// <param name="args">An array of objects to format.</param>
		public void SendErrorMessage(string format, params object[] args)
		{
			SendErrorMessage(string.Format(format, args));
		}

		/// <summary>
		/// Sends a message with the specified color.
		/// </summary>
		/// <param name="msg">The message.</param>
		/// <param name="color">The message color.</param>
		public virtual void SendMessage(string msg, Color color)
		{
			SendMessage(msg, color.R, color.G, color.B);
		}

		/// <summary>
		/// Sends a message with the specified RGB color.
		/// </summary>
		/// <param name="msg">The message.</param>
		/// <param name="red">The amount of red color to factor in. Max: 255.</param>
		/// <param name="green">The amount of green color to factor in. Max: 255</param>
		/// <param name="blue">The amount of blue color to factor in. Max: 255</param>
		public virtual void SendMessage(string msg, byte red, byte green, byte blue)
		{
			if (msg.Contains("\n"))
			{
				string[] msgs = msg.Split('\n');
				foreach (string message in msgs)
				{
					SendMessage(message, red, green, blue);
				}
				return;
			}

			if (this.Index == -1) //-1 is our broadcast index - this implies we're using TSPlayer.All.SendMessage and broadcasting to all clients
			{
				Terraria.Chat.ChatHelper.BroadcastChatMessage(NetworkText.FromLiteral(msg), new Color(red, green, blue));
			}
			else
			{
				Terraria.Chat.ChatHelper.SendChatMessageToClient(NetworkText.FromLiteral(msg), new Color(red, green, blue), this.Index);
			}
		}

		/// <summary>
		/// Sends a message to the player with the specified RGB color.
		/// </summary>
		/// <param name="msg">The message.</param>
		/// <param name="red">The amount of red color to factor in. Max: 255.</param>
		/// <param name="green">The amount of green color to factor in. Max: 255.</param>
		/// <param name="blue">The amount of blue color to factor in. Max: 255.</param>
		/// <param name="ply">The player who receives the message.</param>
		public virtual void SendMessageFromPlayer(string msg, byte red, byte green, byte blue, int ply)
		{
			if (msg.Contains("\n"))
			{
				string[] msgs = msg.Split('\n');
				foreach (string message in msgs)
				{
					SendMessageFromPlayer(message, red, green, blue, ply);
				}
				return;
			}
			Terraria.Chat.ChatHelper.BroadcastChatMessageAs((byte)ply, NetworkText.FromLiteral(msg), new Color(red, green, blue));
		}

		/// <summary>
		/// Sends the text of a given file to the player. Replacement of %map% and %players% if in the file.
		/// </summary>
		/// <param name="file">Filename relative to <see cref="TShock.SavePath"></see></param>
		public void SendFileTextAsMessage(string file)
		{
			string foo = "";
			bool containsOldFormat = false;
			using (var tr = new StreamReader(file))
			{
				Color lineColor;
				while ((foo = tr.ReadLine()) != null)
				{
					lineColor = Color.White;
					if (string.IsNullOrWhiteSpace(foo))
					{
						continue;
					}

					var players = new List<string>();

					foreach (TSPlayer ply in TShock.Players)
					{
						if (ply != null && ply.Active)
						{
							players.Add(ply.Name);
						}
					}

					foo = foo.Replace("%map%", (TShock.Config.Settings.UseServerName ? TShock.Config.Settings.ServerName : Main.worldName));
					foo = foo.Replace("%players%", String.Join(", ", players));
					foo = foo.Replace("%specifier%", TShock.Config.Settings.CommandSpecifier);
					foo = foo.Replace("%onlineplayers%", TShock.Utils.GetActivePlayerCount().ToString());
					foo = foo.Replace("%serverslots%", TShock.Config.Settings.MaxSlots.ToString());

					SendMessage(foo, lineColor);
				}
			}
		}

		/// <summary>
		/// Wounds the player with the given damage.
		/// </summary>
		/// <param name="damage">The amount of damage the player will take.</param>
		public virtual void DamagePlayer(int damage)
		{
			DamagePlayer(damage, PlayerDeathReason.LegacyDefault());
		}

		/// <summary>
		/// Wounds the player with the given damage.
		/// </summary>
		/// <param name="damage">The amount of damage the player will take.</param>
		/// <param name="reason">The reason for causing damage to player.</param>
		public virtual void DamagePlayer(int damage, PlayerDeathReason reason)
		{
			NetMessage.SendPlayerHurt(Index, reason, damage, (new Random()).Next(-1, 1), false, false, 0, -1, -1);
		}

		/// <summary>
		/// Kills the player.
		/// </summary>
		public virtual void KillPlayer()
		{
			KillPlayer(PlayerDeathReason.LegacyDefault());
		}

		/// <summary>
		/// Kills the player.
		/// </summary>
		/// <param name="reason">Reason for killing a player.</param>
		public virtual void KillPlayer(PlayerDeathReason reason)
		{
			NetMessage.SendPlayerDeath(Index, reason, 99999, (new Random()).Next(-1, 1), false, -1, -1);
		}

		/// <summary>
		/// Sets the player's team.
		/// </summary>
		/// <param name="team">The team color index.</param>
		public virtual void SetTeam(int team)
		{
			if (team < 0 || team >= Main.teamColor.Length)
				throw new ArgumentException("The player's team is not in the range of available.");
			Main.player[Index].team = team;
			NetMessage.SendData((int)PacketTypes.PlayerTeam, -1, -1, NetworkText.Empty, Index);
		}

		/// <summary>
		/// Sets the player's pvp.
		/// </summary>
		/// <param name="mode">The state of the pvp mode.</param>
		/// <param name="withMsg">Whether a chat message about the change should be sent.</param>
		public virtual void SetPvP(bool mode, bool withMsg = false)
		{
			Main.player[Index].hostile = mode;
			NetMessage.SendData((int)PacketTypes.TogglePvp, -1, -1, NetworkText.Empty, Index);
			if (withMsg)
				TSPlayer.All.SendMessage(Language.GetTextValue(mode ? "LegacyMultiplayer.11" : "LegacyMultiplayer.12", Name), Main.teamColor[Team]);
		}

		private DateTime LastDisableNotification = DateTime.UtcNow;

		/// <summary>
		/// Represents the ID of the chest that the player is viewing.
		/// </summary>
		public int ActiveChest = -1;

		/// <summary>
		/// Represents the current item the player is holding.
		/// </summary>
		public Item ItemInHand = new Item();

		/// <summary>
		/// Disables the player for the given <paramref name="reason"/>
		/// </summary>
		/// <param name="reason">The reason why the player was disabled.</param>
		/// <param name="flags">Flags to dictate where this event is logged to.</param>
		public virtual void Disable(string reason = "", DisableFlags flags = DisableFlags.WriteToLog)
		{
			LastThreat = DateTime.UtcNow;
			SetBuff(BuffID.Webbed, 330, true);

			if (ActiveChest != -1)
			{
				ActiveChest = -1;
				SendData(PacketTypes.ChestOpen, "", -1);
			}

			if (!string.IsNullOrEmpty(reason))
			{
				if ((DateTime.UtcNow - LastDisableNotification).TotalMilliseconds > 5000)
				{
					if (flags.HasFlag(DisableFlags.WriteToConsole))
					{
						if (flags.HasFlag(DisableFlags.WriteToLog))
						{
							TShock.Log.ConsoleInfo(GetString("Player {0} has been disabled for {1}.", Name, reason));
						}
						else
						{
							Server.SendInfoMessage(GetString("Player {0} has been disabled for {1}.", Name, reason));
						}
					}

					LastDisableNotification = DateTime.UtcNow;
				}
			}

			/*
			 * Calling new StackTrace() is incredibly expensive, and must be disabled
			 * in release builds.  Use a conditional call instead.
			 */
			LogStackFrame();
		}

		/// <summary>
		/// Disconnects this player from the server with a reason.
		/// </summary>
		/// <param name="reason">The reason to display to the user and to the server on kick.</param>
		/// <param name="force">If the kick should happen regardless of immunity to kick permissions.</param>
		/// <param name="silent">If no message should be broadcasted to the server.</param>
		/// <param name="adminUserName">The originator of the kick, for display purposes.</param>
		/// <param name="saveSSI">If the player's server side character should be saved on kick.</param>
		public bool Kick(string reason, bool force = false, bool silent = false, string adminUserName = null, bool saveSSI = false)
		{
			if (!ConnectionAlive)
				return true;
			if (force || !HasPermission(Permissions.immunetokick))
			{
				SilentKickInProgress = silent;
				if (IsLoggedIn && saveSSI)
					SaveServerCharacter();
				Disconnect(GetString("Kicked: {0}", reason));
				TShock.Log.ConsoleInfo(GetString("Kicked {0} for : '{1}'", Name, reason));
				if (!silent)
				{
					if (string.IsNullOrWhiteSpace(adminUserName))
						TShock.Utils.Broadcast(GetString("{0} was kicked for '{1}'", Name, reason), Color.Green);
					else
						TShock.Utils.Broadcast(GetString("{0} kicked {1} for '{2}'", adminUserName, Name, reason), Color.Green);
				}
				return true;
			}
			return false;
		}

		/// <summary>
		/// Bans and disconnects the player from the server.
		/// </summary>
		/// <param name="reason">The reason to be displayed to the server.</param>
		/// <param name="adminUserName">The player who initiated the ban.</param>
		public bool Ban(string reason, string adminUserName = null)
		{
			if (!ConnectionAlive)
				return true;

			TShock.Bans.InsertBan($"{Identifier.IP}{IP}", reason, adminUserName, DateTime.UtcNow, DateTime.MaxValue);
			TShock.Bans.InsertBan($"{Identifier.UUID}{UUID}", reason, adminUserName, DateTime.UtcNow, DateTime.MaxValue);
			if (Account != null)
			{
				TShock.Bans.InsertBan($"{Identifier.Account}{Account.Name}", reason, adminUserName, DateTime.UtcNow, DateTime.MaxValue);
			}

			Disconnect(GetString("Banned: {0}", reason));

			if (string.IsNullOrWhiteSpace(adminUserName))
				TSPlayer.All.SendInfoMessage(GetString("{0} was banned for '{1}'.", Name, reason));
			else
				TSPlayer.All.SendInfoMessage(GetString("{0} banned {1} for '{2}'.", adminUserName, Name, reason));
			return true;
		}

		/// <summary>
		/// Sends the player an error message stating that more than one match was found
		/// appending a csv list of the matches.
		/// </summary>
		/// <param name="matches">An enumerable list with the matches</param>
		public void SendMultipleMatchError(IEnumerable<object> matches)
		{
			SendErrorMessage(GetString("More than one match found -- unable to decide which is correct: "));

			var lines = PaginationTools.BuildLinesFromTerms(matches.ToArray());
			lines.ForEach(SendInfoMessage);

			SendErrorMessage(GetString("Use \"my query\" for items with spaces."));
			SendErrorMessage(GetString("Use tsi:[number] or tsn:[username] to distinguish between user IDs and usernames."));
		}

		[Conditional("DEBUG")]
		private void LogStackFrame()
		{
			var trace = new StackTrace();
			StackFrame frame = null;
			frame = trace.GetFrame(1);
			if (frame != null && frame.GetMethod().DeclaringType != null)
				TShock.Log.Debug(frame.GetMethod().DeclaringType.Name + " called Disable().");
		}

		/// <summary>
		/// Annoys the player for a specified amount of time.
		/// </summary>
		/// <param name="time">The</param>
		public virtual void Whoopie(object time)
		{
			var time2 = (int)time;
			var launch = DateTime.UtcNow;
			var startname = Name;
			while ((DateTime.UtcNow - launch).TotalSeconds < time2 && startname == Name)
			{
				SendData(PacketTypes.NpcSpecial, number: Index, number2: 2f);
				Thread.Sleep(50);
			}
		}

		/// <summary>
		/// Applies a buff to the player.
		/// </summary>
		/// <param name="type">The buff type.</param>
		/// <param name="time">The buff duration.</param>
		/// <param name="bypass"></param>
		public virtual void SetBuff(int type, int time = 3600, bool bypass = false)
		{
			if ((DateTime.UtcNow - LastThreat).TotalMilliseconds < 5000 && !bypass)
				return;

			SendData(PacketTypes.PlayerAddBuff, number: Index, number2: type, number3: time);
		}

		/// <summary>
		/// The list of necessary packets to make sure gets through to the player upon connection (before they finish the handshake).
		/// </summary>
		private static readonly HashSet<PacketTypes> HandshakeNecessaryPackets = new()
		{
			PacketTypes.ContinueConnecting,
			PacketTypes.WorldInfo,
			PacketTypes.Status,
			PacketTypes.Disconnect,
			PacketTypes.TileFrameSection,
			PacketTypes.TileSendSection,
			PacketTypes.PlayerSpawnSelf
		};

		/// <summary>
		/// Determines if an outgoing packet is necessary to send to a player before they have finished the connection handshake.
		/// </summary>
		/// <param name="msgType">The packet type to check against the necessary list.</param>
		/// <returns>Whether the packet is necessary for connection or not</returns>
		private bool NecessaryPacket(PacketTypes msgType) => HandshakeNecessaryPackets.Contains(msgType);

		//Todo: Separate this into a few functions. SendTo, SendToAll, etc
		/// <summary>
		/// Sends data to the player.
		/// </summary>
		/// <param name="msgType">The sent packet</param>
		/// <param name="text">The packet text.</param>
		/// <param name="number"></param>
		/// <param name="number2"></param>
		/// <param name="number3"></param>
		/// <param name="number4"></param>
		/// <param name="number5"></param>
		public virtual void SendData(PacketTypes msgType, string text = "", int number = 0, float number2 = 0f,
			float number3 = 0f, float number4 = 0f, int number5 = 0)
		{
			if (RealPlayer && !ConnectionAlive)
				return;

			if (!NecessaryPacket(msgType) && !FinishedHandshake)
				return;

			if (FakePlayer != null && FakePlayer.whoAmI != -1 && msgType == PacketTypes.WorldInfo && State < (int)ConnectionState.RequestingWorldData) //So.. the All player doesn't have a state, so we cannot check this, skip over them if their index is -1 (server/all)
				return;

			NetMessage.SendData((int)msgType, Index, -1, text == null ? null : NetworkText.FromLiteral(text), number, number2, number3, number4, number5);
		}

		/// <summary>
		/// Sends data from the given player.
		/// </summary>
		/// <param name="msgType">The sent packet.</param>
		/// <param name="ply">The packet sender.</param>
		/// <param name="text">The packet text.</param>
		/// <param name="number2"></param>
		/// <param name="number3"></param>
		/// <param name="number4"></param>
		/// <param name="number5"></param>
		public virtual void SendDataFromPlayer(PacketTypes msgType, int ply, string text = "", float number2 = 0f,
			float number3 = 0f, float number4 = 0f, int number5 = 0)
		{
			if (RealPlayer && !ConnectionAlive)
				return;

			NetMessage.SendData((int)msgType, Index, -1, NetworkText.FromFormattable(text), ply, number2, number3, number4, number5);
		}

		/// <summary>
		/// Sends raw data to the player's socket object.
		/// </summary>
		/// <param name="data">The data to send.</param>
		public virtual void SendRawData(byte[] data)
		{
			if (!RealPlayer || !ConnectionAlive)
				return;

			Client.Socket.AsyncSend(data, 0, data.Length, Client.ServerWriteCallBack);
		}

		/// <summary>
		/// Adds a command callback to a specified command string.
		/// </summary>
		/// <param name="name">The string representing the command i.e "yes" == /yes</param>
		/// <param name="callback">The method that will be executed on confirmation ie user accepts</param>
		public void AddResponse(string name, Action<object> callback)
		{
			if (AwaitingResponse.ContainsKey(name))
			{
				AwaitingResponse.Remove(name);
			}

			AwaitingResponse.Add(name, callback);
		}

		/// <summary>
		/// Checks to see if a player has a specific permission.
		/// Fires the <see cref="PlayerHooks.OnPlayerPermission"/> hook which may be handled to override permission checks.
		/// If the OnPlayerPermission hook is not handled and the player is assigned a temporary group, this method calls <see cref="Group.HasPermission"/> on the temporary group and returns the result.
		/// If the OnPlayerPermission hook is not handled and the player is not assigned a temporary group, this method calls <see cref="Group.HasPermission"/> on the player's current group.
		/// </summary>
		/// <param name="permission">The permission to check.</param>
		/// <returns>True if the player has that permission.</returns>
		public bool HasPermission(string permission)
		{
			PermissionHookResult hookResult = PlayerHooks.OnPlayerPermission(this, permission);

			if (hookResult != PermissionHookResult.Unhandled)
				return hookResult == PermissionHookResult.Granted;

			if (tempGroup != null)
				return tempGroup.HasPermission(permission);
			else
				return Group.HasPermission(permission);
		}

		/// <summary>
		/// Checks to see if a player has permission to use the specific banned item.
		/// Fires the <see cref="PlayerHooks.OnPlayerItembanPermission"/> hook which may be handled to override item ban permission checks.
		/// </summary>
		/// <param name="bannedItem">The <see cref="ItemBan" /> to check.</param>
		/// <returns>True if the player has permission to use the banned item.</returns>
		public bool HasPermission(ItemBan bannedItem)
		{
			return TShock.ItemBans.DataModel.ItemIsBanned(bannedItem.Name, this);
		}

		/// <summary>
		/// Checks to see if a player has permission to use the specific banned projectile.
		/// Fires the <see cref="PlayerHooks.OnPlayerProjbanPermission"/> hook which may be handled to override projectile ban permission checks.
		/// </summary>
		/// <param name="bannedProj">The <see cref="ProjectileBan" /> to check.</param>
		/// <returns>True if the player has permission to use the banned projectile.</returns>
		public bool HasPermission(ProjectileBan bannedProj)
		{
			return TShock.ProjectileBans.ProjectileIsBanned(bannedProj.ID, this);
		}
		/// <summary>
		/// Checks to see if a player has permission to use the specific banned tile.
		/// Fires the <see cref="PlayerHooks.OnPlayerTilebanPermission"/> hook which may be handled to override tile ban permission checks.
		/// </summary>
		/// <param name="bannedTile">The <see cref="TileBan" /> to check.</param>
		/// <returns>True if the player has permission to use the banned tile.</returns>
		public bool HasPermission(TileBan bannedTile)
		{
			return TShock.TileBans.TileIsBanned(bannedTile.ID, this);
		}
	}

	public class TSRestPlayer : TSPlayer
	{
		internal List<string> CommandOutput = new List<string>();

		public TSRestPlayer(string playerName, Group playerGroup) : base(playerName)
		{
			Group = playerGroup;
			AwaitingResponse = new Dictionary<string, Action<object>>();
		}

		public override void SendMessage(string msg, Color color)
		{
			SendMessage(msg, color.R, color.G, color.B);
		}

		public override void SendMessage(string msg, byte red, byte green, byte blue)
		{
			this.CommandOutput.Add(msg);
		}

		public override void SendInfoMessage(string msg)
		{
			SendMessage(msg, Color.Yellow);
		}

		public override void SendSuccessMessage(string msg)
		{
			SendMessage(msg, Color.Green);
		}

		public override void SendWarningMessage(string msg)
		{
			SendMessage(msg, Color.OrangeRed);
		}

		public override void SendErrorMessage(string msg)
		{
			SendMessage(msg, Color.Red);
		}

		public List<string> GetCommandOutput()
		{
			return this.CommandOutput;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/TSServerPlayer.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.Utilities;
using TShockAPI;
using TShockAPI.DB;
using Terraria.Localization;
using System.Linq;
using Terraria.DataStructures;

namespace TShockAPI
{
	public class TSServerPlayer : TSPlayer
	{
		public static string AccountName = GetParticularString("The account name of server console.", "ServerConsole");

		public TSServerPlayer()
			: base("Server")
		{
			Group = new SuperAdminGroup();
			Account = new UserAccount { Name = AccountName };
		}

		public override void SendErrorMessage(string msg)
		{
			SendConsoleMessage(msg, 255, 0, 0);
		}

		public override void SendInfoMessage(string msg)
		{
			SendConsoleMessage(msg, 255, 250, 170);
		}

		public override void SendSuccessMessage(string msg)
		{
			SendConsoleMessage(msg, 0, 255, 0);
		}

		public override void SendWarningMessage(string msg)
		{
			SendConsoleMessage(msg, 139, 0, 0);
		}

		public override void SendMessage(string msg, Color color)
		{
			SendMessage(msg, color.R, color.G, color.B);
		}

		public override void SendMessage(string msg, byte red, byte green, byte blue)
		{
			SendConsoleMessage(msg, red, green, blue);
		}

		public void SendConsoleMessage(string msg, byte red, byte green, byte blue)
		{
			var snippets = Terraria.UI.Chat.ChatManager.ParseMessage(msg, new Color(red, green, blue));

			foreach (var snippet in snippets)
			{
				if (snippet.Color != null)
				{
					Console.ForegroundColor = PickNearbyConsoleColor(snippet.Color);
				}
				else
				{
					Console.ForegroundColor = ConsoleColor.Gray;
				}

				Console.Write(snippet.Text);
			}
			Console.WriteLine();
			Console.ResetColor();
		}

		public void SetFullMoon()
		{
			Main.dayTime = false;
			Main.moonPhase = 0;
			Main.time = 0.0;
			TSPlayer.All.SendData(PacketTypes.WorldInfo);
		}

		public void SetBloodMoon(bool bloodMoon)
		{
			if (bloodMoon)
			{
				Main.dayTime = false;
				Main.bloodMoon = true;
				Main.time = 0.0;
			}
			else
				Main.bloodMoon = false;
			TSPlayer.All.SendData(PacketTypes.WorldInfo);
		}

		public void SetFrostMoon(bool snowMoon)
		{
			if (snowMoon)
			{
				Main.dayTime = false;
				Main.snowMoon = true;
				Main.time = 0.0;
			}
			else
				Main.snowMoon = false;
			TSPlayer.All.SendData(PacketTypes.WorldInfo);
		}

		public void SetPumpkinMoon(bool pumpkinMoon)
		{
			if (pumpkinMoon)
			{
				Main.dayTime = false;
				Main.pumpkinMoon = true;
				Main.time = 0.0;
			}
			else
				Main.pumpkinMoon = false;
			TSPlayer.All.SendData(PacketTypes.WorldInfo);
		}

		public void SetEclipse(bool eclipse)
		{
			if (eclipse)
			{
				Main.dayTime = Main.eclipse = true;
				Main.time = 0.0;
			}
			else
				Main.eclipse = false;
			TSPlayer.All.SendData(PacketTypes.WorldInfo);
		}

		public void SetTime(bool dayTime, double time)
		{
			Main.dayTime = dayTime;
			Main.time = time;
			TSPlayer.All.SendData(PacketTypes.TimeSet, "", dayTime ? 1 : 0, (int)time, Main.sunModY, Main.moonModY);
		}

		public void SpawnNPC(int type, string name, int amount, int startTileX, int startTileY, int tileXRange = 100,
			int tileYRange = 50)
		{
			for (int i = 0; i < amount; i++)
			{
				int spawnTileX;
				int spawnTileY;
				TShock.Utils.GetRandomClearTileWithInRange(startTileX, startTileY, tileXRange, tileYRange, out spawnTileX,
															 out spawnTileY);
				NPC.NewNPC(new EntitySource_DebugCommand(), spawnTileX * 16, spawnTileY * 16, type);
			}
		}

		public void StrikeNPC(int npcid, int damage, float knockBack, int hitDirection)
		{
			// Main.rand is thread static.
			if (Main.rand == null)
				Main.rand = new UnifiedRandom();

			Main.npc[npcid].StrikeNPC(damage, knockBack, hitDirection);
			NetMessage.SendData((int)PacketTypes.NpcStrike, -1, -1, NetworkText.Empty, npcid, damage, knockBack, hitDirection);
		}

		public void RevertTiles(Dictionary<Vector2, ITile> tiles)
		{
			// Update Main.Tile first so that when tile square is sent it is correct
			foreach (KeyValuePair<Vector2, ITile> entry in tiles)
			{
				Main.tile[(int)entry.Key.X, (int)entry.Key.Y] = entry.Value;
			}
			// Send all players updated tile squares
			foreach (Vector2 coords in tiles.Keys)
			{
				All.SendTileSquareCentered((int)coords.X, (int)coords.Y, 3);
			}
		}


		private readonly Dictionary<Color, ConsoleColor> _consoleColorMap = new Dictionary<Color, ConsoleColor>
		{
			{ Color.Red,                    ConsoleColor.Red },
			{ Color.Green,                  ConsoleColor.Green },
			{ Color.Blue,                   ConsoleColor.Cyan },
			{ new Color(255, 250, 170),     ConsoleColor.Yellow },
			{ new Color(170, 170, 255),     ConsoleColor.Cyan },
			{ new Color(255, 170, 255),     ConsoleColor.Magenta },
			{ new Color(170, 255, 170),     ConsoleColor.Green },
			{ new Color(255, 170, 170),     ConsoleColor.Red },
			{ new Color(139, 0, 0),         ConsoleColor.DarkRed }, // This is the console warning color
			{ Color.PaleVioletRed,          ConsoleColor.Magenta }, // This is the command logging color
			{ Color.White,                  ConsoleColor.White }
		};

		private ConsoleColor PickNearbyConsoleColor(Color color)
		{
			//Grabs an integer difference between two colors in euclidean space
			int ColorDiff(Color c1, Color c2)
			{
				return (int)Math.Sqrt((c1.R - c2.R) * (c1.R - c2.R)
									   + (c1.G - c2.G) * (c1.G - c2.G)
									   + (c1.B - c2.B) * (c1.B - c2.B));
			}

			var diffs = _consoleColorMap.Select(kvp => ColorDiff(kvp.Key, color));
			int index = 0;
			int min = int.MaxValue;

			for (int i = 0; i < _consoleColorMap.Count; i++)
			{
				if (diffs.ElementAt(i) < min)
				{
					index = i;
					min = diffs.ElementAt(i);
				}
			}

			return _consoleColorMap.Values.ElementAt(index);
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/TShock.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using MaxMind;
using MySql.Data.MySqlClient;
using Newtonsoft.Json;
using Rests;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using TerrariaApi.Server;
using TShockAPI.DB;
using TShockAPI.Hooks;
using Terraria.Utilities;
using Microsoft.Xna.Framework;
using TShockAPI.Sockets;
using TShockAPI.CLI;
using TShockAPI.Localization;
using TShockAPI.Configuration;
using Terraria.GameContent.Creative;
using System.Runtime.InteropServices;
using MonoMod.Cil;
using Terraria.Achievements;
using Terraria.Initializers;
using Terraria.UI.Chat;
using TShockAPI.Modules;

namespace TShockAPI
{
	/// <summary>
	/// This is the TShock main class. TShock is a plugin on the TerrariaServerAPI, so it extends the base TerrariaPlugin.
	/// TShock also complies with the API versioning system, and defines its required API version here.
	/// </summary>
	[ApiVersion(2, 1)]
	public class TShock : TerrariaPlugin
	{
		/// <summary>VersionNum - The version number the TerrariaAPI will return back to the API. We just use the Assembly info.</summary>
		public static readonly Version VersionNum = Assembly.GetExecutingAssembly().GetName().Version;
		/// <summary>VersionCodename - The version codename is displayed when the server starts. Inspired by software codenames conventions.</summary>
		public static readonly string VersionCodename = "Hopefully SSC works somewhat correctly now edition";

		/// <summary>SavePath - This is the path TShock saves its data in. This path is relative to the TerrariaServer.exe (not in ServerPlugins).</summary>
		public static string SavePath = "tshock";
		/// <summary>LogFormatDefault - This is the default log file naming format. Actually, this is the only log format, because it never gets set again.</summary>
		private const string LogFormatDefault = "yyyy-MM-dd_HH-mm-ss";
		//TODO: Set the log path in the config file.
		/// <summary>LogFormat - This is the log format, which is never set again.</summary>
		private static string LogFormat = LogFormatDefault;
		/// <summary>LogPathDefault - The default log path.</summary>
		private const string LogPathDefault = "tshock/logs";
		/// <summary>This is the log path, which is initially set to the default log path, and then to the config file log path later.</summary>
		private static string LogPath = LogPathDefault;
		/// <summary>LogClear - Determines whether or not the log file should be cleared on initialization.</summary>
		private static bool LogClear;

		/// <summary>Will be set to true once Utils.StopServer() is called.</summary>
		public static bool ShuttingDown;

		/// <summary>Players - Contains all TSPlayer objects for accessing TSPlayers currently on the server</summary>
		public static TSPlayer[] Players = new TSPlayer[Main.maxPlayers];
		/// <summary>Bans - Static reference to the ban manager for accessing bans &amp; related functions.</summary>
		public static BanManager Bans;
		/// <summary>Warps - Static reference to the warp manager for accessing the warp system.</summary>
		public static WarpManager Warps;
		/// <summary>Regions - Static reference to the region manager for accessing the region system.</summary>
		public static RegionManager Regions;
		/// <summary>Backups - Static reference to the backup manager for accessing the backup system.</summary>
		public static BackupManager Backups;
		/// <summary>Groups - Static reference to the group manager for accessing the group system.</summary>
		public static GroupManager Groups;
		/// <summary>Users - Static reference to the user manager for accessing the user database system.</summary>
		public static UserAccountManager UserAccounts;
		/// <summary>ProjectileBans - Static reference to the projectile ban system.</summary>
		public static ProjectileManagager ProjectileBans;
		/// <summary>TileBans - Static reference to the tile ban system.</summary>
		public static TileManager TileBans;
		/// <summary>RememberedPos - Static reference to the remembered position manager.</summary>
		public static RememberedPosManager RememberedPos;
		/// <summary>CharacterDB - Static reference to the SSC character manager.</summary>
		public static CharacterManager CharacterDB;
		/// <summary>Contains the information about what research has been performed in Journey mode.</summary>
		public static ResearchDatastore ResearchDatastore;
		/// <summary>Config - Static reference to the config system, for accessing values set in users' config files.</summary>
		public static TShockConfig Config { get; set; }
		/// <summary>ServerSideCharacterConfig - Static reference to the server side character config, for accessing values set by users to modify SSC.</summary>
		public static ServerSideConfig ServerSideCharacterConfig;
		/// <summary>DB - Static reference to the database.</summary>
		public static IDbConnection DB;
		/// <summary>OverridePort - Determines if TShock should override the server port.</summary>
		public static bool OverridePort;
		/// <summary>Geo - Static reference to the GeoIP system which determines the location of an IP address.</summary>
		public static GeoIPCountry Geo;
		/// <summary>RestApi - Static reference to the Rest API authentication manager.</summary>
		public static SecureRest RestApi;
		/// <summary>RestManager - Static reference to the Rest API manager.</summary>
		public static RestManager RestManager;
		/// <summary>Utils - Static reference to the utilities class, which contains a variety of utility functions.</summary>
		public static Utils Utils = Utils.Instance;
		/// <summary>UpdateManager - Static reference to the update checker, which checks for updates and notifies server admins of updates.</summary>
		public static UpdateManager UpdateManager;
		/// <summary>Log - Static reference to the log system, which outputs to either SQL or a text file, depending on user config.</summary>
		public static ILog Log;
		/// <summary>instance - Static reference to the TerrariaPlugin instance.</summary>
		public static TerrariaPlugin instance;
		/// <summary>
		/// Static reference to a <see cref="CommandLineParser"/> used for simple command-line parsing
		/// </summary>
		public static CommandLineParser CliParser { get; } = new CommandLineParser();
		/// <summary>
		/// Used for implementing REST Tokens prior to the REST system starting up.
		/// </summary>
		public static Dictionary<string, SecureRest.TokenData> RESTStartupTokens = new Dictionary<string, SecureRest.TokenData>();

		/// <summary>The TShock anti-cheat/anti-exploit system.</summary>
		internal Bouncer Bouncer;

		/// <summary>The TShock item ban system.</summary>
		public static ItemBans ItemBans;

		/// <summary>
		/// TShock's Region subsystem.
		/// </summary>
		internal RegionHandler RegionSystem;

		/// <summary>
		/// Called after TShock is initialized. Useful for plugins that needs hooks before tshock but also depend on tshock being loaded.
		/// </summary>
		public static event Action Initialized;

		public static ModuleManager ModuleManager { get; } = new ModuleManager();

		/// <summary>Version - The version required by the TerrariaAPI to be passed back for checking &amp; loading the plugin.</summary>
		/// <value>value - The version number specified in the Assembly, based on the VersionNum variable set in this class.</value>
		public override Version Version
		{
			get { return VersionNum; }
		}

		/// <summary>Name - The plugin name.</summary>
		/// <value>value - "TShock"</value>
		public override string Name
		{
			get { return "TShock"; }
		}

		/// <summary>Author - The author of the plugin.</summary>
		/// <value>value - "The TShock Team"</value>
		public override string Author
		{
			get { return "The TShock Team"; }
		}

		/// <summary>Description - The plugin description.</summary>
		/// <value>value - "The administration modification of the future."</value>
		public override string Description
		{
			get { return "The administration modification of the future."; }
		}

		/// <summary>TShock - The constructor for the TShock plugin.</summary>
		/// <param name="game">game - The Terraria main game.</param>
		public TShock(Main game)
			: base(game)
		{
			Config = new TShockConfig();
			ServerSideCharacterConfig = new ServerSideConfig();
			ServerSideCharacterConfig.Settings.StartingInventory.Add(new NetItem(-15, 1, 0));
			ServerSideCharacterConfig.Settings.StartingInventory.Add(new NetItem(-13, 1, 0));
			ServerSideCharacterConfig.Settings.StartingInventory.Add(new NetItem(-16, 1, 0));
			Order = 0;
			instance = this;
		}


		static Dictionary<string, IntPtr> _nativeCache = new Dictionary<string, IntPtr>();
		static IntPtr ResolveNativeDep(string libraryName, Assembly assembly, DllImportSearchPath? searchPath)
		{
			if (_nativeCache.TryGetValue(libraryName, out IntPtr cached))
				return cached;

			IEnumerable<string> matches = Enumerable.Empty<string>();

			if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
			{
				var osx = Path.Combine(Environment.CurrentDirectory, "runtimes", "osx-x64");
				if (Directory.Exists(osx))
					matches = Directory.GetFiles(osx, "*" + libraryName + "*", SearchOption.AllDirectories);
			}
			else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
			{
				var lib64 = Path.Combine(Environment.CurrentDirectory, "runtimes", "linux-x64");
				if (Directory.Exists(lib64))
					matches = Directory.GetFiles(lib64, "*" + libraryName + "*", SearchOption.AllDirectories);
			}
			else if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
			{
				var x64 = Path.Combine(Environment.CurrentDirectory, "runtimes", "win-x64");
				if (Directory.Exists(x64))
					matches = Directory.GetFiles(x64, "*" + libraryName + "*", SearchOption.AllDirectories);
			}

			if (matches.Count() == 0)
			{
				matches = Directory.GetFiles(Environment.CurrentDirectory, "*" + libraryName + "*");
			}

			Debug.WriteLine($"Looking for `{libraryName}` with {matches.Count()} match(es)");

			var handle = IntPtr.Zero;

			if (matches.Count() == 1)
			{
				var match = matches.Single();
				handle = NativeLibrary.Load(match);
			}

			// cache either way. if zero, no point calling IO if we've checked this assembly before.
			_nativeCache.Add(libraryName, handle);

			return handle;
		}

		/// <summary>Initialize - Called by the TerrariaServerAPI during initialization.</summary>
		[SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]
		public override void Initialize()
		{
			string logFilename;

			OTAPI.Hooks.Netplay.CreateTcpListener += (sender, args) =>
			{
				args.Result = new LinuxTcpSocket();
			};
			OTAPI.Hooks.NetMessage.PlayerAnnounce += (sender, args) =>
			{
				//TShock handles this
				args.Result = OTAPI.Hooks.NetMessage.PlayerAnnounceResult.None;
			};

			Main.SettingsUnlock_WorldEvil = true;

			TerrariaApi.Reporting.CrashReporter.HeapshotRequesting += CrashReporter_HeapshotRequesting;

			Console.CancelKeyPress += new ConsoleCancelEventHandler(ConsoleCancelHandler);

			try
			{
				CliParser.Reset();
				HandleCommandLine(Environment.GetCommandLineArgs());

				if (!Directory.Exists(SavePath))
					Directory.CreateDirectory(SavePath);

				TShockConfig.OnConfigRead += OnConfigRead;
				FileTools.SetupConfig();

				Main.ServerSideCharacter = ServerSideCharacterConfig.Settings.Enabled;

				//TSAPI previously would do this automatically, but the vanilla server wont
				if (Netplay.ServerIP == null)
					Netplay.ServerIP = IPAddress.Any;

				DateTime now = DateTime.Now;
				// Log path was not already set by the command line parameter?
				if (LogPath == LogPathDefault)
					LogPath = Config.Settings.LogPath;
				try
				{
					logFilename = Path.Combine(LogPath, now.ToString(LogFormat) + ".log");
					if (!Directory.Exists(LogPath))
						Directory.CreateDirectory(LogPath);
				}
				catch (Exception ex)
				{
					ServerApi.LogWriter.PluginWriteLine(this, GetString("Could not apply the given log path / log format, defaults will be used. Exception details:\n{0}", ex), TraceLevel.Error);

					// Problem with the log path or format use the default
					logFilename = Path.Combine(LogPathDefault, now.ToString(LogFormatDefault) + ".log");
				}

				AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
			}
			catch (Exception ex)
			{
				// Will be handled by the server api and written to its crashlog.txt.
				throw new Exception("Fatal TShock initialization exception. See inner exception for details.", ex);
			}

			// Further exceptions are written to TShock's log from now on.
			try
			{
				if (Config.Settings.StorageType.ToLower() == "sqlite")
				{
					string sql = Path.Combine(SavePath, Config.Settings.SqliteDBPath);
					Directory.CreateDirectory(Path.GetDirectoryName(sql));
					DB = new Microsoft.Data.Sqlite.SqliteConnection(string.Format("Data Source={0}", sql));
				}
				else if (Config.Settings.StorageType.ToLower() == "mysql")
				{
					try
					{
						var hostport = Config.Settings.MySqlHost.Split(':');
						DB = new MySqlConnection();
						DB.ConnectionString =
							String.Format("Server={0}; Port={1}; Database={2}; Uid={3}; Pwd={4};",
								hostport[0],
								hostport.Length > 1 ? hostport[1] : "3306",
								Config.Settings.MySqlDbName,
								Config.Settings.MySqlUsername,
								Config.Settings.MySqlPassword
								);
					}
					catch (MySqlException ex)
					{
						ServerApi.LogWriter.PluginWriteLine(this, ex.ToString(), TraceLevel.Error);
						throw new Exception("MySql not setup correctly");
					}
				}
				else
				{
					throw new Exception("Invalid storage type");
				}

				if (Config.Settings.UseSqlLogs)
					Log = new SqlLog(DB, logFilename, LogClear);
				else
					Log = new TextLog(logFilename, LogClear);

				if (File.Exists(Path.Combine(SavePath, "tshock.pid")))
				{
					Log.ConsoleInfo(GetString(
						"TShock was improperly shut down. Please use the exit command in the future to prevent this."));
					File.Delete(Path.Combine(SavePath, "tshock.pid"));
				}
				File.WriteAllText(Path.Combine(SavePath, "tshock.pid"),
					Process.GetCurrentProcess().Id.ToString(CultureInfo.InvariantCulture));

				CliParser.Reset();
				HandleCommandLinePostConfigLoad(Environment.GetCommandLineArgs());

				Backups = new BackupManager(Path.Combine(SavePath, "backups"));
				Backups.KeepFor = Config.Settings.BackupKeepFor;
				Backups.Interval = Config.Settings.BackupInterval;
				Bans = new BanManager(DB);
				Warps = new WarpManager(DB);
				Regions = new RegionManager(DB);
				UserAccounts = new UserAccountManager(DB);
				Groups = new GroupManager(DB);
				ProjectileBans = new ProjectileManagager(DB);
				TileBans = new TileManager(DB);
				RememberedPos = new RememberedPosManager(DB);
				CharacterDB = new CharacterManager(DB);
				ResearchDatastore = new ResearchDatastore(DB);
				RestApi = new SecureRest(Netplay.ServerIP, Config.Settings.RestApiPort);
				RestManager = new RestManager(RestApi);
				RestManager.RegisterRestfulCommands();
				Bouncer = new Bouncer();
				RegionSystem = new RegionHandler(Regions);
				ItemBans = new ItemBans(this, DB);

				var geoippath = "GeoIP.dat";
				if (Config.Settings.EnableGeoIP && File.Exists(geoippath))
					Geo = new GeoIPCountry(geoippath);

				// check if a custom tile provider is to be used
				switch(Config.Settings.WorldTileProvider?.ToLower())
				{
					case "heaptile":
						Log.ConsoleInfo(GetString($"Using {nameof(HeapTile)} for tile implementation"), TraceLevel.Info);
						Main.tile = new TileProvider();
						break;
					case "constileation":
						Log.ConsoleInfo(GetString($"Using {nameof(ConstileationProvider)} for tile implementation"), TraceLevel.Info);
						Main.tile = new ConstileationProvider();
						break;
				}

				Log.ConsoleInfo(GetString("TShock {0} ({1}) now running.", Version, VersionCodename));

				ServerApi.Hooks.GamePostInitialize.Register(this, OnPostInit);
				ServerApi.Hooks.GameUpdate.Register(this, OnUpdate);
				ServerApi.Hooks.GameHardmodeTileUpdate.Register(this, OnHardUpdate);
				ServerApi.Hooks.GameStatueSpawn.Register(this, OnStatueSpawn);
				ServerApi.Hooks.ServerConnect.Register(this, OnConnect);
				ServerApi.Hooks.ServerJoin.Register(this, OnJoin);
				ServerApi.Hooks.ServerLeave.Register(this, OnLeave);
				ServerApi.Hooks.ServerChat.Register(this, OnChat);
				ServerApi.Hooks.ServerCommand.Register(this, ServerHooks_OnCommand);
				ServerApi.Hooks.NetGetData.Register(this, OnGetData);
				ServerApi.Hooks.NetSendData.Register(this, NetHooks_SendData);
				ServerApi.Hooks.NetGreetPlayer.Register(this, OnGreetPlayer);
				ServerApi.Hooks.NpcStrike.Register(this, NpcHooks_OnStrikeNpc);
				ServerApi.Hooks.ProjectileSetDefaults.Register(this, OnProjectileSetDefaults);
				ServerApi.Hooks.WorldStartHardMode.Register(this, OnStartHardMode);
				ServerApi.Hooks.WorldSave.Register(this, SaveManager.Instance.OnSaveWorld);
				ServerApi.Hooks.WorldChristmasCheck.Register(this, OnXmasCheck);
				ServerApi.Hooks.WorldHalloweenCheck.Register(this, OnHalloweenCheck);
				ServerApi.Hooks.NetNameCollision.Register(this, NetHooks_NameCollision);
				ServerApi.Hooks.ItemForceIntoChest.Register(this, OnItemForceIntoChest);
				ServerApi.Hooks.WorldGrassSpread.Register(this, OnWorldGrassSpread);
				Hooks.PlayerHooks.PlayerPreLogin += OnPlayerPreLogin;
				Hooks.PlayerHooks.PlayerPostLogin += OnPlayerLogin;
				Hooks.AccountHooks.AccountDelete += OnAccountDelete;
				Hooks.AccountHooks.AccountCreate += OnAccountCreate;

				On.Terraria.RemoteClient.Reset += RemoteClient_Reset;

				GetDataHandlers.InitGetDataHandler();
				Commands.InitCommands();

				EnglishLanguage.Initialize();

				// The AchievementTagHandler expects Main.Achievements to be non-null, which is not normally the case on dedicated servers.
				// When trying to parse an achievement chat tag, it will instead throw.
				// The tag is parsed when calling ChatManager.ParseMessage, which is used in TShock when writing chat messages to the
				// console. Our OnChat handler uses Utils.Broadcast, which will send the message to all connected clients, write the message
				// to the console and the log. Due to the order of execution, the message ends up being sent to all connected clients, but
				// throws whilst trying to write to the console, and never gets written to the log.
				// To solve the issue, we make achievements available on the server, allowing the tag handler to work as expected, and
				// even allowing the localization of achievement names to appear in the console.

				if (Game != null)
				{
					// Initialize the AchievementManager, which is normally only done on clients.
					Game._achievements = new AchievementManager();

					IL.Terraria.Initializers.AchievementInitializer.Load += OnAchievementInitializerLoad;

					// Actually call AchievementInitializer.Load, which is also normally only done on clients.
					AchievementInitializer.Load();
				}
				else
				{
					// If we don't have a Game instance, then we'll just remove the achievement tag handler entirely. This will cause the
					// raw tag to just be used instead (and not be localized), but still avoid all the issues outlined above.
					ChatManager._handlers.Remove("a", out _);
					ChatManager._handlers.Remove("achievement", out _);
				}

				ModuleManager.Initialise(new object[] { this });

				if (Config.Settings.RestApiEnabled)
					RestApi.Start();

				if (Config.Settings.AutoSave)
					Log.ConsoleInfo(GetString("AutoSave Enabled"));
				else
					Log.ConsoleInfo(GetString("AutoSave Disabled"));
				if (Backups.Interval > 0)
					Log.ConsoleInfo(GetString("Backups Enabled"));
				else
					Log.ConsoleInfo(GetString("Backups Disabled"));

				Initialized?.Invoke();

				Log.ConsoleInfo(GetString("Welcome to TShock for Terraria!"));
				Log.ConsoleInfo(GetString("TShock comes with no warranty & is free software."));
				Log.ConsoleInfo(GetString("You can modify & distribute it under the terms of the GNU GPLv3."));

			}
			catch (Exception ex)
			{
				// handle if Log was not initialised
				void SafeError(string message)
				{
					if (Log is not null) Log.ConsoleError(message);
					else Console.WriteLine(message);
				};
				SafeError(GetString("TShock encountered a problem from which it cannot recover. The following message may help diagnose the problem."));
				SafeError(GetString("Until the problem is resolved, TShock will not be able to start (and will crash on startup)."));
				SafeError(ex.ToString());
				Environment.Exit(1);
			}
		}

		private static void RemoteClient_Reset(On.Terraria.RemoteClient.orig_Reset orig, RemoteClient client)
		{
			client.ClientUUID = null;
			orig(client);
		}

		private static void OnAchievementInitializerLoad(ILContext il)
		{
			// Modify AchievementInitializer.Load to remove the Main.netMode == 2 check (occupies the first 4 IL instructions)
			for (var i = 0; i < 4; i++)
				il.Body.Instructions.RemoveAt(0);
		}

		protected void CrashReporter_HeapshotRequesting(object sender, EventArgs e)
		{
			foreach (TSPlayer player in TShock.Players)
			{
				player.Account = null;
			}
		}

		/// <summary>Dispose - Called when disposing.</summary>
		/// <param name="disposing">disposing - If set, disposes of all hooks and other systems.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing)
			{
				// NOTE: order is important here
				if (Geo != null)
				{
					Geo.Dispose();
				}
				SaveManager.Instance.Dispose();

				IL.Terraria.Initializers.AchievementInitializer.Load -= OnAchievementInitializerLoad;

				ModuleManager.Dispose();

				ServerApi.Hooks.GamePostInitialize.Deregister(this, OnPostInit);
				ServerApi.Hooks.GameUpdate.Deregister(this, OnUpdate);
				ServerApi.Hooks.GameHardmodeTileUpdate.Deregister(this, OnHardUpdate);
				ServerApi.Hooks.GameStatueSpawn.Deregister(this, OnStatueSpawn);
				ServerApi.Hooks.ServerConnect.Deregister(this, OnConnect);
				ServerApi.Hooks.ServerJoin.Deregister(this, OnJoin);
				ServerApi.Hooks.ServerLeave.Deregister(this, OnLeave);
				ServerApi.Hooks.ServerChat.Deregister(this, OnChat);
				ServerApi.Hooks.ServerCommand.Deregister(this, ServerHooks_OnCommand);
				ServerApi.Hooks.NetGetData.Deregister(this, OnGetData);
				ServerApi.Hooks.NetSendData.Deregister(this, NetHooks_SendData);
				ServerApi.Hooks.NetGreetPlayer.Deregister(this, OnGreetPlayer);
				ServerApi.Hooks.NpcStrike.Deregister(this, NpcHooks_OnStrikeNpc);
				ServerApi.Hooks.ProjectileSetDefaults.Deregister(this, OnProjectileSetDefaults);
				ServerApi.Hooks.WorldStartHardMode.Deregister(this, OnStartHardMode);
				ServerApi.Hooks.WorldSave.Deregister(this, SaveManager.Instance.OnSaveWorld);
				ServerApi.Hooks.WorldChristmasCheck.Deregister(this, OnXmasCheck);
				ServerApi.Hooks.WorldHalloweenCheck.Deregister(this, OnHalloweenCheck);
				ServerApi.Hooks.NetNameCollision.Deregister(this, NetHooks_NameCollision);
				ServerApi.Hooks.ItemForceIntoChest.Deregister(this, OnItemForceIntoChest);
				ServerApi.Hooks.WorldGrassSpread.Deregister(this, OnWorldGrassSpread);
				TShockAPI.Hooks.PlayerHooks.PlayerPostLogin -= OnPlayerLogin;

				if (File.Exists(Path.Combine(SavePath, "tshock.pid")))
				{
					File.Delete(Path.Combine(SavePath, "tshock.pid"));
				}

				RestApi.Dispose();
				Log.Dispose();

				RegionSystem.Dispose();
			}
			base.Dispose(disposing);
		}

		/// <summary>OnPlayerLogin - Fires the PlayerLogin hook to listening plugins.</summary>
		/// <param name="args">args - The PlayerPostLoginEventArgs object.</param>
		private void OnPlayerLogin(PlayerPostLoginEventArgs args)
		{
			List<String> KnownIps = new List<string>();
			if (!string.IsNullOrWhiteSpace(args.Player.Account.KnownIps))
			{
				KnownIps = JsonConvert.DeserializeObject<List<String>>(args.Player.Account.KnownIps);
			}

			if (KnownIps.Count == 0)
			{
				KnownIps.Add(args.Player.IP);
			}
			else
			{
				bool last = KnownIps.Last() == args.Player.IP;
				if (!last)
				{
					if (KnownIps.Count == 100)
					{
						KnownIps.RemoveAt(0);
					}

					KnownIps.Add(args.Player.IP);
				}
			}

			args.Player.Account.KnownIps = JsonConvert.SerializeObject(KnownIps, Formatting.Indented);
			UserAccounts.UpdateLogin(args.Player.Account);

			Bans.CheckBan(args.Player);
		}

		/// <summary>OnAccountDelete - Internal hook fired on account delete.</summary>
		/// <param name="args">args - The AccountDeleteEventArgs object.</param>
		private void OnAccountDelete(Hooks.AccountDeleteEventArgs args)
		{
			CharacterDB.RemovePlayer(args.Account.ID);
		}

		/// <summary>OnAccountCreate - Internal hook fired on account creation.</summary>
		/// <param name="args">args - The AccountCreateEventArgs object.</param>
		private void OnAccountCreate(Hooks.AccountCreateEventArgs args)
		{
			CharacterDB.SeedInitialData(UserAccounts.GetUserAccount(args.Account));
		}

		/// <summary>OnPlayerPreLogin - Internal hook fired when on player pre login.</summary>
		/// <param name="args">args - The PlayerPreLoginEventArgs object.</param>
		private void OnPlayerPreLogin(Hooks.PlayerPreLoginEventArgs args)
		{
			if (args.Player.IsLoggedIn)
				args.Player.SaveServerCharacter();
		}

		/// <summary>NetHooks_NameCollision - Internal hook fired when a name collision happens.</summary>
		/// <param name="args">args - The NameCollisionEventArgs object.</param>
		private void NetHooks_NameCollision(NameCollisionEventArgs args)
		{
			if (args.Handled)
			{
				return;
			}

			string ip = Utils.GetRealIP(Netplay.Clients[args.Who].Socket.GetRemoteAddress().ToString());

			var player = Players.First(p => p != null && p.Name == args.Name && p.Index != args.Who);
			if (player != null)
			{
				if (player.IP == ip)
				{
					player.Kick(GetString("You logged in from the same IP."), true, true, null, true);
					args.Handled = true;
					return;
				}
				if (player.IsLoggedIn)
				{
					var ips = JsonConvert.DeserializeObject<List<string>>(player.Account.KnownIps);
					if (ips.Contains(ip))
					{
						player.Kick(GetString("You logged in from another location."), true, true, null, true);
						args.Handled = true;
					}
				}
			}
		}

		/// <summary>OnItemForceIntoChest - Internal hook fired when a player quick stacks items into a chest.</summary>
		/// <param name="args">The <see cref="ForceItemIntoChestEventArgs"/> object.</param>
		private void OnItemForceIntoChest(ForceItemIntoChestEventArgs args)
		{
			if (args.Handled)
			{
				return;
			}

			if (args.Player == null)
			{
				args.Handled = true;
				return;
			}

			TSPlayer tsplr = Players[args.Player.whoAmI];
			if (tsplr == null)
			{
				args.Handled = true;
				return;
			}

			if (args.Chest != null)
			{
				// After checking for protected regions, no further range checking is necessarily because the client packet only specifies the
				// inventory slot to quick stack. The vanilla Terraria server itself determines what chests are close enough to the player.
				if (Config.Settings.RegionProtectChests && !Regions.CanBuild((int)args.WorldPosition.X, (int)args.WorldPosition.Y, tsplr))
				{
					args.Handled = true;
					return;
				}
			}
		}

		/// <summary>OnXmasCheck - Internal hook fired when the XMasCheck happens.</summary>
		/// <param name="args">args - The ChristmasCheckEventArgs object.</param>
		private void OnXmasCheck(ChristmasCheckEventArgs args)
		{
			if (args.Handled)
				return;

			if (Config.Settings.ForceXmas)
			{
				args.Xmas = true;
				args.Handled = true;
			}
		}

		/// <summary>OnHalloweenCheck - Internal hook fired when the HalloweenCheck happens.</summary>
		/// <param name="args">args - The HalloweenCheckEventArgs object.</param>
		private void OnHalloweenCheck(HalloweenCheckEventArgs args)
		{
			if (args.Handled)
				return;

			if (Config.Settings.ForceHalloween)
			{
				args.Halloween = true;
				args.Handled = true;
			}
		}

		/// <summary>
		/// Handles exceptions that we didn't catch earlier in the code, or in Terraria.
		/// </summary>
		/// <param name="sender">sender - The object that sent the exception.</param>
		/// <param name="e">e - The UnhandledExceptionEventArgs object.</param>
		private void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
		{
			Log.Error(e.ExceptionObject.ToString());

			if (e.ExceptionObject.ToString().Contains("Terraria.Netplay.ListenForClients") ||
				e.ExceptionObject.ToString().Contains("Terraria.Netplay.ServerLoop"))
			{
				var sb = new List<string>();
				for (int i = 0; i < Netplay.Clients.Length; i++)
				{
					if (Netplay.Clients[i] == null)
					{
						sb.Add("Client[" + i + "]");
					}
					else if (Netplay.Clients[i].Socket == null)
					{
						sb.Add("Tcp[" + i + "]");
					}
				}
				Log.Error(string.Join(", ", sb));
			}

			if (e.IsTerminating)
			{
				if (Main.worldPathName != null && Config.Settings.SaveWorldOnCrash)
				{
					Main.ActiveWorldFileData._path += ".crash";
					SaveManager.Instance.SaveWorld();
				}
			}
		}

		private bool tryingToShutdown = false;

		/// <summary> ConsoleCancelHandler - Handles when Ctrl + C is sent to the server for a safe shutdown. </summary>
		/// <param name="sender">The sender</param>
		/// <param name="args">The ConsoleCancelEventArgs associated with the event.</param>
		private void ConsoleCancelHandler(object sender, ConsoleCancelEventArgs args)
		{
			if (tryingToShutdown)
			{
				System.Environment.Exit(1);
				return;
			}
			// Cancel the default behavior
			args.Cancel = true;

			tryingToShutdown = true;

			Log.ConsoleInfo(GetString("Shutting down safely. To force shutdown, send SIGINT (CTRL + C) again."));

			// Perform a safe shutdown
			TShock.Utils.StopServer(true, GetString("Server console interrupted!"));
		}

		/// <summary>HandleCommandLine - Handles the command line parameters passed to the server.</summary>
		/// <param name="parms">parms - The array of arguments passed in through the command line.</param>
		private void HandleCommandLine(string[] parms)
		{
			string path = null;

			//Generic method for doing a path sanity check
			Action<string> pathChecker = (p) =>
			{
				if (!string.IsNullOrWhiteSpace(p) && p.IndexOfAny(Path.GetInvalidPathChars()) == -1)
				{
					path = p;
				}
			};

			//Prepare the parser with all the flags available
			CliParser
				.AddFlag("-configpath", pathChecker)
					//The .After Action is run after the pathChecker Action
					.After(() =>
					{
						SavePath = path ?? "tshock";
						if (path != null)
						{
							ServerApi.LogWriter.PluginWriteLine(this, GetString("Config path has been set to {0}", path), TraceLevel.Info);
						}
					})

				.AddFlag("-worldselectpath", pathChecker)
					.After(() =>
					{
						if (path != null)
						{
							Main.WorldPath = path;
							ServerApi.LogWriter.PluginWriteLine(this, GetString("World path has been set to {0}", path), TraceLevel.Info);
						}
					})

				.AddFlag("-logpath", pathChecker)
					.After(() =>
					{
						if (path != null)
						{
							LogPath = path;
							ServerApi.LogWriter.PluginWriteLine(this, GetString("Log path has been set to {0}", path), TraceLevel.Info);
						}
					})

				.AddFlag("-logformat", (format) =>
					{
						if (!string.IsNullOrWhiteSpace(format)) { LogFormat = format; }
					})

				.AddFlag("-config", (cfg) =>
					{
						if (!string.IsNullOrWhiteSpace(cfg))
						{
							ServerApi.LogWriter.PluginWriteLine(this, GetString("Loading dedicated config file: {0}", cfg), TraceLevel.Verbose);
							Main.instance.LoadDedConfig(cfg);
						}
					})

				.AddFlag("-port", (p) =>
					{
						int port;
						if (int.TryParse(p, out port))
						{
							Netplay.ListenPort = port;
							ServerApi.LogWriter.PluginWriteLine(this, GetString("Listening on port {0}.", port), TraceLevel.Verbose);
						}
					})

				.AddFlag("-worldname", (world) =>
					{
						if (!string.IsNullOrWhiteSpace(world))
						{
							Main.instance.SetWorldName(world);
							ServerApi.LogWriter.PluginWriteLine(this, GetString("World name will be overridden by: {0}", world), TraceLevel.Verbose);
						}
					})

				.AddFlag("-ip", (ip) =>
					{
						IPAddress addr;
						if (IPAddress.TryParse(ip, out addr))
						{
							Netplay.ServerIP = addr;
							ServerApi.LogWriter.PluginWriteLine(this, GetString("Listening on IP {0}.", addr), TraceLevel.Verbose);
						}
						else
						{
							// The server should not start up if this argument is invalid.
							throw new InvalidOperationException("Invalid value given for command line argument \"-ip\".");
						}
					})

				.AddFlag("-autocreate", (size) =>
					{
						if (!string.IsNullOrWhiteSpace(size))
						{
							Main.instance.autoCreate(size);
						}
					})

				.AddFlag("-worldevil", (value) =>
				{

					int worldEvil;
					switch (value.ToLower())
					{
						case "random":
							worldEvil = -1;
							break;
						case "corrupt":
							worldEvil = 0;
							break;
						case "crimson":
							worldEvil = 1;
							break;
						default:
							throw new InvalidOperationException("Invalid value given for command line argument \"-worldevil\".");
					}

					ServerApi.LogWriter.PluginWriteLine(this, GetString("New worlds will be generated with the {0} world evil type!", value), TraceLevel.Verbose);
					WorldGen.WorldGenParam_Evil = worldEvil;
				})

				//Flags without arguments
				.AddFlag("-logclear", () => LogClear = true)
				.AddFlag("-autoshutdown", () => Main.instance.EnableAutoShutdown())
				.AddFlag("-dump", () => Utils.Dump());

			CliParser.ParseFromSource(parms);
		}

		/// <summary>HandleCommandLinePostConfigLoad - Handles additional command line options after the config file is read.</summary>
		/// <param name="parms">parms - The array of arguments passed in through the command line.</param>
		public static void HandleCommandLinePostConfigLoad(string[] parms)
		{
			FlagSet portSet = new FlagSet("-port");
			FlagSet playerSet = new FlagSet("-maxplayers", "-players");
			FlagSet restTokenSet = new FlagSet("--rest-token", "-rest-token");
			FlagSet restEnableSet = new FlagSet("--rest-enabled", "-rest-enabled");
			FlagSet restPortSet = new FlagSet("--rest-port", "-rest-port");

			CliParser
				.AddFlags(portSet, (p) =>
					{
						int port;
						if (int.TryParse(p, out port))
						{
							Netplay.ListenPort = port;
							Config.Settings.ServerPort = port;
							OverridePort = true;
							Log.ConsoleInfo(GetString("Port overridden by startup argument. Set to {0}", port));
						}
					})
				.AddFlags(restTokenSet, (token) =>
					{
						RESTStartupTokens.Add(token, new SecureRest.TokenData { Username = "null", UserGroupName = "superadmin" });
						Console.WriteLine(GetString("Startup parameter overrode REST token."));
					})
				.AddFlags(restEnableSet, (e) =>
					{
						bool enabled;
						if (bool.TryParse(e, out enabled))
						{
							Config.Settings.RestApiEnabled = enabled;
							Console.WriteLine(GetString("Startup parameter overrode REST enable."));
						}
					})
				.AddFlags(restPortSet, (p) =>
				{
					int restPort;
					if (int.TryParse(p, out restPort))
					{
						Config.Settings.RestApiPort = restPort;
						Console.WriteLine(GetString("Startup parameter overrode REST port."));
					}
				})
				.AddFlags(playerSet, (p) =>
					{
						int slots;
						if (int.TryParse(p, out slots))
						{
							Config.Settings.MaxSlots = slots;
							Console.WriteLine(GetString("Startup parameter overrode maximum player slot configuration value."));
						}
					});

			CliParser.ParseFromSource(parms);
		}

		/// <summary>SetupToken - The auth token used by the setup system to grant temporary superadmin access to new admins.</summary>
		public static int SetupToken = -1;
		private string _cliPassword = null;

		/// <summary>OnPostInit - Fired when the server loads a map, to perform world specific operations.</summary>
		/// <param name="args">args - The EventArgs object.</param>
		private void OnPostInit(EventArgs args)
		{
			Utils.SetConsoleTitle(false);

			//This is to prevent a bug where a CLI-defined password causes packets to be
			//sent in an unexpected order, resulting in clients being unable to connect
			if (!string.IsNullOrEmpty(Netplay.ServerPassword))
			{
				//CLI defined password overrides a config password
				if (!string.IsNullOrEmpty(Config.Settings.ServerPassword))
				{
					Log.ConsoleError(GetString("!!! The server password in config.json was overridden by the interactive prompt and will be ignored."));
				}

				if (!Config.Settings.DisableUUIDLogin)
				{
					Log.ConsoleError(GetString("!!! UUID login is enabled. If a user's UUID matches an account, the server password will be bypassed."));
					Log.ConsoleError(GetString("!!! > Set DisableUUIDLogin to true in the config file and /reload if this is a problem."));
				}

				if (!Config.Settings.DisableLoginBeforeJoin)
				{
					Log.ConsoleError(GetString("!!! Login before join is enabled. Existing accounts can login & the server password will be bypassed."));
					Log.ConsoleError(GetString("!!! > Set DisableLoginBeforeJoin to true in the config file and /reload if this is a problem."));
				}

				_cliPassword = Netplay.ServerPassword;
				Netplay.ServerPassword = "";
				Config.Settings.ServerPassword = _cliPassword;
			}
			else
			{
				if (!string.IsNullOrEmpty(Config.Settings.ServerPassword))
				{
					Log.ConsoleInfo(GetString("A password for this server was set in config.json and is being used."));
				}
			}

			if (!Config.Settings.DisableLoginBeforeJoin)
			{
				Log.ConsoleInfo(GetString("Login before join enabled. Users may be prompted for an account specific password instead of a server password on connect."));
			}

			if (!Config.Settings.DisableUUIDLogin)
			{
				Log.ConsoleInfo(GetString("Login using UUID enabled. Users automatically login via UUID."));
				Log.ConsoleInfo(GetString("A malicious server can easily steal a user's UUID. You may consider turning this option off if you run a public server."));
			}

			// Disable the auth system if "setup.lock" is present or a user account already exists
			if (File.Exists(Path.Combine(SavePath, "setup.lock")) || (UserAccounts.GetUserAccounts().Count() > 0))
			{
				SetupToken = 0;

				if (File.Exists(Path.Combine(SavePath, "setup-code.txt")))
				{
					Log.ConsoleInfo(GetString("An account has been detected in the user database, but setup-code.txt is still present."));
					Log.ConsoleInfo(GetString("TShock will now disable the initial setup system and remove setup-code.txt as it is no longer needed."));
					File.Delete(Path.Combine(SavePath, "setup-code.txt"));
				}

				if (!File.Exists(Path.Combine(SavePath, "setup.lock")))
				{
					// This avoids unnecessary database work, which can get ridiculously high on old servers as all users need to be fetched
					File.Create(Path.Combine(SavePath, "setup.lock"));
				}
			}
			else if (!File.Exists(Path.Combine(SavePath, "setup-code.txt")))
			{
				var r = new Random((int)DateTime.Now.ToBinary());
				SetupToken = r.Next(100000, 10000000);
				Console.ForegroundColor = ConsoleColor.Yellow;
				Console.WriteLine(GetString("To setup the server, join the game and type {0}setup {1}", Commands.Specifier, SetupToken));
				Console.WriteLine(GetString("This token will display until disabled by verification. ({0}setup)", Commands.Specifier));
				Console.ResetColor();
				File.WriteAllText(Path.Combine(SavePath, "setup-code.txt"), SetupToken.ToString());
			}
			else
			{
				SetupToken = Convert.ToInt32(File.ReadAllText(Path.Combine(SavePath, "setup-code.txt")));
				Console.ForegroundColor = ConsoleColor.Yellow;
				Console.WriteLine(GetString("TShock Notice: setup-code.txt is still present, and the code located in that file will be used."));
				Console.WriteLine(GetString("To setup the server, join the game and type {0}setup {1}", Commands.Specifier, SetupToken));
				Console.WriteLine(GetString("This token will display until disabled by verification. ({0}setup)", Commands.Specifier));
				Console.ResetColor();
			}

			Regions.Reload();
			Warps.ReloadWarps();

			Utils.ComputeMaxStyles();
			Utils.FixChestStacks();

			if (Config.Settings.UseServerName)
			{
				Main.worldName = Config.Settings.ServerName;
			}

			UpdateManager = new UpdateManager();
		}

		/// <summary>LastCheck - Used to keep track of the last check for basically all time based checks.</summary>
		private DateTime LastCheck = DateTime.UtcNow;

		/// <summary>LastSave - Used to keep track of SSC save intervals.</summary>
		private DateTime LastSave = DateTime.UtcNow;

		/// <summary>OnUpdate - Called when ever the server ticks.</summary>
		/// <param name="args">args - EventArgs args</param>
		private void OnUpdate(EventArgs args)
		{
			// This forces Terraria to actually continue to update
			// even if there are no clients connected
			if (ServerApi.ForceUpdate)
			{
				Netplay.HasClients = true;
			}

			if (Backups.IsBackupTime)
				Backups.Backup();
			//call these every second, not every update
			if ((DateTime.UtcNow - LastCheck).TotalSeconds >= 1)
			{
				OnSecondUpdate();
				LastCheck = DateTime.UtcNow;
			}

			if (Main.ServerSideCharacter && (DateTime.UtcNow - LastSave).TotalMinutes >= ServerSideCharacterConfig.Settings.ServerSideCharacterSave)
			{
				foreach (TSPlayer player in Players)
				{
					// prevent null point exceptions
					if (player != null && player.IsLoggedIn && !player.IsDisabledPendingTrashRemoval)
					{

						CharacterDB.InsertPlayerData(player);
					}
				}
				LastSave = DateTime.UtcNow;
			}
		}

		/// <summary>OnSecondUpdate - Called effectively every second for all time based checks.</summary>
		private void OnSecondUpdate()
		{
			DisableFlags flags = Config.Settings.DisableSecondUpdateLogs ? DisableFlags.WriteToConsole : DisableFlags.WriteToLogAndConsole;

			if (Config.Settings.ForceTime != "normal")
			{
				switch (Config.Settings.ForceTime)
				{
					case "day":
						TSPlayer.Server.SetTime(true, 27000.0);
						break;
					case "night":
						TSPlayer.Server.SetTime(false, 16200.0);
						break;
				}
			}

			foreach (TSPlayer player in Players)
			{
				if (player != null && player.Active)
				{
					if (player.TilesDestroyed != null)
					{
						if (player.TileKillThreshold >= Config.Settings.TileKillThreshold)
						{
							player.Disable(GetString("Reached TileKill threshold."), flags);
							TSPlayer.Server.RevertTiles(player.TilesDestroyed);
							player.TilesDestroyed.Clear();
						}
					}
					if (player.TileKillThreshold > 0)
					{
						player.TileKillThreshold = 0;
						//We don't want to revert the entire map in case of a disable.
						lock (player.TilesDestroyed)
							player.TilesDestroyed.Clear();
					}

					if (player.TilesCreated != null)
					{
						if (player.TilePlaceThreshold >= Config.Settings.TilePlaceThreshold)
						{
							player.Disable(GetString("Reached TilePlace threshold"), flags);
							lock (player.TilesCreated)
							{
								TSPlayer.Server.RevertTiles(player.TilesCreated);
								player.TilesCreated.Clear();
							}
						}
					}
					if (player.TilePlaceThreshold > 0)
					{
						player.TilePlaceThreshold = 0;
					}

					if (player.RecentFuse > 0)
						player.RecentFuse--;

					if (Main.ServerSideCharacter && player.initialSpawn)
					{
						player.initialSpawn = false;

						// reassert the correct spawnpoint value after the game's Spawn handler changed it
						player.TPlayer.SpawnX = player.initialServerSpawnX;
						player.TPlayer.SpawnY = player.initialServerSpawnY;

						player.TeleportSpawnpoint();
						TShock.Log.ConsoleDebug(GetString("OnSecondUpdate / initial ssc spawn for {0} at ({1}, {2})", player.Name, player.TPlayer.SpawnX, player.TPlayer.SpawnY));
					}

					if (player.RPPending > 0)
					{
						if (player.RPPending == 1)
						{
							var pos = RememberedPos.GetLeavePos(player.Name, player.IP);
							player.Teleport(pos.X * 16, pos.Y * 16);
							player.RPPending = 0;
						}
						else
						{
							player.RPPending--;
						}
					}

					if (player.TileLiquidThreshold >= Config.Settings.TileLiquidThreshold)
					{
						player.Disable(GetString("Reached TileLiquid threshold"), flags);
					}
					if (player.TileLiquidThreshold > 0)
					{
						player.TileLiquidThreshold = 0;
					}

					if (player.ProjectileThreshold >= Config.Settings.ProjectileThreshold)
					{
						player.Disable(GetString("Reached projectile threshold"), flags);
					}
					if (player.ProjectileThreshold > 0)
					{
						player.ProjectileThreshold = 0;
					}

					if (player.PaintThreshold >= Config.Settings.TilePaintThreshold)
					{
						player.Disable(GetString("Reached paint threshold"), flags);
					}
					if (player.PaintThreshold > 0)
					{
						player.PaintThreshold = 0;
					}

					if (player.HealOtherThreshold >= TShock.Config.Settings.HealOtherThreshold)
					{
						player.Disable(GetString("Reached HealOtherPlayer threshold"), flags);
					}
					if (player.HealOtherThreshold > 0)
					{
						player.HealOtherThreshold = 0;
					}

					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)
					{
						player.Spawn(PlayerSpawnContext.ReviveFromDeath);
					}

					if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))
					{
						if (!player.HasPermission(Permissions.ignorestackhackdetection))
						{
							player.IsDisabledForStackDetection = player.HasHackedItemStacks(shouldWarnPlayer: true);
						}

						if (player.IsBeingDisabled())
						{
							player.Disable(flags: flags);
						}
					}
				}
			}

			Bouncer.OnSecondUpdate();
			Utils.SetConsoleTitle(false);
		}

		/// <summary>OnHardUpdate - Fired when a hardmode tile update event happens.</summary>
		/// <param name="args">args - The HardmodeTileUpdateEventArgs object.</param>
		private void OnHardUpdate(HardmodeTileUpdateEventArgs args)
		{
			if (args.Handled)
				return;

			if (!OnCreep(args.Type))
			{
				args.Handled = true;
			}
		}

		/// <summary>OnWorldGrassSpread - Fired when grass is attempting to spread.</summary>
		/// <param name="args">args - The GrassSpreadEventArgs object.</param>
		private void OnWorldGrassSpread(GrassSpreadEventArgs args)
		{
			if (args.Handled)
				return;

			if (!OnCreep(args.Grass))
			{
				args.Handled = true;
			}
		}

		/// <summary>
		/// Checks if the tile type is allowed to creep
		/// </summary>
		/// <param name="tileType">Tile id</param>
		/// <returns>True if allowed, otherwise false</returns>
		private bool OnCreep(int tileType)
		{
			if (!Config.Settings.AllowCrimsonCreep && (tileType == TileID.Dirt || tileType == TileID.CrimsonGrass
				|| TileID.Sets.Crimson[tileType]))
			{
				return false;
			}

			if (!Config.Settings.AllowCorruptionCreep && (tileType == TileID.Dirt || tileType == TileID.CorruptThorns
				|| TileID.Sets.Corrupt[tileType]))
			{
				return false;
			}

			if (!Config.Settings.AllowHallowCreep && (TileID.Sets.Hallow[tileType]))
			{
				return false;
			}

			return true;
		}

		/// <summary>OnStatueSpawn - Fired when a statue spawns.</summary>
		/// <param name="args">args - The StatueSpawnEventArgs object.</param>
		private void OnStatueSpawn(StatueSpawnEventArgs args)
		{
			if (args.Within200 < Config.Settings.StatueSpawn200 && args.Within600 < Config.Settings.StatueSpawn600 && args.WorldWide < Config.Settings.StatueSpawnWorld)
			{
				args.Handled = true;
			}
			else
			{
				args.Handled = false;
			}
		}

		/// <summary>OnConnect - Fired when a player connects to the server.</summary>
		/// <param name="args">args - The ConnectEventArgs object.</param>
		private void OnConnect(ConnectEventArgs args)
		{
			if (ShuttingDown)
			{
				NetMessage.SendData((int)PacketTypes.Disconnect, args.Who, -1, NetworkText.FromLiteral(GetString("Server is shutting down...")));
				args.Handled = true;
				return;
			}

			var player = new TSPlayer(args.Who);

			if (Utils.GetActivePlayerCount() + 1 > Config.Settings.MaxSlots + Config.Settings.ReservedSlots)
			{
				player.Kick(Config.Settings.ServerFullNoReservedReason, true, true, null, false);
				args.Handled = true;
				return;
			}

			if (!FileTools.OnWhitelist(player.IP))
			{
				player.Kick(Config.Settings.WhitelistKickReason, true, true, null, false);
				args.Handled = true;
				return;
			}

			if (Geo != null)
			{
				var code = Geo.TryGetCountryCode(IPAddress.Parse(player.IP));
				player.Country = code == null ? "N/A" : GeoIPCountry.GetCountryNameByCode(code);
				if (code == "A1")
				{
					if (Config.Settings.KickProxyUsers)
					{
						player.Kick(GetString("Connecting via a proxy is not allowed."), true, true, null, false);
						args.Handled = true;
						return;
					}
				}
			}

			Bans.CheckBan(player);
			Players[args.Who] = player;
		}

		/// <summary>OnJoin - Internal hook called when a player joins. This is called after OnConnect.</summary>
		/// <param name="args">args - The JoinEventArgs object.</param>
		private void OnJoin(JoinEventArgs args)
		{
			var player = Players[args.Who];
			if (player == null)
			{
				args.Handled = true;
				return;
			}

			if (Config.Settings.KickEmptyUUID && String.IsNullOrWhiteSpace(player.UUID))
			{
				player.Kick(GetString("Your client sent a blank UUID. Configure it to send one or use a different client."), true, true, null, false);
				args.Handled = true;
				return;
			}

			if (Bans.CheckBan(player))
				return;
		}

		/// <summary>OnLeave - Called when a player leaves the server.</summary>
		/// <param name="args">args - The LeaveEventArgs object.</param>
		private void OnLeave(LeaveEventArgs args)
		{
			if (args.Who >= Players.Length || args.Who < 0)
			{
				//Something not right has happened
				return;
			}

			var tsplr = Players[args.Who];
			if (tsplr == null)
			{
				return;
			}

			Players[args.Who] = null;

			//Reset toggle creative powers to default, preventing potential power transfer & desync on another user occupying this slot later.

			foreach (var kv in CreativePowerManager.Instance._powersById)
			{
				var power = kv.Value;

				//No need to reset sliders - those are reset manually by the game, most likely an oversight that toggles don't receive this treatment.

				if (power is CreativePowers.APerPlayerTogglePower toggle)
				{
					if (toggle._perPlayerIsEnabled[args.Who] == toggle._defaultToggleState)
						continue;

					toggle.SetEnabledState(args.Who, toggle._defaultToggleState);
				}
			}

			if (tsplr.ReceivedInfo)
			{
				if (!tsplr.SilentKickInProgress && tsplr.State >= (int)ConnectionState.RequestingWorldData && tsplr.FinishedHandshake) //The player has left, do not broadcast any clients exploiting the behaviour of not spawning their player.
					Utils.Broadcast(GetString("{0} has left.", tsplr.Name), Color.Yellow);
				Log.Info(GetString("{0} disconnected.", tsplr.Name));

				if (tsplr.IsLoggedIn && !tsplr.IsDisabledPendingTrashRemoval && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2))
				{
					tsplr.PlayerData.CopyCharacter(tsplr);
					CharacterDB.InsertPlayerData(tsplr);
				}

				if (Config.Settings.RememberLeavePos && !tsplr.LoginHarassed)
				{
					RememberedPos.InsertLeavePos(tsplr.Name, tsplr.IP, (int)(tsplr.X / 16), (int)(tsplr.Y / 16));
				}

				if (tsplr.tempGroupTimer != null)
				{
					tsplr.tempGroupTimer.Stop();
				}
			}

			tsplr.FinishedHandshake = false;

			// Fire the OnPlayerLogout hook too, if the player was logged in and they have a TSPlayer object.
			if (tsplr.IsLoggedIn)
			{
				Hooks.PlayerHooks.OnPlayerLogout(tsplr);
			}

			// If this is the last player online, update the console title and save the world if needed
			if (Utils.GetActivePlayerCount() == 0)
			{
				if (Config.Settings.SaveWorldOnLastPlayerExit)
					SaveManager.Instance.SaveWorld();
				Utils.SetConsoleTitle(true);
			}
		}

		/// <summary>OnChat - Fired when a player chats. Used for handling chat and commands.</summary>
		/// <param name="args">args - The ServerChatEventArgs object.</param>
		private void OnChat(ServerChatEventArgs args)
		{
			if (args.Handled)
				return;

			var tsplr = Players[args.Who];
			if (tsplr == null)
			{
				args.Handled = true;
				return;
			}

			if (!tsplr.FinishedHandshake)
			{
				tsplr.Kick(GetString("Your client didn't send the right connection information."), true);
				args.Handled = true;
				return;
			}

			if (args.Text.Length > 500)
			{
				tsplr.Kick(GetString("Crash attempt via long chat packet."), true);
				args.Handled = true;
				return;
			}

			string text = args.Text;

			// Terraria now has chat commands on the client side.
			// These commands remove the commands prefix (e.g. /me /playing) and send the command id instead
			// In order for us to keep legacy code we must reverse this and get the prefix using the command id
			foreach (var item in Terraria.UI.Chat.ChatManager.Commands._localizedCommands)
			{
				if (item.Value._name == args.CommandId._name)
				{
					if (!String.IsNullOrEmpty(text))
					{
						text = EnglishLanguage.GetCommandPrefixByName(item.Value._name) + ' ' + text;
					}
					else
					{
						text = EnglishLanguage.GetCommandPrefixByName(item.Value._name);
					}
					break;
				}
			}

			if ((text.StartsWith(Config.Settings.CommandSpecifier) || text.StartsWith(Config.Settings.CommandSilentSpecifier))
				&& !string.IsNullOrWhiteSpace(text.Substring(1)))
			{
				try
				{
					args.Handled = true;
					if (!Commands.HandleCommand(tsplr, text))
					{
						// This is required in case anyone makes HandleCommand return false again
						tsplr.SendErrorMessage(GetString("Unable to parse command. Please contact an administrator for assistance."));
						Log.ConsoleError(GetString("Unable to parse command '{0}' from player {1}."), text, tsplr.Name);
					}
				}
				catch (Exception ex)
				{
					Log.ConsoleError(GetString("An exception occurred executing a command."));
					Log.Error(ex.ToString());
				}
			}
			else
			{
				if (!tsplr.HasPermission(Permissions.canchat))
				{
					args.Handled = true;
				}
				else if (tsplr.mute)
				{
					tsplr.SendErrorMessage(GetString("You are muted!"));
					args.Handled = true;
				}
				else if (!TShock.Config.Settings.EnableChatAboveHeads)
				{
					text = String.Format(Config.Settings.ChatFormat, tsplr.Group.Name, tsplr.Group.Prefix, tsplr.Name, tsplr.Group.Suffix,
											 args.Text);

					//Invoke the PlayerChat hook. If this hook event is handled then we need to prevent sending the chat message
					bool cancelChat = PlayerHooks.OnPlayerChat(tsplr, args.Text, ref text);
					args.Handled = true;

					if (cancelChat)
					{
						return;
					}

					Utils.Broadcast(text, tsplr.Group.R, tsplr.Group.G, tsplr.Group.B);
				}
				else
				{
					Player ply = Main.player[args.Who];
					string name = ply.name;
					ply.name = String.Format(Config.Settings.ChatAboveHeadsFormat, tsplr.Group.Name, tsplr.Group.Prefix, tsplr.Name, tsplr.Group.Suffix);
					//Update the player's name to format text nicely. This needs to be done because Terraria automatically formats messages against our will
					NetMessage.SendData((int)PacketTypes.PlayerInfo, -1, -1, NetworkText.FromLiteral(ply.name), args.Who, 0, 0, 0, 0);

					//Give that poor player their name back :'c
					ply.name = name;

					bool cancelChat = PlayerHooks.OnPlayerChat(tsplr, args.Text, ref text);
					if (cancelChat)
					{
						args.Handled = true;
						return;
					}

					//This netpacket is used to send chat text from the server to clients, in this case on behalf of a client
					Terraria.Net.NetPacket packet = Terraria.GameContent.NetModules.NetTextModule.SerializeServerMessage(
						NetworkText.FromLiteral(text), new Color(tsplr.Group.R, tsplr.Group.G, tsplr.Group.B), (byte)args.Who
					);
					//Broadcast to everyone except the player who sent the message.
					//This is so that we can send them the same nicely formatted message that everyone else gets
					Terraria.Net.NetManager.Instance.Broadcast(packet, args.Who);

					//Reset their name
					NetMessage.SendData((int)PacketTypes.PlayerInfo, -1, -1, NetworkText.FromLiteral(name), args.Who, 0, 0, 0, 0);

					string msg = String.Format("<{0}> {1}",
						String.Format(Config.Settings.ChatAboveHeadsFormat, tsplr.Group.Name, tsplr.Group.Prefix, tsplr.Name, tsplr.Group.Suffix),
						text
					);

					//Send the original sender their nicely formatted message, and do all the loggy things
					tsplr.SendMessage(msg, tsplr.Group.R, tsplr.Group.G, tsplr.Group.B);
					TSPlayer.Server.SendMessage(msg, tsplr.Group.R, tsplr.Group.G, tsplr.Group.B);
					Log.Info("Broadcast: {0}", msg);
					args.Handled = true;
				}
			}
		}

		/// <summary>
		/// Called when a command is issued from the server console.
		/// </summary>
		/// <param name="args">The CommandEventArgs object</param>
		private void ServerHooks_OnCommand(CommandEventArgs args)
		{
			if (args.Handled)
				return;

			if (string.IsNullOrWhiteSpace(args.Command))
			{
				args.Handled = true;
				return;
			}

			// Damn you ThreadStatic and Redigit
			if (Main.rand == null)
			{
				Main.rand = new UnifiedRandom();
			}

			if (args.Command == "autosave")
			{
				Main.autoSave = Config.Settings.AutoSave = !Config.Settings.AutoSave;
				if (Config.Settings.AutoSave)
					Log.ConsoleInfo(GetString("AutoSave Enabled"));
				else
					Log.ConsoleInfo(GetString("AutoSave Disabled"));
			}
			else if (args.Command.StartsWith(Commands.Specifier) || args.Command.StartsWith(Commands.SilentSpecifier))
			{
				Commands.HandleCommand(TSPlayer.Server, args.Command);
			}
			else
			{
				Commands.HandleCommand(TSPlayer.Server, "/" + args.Command);
			}
			args.Handled = true;
		}

		/// <summary>OnGetData - Called when the server gets raw data packets.</summary>
		/// <param name="e">e - The GetDataEventArgs object.</param>
		private void OnGetData(GetDataEventArgs e)
		{
			if (e.Handled)
				return;

			PacketTypes type = e.MsgID;

			var player = Players[e.Msg.whoAmI];
			if (player == null || !player.ConnectionAlive)
			{
				e.Handled = true;
				return;
			}

			if (player.RequiresPassword && type != PacketTypes.PasswordSend)
			{
				e.Handled = true;
				return;
			}

			if ((player.State < (int)ConnectionState.Complete || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&
				(int)type != 38 && (int)type != 21 && (int)type != 22 && type != PacketTypes.SyncLoadout)
			{
				e.Handled = true;
				return;
			}

			int length = e.Length - 1;
			if (length < 0)
			{
				length = 0;
			}
			using (var data = new MemoryStream(e.Msg.readBuffer, e.Index, e.Length - 1))
			{
				// Exceptions are already handled
				e.Handled = GetDataHandlers.HandlerGetData(type, player, data);
			}
		}

		/// <summary>OnGreetPlayer - Fired when a player is greeted by the server. Handles things like the MOTD, join messages, etc.</summary>
		/// <param name="args">args - The GreetPlayerEventArgs object.</param>
		private void OnGreetPlayer(GreetPlayerEventArgs args)
		{
			var player = Players[args.Who];
			if (player == null)
			{
				args.Handled = true;
				return;
			}

			player.LoginMS = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;

			if (Config.Settings.EnableGeoIP && TShock.Geo != null)
			{
				Log.Info(GetString("{0} ({1}) from '{2}' group from '{3}' joined. ({4}/{5})", player.Name, player.IP,
									   player.Group.Name, player.Country, TShock.Utils.GetActivePlayerCount(),
									   TShock.Config.Settings.MaxSlots));
				if (!player.SilentJoinInProgress && player.FinishedHandshake)
					Utils.Broadcast(GetString("{0} ({1}) has joined.", player.Name, player.Country), Color.Yellow);
			}
			else
			{
				Log.Info(GetString("{0} ({1}) from '{2}' group joined. ({3}/{4})", player.Name, player.IP,
									   player.Group.Name, TShock.Utils.GetActivePlayerCount(), TShock.Config.Settings.MaxSlots));
				if (!player.SilentJoinInProgress && player.FinishedHandshake)
					Utils.Broadcast(GetString("{0} has joined.", player.Name), Color.Yellow);
			}

			if (Config.Settings.DisplayIPToAdmins)
				Utils.SendLogs(GetString("{0} has joined. IP: {1}", player.Name, player.IP), Color.Blue);

			player.SendFileTextAsMessage(FileTools.MotdPath);

			string pvpMode = Config.Settings.PvPMode.ToLowerInvariant();
			if (pvpMode == "always" || pvpMode == "pvpwithnoteam")
			{
				player.TPlayer.hostile = true;
				player.SendData(PacketTypes.TogglePvp, "", player.Index);
				TSPlayer.All.SendData(PacketTypes.TogglePvp, "", player.Index);
			}

			if (!player.IsLoggedIn)
			{
				if (Main.ServerSideCharacter)
				{
					player.IsDisabledForSSC = true;
					player.SendErrorMessage(GetString("Server side characters is enabled! Please {0}register or {0}login to play!", Commands.Specifier));
					player.LoginHarassed = true;
				}
				else if (Config.Settings.RequireLogin)
				{
					player.SendErrorMessage(GetString("Please {0}register or {0}login to play!", Commands.Specifier));
					player.LoginHarassed = true;
				}
			}

			player.LastNetPosition = new Vector2(Main.spawnTileX * 16f, Main.spawnTileY * 16f);

			if (Config.Settings.RememberLeavePos && (RememberedPos.GetLeavePos(player.Name, player.IP) != Vector2.Zero) && !player.LoginHarassed)
			{
				player.RPPending = 3;
				player.SendInfoMessage(GetString("You will be teleported to your last known location..."));
			}

			args.Handled = true;
		}

		/// <summary>NpcHooks_OnStrikeNpc - Fired when an NPC strike packet happens.</summary>
		/// <param name="e">e - The NpcStrikeEventArgs object.</param>
		private void NpcHooks_OnStrikeNpc(NpcStrikeEventArgs e)
		{
			if (Config.Settings.InfiniteInvasion)
			{
				if (Main.invasionSize < 10)
				{
					Main.invasionSize = 20000000;
				}
			}
		}

		/// <summary>OnProjectileSetDefaults - Called when a projectile sets the default attributes for itself.</summary>
		/// <param name="e">e - The SetDefaultsEventArgs object parameterized with Projectile and int.</param>
		private void OnProjectileSetDefaults(SetDefaultsEventArgs<Projectile, int> e)
		{
			//tombstone fix.
			if (e.Info == ProjectileID.Tombstone || (e.Info >= ProjectileID.GraveMarker && e.Info <= ProjectileID.Obelisk) || (e.Info >= ProjectileID.RichGravestone1 && e.Info <= ProjectileID.RichGravestone5))
				if (Config.Settings.DisableTombstones)
					e.Object.SetDefaults(0);
			if (e.Info == ProjectileID.HappyBomb)
				if (Config.Settings.DisableClownBombs)
					e.Object.SetDefaults(0);
			if (e.Info == ProjectileID.SnowBallHostile)
				if (Config.Settings.DisableSnowBalls)
					e.Object.SetDefaults(0);
			if (e.Info == ProjectileID.BombSkeletronPrime)
				if (Config.Settings.DisablePrimeBombs)
					e.Object.SetDefaults(0);
		}

		/// <summary>NetHooks_SendData - Fired when the server sends data.</summary>
		/// <param name="e">e - The SendDataEventArgs object.</param>
		private void NetHooks_SendData(SendDataEventArgs e)
		{
			if (e.MsgId == PacketTypes.PlayerHp)
			{
				if (Main.player[(byte)e.number].statLife <= 0)
				{
					e.Handled = true;
					return;
				}
			}
			else if (e.MsgId == PacketTypes.ProjectileNew)
			{
				if (e.number >= 0 && e.number < Main.projectile.Length)
				{
					var projectile = Main.projectile[e.number];
					if (projectile.active && projectile.owner >= 0 &&
						(GetDataHandlers.projectileCreatesLiquid.ContainsKey(projectile.type) || GetDataHandlers.projectileCreatesTile.ContainsKey(projectile.type)))
					{
						var player = Players[projectile.owner];
						if (player != null)
						{
							if (player.RecentlyCreatedProjectiles.Any(p => p.Index == e.number && p.Killed))
							{
								player.RecentlyCreatedProjectiles.RemoveAll(p => p.Index == e.number && p.Killed);
							}

							if (!player.RecentlyCreatedProjectiles.Any(p => p.Index == e.number))
							{
								player.RecentlyCreatedProjectiles.Add(new GetDataHandlers.ProjectileStruct()
								{
									Index = e.number,
									Type = (short)projectile.type,
									CreatedAt = DateTime.Now
								});
							}
						}
					}
				}
			}
		}

		/// <summary>OnStartHardMode - Fired when hard mode is started.</summary>
		/// <param name="e">e - The HandledEventArgs object.</param>
		private void OnStartHardMode(HandledEventArgs e)
		{
			if (Config.Settings.DisableHardmode)
				e.Handled = true;
		}

		/// <summary>OnConfigRead - Fired when the config file has been read.</summary>
		/// <param name="file">file - The config file object.</param>
		public void OnConfigRead(ConfigFile<TShockSettings> file)
		{
			NPC.defaultMaxSpawns = file.Settings.DefaultMaximumSpawns;
			NPC.defaultSpawnRate = file.Settings.DefaultSpawnRate;

			Main.autoSave = file.Settings.AutoSave;
			if (Backups != null)
			{
				Backups.KeepFor = file.Settings.BackupKeepFor;
				Backups.Interval = file.Settings.BackupInterval;
			}
			if (!OverridePort)
			{
				Netplay.ListenPort = file.Settings.ServerPort;
			}

			if (file.Settings.MaxSlots > Main.maxPlayers - file.Settings.ReservedSlots)
				file.Settings.MaxSlots = Main.maxPlayers - file.Settings.ReservedSlots;
			Main.maxNetPlayers = file.Settings.MaxSlots + file.Settings.ReservedSlots;

			Netplay.ServerPassword = "";
			if (!string.IsNullOrEmpty(_cliPassword))
			{
				//This prevents a config reload from removing/updating a CLI-defined password
				file.Settings.ServerPassword = _cliPassword;
			}

			Netplay.SpamCheck = false;
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/TShockAPI.csproj`
```
﻿<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Library</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <GenerateDocumentationFile>True</GenerateDocumentationFile>
    <!-- 
      Version information for an assembly consists of the following four values:

          Major Version
          Minor Version 
          Build Number
          Starting in version 4.2.5, we are no longer including the fourth decimal
          location, which previously held the date and time.

      Also, be sure to release on github with the exact assembly version tag as below
      so that the update manager works correctly (via the Github releases api and mimic)
    -->
    <Version>5.2.4</Version>
    <AssemblyTitle>TShock for Terraria</AssemblyTitle>
    <Company>Pryaxis &amp; TShock Contributors</Company>
    <Product>TShockAPI</Product>
    <Copyright>Copyright © Pryaxis &amp; TShock Contributors 2011-2025</Copyright>
    <!-- extras for nuget -->
    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
    <PackageLicenseExpression>GPL-3.0-or-later</PackageLicenseExpression>
    <Authors>Pryaxis &amp; TShock Contributors</Authors>
    <Description>TShock is a toolbox for Terraria servers and communities.</Description>
    <PackageId>TShock</PackageId> <!-- package name for nuget, instead of TShockAPI -->
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
    <PackageReference Include="GetText.NET" Version="1.7.14" />
    <PackageReference Include="MySql.Data" Version="8.4.0" />
    <PackageReference Include="Microsoft.Data.Sqlite" Version="6.0.11" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\TerrariaServerAPI\TerrariaServerAPI\TerrariaServerAPI.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Reference Include="HttpServer">
      <HintPath>..\prebuilts\HttpServer.dll</HintPath>
    </Reference>
  </ItemGroup>

  <ItemGroup>
    <None Include="..\prebuilts\HttpServer.dll">
      <Link>HttpServer.dll</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <PackageCopyToOutput>true</PackageCopyToOutput>
      <Pack>true</Pack>
    </None>
  </ItemGroup>

</Project>

```
#### File: `temp_TShock-5.2.4/TShockAPI/TShockAPI.licenseheader`
```
extensions: .cs
/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
```
#### File: `temp_TShock-5.2.4/TShockAPI/TextLog.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using TerrariaApi.Server;

namespace TShockAPI
{
	/// <summary>
	/// Class inheriting ILog for writing logs to a text file
	/// </summary>
	public class TextLog : ILog, IDisposable
	{
		private readonly bool ClearFile;
		private StreamWriter _logWriter;

		/// <summary>
		/// File name of the Text log
		/// </summary>
		public string FileName { get; set; }

		/// <summary>
		/// Creates the log file stream and sets the initial log level.
		/// </summary>
		/// <param name="filename">The output filename. This file will be overwritten if 'clear' is set.</param>
		/// <param name="clear">Whether or not to clear the log file on initialization.</param>
		public TextLog(string filename, bool clear)
		{
			FileName = filename;
			ClearFile = clear;
		}

		public bool MayWriteType(TraceLevel type)
		{
			return type != TraceLevel.Off;
		}

		/// <summary>
		/// Writes data to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Data(string message)
		{
			Write(message, TraceLevel.Verbose);
		}

		/// <summary>
		/// Writes data to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Data(string format, params object[] args)
		{
			Data(string.Format(format, args));
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Error(string message)
		{
			Write(message, TraceLevel.Error);
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Error(string format, params object[] args)
		{
			Error(string.Format(format, args));
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void ConsoleError(string message)
		{
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine(message);
			Console.ForegroundColor = ConsoleColor.Gray;
			Write(message, TraceLevel.Error);
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void ConsoleWarn(string message)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(message);
			Console.ForegroundColor = ConsoleColor.Gray;
			Write(message, TraceLevel.Warning);
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void ConsoleWarn(string format, params object[] args)
		{
			ConsoleWarn(string.Format(format, args));
		}

		/// <summary>
		/// Writes an error to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void ConsoleError(string format, params object[] args)
		{
			ConsoleError(string.Format(format, args));
		}

		/// <summary>
		/// Writes a warning to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Warn(string message)
		{
			Write(message, TraceLevel.Warning);
		}

		/// <summary>
		/// Writes a warning to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Warn(string format, params object[] args)
		{
			Warn(string.Format(format, args));
		}

		/// <summary>
		/// Writes an informative string to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Info(string message)
		{
			Write(message, TraceLevel.Info);
		}

		/// <summary>
		/// Writes an informative string to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Info(string format, params object[] args)
		{
			Info(string.Format(format, args));
		}

		/// <summary>
		/// Writes an informative string to the log file. Also outputs to the console.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void ConsoleInfo(string message)
		{
			Console.ForegroundColor = ConsoleColor.Yellow;
			Console.WriteLine(message);
			Console.ForegroundColor = ConsoleColor.Gray;
			Write(message, TraceLevel.Info);
		}

		/// <summary>
		/// Writes an informative string to the log file. Also outputs to the console.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void ConsoleInfo(string format, params object[] args)
		{
			ConsoleInfo(string.Format(format, args));
		}

		/// <summary>
		/// Writes a debug string to the log file. Also outputs to the console. Requires config TShock.DebugLogs to be true.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void ConsoleDebug(string message)
		{
			if (TShock.Config.Settings.DebugLogs)
			{
				Console.WriteLine("Debug: " + message);
				Write(message, TraceLevel.Verbose);
			}
		}

		/// <summary>
		/// Writes a debug string to the log file. Also outputs to the console. Requires config TShock.DebugLogs to be true.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void ConsoleDebug(string format, params object[] args)
		{
			ConsoleDebug(string.Format(format, args));
		}

		/// <summary>
		/// Writes a debug string to the log file.
		/// </summary>
		/// <param name="message">The message to be written.</param>
		public void Debug(string message)
		{
			if (TShock.Config.Settings.DebugLogs)
				Write(message, TraceLevel.Verbose);
		}

		/// <summary>
		/// Writes a debug string to the log file.
		/// </summary>
		/// <param name="format">The format of the message to be written.</param>
		/// <param name="args">The format arguments.</param>
		public void Debug(string format, params object[] args)
		{
			if (TShock.Config.Settings.DebugLogs)
				Debug(string.Format(format, args));
		}

		/// <summary>
		/// Writes a message to the log
		/// </summary>
		/// <param name="message"></param>
		/// <param name="level"></param>
		public void Write(string message, TraceLevel level)
		{
			if (!MayWriteType(level))
				return;
			if (_logWriter is null)
			{
				_logWriter = new StreamWriter(FileName, !ClearFile);
			}

			var caller = "TShock";

			var frame = new StackTrace().GetFrame(2);
			if (frame != null)
			{
				var meth = frame.GetMethod();
				if (meth != null && meth.DeclaringType != null)
					caller = meth.DeclaringType.Name;
			}

			var logEntry = string.Format("{0} - {1}: {2}: {3}",
					DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture),
					caller, level.ToString().ToUpper(), message);
			try
			{
				_logWriter.WriteLine(logEntry);
				_logWriter.Flush();
			}
			catch (ObjectDisposedException)
			{
				ServerApi.LogWriter.PluginWriteLine(TShock.instance, logEntry, TraceLevel.Error);
				Console.WriteLine("Unable to write to log as log has been disposed.");
				Console.WriteLine("{0} - {1}: {2}: {3}",
					DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture),
					caller, level.ToString().ToUpper(), message);
			}
		}

		public void Dispose()
		{
			if (_logWriter != null)
			{
				_logWriter.Dispose();
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockAPI/UpdateManager.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading;
using Newtonsoft.Json;
using Microsoft.Xna.Framework;
using System.Net.Http;
using System.Threading.Tasks;
using TShockAPI.Extensions;

namespace TShockAPI
{
	/// <summary>
	/// Responsible for checking for and notifying users about new updates to TShock
	/// </summary>
	public class UpdateManager
	{
		private const string UpdateUrl = "https://update.tshock.co/latest/";
		private HttpClient _client = new HttpClient();

		/// <summary>
		/// Check once every X minutes.
		/// </summary>
		private int CheckXMinutes = 30;

		/// <summary>
		/// Creates a new instance of <see cref="UpdateManager"/> and starts the update thread
		/// </summary>
		public UpdateManager()
		{
			//5 second timeout
			_client.Timeout = new TimeSpan(0, 0, 5);

			Thread t = new Thread(async () =>
			{
				do
				{
					//Sleep for X minutes
					await Task.Delay(1000 * 60 * CheckXMinutes);
					//Then check again
					await CheckForUpdatesAsync(null);
				} while (true);
			})
			{
				Name = "TShock Update Thread",
				IsBackground = true
			};
			t.Start();
		}

		private async Task CheckForUpdatesAsync(object state)
		{
			try
			{
				CheckXMinutes = 30;
				await UpdateCheckAsync(state);
			}
			catch (Exception ex)
			{
				// Skip this run and check more frequently...

				string msg = ex.BuildExceptionString();
				//Give the console a brief
				Console.ForegroundColor = ConsoleColor.Yellow;
				Console.WriteLine(GetString($"UpdateManager warning: {msg}"));
				Console.ForegroundColor = ConsoleColor.Gray;
				//And log the full exception
				TShock.Log.Warn(GetString($"UpdateManager warning: {ex.ToString()}"));
				TShock.Log.ConsoleError(GetString("Retrying in 5 minutes."));
				CheckXMinutes = 5;
			}
		}

		/// <summary>
		/// Checks for updates to the TShock server
		/// </summary>
		/// <param name="o"></param>
		/// <returns></returns>
		public async Task UpdateCheckAsync(object o)
		{
			var updates = await ServerIsOutOfDateAsync();
			if (updates != null)
			{
				NotifyAdministrators(updates);
			}
		}

		/// <summary>
		/// Checks to see if the server is out of date.
		/// </summary>
		/// <returns></returns>
		private async Task<Dictionary<string, string>> ServerIsOutOfDateAsync()
		{
			var resp = await _client.GetAsync(UpdateUrl);
			if (resp.StatusCode != HttpStatusCode.OK)
			{
				string reason = resp.ReasonPhrase;
				if (string.IsNullOrWhiteSpace(reason))
				{
					reason = "none";
				}
				throw new WebException(GetString($"Update server did not respond with an OK. Server message: [error {resp.StatusCode}] {reason}"));
			}

			string json = await resp.Content.ReadAsStringAsync();
			var update = JsonConvert.DeserializeObject<Dictionary<string, string>>(json);

			var version = new Version(update["version"]);
			if (TShock.VersionNum.CompareTo(version) < 0)
			{
				return update;
			}

			return null;
		}

		private void NotifyAdministrators(Dictionary<string, string> update)
		{
			var changes = update["changes"].Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
			NotifyAdministrator(TSPlayer.Server, changes);
			foreach (TSPlayer player in TShock.Players)
			{
				if (player != null && player.Active && player.HasPermission(Permissions.maintenance))
				{
					NotifyAdministrator(player, changes);
				}
			}
		}

		private void NotifyAdministrator(TSPlayer player, string[] changes)
		{
			player.SendMessage(GetString("The server is out of date. Latest version: "), Color.Red);
			for (int j = 0; j < changes.Length; j++)
			{
				player.SendMessage(changes[j], Color.Red);
			}
		}
	}
}
```
#### File: `temp_TShock-5.2.4/TShockAPI/Utils.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using Terraria;
using Terraria.ID;
using Terraria.Utilities;
using Microsoft.Xna.Framework;
using Terraria.Localization;
using TShockAPI.Localization;

namespace TShockAPI
{
	/// <summary>
	/// Utilities and other TShock core calls that don't fit anywhere else
	/// </summary>
	public class Utils
	{
		/// <summary>
		/// Hex code for a blue pastel color
		/// </summary>
		public const string BoldHighlight = "AAAAFF";
		/// <summary>
		/// Hex code for a red pastel color
		/// </summary>
		public const string RedHighlight = "FFAAAA";
		/// <summary>
		/// Hex code for a green pastel color
		/// </summary>
		public const string GreenHighlight = "AAFFAA";
		/// <summary>
		/// Hex code for a pink pastel color
		/// </summary>
		public const string PinkHighlight = "FFAAFF";
		/// <summary>
		/// Hex code for a yellow pastel color
		/// </summary>
		public const string YellowHighlight = "FFFAAA";
		/// <summary>
		/// Hex code for a white highlight
		/// </summary>
		public const string WhiteHighlight = "FFFFFF";
		/// <summary>
		/// Hex code for a cyan pastel color
		/// </summary>
		public const string CyanHighlight = "AAFFFF";

		/// <summary>
		/// The lowest id for a prefix.
		/// </summary>
		private const int FirstItemPrefix = 1;

		/// <summary>
		/// The highest id for a prefix.
		/// </summary>
		private const int LastItemPrefix = 83;

		/// <summary>instance - an instance of the utils class</summary>
		private static readonly Utils instance = new Utils();

		/// <summary>Utils - Creates a utilities object.</summary>
		private Utils() { }

		/// <summary>Instance - An instance of the utils class.</summary>
		/// <value>value - the Utils instance</value>
		public static Utils Instance { get { return instance; } }

		/// <summary>
		/// Provides the real IP address from a RemoteEndPoint string that contains a port and an IP
		/// </summary>
		/// <param name="mess">A string IPv4 address in IP:PORT form.</param>
		/// <returns>A string IPv4 address.</returns>
		public string GetRealIP(string mess)
		{
			return mess.Split(':')[0];
		}

		/// <summary>
		/// It's a clamp function
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="value">Value to clamp</param>
		/// <param name="max">Maximum bounds of the clamp</param>
		/// <param name="min">Minimum bounds of the clamp</param>
		/// <returns></returns>
		public T Clamp<T>(T value, T max, T min)
			where T : IComparable<T>
		{
			T result = value;
			if (value.CompareTo(max) > 0)
				result = max;
			if (value.CompareTo(min) < 0)
				result = min;
			return result;
		}

		/// <summary>
		/// Saves the map data by calling the SaveManager and instructing it to save the world.
		/// </summary>
		public void SaveWorld()
		{
			SaveManager.Instance.SaveWorld();
		}

		/// <summary>Broadcast - Broadcasts a message to all players on the server, as well as the server console, and the logs.</summary>
		/// <param name="msg">msg - The message to send</param>
		/// <param name="red">red - The amount of red (0-255) in the color for supported destinations.</param>
		/// <param name="green">green - The amount of green (0-255) in the color for supported destinations.</param>
		/// <param name="blue">blue - The amount of blue (0-255) in the color for the supported destinations.</param>
		public void Broadcast(string msg, byte red, byte green, byte blue)
		{
			TSPlayer.All.SendMessage(msg, red, green, blue);
			TSPlayer.Server.SendMessage(msg, red, green, blue);
			TShock.Log.Info(GetString("Broadcast: {0}", msg));
		}

		/// <summary>>Broadcast - Broadcasts a message to all players on the server, as well as the server console, and the logs.</summary>
		/// <param name="msg">msg - The message to send</param>
		/// <param name="color">color - The color object for supported destinations.</param>
		public void Broadcast(string msg, Color color)
		{
			Broadcast(msg, color.R, color.G, color.B);
		}

		/// <summary>
		/// Broadcasts a message from a Terraria player, not TShock
		/// </summary>
		/// <param name="ply">ply - the Terraria player index that will send the packet</param>
		/// <param name="msg">msg - The message to send</param>
		/// <param name="red">red - The amount of red (0-255) in the color for supported destinations.</param>
		/// <param name="green">green - The amount of green (0-255) in the color for supported destinations.</param>
		/// <param name="blue">blue - The amount of blue (0-255) in the color for the supported destinations.</param>
		public void Broadcast(int ply, string msg, byte red, byte green, byte blue)
		{
			TSPlayer.All.SendMessageFromPlayer(msg, red, green, blue, ply);
			TSPlayer.Server.SendMessage(Main.player[ply].name + ": " + msg, red, green, blue);
			TShock.Log.Info(GetString("Broadcast: {0}: {1}", Main.player[ply].name, msg));
		}

		/// <summary>
		/// Sends message to all players with 'logs' permission.
		/// </summary>
		/// <param name="log">Message to send</param>
		/// <param name="color">Color of the message</param>
		/// <param name="excludedPlayer">The player to not send the message to.</param>
		public void SendLogs(string log, Color color, TSPlayer excludedPlayer = null)
		{
			TShock.Log.Info(log);
			TSPlayer.Server.SendMessage(log, color);
			foreach (TSPlayer player in TShock.Players)
			{
				if (player != null && player != excludedPlayer && player.Active && player.HasPermission(Permissions.logs) &&
						player.DisplayLogs && !TShock.Config.Settings.DisableSpewLogs)
					player.SendMessage(log, color);
			}
		}

		/// <summary>
		/// Gets the number of active players on the server.
		/// </summary>
		/// <returns>The number of active players on the server.</returns>
		public int GetActivePlayerCount()
		{
			return TShock.Players.Count(p => null != p && p.Active && p.FinishedHandshake);
		}

		//Random should not be generated in a method
		Random r = new Random();

		/// <summary>
		/// Gets a random clear tile in range
		/// </summary>
		/// <param name="startTileX">Bound X</param>
		/// <param name="startTileY">Bound Y</param>
		/// <param name="tileXRange">Range on the X axis</param>
		/// <param name="tileYRange">Range on the Y axis</param>
		/// <param name="tileX">X location</param>
		/// <param name="tileY">Y location</param>
		public void GetRandomClearTileWithInRange(int startTileX, int startTileY, int tileXRange, int tileYRange,
																							out int tileX, out int tileY)
		{
			int j = 0;
			do
			{
				if (j == 100)
				{
					tileX = startTileX;
					tileY = startTileY;
					break;
				}
				tileX = startTileX + r.Next(tileXRange * -1, tileXRange);
				tileY = startTileY + r.Next(tileYRange * -1, tileYRange);
				j++;
			} while (TilePlacementValid(tileX, tileY) && TileSolid(tileX, tileY));
		}

		/// <summary>
		/// Determines if a tile is valid.
		/// </summary>
		/// <param name="tileX">Location X</param>
		/// <param name="tileY">Location Y</param>
		/// <returns>If the tile is valid</returns>
		public bool TilePlacementValid(int tileX, int tileY)
		{
			return tileX >= 0 && tileX < Main.maxTilesX && tileY >= 0 && tileY < Main.maxTilesY;
		}

		/// <summary>
		/// Checks if the tile is solid.
		/// </summary>
		/// <param name="tileX">Location X</param>
		/// <param name="tileY">Location Y</param>
		/// <returns>The tile's solidity.</returns>
		public bool TileSolid(int tileX, int tileY)
		{
			return TilePlacementValid(tileX, tileY) && Main.tile[tileX, tileY] != null &&
				Main.tile[tileX, tileY].active() && Main.tileSolid[Main.tile[tileX, tileY].type] &&
				!Main.tile[tileX, tileY].inActive() && !Main.tile[tileX, tileY].halfBrick() &&
				Main.tile[tileX, tileY].slope() == 0 && Main.tile[tileX, tileY].type != TileID.Bubble;
		}

		/// <summary>
		/// Gets a list of items by ID, Name or Tag.
		/// </summary>
		/// <param name="text">Item ID, Name or Tag.</param>
		/// <returns>A list of matching items.</returns>
		public List<Item> GetItemByIdOrName(string text)
		{
			int type = -1;
			if (Int32.TryParse(text, out type))
			{
				if (type >= Terraria.ID.ItemID.Count)
					return new List<Item>();
				return new List<Item> { GetItemById(type) };
			}
			Item item = GetItemFromTag(text);
			if (item != null)
				return new List<Item>() { item };
			return GetItemByName(text);
		}

		/// <summary>
		/// Gets an item by ID
		/// </summary>
		/// <param name="id">ID</param>
		/// <returns>Item</returns>
		public Item GetItemById(int id)
		{
			Item item = new Item();
			item.netDefaults(id);
			return item;
		}

		/// <summary>
		/// Gets items by name
		/// </summary>
		/// <param name="name">name</param>
		/// <returns>List of Items</returns>
		public List<Item> GetItemByName(string name)
		{
			var startswith = new List<int>();
			var contains = new List<int>();
			for (int i = 1; i < ItemID.Count; i++)
			{
				var currentName = Lang.GetItemNameValue(i);
				if (!string.IsNullOrEmpty(currentName))
				{
					if (currentName.Equals(name, StringComparison.InvariantCultureIgnoreCase))
						return new List<Item> { GetItemById(i) };
					if (currentName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase))
					{
						startswith.Add(i);
						continue;
					}
					if (currentName.Contains(name, StringComparison.InvariantCultureIgnoreCase))
					{
						contains.Add(i);
						continue;
					}
				}
				currentName = EnglishLanguage.GetItemNameById(i);
				if (!string.IsNullOrEmpty(currentName))
				{
					if (currentName.Equals(name, StringComparison.InvariantCultureIgnoreCase))
						return new List<Item> { GetItemById(i) };
					if (currentName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase))
					{
						startswith.Add(i);
						continue;
					}
					if (currentName.Contains(name, StringComparison.InvariantCultureIgnoreCase))
					{
						contains.Add(i);
						continue;
					}
				}
			}

			if (startswith.Count != 1)
				startswith.AddRange(contains);
			return startswith.Select(GetItemById).ToList();
		}

		/// <summary>
		/// Gets an item based on a chat item tag.
		/// </summary>
		/// <param name="tag">A tag in the [i/s#/p#:netid] format.</param>
		/// <returns>The item represented by the tag.</returns>
		public Item GetItemFromTag(string tag)
		{
			Regex regex = new Regex(@"\[i(tem)?(?:\/s(?<Stack>\d{1,4}))?(?:\/p(?<Prefix>\d{1,3}))?:(?<NetID>-?\d{1,4})\]");
			Match match = regex.Match(tag);
			if (!match.Success)
				return null;
			Item item = new Item();
			item.netDefaults(Int32.Parse(match.Groups["NetID"].Value));
			if (!String.IsNullOrWhiteSpace(match.Groups["Stack"].Value))
				item.stack = Int32.Parse(match.Groups["Stack"].Value);
			if (!String.IsNullOrWhiteSpace(match.Groups["Prefix"].Value))
				item.prefix = Byte.Parse(match.Groups["Prefix"].Value);
			return item;
		}

		/// <summary>
		/// Gets an NPC by ID or Name
		/// </summary>
		/// <param name="idOrName"></param>
		/// <returns>List of NPCs</returns>
		public List<NPC> GetNPCByIdOrName(string idOrName)
		{
			int type = -1;
			if (int.TryParse(idOrName, out type))
			{
				if (type >= Terraria.ID.NPCID.Count)
					return new List<NPC>();
				return new List<NPC> { GetNPCById(type) };
			}
			return GetNPCByName(idOrName);
		}

		/// <summary>
		/// Gets an NPC by ID
		/// </summary>
		/// <param name="id">ID</param>
		/// <returns>NPC</returns>
		public NPC GetNPCById(int id)
		{
			NPC npc = new NPC();
			npc.SetDefaults(id);
			return npc;
		}

		/// <summary>
		/// Gets a NPC by name
		/// </summary>
		/// <param name="name">Name</param>
		/// <returns>List of matching NPCs</returns>
		public List<NPC> GetNPCByName(string name)
		{
			var startswith = new List<int>();
			var contains = new List<int>();
			for (int i = -17; i < NPCID.Count; i++)
			{
				var currentName = Lang.GetNPCNameValue(i);
				if (!string.IsNullOrEmpty(currentName))
				{
					if (currentName.Equals(name, StringComparison.InvariantCultureIgnoreCase))
						return new List<NPC> { GetNPCById(i) };
					if (currentName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase))
					{
						startswith.Add(i);
						continue;
					}
					if (currentName.Contains(name, StringComparison.InvariantCultureIgnoreCase))
					{
						contains.Add(i);
						continue;
					}
				}
				currentName = EnglishLanguage.GetNpcNameById(i);
				if (!string.IsNullOrEmpty(currentName))
				{
					if (currentName.Equals(name, StringComparison.InvariantCultureIgnoreCase))
						return new List<NPC> { GetNPCById(i) };
					if (currentName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase))
					{
						startswith.Add(i);
						continue;
					}
					if (currentName.Contains(name, StringComparison.InvariantCultureIgnoreCase))
					{
						contains.Add(i);
						continue;
					}
				}
			}

			if (startswith.Count != 1)
				startswith.AddRange(contains);
			return startswith.Select(GetNPCById).ToList();
		}

		/// <summary>
		/// Gets a buff name by id
		/// </summary>
		/// <param name="id">ID</param>
		/// <returns>name</returns>
		public string GetBuffName(int id)
		{
			return (id > 0 && id < Terraria.ID.BuffID.Count) ? Lang.GetBuffName(id) : null;
		}

		/// <summary>
		/// Gets the description of a buff
		/// </summary>
		/// <param name="id">ID</param>
		/// <returns>description</returns>
		public string GetBuffDescription(int id)
		{
			return (id > 0 && id < Terraria.ID.BuffID.Count) ? Lang.GetBuffDescription(id) : null;
		}

		/// <summary>
		/// Gets a list of buffs by name
		/// </summary>
		/// <param name="name">name</param>
		/// <returns>Matching list of buff ids</returns>
		public List<int> GetBuffByName(string name)
		{
			var startswith = new List<int>();
			var contains = new List<int>();
			for (int i = 1; i < BuffID.Count; i++)
			{
				var currentName = Lang.GetBuffName(i);
				if (!string.IsNullOrWhiteSpace(currentName))
				{
					if (currentName.Equals(name, StringComparison.InvariantCultureIgnoreCase))
						return new List<int> { i };
					if (currentName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase))
					{
						startswith.Add(i);
						continue;
					}
					if (currentName.Contains(name, StringComparison.InvariantCultureIgnoreCase))
					{
						contains.Add(i);
						continue;
					}
				}
				currentName = EnglishLanguage.GetBuffNameById(i);
				if (!string.IsNullOrWhiteSpace(currentName))
				{
					if (currentName.Equals(name, StringComparison.InvariantCultureIgnoreCase))
						return new List<int> { i };
					if (currentName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase))
					{
						startswith.Add(i);
						continue;
					}
					if (currentName.Contains(name, StringComparison.InvariantCultureIgnoreCase))
					{
						contains.Add(i);
						continue;
					}
				}
			}

			if (startswith.Count != 1)
				startswith.AddRange(contains);
			return startswith;
		}

		/// <summary>
		/// Gets a prefix based on its id
		/// </summary>
		/// <param name="id">ID</param>
		/// <returns>Prefix name</returns>
		public string GetPrefixById(int id)
		{
			return id < FirstItemPrefix || id > LastItemPrefix ? "" : Lang.prefix[id].ToString() ?? "";
		}

		/// <summary>
		/// Gets a list of prefixes by name
		/// </summary>
		/// <param name="name">Name</param>
		/// <returns>List of prefix IDs</returns>
		public List<int> GetPrefixByName(string name)
		{
			var startswith = new List<int>();
			var contains = new List<int>();
			for (int i = FirstItemPrefix; i <= LastItemPrefix; i++)
			{
				var currentName = Lang.prefix[i].ToString();
				if (!string.IsNullOrWhiteSpace(currentName))
				{
					if (currentName.Equals(name, StringComparison.InvariantCultureIgnoreCase))
						return new List<int> { i };
					if (currentName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase))
					{
						startswith.Add(i);
						continue;
					}
					if (currentName.Contains(name, StringComparison.InvariantCultureIgnoreCase))
					{
						contains.Add(i);
						continue;
					}
				}
				currentName = EnglishLanguage.GetPrefixById(i);
				if (!string.IsNullOrWhiteSpace(currentName))
				{
					if (currentName.Equals(name, StringComparison.InvariantCultureIgnoreCase))
						return new List<int> { i };
					if (currentName.StartsWith(name, StringComparison.InvariantCultureIgnoreCase))
					{
						startswith.Add(i);
						continue;
					}
					if (currentName.Contains(name, StringComparison.InvariantCultureIgnoreCase))
					{
						contains.Add(i);
						continue;
					}
				}
			}

			if (startswith.Count != 1)
				startswith.AddRange(contains);
			return startswith;
		}

		/// <summary>
		/// Gets a prefix by ID or name
		/// </summary>
		/// <param name="idOrName">ID or name</param>
		/// <returns>List of prefix IDs</returns>
		public List<int> GetPrefixByIdOrName(string idOrName)
		{
			int type = -1;
			if (int.TryParse(idOrName, out type) && type >= FirstItemPrefix && type <= LastItemPrefix)
			{
				return new List<int> { type };
			}
			return GetPrefixByName(idOrName);
		}

		/// <summary>
		/// Stops the server after kicking all players with a reason message, and optionally saving the world
		/// </summary>
		/// <param name="save">bool perform a world save before stop (default: true)</param>
		/// <param name="reason">string reason (default: "Server shutting down!")</param>
		public void StopServer(bool save = true, string reason = "Server shutting down!")
		{
			TShock.ShuttingDown = true;

			if (save)
				SaveManager.Instance.SaveWorld();

			foreach (var player in TShock.Players.Where(p => p != null))
			{
				if (player.IsLoggedIn)
				{
					player.SaveServerCharacter();
				}
				player.Disconnect(reason);
			}

			// Broadcast so console can see we are shutting down as well
			TShock.Utils.Broadcast(reason, Color.Red);

			// Disconnect after kick as that signifies server is exiting and could cause a race
			Netplay.Disconnect = true;
		}

		/// <summary>
		/// Reloads all configuration settings, groups, regions and raises the reload event.
		/// </summary>
		public void Reload()
		{
			FileTools.SetupConfig();
			TShock.HandleCommandLinePostConfigLoad(Environment.GetCommandLineArgs());
			TShock.Groups.LoadPermisions();
			TShock.Regions.Reload();
			TShock.ItemBans.DataModel.UpdateItemBans();
			TShock.ProjectileBans.UpdateBans();
			TShock.TileBans.UpdateBans();
		}

		/// <summary>
		/// Returns an IPv4 address from a DNS query
		/// </summary>
		/// <param name="hostname">string ip</param>
		public string GetIPv4AddressFromHostname(string hostname)
		{
			try
			{
				//Get the ipv4 address from GetHostAddresses, if an ip is passed it will return that ip
				var ip = Dns.GetHostAddresses(hostname).FirstOrDefault(i => i.AddressFamily == AddressFamily.InterNetwork);
				//if the dns query was successful then return it, otherwise return an empty string
				return ip != null ? ip.ToString() : "";
			}
			catch (SocketException)
			{
			}
			return "";
		}

		/// <summary>
		/// Checks if world has hit the max number of chests
		/// </summary>
		/// <returns>True if the entire chest array is used</returns>
		public bool HasWorldReachedMaxChests()
		{
			for (int i = 0; i < Main.chest.Length; i++)
			{
				if (Main.chest[i] == null)
					return false;
			}
			return true;
		}

		/// <summary>
		/// Attempts to parse a string as a timespan (_d_m_h_s).
		/// </summary>
		/// <param name="str">The time string.</param>
		/// <param name="seconds">The seconds.</param>
		/// <returns>Whether the string was parsed successfully.</returns>
		public bool TryParseTime(string str, out int seconds)
		{
			seconds = 0;

			if (string.IsNullOrWhiteSpace(str))
			{
				return false;
			}

			var sb = new StringBuilder(3);
			for (int i = 0; i < str.Length; i++)
			{
				if (char.IsDigit(str[i]) || str[i] == '-' || str[i] == '+' || str[i] == ' ')
					sb.Append(str[i]);
				else
				{
					int num;
					if (!int.TryParse(sb.ToString(), out num))
						return false;

					sb.Clear();
					switch (str[i])
					{
						case 's':
							seconds += num;
							break;
						case 'm':
							seconds += num * 60;
							break;
						case 'h':
							seconds += num * 60 * 60;
							break;
						case 'd':
							seconds += num * 60 * 60 * 24;
							break;
						default:
							return false;
					}
				}
			}
			if (sb.Length != 0)
				return false;
			return true;
		}

		/// <summary>
		/// Attempts to parse a string as a positive timespan (_d_m_h_s).
		/// </summary>
		/// <param name="str">The time string.</param>
		/// <param name="seconds">The seconds.</param>
		/// <returns>Whether the string was parsed successfully.</returns>
		public bool TryParseTime(string str, out ulong seconds)
		{
			seconds = 0;

			if (string.IsNullOrWhiteSpace(str))
			{
				return false;
			}

			var sb = new StringBuilder(3);
			for (int i = 0; i < str.Length; i++)
			{
				if (char.IsDigit(str[i]) || str[i] == '-' || str[i] == '+' || str[i] == ' ')
					sb.Append(str[i]);
				else
				{
					int num;
					if (!int.TryParse(sb.ToString().Trim(' '), out num))
						return false;

					sb.Clear();

					if (num == 0)
					{
						continue;
					}

					int numSeconds;
					switch (str[i])
					{
						case 's':
							numSeconds = num;
							break;
						case 'm':
							numSeconds = num * 60;
							break;
						case 'h':
							numSeconds = num * 60 * 60;
							break;
						case 'd':
							numSeconds = num * 60 * 60 * 24;
							break;
						default:
							return false;
					}

					if (numSeconds > 0)
					{
						if (ulong.MaxValue - seconds < (uint)numSeconds)
						{
							return false;
						}

						seconds += (uint)numSeconds;
					}
					else if (seconds >= (uint)Math.Abs(numSeconds))
					{
						seconds -= (uint)Math.Abs(numSeconds);
					}
					else
					{
						return false;
					}
				}
			}
			if (sb.Length != 0)
				return false;
			return true;
		}

		/// <summary>
		/// Searches for a projectile by identity and owner
		/// </summary>
		/// <param name="identity">identity</param>
		/// <param name="owner">owner</param>
		/// <returns>projectile ID</returns>
		public int SearchProjectile(short identity, int owner)
		{
			for (int i = 0; i < Main.maxProjectiles; i++)
			{
				if (Main.projectile[i].identity == identity && Main.projectile[i].owner == owner)
					return i;
			}
			return 1000;
		}

		/// <summary>
		/// Enumerates boundary points of the given region's rectangle.
		/// </summary>
		/// <param name="regionArea">The region's area to enumerate through.</param>
		/// <returns>The enumerated boundary points.</returns>
		public IEnumerable<Point> EnumerateRegionBoundaries(Rectangle regionArea)
		{
			for (int x = 0; x < regionArea.Width + 1; x++)
			{
				yield return new Point(regionArea.Left + x, regionArea.Top);
				yield return new Point(regionArea.Left + x, regionArea.Bottom);
			}

			for (int y = 1; y < regionArea.Height; y++)
			{
				yield return new Point(regionArea.Left, regionArea.Top + y);
				yield return new Point(regionArea.Right, regionArea.Top + y);
			}
		}

		/// <summary>EncodeColor - Encodes a color as an int.</summary>
		/// <param name="color">color - The color to encode</param>
		/// <returns>int? - The encoded color</returns>
		public int? EncodeColor(Color? color)
		{
			if (color == null)
				return null;

			return BitConverter.ToInt32(new[] { color.Value.R, color.Value.G, color.Value.B, color.Value.A }, 0);
		}

		/// <summary>DecodeColor - Decodes a color encoded by the EncodeColor function.</summary>
		/// <param name="encodedColor">encodedColor - The encoded color</param>
		/// <returns>Color? - The decoded color</returns>
		public Color? DecodeColor(int? encodedColor)
		{
			if (encodedColor == null)
				return null;

			byte[] data = BitConverter.GetBytes(encodedColor.Value);
			return new Color(data[0], data[1], data[2], data[3]);
		}

		/// <summary>
		/// Encodes a Boolean Array as an int.
		/// </summary>
		/// <param name="bools">The boolean array to encode.</param>
		/// <returns>The encoded int.</returns>
		public int? EncodeBoolArray(bool[] bools)
		{
			if (bools == null)
				return null;

			int result = 0;
			for (int i = 0; i < bools.Length; i++)
				if (bools[i])
					result |= (1 << i);

			return result;
		}

		/// <summary>
		/// Decodes a Boolean Array from an int.
		/// </summary>
		/// <param name="encodedbools">The encoded Boolean Array.</param>
		/// <returns>The resulting Boolean Array.</returns>
		public bool[] DecodeBoolArray(int? encodedbools)
		{
			if (encodedbools == null)
				return null;

			bool[] result = new bool[10];
			for (int i = 0; i < result.Length; i++)
				result[i] = (encodedbools & 1 << i) != 0;

			return result;
		}

		/// <summary>EncodeBitsByte - Encodes a BitsByte as a byte.</summary>
		/// <param name="bitsByte">bitsByte - The BitsByte object</param>
		/// <returns>byte? - The converted byte</returns>
		public byte? EncodeBitsByte(BitsByte? bitsByte)
		{
			if (bitsByte == null)
				return null;

			byte result = 0;
			for (int i = 0; i < 8; i++)
				if (bitsByte.Value[i])
					result |= (byte)(1 << i);

			return result;
		}

		/// <summary>DecodeBitsByte - Decodes a bitsbyte from an int.</summary>
		/// <param name="encodedBitsByte">encodedBitsByte - The encoded bitsbyte object.</param>
		/// <returns>BitsByte? - The decoded bitsbyte object</returns>
		public BitsByte? DecodeBitsByte(int? encodedBitsByte)
		{
			if (encodedBitsByte == null)
				return null;

			BitsByte result = new BitsByte();
			for (int i = 0; i < 8; i++)
				result[i] = (encodedBitsByte & 1 << i) != 0;

			return result;
		}

		/// <summary>GetResponseNoException - Gets a web response without generating an exception.</summary>
		/// <param name="req">req - The request to send.</param>
		/// <returns>HttpWebResponse - The response object.</returns>
		public HttpWebResponse GetResponseNoException(HttpWebRequest req)
		{
			try
			{
				return (HttpWebResponse)req.GetResponse();
			}
			catch (WebException we)
			{
				var resp = we.Response as HttpWebResponse;
				if (resp == null)
					throw;
				return resp;
			}
		}

		/// <summary>
		/// Colors the given text by correctly applying the color chat tag.
		/// </summary>
		/// <param name="text">The text to color.</param>
		/// <param name="color">The color to apply.</param>
		/// <returns>The <paramref name="text"/>, surrounded by the color tag with the appropriated hex code.</returns>
		public string ColorTag(string text, Color color)
		{
			return String.Format("[c/{0}:{1}]", color.Hex3(), text);
		}

		/// <summary>
		/// Converts an item into its text representation using the item chat tag.
		/// </summary>
		/// <param name="item">The item to convert.</param>
		/// <returns>The <paramref name="item"/> NetID surrounded by the item tag with proper stack/prefix data.</returns>
		public string ItemTag(Item item)
		{
			int netID = item.netID;
			int stack = item.stack;
			int prefix = item.prefix;
			string options = stack > 1 ? "/s" + stack : prefix != 0 ? "/p" + prefix : "";
			return String.Format("[i{0}:{1}]", options, netID);
		}

		/// <summary>
		/// Gets a list of points selected by a mass-wiring tool.
		/// </summary>
		/// <param name="start">The starting point for the selection.</param>
		/// <param name="end">The ending point for the selection.</param>
		/// <param name="direction">False if facing left, True if facing right.</param>
		/// <returns>
		/// A list of coordinates containing the <paramref name="start"/> and <paramref name="end"/>
		/// points and a list of points between them, forming an L shape based on <paramref name="direction"/>.
		/// </returns>
		public List<Point> GetMassWireOperationRange(Point start, Point end, bool direction = false)
		{
			List<Point> points = new List<Point>();

			#region Tile Selection Logic stolen from Wiring.cs

			// Slightly modified version of Wiring.MassWireOperationInner, ignores a player's wire count
			int num = Math.Sign(end.X - start.X);
			int num2 = Math.Sign(end.Y - start.Y);
			Point pt = new Point();
			int num3;
			int num4;
			int num5;
			if (direction)
			{
				pt.X = start.X;
				num3 = start.Y;
				num4 = end.Y;
				num5 = num2;
			}
			else
			{
				pt.Y = start.Y;
				num3 = start.X;
				num4 = end.X;
				num5 = num;
			}
			int num6 = num3;
			while (num6 != num4)
			{
				if (direction)
				{
					pt.Y = num6;
				}
				else
				{
					pt.X = num6;
				}
				points.Add(pt);
				num6 += num5;
			}
			if (direction)
			{
				pt.Y = end.Y;
				num3 = start.X;
				num4 = end.X;
				num5 = num;
			}
			else
			{
				pt.X = end.X;
				num3 = start.Y;
				num4 = end.Y;
				num5 = num2;
			}
			int num7 = num3;
			while (num7 != num4)
			{
				if (!direction)
				{
					pt.Y = num7;
				}
				else
				{
					pt.X = num7;
				}
				points.Add(pt);
				num7 += num5;
			}
			points.Add(end);

			#endregion

			return points;
		}

		/// <summary>
		/// Dumps information and optionally exits afterwards
		/// </summary>
		/// <param name="exit"></param>
		public void Dump(bool exit = true)
		{
			PrepareLangForDump();
			// Lang.setLang(true);

			Directory.CreateDirectory("docs");

			Configuration.TShockConfig.DumpDescriptions();
			Permissions.DumpDescriptions();
			Configuration.ServerSideConfig.DumpDescriptions();
			RestManager.DumpDescriptions();

			if (exit)
			{
				Environment.Exit(1);
			}
		}

		internal void PrepareLangForDump()
		{
			for (int i = 0; i < Main.recipe.Length; i++)
				Main.recipe[i] = new Recipe();
		}

		/// <summary>Dumps a matrix of all permissions &amp; all groups in Markdown table format.</summary>
		/// <param name="path">The save destination.</param>
		internal void DumpPermissionMatrix(string path)
		{
			StringBuilder output = new StringBuilder();
			output.Append("|Permission|");

			// Traverse to build group name list
			foreach (Group g in TShock.Groups.groups)
			{
				output.Append("[[");
				output.Append(g.Name);
				output.Append("]]");
				output.Append("|");
			}

			output.AppendLine();
			output.Append("|-------|");

			foreach (Group g in TShock.Groups.groups)
			{
				output.Append("-------|");
			}
			output.AppendLine();

			foreach (var field in typeof(Permissions).GetFields().OrderBy(f => f.Name))
			{
				output.Append("|[[");
				output.Append((string)field.GetValue(null));
				output.Append("]]|");

				foreach (Group g in TShock.Groups.groups)
				{
					if (g.HasPermission((string)field.GetValue(null)))
					{
						output.Append("✔|");
					}
					else
					{
						output.Append("|");
					}
				}
				output.AppendLine();
			}

			File.WriteAllText(path, output.ToString());
		}

		/// <summary>Starts an invasion on the server.</summary>
		/// <param name="type">The invasion type id.</param>
		internal void StartInvasion(int type)
		{
			int invasionSize = 0;

			if (TShock.Config.Settings.InfiniteInvasion)
			{
				// Not really an infinite size
				invasionSize = 20000000;
			}
			else
			{
				invasionSize = 100 + (TShock.Config.Settings.InvasionMultiplier * GetActivePlayerCount());
			}

			// Order matters
			// StartInvasion will reset the invasion size

			Main.StartInvasion(type);

			// Note: This is a workaround to previously providing the size as a parameter in StartInvasion
			// Have to set start size to report progress correctly
			Main.invasionSizeStart = invasionSize;
			Main.invasionSize = invasionSize;
		}

		/// <summary>Verifies that each stack in each chest is valid and not over the max stack count.</summary>
		internal void FixChestStacks()
		{
			if (TShock.Config.Settings.IgnoreChestStacksOnLoad)
				return;

			foreach (Chest chest in Main.chest)
			{
				if (chest != null)
				{
					foreach (Item item in chest.item)
					{
						if (item != null && item.stack > item.maxStack)
							item.stack = item.maxStack;
					}
				}
			}
		}

		/// <summary>Updates the console title with some pertinent information.</summary>
		/// <param name="empty">If the server is empty; determines if we should use Utils.GetActivePlayerCount() for player count or 0.</param>
		internal void SetConsoleTitle(bool empty)
		{
			if (ShouldSkipTitle)
				return;
			Console.Title = GetString("{0}{1}/{2} on {3} @ {4}:{5} (TShock for Terraria v{6})",
					!string.IsNullOrWhiteSpace(TShock.Config.Settings.ServerName) ? TShock.Config.Settings.ServerName + " - " : "",
					empty ? 0 : GetActivePlayerCount(),
					TShock.Config.Settings.MaxSlots, Main.worldName, Netplay.ServerIP.ToString(), Netplay.ListenPort, TShock.VersionNum);
		}
		// Some terminals doesn't supports XTerm escape sequences for setting the title
		private static bool ShouldSkipTitle = !System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Windows) && !(Environment.GetEnvironmentVariable("TERM")?.Contains("xterm") ?? false);

		/// <summary>Determines the distance between two vectors.</summary>
		/// <param name="value1">The first vector location.</param>
		/// <param name="value2">The second vector location.</param>
		/// <returns>The distance between the two vectors.</returns>
		public static float Distance(Vector2 value1, Vector2 value2)
		{
			float num2 = value1.X - value2.X;
			float num = value1.Y - value2.Y;
			float num3 = (num2 * num2) + (num * num);
			return (float)Math.Sqrt(num3);
		}

		/// <summary>Checks to see if a location is in the spawn protection area.</summary>
		/// <param name="x">The x coordinate to check.</param>
		/// <param name="y">The y coordinate to check.</param>
		/// <returns>If the given x,y location is in the spawn area.</returns>
		public static bool IsInSpawn(int x, int y)
		{
			Vector2 tile = new Vector2(x, y);
			Vector2 spawn = new Vector2(Main.spawnTileX, Main.spawnTileY);
			return Distance(spawn, tile) <= TShock.Config.Settings.SpawnProtectionRadius;
		}

		/// <summary>Computes the max styles...</summary>
		internal void ComputeMaxStyles()
		{
			var item = new Item();
			for (int i = 0; i < Terraria.ID.ItemID.Count; i++)
			{
				item.netDefaults(i);
				if (item.placeStyle >= 0)
				{
					if (GetDataHandlers.MaxPlaceStyles.ContainsKey(item.createTile))
					{
						if (item.placeStyle > GetDataHandlers.MaxPlaceStyles[item.createTile])
							GetDataHandlers.MaxPlaceStyles[item.createTile] = item.placeStyle;
					}
					else
						GetDataHandlers.MaxPlaceStyles.Add(item.createTile, item.placeStyle);
				}
			}
		}
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockInstaller`
#### File: `temp_TShock-5.2.4/TShockInstaller/Program.cs`
```
﻿using System.Diagnostics;
using System.IO.Compression;
using System.Runtime.InteropServices;
using ICSharpCode.SharpZipLib.GZip;
using ICSharpCode.SharpZipLib.Tar;

Console.ForegroundColor = ConsoleColor.White;
Console.WriteLine($"TShock Installer {typeof(Program).Assembly.GetName().Version}.");

// reference: https://github.com/dotnet/install-scripts/blob/main/src/dotnet-install.sh
// ./dotnet-install.sh -verbose -version 6.0.11 --runtime dotnet

Console.WriteLine("Determining dotnet runtime url...");

var arch = RuntimeInformation.ProcessArchitecture switch
{
	Architecture.X64 => "x64",
	Architecture.Arm64 => "arm64",
	_ => null
};

if (arch is null)
{
	Console.WriteLine($"{RuntimeInformation.ProcessArchitecture} is not yet supported via this installer.");
	return;
}

string? url = null;
if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
	url = $"https://dotnetcli.azureedge.net/dotnet/Runtime/6.0.11/dotnet-runtime-6.0.11-osx-{arch}.tar.gz";
else if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
	url = $"https://dotnetcli.azureedge.net/dotnet/Runtime/6.0.11/dotnet-runtime-6.0.11-win-{arch}.zip";
else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
	url = $"https://dotnetcli.azureedge.net/dotnet/Runtime/6.0.11/dotnet-runtime-6.0.11-linux-{arch}.tar.gz";

if(url is null)
{
	Console.WriteLine("Unable to determine .net runtime to install. " +
		"Refer to https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script " +
		"and install using --install-dir dotnet, so that the dotnet folder is beside TShock.Server[.exe]");
	return;
}

Console.WriteLine("Using url: " + url);

var filename = url.Split('/').Last();
var is_targz = filename.EndsWith(".tar.gz");

var download_info = new FileInfo(filename);
if (!download_info.Exists) // todo hash check
{
	Console.WriteLine($"Downloading: {filename}...");

	using var client = new HttpClient();
	using var resp = await client.GetStreamAsync(url);
	using var fs = new FileStream(filename, FileMode.Create);
	await resp.CopyToAsync(fs);
}
else
{
	Console.WriteLine("Using existing download on disk: " + filename);
}

var dotnet_path = Path.Combine("dotnet", "dotnet" + (is_targz ? "" : ".exe"));
var tshock_path = "TShock.Server" + (is_targz ? "" : ".exe");

if (!File.Exists(dotnet_path))
{
	try
	{
		Console.WriteLine("Extracting to ./dotnet/");
		if (is_targz)
		{
			using var srm_dotnet_file = File.OpenRead(filename);
			using var srm_gzip = new GZipInputStream(srm_dotnet_file);

			using var tar_archive = TarArchive.CreateInputTarArchive(srm_gzip, System.Text.Encoding.UTF8);
			tar_archive.ExtractContents("dotnet");

			[DllImport("libc", SetLastError = true)]
			static extern int chmod(string pathname, int mode);

			chmod(dotnet_path, 755);
		}
		else
		{
			ZipFile.ExtractToDirectory(filename, "dotnet");
		}
	}
	catch (Exception ex)
	{
		Console.ForegroundColor = ConsoleColor.Red;
		Console.Error.WriteLine($"Failed to extract {filename}. The archive will be removed. Restart the installer to begin the download again.");
		Console.Error.WriteLine(ex);

		if (File.Exists(filename))
			File.Delete(filename);

		return;
	}
}
else
{
	Console.WriteLine($"Extract skipped, existing found at: {dotnet_path}");
}

var dotnet_root = System.IO.Path.GetFullPath("dotnet");
Console.WriteLine($"To be able to run {tshock_path} yourself set the environment variable DOTNET_ROOT={dotnet_root}");

Environment.SetEnvironmentVariable("DOTNET_ROOT", dotnet_root);

Console.WriteLine($"Extracted, launching: {tshock_path}");

var proc = new Process();

Console.CancelKeyPress += (sender, e) =>
{
	e.Cancel = !proc.HasExited;
};

proc.StartInfo = new()
{
	 FileName = tshock_path,
};
foreach (var arg in args)
	proc.StartInfo.ArgumentList.Add(arg);
proc.Start();
await proc.WaitForExitAsync();

```
#### File: `temp_TShock-5.2.4/TShockInstaller/TShockInstaller.csproj`
```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <Version>5.0.0</Version>
    <PublishTrimmed>true</PublishTrimmed>
    <AssemblyName>TShock.Installer</AssemblyName>
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="SharpZipLib" Version="1.4.2" />
  </ItemGroup>
</Project>

```
### Folder: `temp_TShock-5.2.4/TShockLauncher.Tests`
#### File: `temp_TShock-5.2.4/TShockLauncher.Tests/ChatTests.cs`
```
using Microsoft.Xna.Framework;
using NUnit.Framework;
using Terraria.UI.Chat;

namespace TShockLauncher.Tests;

public class ChatTests
{
	/// <summary>
	/// Ensures that the <see cref="Terraria.GameContent.UI.Chat.AchievementTagHandler"/> does not cause exceptions when used on the server.
	/// </summary>
	///
	/// <remarks>The behaviour of TShock regarding the achievement tag handler changes depending on if TShock has
	/// a <see cref="Terraria.Main"/> instance or not. Therefore, we do not check the correctness of the parsed message, but only if it
	/// throws an exception.
	/// </remarks>
	[TestCase]
	public void TestChatAchievementTagHandler()
	{
		Assert.That(() =>
		{
			ChatManager.ParseMessage("No achievement tags", Color.White);
			ChatManager.ParseMessage("One achievement tag: [a:KILL_THE_SUN]", Color.White);
			ChatManager.ParseMessage("One achievement tag, using the longer variant: [achievement:KILL_THE_SUN]", Color.White);
			ChatManager.ParseMessage("Multiple achievement tags: [a:KILL_THE_SUN] and [a:TOPPED_OFF]", Color.White);
			ChatManager.ParseMessage("One achievement tag, referring to a non-existent achievement: [a:_THIS_WILL_NEVER_EXIST_]", Color.White);
			ChatManager.ParseMessage("Both valid and invalid achievement tags: [a:KILL_THE_SUN] and [a:_THIS_WILL_NEVER_EXIST_]", Color.White);
		}, Throws.Nothing);
	}
}

```
#### File: `temp_TShock-5.2.4/TShockLauncher.Tests/GroupTests.cs`
```
using NUnit.Framework;
using TShockAPI;
using TShockAPI.DB;

namespace TShockLauncher.Tests;

public class GroupTests
{
	/// <summary>
	/// This tests to ensure the group commands work.
	/// </summary>
	/// <remarks>Due to the switch to Microsoft.Data.Sqlite, nulls have to be replaced with DBNull for the query to complete</remarks>
	[TestCase]
	public void TestPermissions()
	{
		var groups = TShock.Groups = new GroupManager(TShock.DB);

		if (!groups.GroupExists("test"))
			groups.AddGroup("test", null, "test", Group.defaultChatColor);

		groups.AddPermissions("test", new() { "abc" });

		var hasperm = groups.GetGroupByName("test").Permissions.Contains("abc");
		Assert.IsTrue(hasperm);

		groups.DeletePermissions("test", new() { "abc" });

		hasperm = groups.GetGroupByName("test").Permissions.Contains("abc");
		Assert.IsFalse(hasperm);

		groups.DeleteGroup("test");

		var g = groups.GetGroupByName("test");
		Assert.IsNull(g);
	}
}


```
#### File: `temp_TShock-5.2.4/TShockLauncher.Tests/ServerInitTests.cs`
```
using NUnit.Framework;
using System;
using System.Diagnostics;
using System.Threading;

namespace TShockLauncher.Tests;

public class ServerInitTests
{
	/// <summary>
	/// This test will ensure that the TSAPI binary boots up as expected
	/// </summary>
	[TestCase]
	public void EnsureBoots()
	{
		var are = new AutoResetEvent(false);
		On.Terraria.Main.hook_DedServ cb = (On.Terraria.Main.orig_DedServ orig, Terraria.Main instance) =>
		{
			are.Set();
			Debug.WriteLine("Server init process successful");
		};
		On.Terraria.Main.DedServ += cb;

		new Thread(() => TerrariaApi.Server.Program.Main(new string[] { })).Start();

		var hit = are.WaitOne(TimeSpan.FromSeconds(10));

		On.Terraria.Main.DedServ -= cb;

		Assert.IsTrue(hit);
	}
}


```
#### File: `temp_TShock-5.2.4/TShockLauncher.Tests/TShockLauncher.Tests.csproj`
```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.3.2" />
    <PackageReference Include="NUnit" Version="3.13.3" />
    <PackageReference Include="NUnit3TestAdapter" Version="4.2.1" />
    <PackageReference Include="NUnit.Analyzers" Version="3.5.0" />
    <PackageReference Include="coverlet.collector" Version="3.1.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\TShockAPI\TShockAPI.csproj" />
    <ProjectReference Include="..\TShockLauncher\TShockLauncher.csproj" />
  </ItemGroup>

</Project>

```
#### File: `temp_TShock-5.2.4/TShockLauncher.Tests/TestSetup.cs`
```
using NUnit.Framework;
using Terraria;
using Terraria.Initializers;
using Terraria.Localization;
using TShockAPI;

namespace TShockLauncher.Tests;

[SetUpFixture]
public class TestSetup
{
	/// <summary>
	/// This will be called automatically by NUnit before the first test.
	/// It serves to initialise the bare minimum variables needed for TShock to be testable without booting up an actual server.
	/// </summary>
	[OneTimeSetUp]
	public static void SetupTShock()
	{
		ChatInitializer.Load();

		Program.SavePath = ""; // 1.4.4.2 staticness introduced this where by default it is null, and any touch to Terraria.Main will use it and cause a crash.
		LanguageManager.Instance.SetLanguage(GameCulture.DefaultCulture); // TShockAPI.Localization will fail without ActiveCulture set
		Lang.InitializeLegacyLocalization(); // TShockAPI.Localization will fail without preparing NPC names etc

		var ts = new TShock(null); // prepares configs etc
		ts.Initialize(); // used to prepare tshocks own static variables, such as the TShock.DB instance
	}
}

```
### Folder: `temp_TShock-5.2.4/TShockLauncher`
#### File: `temp_TShock-5.2.4/TShockLauncher/.gitignore`
```
/packages

```
#### File: `temp_TShock-5.2.4/TShockLauncher/Program.cs`
```
﻿/*
TShock, a server mod for Terraria
Copyright (C) 2021-2022 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
 * The purpose of this project is to be the launcher of the TSAPI server.
 * We use this project:
 *	- to copy/move around TShockAPI.dll (the TShock plugin to TSAPI)
 *	- to publish TShock releases.
 *	- move dependencies to a ./bin folder
 *
 * The assembly name of this launcher (TShock.exe) was decided on by a community poll.
 */

using System.Reflection;
using TShockPluginManager;

// On occasion, users have been seen extracting TShock into their client installation directory -- this is of course incorrect, and is known
// to cause issues. Let's attempt to catch this before anything happens (specifically, before Terraria assemblies are resolved) and prevent
// TShock from launching.
if (File.Exists("TerrariaServer.exe"))
{
	Console.ForegroundColor = ConsoleColor.Red;
	Console.Error.WriteLine("A \"TerrariaServer.exe\" file has been found in the current working directory.");
	Console.Error.WriteLine(
		"This indicates either installation into a Terraria client directory, or installation into a legacy (TShock 4 or older) TShock directory.");
	Console.Error.WriteLine(
		"TShock is never to be installed inside a Terraria client directory. You should instead extract your TShock installation into it's own directory.");
	Console.Error.WriteLine(
		"If you are updating a legacy TShock installation, please follow the following documentation to update: https://ikebukuro.tshock.co/#/?id=upgrading-from-tshock-4");
	Console.Error.WriteLine("The launcher will now exit.");
	Console.ResetColor();
	return 1;
}

if (args.Length > 0 && args[0].ToLower() == "plugins")
{
	var items = args.ToList();
	items.RemoveAt(0);
	await NugetCLI.Main(items);
	return 0;
}


Dictionary<string, Assembly> _cache = new Dictionary<string, Assembly>();

System.Runtime.Loader.AssemblyLoadContext.Default.Resolving += Default_Resolving;

return Start();

/// <summary>
/// Resolves a module from the ./bin folder, either with a .dll by preference or .exe
/// </summary>
Assembly? Default_Resolving(System.Runtime.Loader.AssemblyLoadContext arg1, AssemblyName arg2)
{
	if (arg2?.Name is null) return null;
	if (_cache.TryGetValue(arg2.Name, out Assembly? asm) && asm is not null) return asm;

	var loc = Path.Combine(AppContext.BaseDirectory, "bin", arg2.Name + ".dll");
	if (File.Exists(loc))
		asm = arg1.LoadFromAssemblyPath(loc);

	loc = Path.ChangeExtension(loc, ".exe");
	if (File.Exists(loc))
		asm = arg1.LoadFromAssemblyPath(loc);

	if(asm is not null)
		_cache[arg2.Name] = asm;

	return asm;
}

/// <summary>
/// Initiates the TSAPI server.
/// </summary>
/// <remarks>This method exists so that the resolver can attach before TSAPI needs its dependencies.</remarks>
int Start()
{
	TerrariaApi.Server.Program.Main(args);
	return 0;
}

```
#### File: `temp_TShock-5.2.4/TShockLauncher/TShockLauncher.csproj`
```
﻿<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<TargetFramework>net6.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
		<AssemblyName>TShock.Server</AssemblyName> <!-- TShock was initially decided on by a community poll, however tshock already exists as a folder and will clash -->
		<RunPostBuildEvent>Always</RunPostBuildEvent>
		<DebugType>embedded</DebugType>
		<IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract> <!-- needed for sqlite native libs -->
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\TerrariaServerAPI\TerrariaServerAPI\TerrariaServerAPI.csproj" ExcludeFromSingleFile="true" />
		<ProjectReference Include="..\TShockAPI\TShockAPI.csproj" ExcludeFromSingleFile="true" ReferenceOutputAssembly="false" /> <!-- allow api to rebuilt with this project, so ServerPlugins are refreshed -->
		<ProjectReference Include="..\TShockPluginManager\TShockPluginManager.csproj"/>
		<Reference Include="HttpServer" ExcludeFromSingleFile="true">
			<HintPath>..\prebuilts\HttpServer.dll</HintPath>
		</Reference>
	</ItemGroup>

	<ItemGroup>
		<None Include="..\prebuilts\GeoIP.dat">
		  <Link>GeoIP.dat</Link>
		  <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
		  <ExcludeFromSingleFile>true</ExcludeFromSingleFile>
		</None>
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
		<PackageReference Include="MySql.Data" Version="8.4.0" />
		<PackageReference Include="Microsoft.Data.Sqlite" Version="6.0.11" />
		<PackageReference Include="ModFramework" Version="1.1.7" GeneratePathProperty="true" /> <!-- only used to extract out to ./bin. -->
		<PackageReference Include="GetText.NET" Version="1.7.14" /> <!-- only used to extract out to ./bin. -->

		<!-- the launcher doesnt need the direct OTAPI reference, but since PackageReference[ExcludeFromSingleFile] doesnt work, exclude the assets and copy manually -->
		<PackageReference Include="OTAPI.Upcoming" Version="3.1.20" ExcludeAssets="all" GeneratePathProperty="true" />
		<None Include="$(PkgOTAPI_Upcoming)\lib\net6.0\OTAPI.dll">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
			<ExcludeFromSingleFile>true</ExcludeFromSingleFile>
		</None>
		<None Include="$(PkgOTAPI_Upcoming)\lib\net6.0\OTAPI.Runtime.dll">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
			<ExcludeFromSingleFile>true</ExcludeFromSingleFile>
		</None>
		<None Include="$(PkgModFramework)\lib\net6.0\ModFramework.dll">
		  <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
		  <ExcludeFromSingleFile>true</ExcludeFromSingleFile>
		</None>
	</ItemGroup>

	<Target Name="CheckMsgfmtCallable">
		<Exec Command="msgfmt --help > NUL" IgnoreExitCode="True" Condition=" '$(OS)' == 'Windows_NT' ">
			<Output TaskParameter="ExitCode" PropertyName="MsgfmtExitCode" />
		</Exec>
		<Exec Command="msgfmt --help 2>/dev/null >/dev/null" IgnoreExitCode="True" Condition=" '$(OS)' != 'Windows_NT' ">
			<Output TaskParameter="ExitCode" PropertyName="MsgfmtExitCode" />
		</Exec>
	</Target>

	<!-- The condition for a Target can't come from the values of another target, so instead we have to put the same condition on all three of the items inside. -->
	<Target
		Name="GenerateMOFiles"
		DependsOnTargets="CheckMsgfmtCallable"
		AfterTargets="PostBuildEvent;Publish"
		Inputs="..\i18n\**\*.po"
		Outputs="$(OutDir)i18n\**\*.mo">
		<ItemGroup Condition="'$(MsgfmtExitCode)' == '0'">
			<POFiles Include="..\i18n\**\*.po" />
		</ItemGroup>
		<MakeDir Directories="$(OutDir)i18n/%(POFiles.RecursiveDir)" Condition="'$(MsgfmtExitCode)' == '0'" />
		<Exec Command="msgfmt -o $(OutDir)i18n/%(RecursiveDir)%(Filename).mo @(POFiles)" Outputs="$(OutDir)i18n\**\*.mo" Condition="'$(MsgfmtExitCode)' == '0'">
			<Output ItemName="Generated" TaskParameter="Outputs"/>
		</Exec>
	</Target>

	<Target Name="CreateServerPlugins" AfterTargets="PostBuildEvent;Publish">
		<MakeDir Directories="$(OutDir)ServerPlugins" />
		<MakeDir Directories="$(PublishDir)ServerPlugins" />
		<ItemGroup>
			<ApiFiles Include="$(ProjectDir)../TShockAPI/bin/$(Configuration)/$(TargetFramework)/TShockAPI*" />
		</ItemGroup>
		<Copy SourceFiles="@(ApiFiles)" DestinationFolder="$(OutDir)ServerPlugins" ContinueOnError="true" />
		<Copy SourceFiles="@(ApiFiles)" DestinationFolder="$(PublishDir)ServerPlugins" ContinueOnError="true" />
	</Target>
	<Target Name="CopyI18n" AfterTargets="Publish">
		<ItemGroup>
			<MOFiles Include="$(OutDir)**/*.mo"/>
		</ItemGroup>
		<Copy SourceFiles="@(MOFiles)" DestinationFolder="$(PublishDir)%(RecursiveDir)" />
	</Target>
	<Target Name="MoveBin" AfterTargets="Publish">
		<ItemGroup>
			<MoveBinaries Include="$(PublishDir)*" Exclude="$(PublishDir)\TShock.Server*;$(PublishDir)\GeoIP.dat" />
		</ItemGroup>
		<Move SourceFiles="@(MoveBinaries)" DestinationFolder="$(PublishDir)bin" ContinueOnError="true" />
	</Target>
</Project>

```
### Folder: `temp_TShock-5.2.4/TShockPluginManager`
#### File: `temp_TShock-5.2.4/TShockPluginManager/CLIHelpers.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2022 Janet Blackquill

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Text;

namespace TShockPluginManager
{
	static class CLIHelpers
	{
		static public bool YesNo()
		{
			System.Console.Write("[y/n] ");
			bool accept;
			bool confirm = false;
			do
			{
				ConsoleKey response = Console.ReadKey(true).Key;
				(accept, confirm) = response switch {
					ConsoleKey.Y => (true, true),
					ConsoleKey.N => (false, true),
					_ => (false, false)
				};
			} while (!confirm);
			if (accept)
				System.Console.WriteLine("yes");
			else
				System.Console.WriteLine("no");
			return accept;
		}
		public enum Answers {
			Yes,
			No,
			Explain
		}
		static public Answers YesNoExplain()
		{
			System.Console.Write("[y/n/e] ");
			Answers ans;
			bool confirm = false;
			do
			{
				ConsoleKey response = Console.ReadKey(true).Key;
				(ans, confirm) = response switch {
					ConsoleKey.Y => (Answers.Yes, true),
					ConsoleKey.N => (Answers.No, true),
					ConsoleKey.E => (Answers.Explain, true),
					_ => (Answers.Explain, false)
				};
			} while (!confirm);
			if (ans == Answers.Yes)
				System.Console.WriteLine("yes");
			else if (ans == Answers.No)
				System.Console.WriteLine("no");
			else
				System.Console.WriteLine("explain");
			return ans;
		}
		static private string[] ColorNames = Enum.GetNames(typeof(ConsoleColor));
		static public void Write(string text)
		{
			var initial = Console.ForegroundColor;

			var buffer = new StringBuilder();
			var chars = text.ToCharArray().ToList();
			while (chars.Count > 0)
			{
				var ch = chars.First();
				if (ch == '<')
				{
					var possibleColor = new string(chars.Skip(1).TakeWhile(c => c != '>').ToArray());
					Func<string, bool> predicate = x => string.Equals(x, possibleColor, StringComparison.CurrentCultureIgnoreCase);
					if (!ColorNames.Any(predicate))
						goto breakFromIf;
					var color = ColorNames.First(predicate);
					if (buffer.Length > 0)
					{
						Console.Write(buffer.ToString());
						buffer.Clear();
					}
					Console.ForegroundColor = Enum.Parse<ConsoleColor>(color);
					chars = chars.Skip(2 + possibleColor.Length).ToList();
					continue;
				}
			breakFromIf:
				buffer.Append(ch);
				chars.RemoveAt(0);
			}

			if (buffer.Length > 0)
				Console.Write(buffer.ToString());

			Console.ForegroundColor = initial;
		}
		static public void WriteLine(string text)
		{
			Write(text + "\n");
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockPluginManager/I18n.cs`
```
using GetText;

namespace TShockPluginManager
{
	static class I18n
	{
		static string TranslationsDirectory => Path.Combine(AppContext.BaseDirectory, "i18n");
		// we share the same translations catalog as TShockAPI
		public static Catalog C = new Catalog("TShockAPI", TranslationsDirectory);
	}
}

```
#### File: `temp_TShock-5.2.4/TShockPluginManager/Nuget.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2022 Janet Blackquill

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System.Reflection;
using System.Runtime.InteropServices;
using NuGet.Common;
using NuGet.Configuration;
using NuGet.Frameworks;
using NuGet.Packaging;
using NuGet.Packaging.Core;
using NuGet.Packaging.Signing;
using NuGet.Protocol.Core.Types;
using NuGet.Resolver;
using NuGet.Versioning;

namespace TShockPluginManager
{
	public class Nugetter
	{
		// this object can figure out the right framework folders to use from a set of packages
		private FrameworkReducer FrameworkReducer;
		// the package framework we want to install
		private NuGetFramework NuGetFramework;
		// nuget settings
		private ISettings Settings;
		// this is responsible for bookkeeping the folders that nuget touches
		private NuGetPathContext PathContext;
		// this is responsible for managing the package sources
		private PackageSourceProvider PackageSourceProvider;
		// this is responsible for managing the repositories of packages from all of the package sources
		private SourceRepositoryProvider SourceRepositoryProvider;
		// this can tell us the paths of local packages
		private PackagePathResolver PackagePathResolver;
		// this is possible for bookkeeping the extraction state of packages
		private PackageExtractionContext PackageExtractionContext;

		public Nugetter()
		{
			FrameworkReducer = new FrameworkReducer();
			NuGetFramework = NuGetFramework.ParseFolder("net6.0");
			Settings = NuGet.Configuration.Settings.LoadDefaultSettings(root: null);
			PathContext = NuGetPathContext.Create(Settings);
			PackageSourceProvider = new PackageSourceProvider(Settings);
			SourceRepositoryProvider = new SourceRepositoryProvider(PackageSourceProvider, Repository.Provider.GetCoreV3());
			PackagePathResolver = new PackagePathResolver(Path.GetFullPath("packages"));
			PackageExtractionContext = new PackageExtractionContext(
				PackageSaveMode.Defaultv3,
				XmlDocFileSaveMode.Skip,
				ClientPolicyContext.GetClientPolicy(Settings, NullLogger.Instance),
				NullLogger.Instance);
		}

		async Task GetPackageDependencies(
			PackageIdentity package,
			NuGetFramework framework,
			SourceCacheContext cacheContext,
			ILogger logger,
			IEnumerable<SourceRepository> repositories,
			ISet<SourcePackageDependencyInfo> availablePackages)
		{
			// if we've already gotten dependencies for this package, don't
			if (availablePackages.Contains(package)) return;

			foreach (var sourceRepository in repositories)
			{
				// make sure the source repository can actually tell us about dependencies
				var dependencyInfoResource = await sourceRepository.GetResourceAsync<DependencyInfoResource>();
				// get the try and dependencies
				if (dependencyInfoResource is null) continue;
				var dependencyInfo = await dependencyInfoResource.ResolvePackage(
					package, framework, cacheContext, logger, CancellationToken.None);

				// oop, we don't have the ability to get dependency info from this repository, or
				// it wasn't found. let's try the next source repository!
				if (dependencyInfo is null) continue;

				availablePackages.Add(dependencyInfo);
				foreach (var dependency in dependencyInfo.Dependencies)
				{
					// make sure we get the dependencies of the dependencies of the dependencies ... as well
					await GetPackageDependencies(
						new PackageIdentity(dependency.Id, dependency.VersionRange.MinVersion),
						framework, cacheContext, logger, repositories, availablePackages);
				}
			}
		}

		/// <returns>all the packages representing dependencies bundled with TShock.Server</returns>
		public async Task<IEnumerable<SourcePackageDependencyInfo>> GetAllBuiltinDependencies()
		{
			// this is a convenient approximation of what dependencies will be included with TShock.Server
			// and really only needs to be updated if new third-party dependencies are added

			var knownBundles = new[] {
				new PackageIdentity("GetText.NET", NuGetVersion.Parse("1.6.6")),
				new PackageIdentity("OTAPI.Upcoming", NuGetVersion.Parse("3.1.8-alpha")),
				new PackageIdentity("TSAPI", NuGetVersion.Parse("5.0.0-beta")),
				new PackageIdentity("TShock", NuGetVersion.Parse("5.0.0-beta")),
			};

			return await GetAllDependenciesFor(knownBundles);
		}

		/// <returns>all the dependencies for the provided package identities</returns>
		public async Task<IEnumerable<SourcePackageDependencyInfo>> GetAllDependenciesFor(IEnumerable<PackageIdentity> targets)
		{
			using var cacheContext = new SourceCacheContext();

			// get all of the possible packages in our dependency tree
			var possiblePackages = new HashSet<SourcePackageDependencyInfo>(PackageIdentityComparer.Default);
			foreach (var target in targets)
			{
				await GetPackageDependencies(
					target,
					NuGetFramework,
					cacheContext,
					NullLogger.Instance,
					SourceRepositoryProvider.GetRepositories(),
					possiblePackages
				);
			}

			var resolverContext = new PackageResolverContext(
				// select minimum possible versions
				DependencyBehavior.Lowest,
				// these are the packages the user wanted
				targets.Select(x => x.Id),
				// we don't hard-require anything
				Enumerable.Empty<string>(),
				// we don't have a lockfile
				Enumerable.Empty<PackageReference>(),
				// we don't have fancy versioning
				Enumerable.Empty<PackageIdentity>(),
				// these are the packages that we figured out are in the dependency tree from nuget
				possiblePackages,
				// all the package sources
				SourceRepositoryProvider.GetRepositories().Select(s => s.PackageSource),
				NullLogger.Instance
			);

			var resolver = new PackageResolver();
			var packagesToInstall =
				// get the resolved versioning info from the resolver
				resolver.Resolve(resolverContext, CancellationToken.None)
					// and use that to select the specific packages to install from the possible packages
					.Select(p => possiblePackages.Single(x => PackageIdentityComparer.Default.Equals(x, p)));

			return packagesToInstall;
		}

		/// <returns>whether or not subPath is a subpath of basePath</returns>
		public static bool IsSubPathOf(string subPath, string basePath)
		{
			var rel = Path.GetRelativePath(basePath, subPath);
			return rel != "."
				&& rel != ".."
				&& !rel.StartsWith("../")
				&& !rel.StartsWith(@"..\")
				&& !Path.IsPathRooted(rel);
		}

		/// <returns>items required for end-user running of a package</returns>
		public IEnumerable<FrameworkSpecificGroup> ItemsToInstall(PackageReaderBase packageReader)
		{
			var libItems = packageReader.GetLibItems();
			var libnearest = FrameworkReducer.GetNearest(NuGetFramework, libItems.Select(x => x.TargetFramework));
			libItems = libItems.Where(x => x.TargetFramework.Equals(libnearest));

			var frameworkItems = packageReader.GetFrameworkItems();
			var fwnearest = FrameworkReducer.GetNearest(NuGetFramework, frameworkItems.Select(x => x.TargetFramework));
			frameworkItems = frameworkItems.Where(x => x.TargetFramework.Equals(fwnearest));

			return libItems.Concat(frameworkItems);
		}

		/// <returns>path to package folder and metadata reader</returns>
		public async Task<(string, PackageReaderBase)> GetOrDownloadPackage(SourcePackageDependencyInfo pkg)
		{
			using var cacheContext = new SourceCacheContext();

			PackageReaderBase packageReader;
			string pkgPath;
			// already installed?
			if (PackagePathResolver.GetInstalledPath(pkg) is string path)
			{
				// we're gaming
				packageReader = new PackageFolderReader(path);
				pkgPath = path;
			}
			else
			{
				// gotta download it...
				var downloadResource = await pkg.Source.GetResourceAsync<DownloadResource>(CancellationToken.None);
				Console.WriteLine($"Downloading {pkg.Id}...");
				var downloadResult = await downloadResource.GetDownloadResourceResultAsync(
					pkg,
					new PackageDownloadContext(cacheContext),
					SettingsUtility.GetGlobalPackagesFolder(Settings),
					NullLogger.Instance, CancellationToken.None);
				packageReader = downloadResult.PackageReader;
				Console.WriteLine($"Extracting {pkg.Id}...");
				// and extract the package
				await PackageExtractor.ExtractPackageAsync(
					downloadResult.PackageSource,
					downloadResult.PackageStream,
					PackagePathResolver,
					PackageExtractionContext,
					CancellationToken.None);

				if (PackagePathResolver.GetInstalledPath(pkg) is string loc)
				{
					pkgPath = loc;
				}
				else
				{
					pkgPath = null;
					// die somehow
				}
			}
			return (pkgPath, packageReader);
		}

		/// <returns>resolved packages to be installed for what the user requested</returns>
		public async Task<IEnumerable<SourcePackageDependencyInfo>> GetPackagesToInstallFor(PackageIdentity[] userRequest)
		{
			using var cacheContext = new SourceCacheContext();
			return (await GetAllDependenciesFor(userRequest)).OrderBy(v => v.Id);
		}

		/// <summary>installs a locally downloaded package</summary>
		public void InstallPackage(SourcePackageDependencyInfo pkg, string pkgPath, PackageReaderBase packageReader)
		{
			// objects to help us detect if packages already come with the .NET distribution
			string[] runtimeAssemblies = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");
			var paResolver = new PathAssemblyResolver(runtimeAssemblies);
			using var mlc = new MetadataLoadContext(paResolver);

			// packages can declare themselves as plugin via the TShockPlugin package type
			var isPlugin = packageReader.NuspecReader.GetPackageTypes().Any(v => v.Name == "TShockPlugin");

			Console.WriteLine($"Installing {pkg.Id}...");

			foreach (var item in ItemsToInstall(packageReader))
			{
				var files = item.Items;
				if (item.Items.Count() == 0)
					continue;

				// the common ancestor directory of all files in the package.
				// if a package has the following files:
				// - /home/orwell/packages/FooBar/hi.dll
				// - /home/orwell/packages/FooBar/en-US/hi.resources.dll
				// - /home/orwell/packages/FooBar/de-DE/hi.resources.dll
				// - /home/orwell/packages/FooBar/ar-AR/hi.resources.dll
				// this will be /home/orwell/packages/FooBar
				var rootmostPath = files
					.Select(x => Path.Join(pkgPath, x))
					.Aggregate(Path.GetDirectoryName(Path.Join(pkgPath, files.First())), (acc, x) =>
						IsSubPathOf(acc!, Path.GetDirectoryName(x)!) ?
							Path.GetDirectoryName(x) :
							acc);

				foreach (var file in files)
				{
					// the absolute path of the package on the filesystem
					var filePath = Path.Join(pkgPath, file);
					// the path of the package relative to the package root
					var packageRelativeFilePath = filePath.Substring(rootmostPath!.Length);
					bool alreadyExists;
					// if it's a .dll, we try to detect if we already have the assemblies
					// (e.g. because we bundle them in TShock.Server or the .NET runtime comes)
					// with them
					if (file.EndsWith(".dll"))
					{
						var asms = AppDomain.CurrentDomain.GetAssemblies();
						var asm = mlc.LoadFromAssemblyPath(filePath);
						alreadyExists = asms.Any(a => a.GetName().Name == asm.GetName().Name);
					}
					else alreadyExists = false;

					// if it already exists, skip. but only if it's not an explicitly requested plugin.
					if (alreadyExists && !isPlugin)
						continue;

					var relativeFolder = Path.GetDirectoryName(packageRelativeFilePath);
					var targetFolder = Path.Join(isPlugin ? "./ServerPlugins" : "./bin", relativeFolder);
					if (File.Exists(filePath))
					{
						Directory.CreateDirectory(targetFolder);
						File.Copy(filePath, Path.Join(targetFolder, Path.GetFileName(filePath)), true);
					}
				}
			}
		}

		/// <summary>downloads and installs the given packages</summary>
		public async Task DownloadAndInstall(PackageIdentity[] userRequest)
		{
			var packagesToInstall = await GetAllDependenciesFor(userRequest);
			var builtins = await GetAllBuiltinDependencies();

			foreach (var pkg in packagesToInstall)
			{
				var bundled = builtins!.Where(x => x.Id == pkg.Id).FirstOrDefault();
				if (bundled != null)
					continue;

				(string pkgPath, PackageReaderBase packageReader) = await GetOrDownloadPackage(pkg);
				InstallPackage(pkg, pkgPath, packageReader);
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockPluginManager/NugetCLI.cs`
```
/*
TShock, a server mod for Terraria
Copyright (C) 2022 Janet Blackquill

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

global using static TShockPluginManager.I18n;

using System.CommandLine;
using System.Text.Json;
using System.Text.Json.Serialization;
using NuGet.Packaging.Core;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;

namespace TShockPluginManager
{
	public static class NugetCLI
	{
		static public async Task<int> Main(List<string> args)
		{
			RootCommand root = new RootCommand(
				description: C.GetString("Manage plugins and their requirements")
			);
			Command cmdSync = new Command(
				name: "sync",
				description: C.GetString("Install the plugins as specified in the plugins.json")
			);
			cmdSync.SetHandler(Sync);
			root.Add(cmdSync);
			return await root.InvokeAsync(args.ToArray());
		}
		class SyncManifest
		{
			[JsonPropertyName("packages")]
			public Dictionary<string, NuGetVersion> Packages { get; set; } = new();
			public PackageIdentity[] GetPackageIdentities() =>
				Packages.Select((kvp) => new PackageIdentity(kvp.Key, kvp.Value))
						.OrderBy(kvp => kvp.Id)
						.ToArray();
		}
		public class NuGetVersionConverter : JsonConverter<NuGetVersion>
		{
			public override NuGetVersion? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			{
				return NuGetVersion.Parse(reader.GetString()!);
			}

			public override void Write(Utf8JsonWriter writer, NuGetVersion value, JsonSerializerOptions options)
			{
				writer.WriteStringValue(value.ToNormalizedString());
			}
		}
		static async Task Sync()
		{
			var opts = new JsonSerializerOptions
			{
				ReadCommentHandling = JsonCommentHandling.Skip,
				Converters =
				{
					new NuGetVersionConverter()
				}
			};
			SyncManifest manifest;
			try
			{
				string txt = await File.ReadAllTextAsync("packages.json");
				manifest = JsonSerializer.Deserialize<SyncManifest>(txt, opts)!;
			}
			catch (System.IO.FileNotFoundException)
			{
				CLIHelpers.WriteLine(C.GetString("You're trying to sync, but you don't have a packages.json file."));
				CLIHelpers.WriteLine(C.GetString("Without a list of plugins to install, no plugins can be installed."));
				return;
			}
			catch (System.Text.Json.JsonException e)
			{
				CLIHelpers.WriteLine(C.GetString("There was an issue reading the packages.json."));
				CLIHelpers.WriteLine($"{e.Message}");
				return;
			}
			foreach (var item in manifest.GetPackageIdentities())
			{
				CLIHelpers.WriteLine($"<green>{item.Id}<black> [{item.Version}]");
			}
			var numWanted = manifest.GetPackageIdentities().Count();
			CLIHelpers.WriteLine(C.GetPluralString("This is the plugin you requested to install.", "These are the plugins you requested to install", numWanted));
			CLIHelpers.WriteLine(C.GetString("Connect to the internet to figure out what to download?"));
			if (!CLIHelpers.YesNo())
				return;
			CLIHelpers.WriteLine(C.GetString("One moment..."));

			var nugetter = new Nugetter();
			PackageIdentity[] userRequests;
			IEnumerable<SourcePackageDependencyInfo> packagesToInstall;
			IEnumerable<SourcePackageDependencyInfo> builtinDependencies;
			IEnumerable<SourcePackageDependencyInfo> directlyRequestedPackages;
			IEnumerable<SourcePackageDependencyInfo> indirectlyRequiredPackages;
			try
			{
				userRequests = manifest.GetPackageIdentities();
				packagesToInstall = await nugetter.GetPackagesToInstallFor(manifest.GetPackageIdentities());
				builtinDependencies = await nugetter.GetAllBuiltinDependencies();
				directlyRequestedPackages = packagesToInstall.Where(x => userRequests.Any(y => x.Id == y.Id));
				indirectlyRequiredPackages = packagesToInstall.Where(x => !userRequests.Any(y => x.Id == y.Id));
			}
			catch (NuGet.Resolver.NuGetResolverInputException e)
			{
				CLIHelpers.WriteLine(C.GetString("There was an issue figuring out what to download."));
				CLIHelpers.WriteLine($"{e.Message}");
				return;
			}
			catch (NuGet.Resolver.NuGetResolverConstraintException e)
			{
				CLIHelpers.WriteLine(C.GetString("The versions of plugins you requested aren't compatible with eachother."));
				CLIHelpers.WriteLine(C.GetString("Read the message below to find out more."));
				CLIHelpers.WriteLine($"{e.Message}");
				return;
			}

			CLIHelpers.WriteLine(C.GetPluralString("=== Requested Plugin ===", "=== Requested Plugins ===", directlyRequestedPackages.Count()));
			foreach (var item in directlyRequestedPackages)
				DumpOne(item, builtinDependencies);
			CLIHelpers.WriteLine(C.GetPluralString("=== Dependency ===", "=== Dependencies ===", indirectlyRequiredPackages.Count()));
			foreach (var item in indirectlyRequiredPackages)
				DumpOne(item, builtinDependencies);

			CLIHelpers.WriteLine(C.GetString("Download and install the given packages?"));
			CLIHelpers.WriteLine(C.GetString("Make sure that you trust the plugins you're installing."));
			CLIHelpers.WriteLine(C.GetString("If you want to know which plugins need which dependencies, press E."));

			bool ok = false;
			do
			{
				switch (CLIHelpers.YesNoExplain())
				{
					case CLIHelpers.Answers.Yes:
						ok = true;
						break;

					case CLIHelpers.Answers.No:
						return;

					case CLIHelpers.Answers.Explain:
						foreach (var pkg in directlyRequestedPackages)
						{
							DumpGraph(pkg, packagesToInstall, builtinDependencies, 0);
						}
						CLIHelpers.WriteLine(C.GetString("Download and install the given packages?"));
						CLIHelpers.WriteLine(C.GetString("If you'd like to see which plugins need which dependencies again, press E."));
						break;
				}
			} while (!ok);

			await nugetter.DownloadAndInstall(userRequests);

			CLIHelpers.WriteLine(C.GetString("All done! :)"));
		}
		static public void DumpOne(SourcePackageDependencyInfo pkg, IEnumerable<SourcePackageDependencyInfo> builtins)
		{
			if (builtins.Any(x => x.Id == pkg.Id))
				return;

			var initial = Console.ForegroundColor;

			CLIHelpers.WriteLine(C.GetString($"<green>{pkg.Id}<black> from <blue>{pkg.Source.PackageSource.Name} <black>[{pkg.Source.PackageSource.Source}]"));

			Console.ForegroundColor = initial;
		}
		static public void DumpGraph(SourcePackageDependencyInfo from, IEnumerable<SourcePackageDependencyInfo> data, IEnumerable<SourcePackageDependencyInfo> builtins, int level)
		{
			var indent = new String('\t', level);
			Console.Write(indent);

			CLIHelpers.WriteLine(C.GetString($"<green>{from.Id} <black>from <blue>{from.Source.PackageSource.Name} <black>[{from.Source.PackageSource.Source}]"));

			foreach (var dep in from.Dependencies)
			{
				if (!builtins.Any(x => x.Id == dep.Id))
				{
					DumpGraph(data.Single(x => x.Id == dep.Id), data, builtins, level + 1);
				}
			}
		}
	}
}

```
#### File: `temp_TShock-5.2.4/TShockPluginManager/TShockPluginManager.csproj`
```
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
		<PackageReference Include="NuGet.Packaging" Version="6.3.4" />
		<PackageReference Include="NuGet.Protocol" Version="6.3.3" />
		<PackageReference Include="NuGet.Resolver" Version="6.3.1" />
		<PackageReference Include="System.CommandLine" Version="2.0.0-beta4.22272.1" />
    <PackageReference Include="System.Reflection.MetadataLoadContext" Version="6.0.0" />
    <PackageReference Include="GetText.NET" Version="1.7.14" />
  </ItemGroup>

</Project>

```
### Folder: `temp_TShock-5.2.4`
#### File: `temp_TShock-5.2.4/appveyor.yml`
```
version: '{build}'
max_jobs: 16
image: Visual Studio 2022
build_script:
- ps: >-
    git submodule update --init --recursive

    dotnet build TShock.sln

    dotnet test
artifacts:
- path: ./TShockLauncher/bin/Debug/net6.0
  name: TShockAVDebug

```
#### File: `temp_TShock-5.2.4/crowdin.yml`
```
commit_message: "[skip actions]"

files:
  - source: /i18n/template.pot
    translation: /i18n/%locale_with_underscore%/TShockAPI.po

```
### Folder: `temp_TShock-5.2.4/docs`
#### File: `temp_TShock-5.2.4/docs/CNAME`
```
ikebukuro.tshock.co
```
#### File: `temp_TShock-5.2.4/docs/_sidebar.md`
```
* [☕️⚡️ TShock documentation home](/)
* [Changelog](/changelog.md)
* [Command line parameters](/command-line-parameters.md)
* [Docker setup](/docker.md)

* Subsystems
  * [Tile providers](/tile-providers.md)
  * [Message-of-the-day](/motd.md)
  * [Server-side characters](/ssc.md)
  * [Languages](/lang.md)

* Field definitions
  * [Permissions](/permission-descriptions.md)
  * [REST fields](/rest-fields.md)
  * [config.json fields](/config-file-descriptions.md)
  * [sscconfig.json fields](/ssc-config.md)

* Developer documentation
  * [i18n in the tshock project](/i18n.md)

```
#### File: `temp_TShock-5.2.4/docs/changelog.md`
```
The changelog has moved to the wiki. In lieu of this, please put the text you want in the changelog in your PR description. It will be added to the wiki after we merge your PR.

```
#### File: `temp_TShock-5.2.4/docs/command-line-parameters.md`
```
The following parameters can be added to TShock to alter the way a server initializes. Options set on the command line override any of their counterparts in the config file. These can be used either for personal use or in a GSP environment for easier hosting without hassle:

* `-ip` - Starts the server bound to a given IPv4 address. For example: `-ip 0.0.0.0` will bind all interfaces. In contrast, `-ip 127.0.0.1` will bind only `127.0.0.1`. If your interface has another IP address assigned to it, you should be able to bind that.
* `-port` - Starts the server bound to a given port. For example: `-port 7777` will use the default port for Terraria. `-port 25565` will use the Minecraft default port. Ports below `1000` usually require administrator or root privileges to bind on most operating systems. You will also need to allow accessing this port from your firewall, and port forward this port.
* `-maxplayers`, or `-players` - Starts the server with a given player count. For example: `-maxplayers 5` sets the maximum number of players to 5. The theoretical maximum is `255`. You can set `-maxplayers 255` for this.
* `-world` - Starts the server and immediately loads a given world file. Note: this parameter expects an absolute path. For example: `-world C:\Terraria\MyWorld.wld` or `-world /root/MyWorld.wld`.
* `-worldselectpath` - Starts the server and changes the location for worlds to be the specified path. The server will look in this path for worlds to load. For example: `-worldselectpath /root` or `-worldselectpath C:\Terraria`.
* `-worldname` - Starts the server using the world name that exists in the set `world select path`. For example, if `MyWorld.wld` is inside `C:\Terraria\` and `-worldselectpath C:\Terraria\` is set, then `-worldname MyWorld` will load that world.
* `-autocreate` - Starts the server and, if a world file isn't found, automatically create the world file with a given size, 1-3, 1 being small. For example, set `-autocreate 3` to create a large world.
* `-config` - Starts the server with a given config file. For example, `-config C:\Terraria\config.json`.
* `-ignoreversion` - Ignores API version checks for plugins allowing for old plugins to run.
* `-forceupdate` - Forces the server to continue running, and not hibernating when no players are on. This results in time passing, grass growing, and cpu running.
* `-pass`, `-password` - Sets the server password. For example, `-pass mypassword` will set the password to `mypassword`.
* `-motd` - Sets the base game MOTD. For example, `-motd "Welcome to my server!"` will set the MOTD to `Welcome to my server!`.
* `-autoshutdown` - Enables the base game's "auto shutdown" feature.
* `-secure` - Turns on the base game's "antispam" feature.
* `-configpath` - Specifies the path tshock uses to resolve configs, log files, and sqlite db. For example, `-configpath C:\Terraria\` will set the config path to `C:\Terraria\`.
* `-logpath` - Overrides the default log path and saves logs here. For example, `-logpath C:\Terraria\` will set the log path to `C:\Terraria\`.
* `-logformat` - Changes the format of the name of log files, subject to C# date standard abbreviations. For example, `-logformat "yyyy-MM-dd"` will create a new log file for each day. The default is `yyyy-MM-dd_HH-mm-ss`.
* `-logclear` - Overwrites old config if it exists. Useful for docker. For example, `-logclear`.
* `-dump` - Dumps permissions and config file descriptions for documentation purposes.
* `-worldevil` - Sets the world's evil state (`random`, `corrupt`, or `crimson`). This only affects new worlds. For example, `-worldevil random` will set the world to a random evil state.
* `-heaptile` - Runs the server with the heaptile tile provider. HeapTile is an alternative ITile provider that uses less memory than the default. This is experimental and may cause issues. For example, `-heaptile`.
* `-constileation` or `-c` - Runs the server with the Constileation tile provider. Constileation is an alternative ITile provider that uses less memory than the default. This is experimental and may cause issues. For example, `-constileation`.
* `-difficulty` - Sets the world's difficulty (`0` for `normal`, `1` for `expert`, `2` for `master`, `3` for `journey`). This only affects new worlds.
* `-loadlib` - Instructs the base game to load the library at the path. For example, `-loadlib C:\Terraria\MyLibrary.dll` will load the library `MyLibrary.dll` from the path `C:\Terraria\`.
* `-crashdir` - Instructs the base game to save crash dumps to the path. For example, `-crashdir C:\Terraria\CrashDumps` will save crash dumps to `C:\Terraria\CrashDumps`.
* `-additionalplugins` - Instructs the server to load plugins from the directory specified, in addition to the `ServerPlugins` folder. For example, `-additionalplugins C:\Terraria\MyPlugins` will load plugins from `C:\Terraria\MyPlugins`. This is useful if you run multiple servers with the same plugins (generally).

These command line flags are in-addition to the ones that the Terraria server offers (for example, `-lang` is now a vanilla flag, and still works).

## Autostarting TShock

If you want to start TShock automatically though a script, and bypass the interactive startup prompt, you need to specify a `-world` path, a `-port`, and `-maxplayers`.

For example: `TShock.Server.exe -world C:\Terraria\worlds\MyWorld.wld -port 7777 -maxplayers 8`

```
#### File: `temp_TShock-5.2.4/docs/config-file-descriptions.md`
```
## AllowAllowedGroupsToSpawnBannedItems  
Allows groups on the banned item allowed list to spawn banned items even if PreventBannedItemSpawn is set to true.
* **Field type**: `Boolean`
* **Default**: `False`

## AllowCorruptionCreep  
Allows the corruption to spread when a world is in hardmode.
* **Field type**: `Boolean`
* **Default**: `True`

## AllowCrimsonCreep  
Allows the crimson to spread when a world is in hardmode.
* **Field type**: `Boolean`
* **Default**: `True`

## AllowCutTilesAndBreakables  
Allows players to break temporary tiles (grass, pots, etc) where they cannot usually build.
* **Field type**: `Boolean`
* **Default**: `False`

## AllowHallowCreep  
Allows the hallow to spread when a world is in hardmode.
* **Field type**: `Boolean`
* **Default**: `True`

## AllowIce  
Allows ice placement even where a user cannot usually build.
* **Field type**: `Boolean`
* **Default**: `False`

## AllowLoginAnyUsername  
Allows users to login to any account even if the username doesn't match their character name.
* **Field type**: `Boolean`
* **Default**: `True`

## AllowRegisterAnyUsername  
Allows users to register a username that doesn't necessarily match their character name.
* **Field type**: `Boolean`
* **Default**: `False`

## AnnounceSave  
Enable or disable world save announcements.
* **Field type**: `Boolean`
* **Default**: `True`

## AnonymousBossInvasions  
Whether or not to announce boss spawning or invasion starts.
* **Field type**: `Boolean`
* **Default**: `True`

## ApplicationRestTokens  
A dictionary of REST tokens that external applications may use to make queries to your server.
* **Field type**: `Dictionary`2`
* **Default**: `System.Collections.Generic.Dictionary`2[System.String,Rests.SecureRest+TokenData]`

## AutoSave  
Enable or disable Terraria's built-in world auto save.
* **Field type**: `Boolean`
* **Default**: `True`

## BackupInterval  
The interval between backups, in minutes. Backups are stored in the tshock/backups folder.
* **Field type**: `Int32`
* **Default**: `10`

## BackupKeepFor  
For how long backups are kept in minutes.
eg. 2880 = 2 days.
* **Field type**: `Int32`
* **Default**: `240`

## BanOnHardcoreDeath  
Whether or not to ban hardcore players on death.
* **Field type**: `Boolean`
* **Default**: `False`

## BanOnMediumcoreDeath  
Whether or not to ban mediumcore players on death.
* **Field type**: `Boolean`
* **Default**: `False`

## BCryptWorkFactor  
Determines the BCrypt work factor to use. If increased, all passwords will be upgraded to new work-factor on verify. The number of computational rounds is 2^n. Increase with caution. Range: 5-31.
* **Field type**: `Int32`
* **Default**: `7`

## BombExplosionRadius  
Determines the range in tiles that a bomb can affect tiles from detonation point.
* **Field type**: `Int32`
* **Default**: `5`

## BroadcastRGB  
The RGB values used for the color of broadcast messages.
#.#.# = Red/Blue/Green
Max value: 255
* **Field type**: `Int32[]`
* **Default**: `System.Int32[]`

## ChatAboveHeadsFormat  
Changes the player name when using chat above heads. Starts with a player name wrapped in brackets, as per Terraria's formatting.
Same formatting as ChatFormat without the message.
* **Field type**: `String`
* **Default**: `{2}`

## ChatFormat  
Changes in-game chat format: {0} = Group Name, {1} = Group Prefix, {2} = Player Name, {3} = Group Suffix, {4} = Chat Message.
* **Field type**: `String`
* **Default**: `{1}{2}{3}: {4}`

## CommandSilentSpecifier  
Specifies which string starts a command silently.
Note: Will not function properly if the string length is bigger than 1.
* **Field type**: `String`
* **Default**: `.`

## CommandSpecifier  
Specifies which string starts a command.
Note: Will not function properly if the string length is bigger than 1.
* **Field type**: `String`
* **Default**: `/`

## DebugLogs  
Whether or not the server should output debug level messages related to system operation.
* **Field type**: `Boolean`
* **Default**: `False`

## DefaultGuestGroupName  
The default group name to place unregistered players under.
* **Field type**: `String`
* **Default**: `guest`

## DefaultMaximumSpawns  
The default maximum number of mobs that will spawn per wave. Higher means more mobs in that wave.
* **Field type**: `Int32`
* **Default**: `5`

## DefaultRegistrationGroupName  
The default group name to place newly registered users under.
* **Field type**: `String`
* **Default**: `default`

## DefaultSpawnRate  
The delay between waves. Lower values lead to more mobs.
* **Field type**: `Int32`
* **Default**: `600`

## DisableBuild  
Disables any placing, or removal of blocks.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableClownBombs  
Disables clown bomb projectiles from spawning.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableCustomDeathMessages  
Allows you to disable or enable protection against creating custom messages with death. Created for developers who came up with a more original solution to this problem.
* **Field type**: `Boolean`
* **Default**: `True`

## DisableDefaultIPBan  
Disbales IP bans by default, if no arguments are passed to the ban command.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableDungeonGuardian  
Prevents the dungeon guardian from being spawned while sending players to their spawn point instead.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableHardmode  
If enabled, hardmode will not be activated by the Wall of Flesh or the /starthardmode command.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableInvisPvP  
Disables the effect of invisibility potions while PvP is enabled by turning the player visible to the other clients.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableLoginBeforeJoin  
Prevents users from being able to login before they finish connecting.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableModifiedZenith  
Prohibit the use of Zenith projectile with different objects instead of weapons.
* **Field type**: `Boolean`
* **Default**: `False`

## DisablePrimeBombs  
Disables Skeletron Prime Bombs from spawning, useful for preventing unwanted world destruction on for the worthy seed world.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableSecondUpdateLogs  
Prevents OnSecondUpdate checks from writing to the log file.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableSnowBalls  
Disables snow ball projectiles from spawning.
* **Field type**: `Boolean`
* **Default**: `False`

## DisableSpewLogs  
Disables sending logs as messages to players with the log permission.
* **Field type**: `Boolean`
* **Default**: `True`

## DisableTombstones  
Disables tombstone dropping during death for all players.
* **Field type**: `Boolean`
* **Default**: `True`

## DisableUUIDLogin  
Prevents users from being able to login with their client UUID.
* **Field type**: `Boolean`
* **Default**: `False`

## DisplayIPToAdmins  
Displays a player's IP on join to users with the log permission.
* **Field type**: `Boolean`
* **Default**: `False`

## EnableChatAboveHeads  
Whether or not to display chat messages above players' heads.
* **Field type**: `Boolean`
* **Default**: `False`

## EnableGeoIP  
Whether or not to announce a player's geographic location on join, based on their IP.
* **Field type**: `Boolean`
* **Default**: `False`

## EnableTokenEndpointAuthentication  
Whether or not to require token authentication to use the public REST API endpoints.
* **Field type**: `Boolean`
* **Default**: `False`

## EnableWhitelist  
Enable or disable the whitelist based on IP addresses in the whitelist.txt file.
* **Field type**: `Boolean`
* **Default**: `False`

## ForceHalloween  
Forces Halloween-only events to occur all year.
* **Field type**: `Boolean`
* **Default**: `False`

## ForceTime  
Forces the world time to be normal, day, or night.
* **Field type**: `String`
* **Default**: `normal`

## ForceXmas  
Forces Christmas-only events to occur all year.
* **Field type**: `Boolean`
* **Default**: `False`

## GiveItemsDirectly  
If set to true, items given to players will be inserted directly into their inventory. Requires SSC. Otherwise, items given to players will spawn as dropped items. Experimental feature. May not work correctly or result in item loss.
* **Field type**: `Boolean`
* **Default**: `False`

## HardcoreBanReason  
The reason given when banning hardcore players on death.
* **Field type**: `String`
* **Default**: `Death results in a ban`

## HardcoreKickReason  
The reason given when kicking hardcore players on death.
* **Field type**: `String`
* **Default**: `Death results in a kick`

## HardcoreOnly  
Prevents non-hardcore players from connecting.
* **Field type**: `Boolean`
* **Default**: `False`

## HealOtherThreshold  
Disables a player if this number of HealOtherPlayer packets is sent within 1 second.
* **Field type**: `Int32`
* **Default**: `50`

## IgnoreChestStacksOnLoad  
Allows stacks in chests to go beyond the stack limit during world loading.
* **Field type**: `Boolean`
* **Default**: `False`

## IgnoreProjKill  
Ignores checks to see if a player 'can' kill a projectile.
* **Field type**: `Boolean`
* **Default**: `False`

## IgnoreProjUpdate  
Ignores checks to see if a player 'can' update a projectile.
* **Field type**: `Boolean`
* **Default**: `False`

## InfiniteInvasion  
Enables never ending invasion events. You still need to start the event, such as with the /invade command.
* **Field type**: `Boolean`
* **Default**: `False`

## InvasionMultiplier  
Determines the size of invasion events.
The equation for calculating invasion size is 100 + (multiplier * (number of active players with greater than 200 health)).
* **Field type**: `Int32`
* **Default**: `1`

## KickEmptyUUID  
Kick clients that don't send their UUID to the server.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnDamageThresholdBroken  
Whether or not to kick users when they surpass the MaxDamage threshold.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnHardcoreDeath  
Whether or not to kick hardcore players on death.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnHealOtherThresholdBroken  
Whether or not to kick users when they surpass the HealOther threshold.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnMediumcoreDeath  
Whether or not to kick mediumcore players on death.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnProjectileThresholdBroken  
Whether or not to kick users when they surpass the Projectile threshold.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnTileKillThresholdBroken  
Whether or not to kick users when they surpass the TileKill threshold.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnTileLiquidThresholdBroken  
Whether or not to kick users when they surpass the TileLiquid threshold.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnTilePaintThresholdBroken  
Whether or not to kick users when they surpass the TilePaint threshold.
* **Field type**: `Boolean`
* **Default**: `False`

## KickOnTilePlaceThresholdBroken  
Whether or not to kick users when they surpass the TilePlace threshold.
* **Field type**: `Boolean`
* **Default**: `False`

## KickProxyUsers  
If GeoIP is enabled, this will kick users identified as being under a proxy.
* **Field type**: `Boolean`
* **Default**: `True`

## LogPath  
The path to the directory where logs should be written to.
* **Field type**: `String`
* **Default**: `tshock/logs`

## LogRest  
Whether or not to log REST API connections.
* **Field type**: `Boolean`
* **Default**: `False`

## MaxDamage  
The maximum damage a player/NPC can inflict.
* **Field type**: `Int32`
* **Default**: `1175`

## MaxHP  
The maximum HP a player can have, before equipment buffs.
* **Field type**: `Int32`
* **Default**: `500`

## MaximumLoginAttempts  
Number of failed login attempts before kicking the player.
* **Field type**: `Int32`
* **Default**: `3`

## MaxMP  
The maximum MP a player can have, before equipment buffs.
* **Field type**: `Int32`
* **Default**: `200`

## MaxProjDamage  
The maximum damage a projectile can inflict.
* **Field type**: `Int32`
* **Default**: `1175`

## MaxRangeForDisabled  
The maximum distance, in tiles, that disabled players can move from.
* **Field type**: `Int32`
* **Default**: `10`

## MaxSlots  
Maximum number of clients connected at once.
If you want people to be kicked with "Server is full" set this to how many players you want max and then set Terraria max players to 2 higher.
* **Field type**: `Int32`
* **Default**: `8`

## MediumcoreBanReason  
The reason given if banning a mediumcore player on death.
* **Field type**: `String`
* **Default**: `Death results in a ban`

## MediumcoreKickReason  
The reason given if kicking a mediumcore players on death.
* **Field type**: `String`
* **Default**: `Death results in a kick`

## MediumcoreOnly  
Prevents softcore players from connecting.
* **Field type**: `Boolean`
* **Default**: `False`

## MinimumPasswordLength  
The minimum password length for new user accounts. Can never be lower than 4.
* **Field type**: `Int32`
* **Default**: `4`

## MySqlDbName  
The database name to connect to when using MySQL as the database type.
* **Field type**: `String`
* **Default**: ``

## MySqlHost  
The MySQL hostname and port to direct connections to.
* **Field type**: `String`
* **Default**: `localhost:3306`

## MySqlPassword  
The password used when connecting to a MySQL database.
* **Field type**: `String`
* **Default**: ``

## MySqlUsername  
The username used when connecting to a MySQL database.
* **Field type**: `String`
* **Default**: ``

## PreventBannedItemSpawn  
Prevent banned items from being spawned or given with commands.
* **Field type**: `Boolean`
* **Default**: `False`

## PreventDeadModification  
Prevent players from interacting with the world while they are dead.
* **Field type**: `Boolean`
* **Default**: `True`

## PreventInvalidPlaceStyle  
Prevents players from placing tiles with an invalid style.
* **Field type**: `Boolean`
* **Default**: `True`

## ProjectileThreshold  
Disable a player if this number of projectiles is created within 1 second.
* **Field type**: `Int32`
* **Default**: `50`

## ProjIgnoreShrapnel  
Whether or not to ignore shrapnel from crystal bullets for the projectile threshold count.
* **Field type**: `Boolean`
* **Default**: `True`

## PvPMode  
Sets the PvP mode. Valid types are: "normal", "always" and "disabled".
* **Field type**: `String`
* **Default**: `normal`

## RangeChecks  
Enable or disable anti-cheat range checks based on distance between the player and their block placements.
* **Field type**: `Boolean`
* **Default**: `True`

## RegionProtectChests  
Whether or not region protection should apply to chests.
* **Field type**: `Boolean`
* **Default**: `False`

## RegionProtectGemLocks  
Whether or not region protection should apply to gem locks.
* **Field type**: `Boolean`
* **Default**: `True`

## RememberLeavePos  
Remembers where a player left off, based on their IP. Does not persist through server restarts.
eg. When you try to disconnect, and reconnect to be automatically placed at spawn, you'll be at your last location.
* **Field type**: `Boolean`
* **Default**: `False`

## RequireLogin  
Require all players to register or login before being allowed to play.
* **Field type**: `Boolean`
* **Default**: `False`

## ReservedSlots  
The number of reserved slots past your max server slots that can be joined by reserved players.
* **Field type**: `Int32`
* **Default**: `20`

## RespawnBossSeconds  
The number of seconds a player must wait before being respawned if there is a boss nearby. Valid range: 0 (default) to 30 seconds. Use at your own risk.
* **Field type**: `Int32`
* **Default**: `0`

## RespawnSeconds  
The number of seconds a player must wait before being respawned. Valid range: 0 (default) to 15 seconds. Use at your own risk.
* **Field type**: `Int32`
* **Default**: `0`

## RestApiEnabled  
Enable or disable the REST API.
* **Field type**: `Boolean`
* **Default**: `False`

## RestApiPort  
The port used by the REST API.
* **Field type**: `Int32`
* **Default**: `7878`

## RESTMaximumRequestsPerInterval  
The maximum REST requests in the bucket before denying requests. Minimum value is 5.
* **Field type**: `Int32`
* **Default**: `5`

## RESTRequestBucketDecreaseIntervalMinutes  
How often in minutes the REST requests bucket is decreased by one. Minimum value is 1 minute.
* **Field type**: `Int32`
* **Default**: `1`

## RevertToTextLogsOnSqlFailures  
Number of times the SQL log must fail to insert logs before falling back to the text log.
* **Field type**: `Int32`
* **Default**: `10`

## SaveWorldOnCrash  
Whether or not to save the world if the server crashes from an unhandled exception.
* **Field type**: `Boolean`
* **Default**: `True`

## SaveWorldOnLastPlayerExit  
Whether or not to save the world when the last player disconnects.
* **Field type**: `Boolean`
* **Default**: `True`

## ServerFullNoReservedReason  
The reason given when kicking players that attempt to join while the server is full with no reserved slots available.
* **Field type**: `String`
* **Default**: `Server is full. No reserved slots open.`

## ServerFullReason  
The reason given when kicking players that attempt to join while the server is full.
* **Field type**: `String`
* **Default**: `Server is full`

## ServerName  
Replaces the world name during a session if UseServerName is true.
* **Field type**: `String`
* **Default**: ``

## ServerPassword  
The server password required to join the server.
* **Field type**: `String`
* **Default**: ``

## ServerPort  
The port the server runs on.
* **Field type**: `Int32`
* **Default**: `7777`

## ShowBackupAutosaveMessages  
Whether or not to show backup auto save messages.
* **Field type**: `Boolean`
* **Default**: `True`

## SoftcoreOnly  
Prevents non-softcore players from connecting.
* **Field type**: `Boolean`
* **Default**: `False`

## SpawnProtection  
Prevents tiles from being placed within SpawnProtectionRadius of the default spawn.
* **Field type**: `Boolean`
* **Default**: `True`

## SpawnProtectionRadius  
The tile radius around the spawn tile that is protected by the SpawnProtection setting.
* **Field type**: `Int32`
* **Default**: `10`

## SqliteDBPath  
The path of sqlite db.
* **Field type**: `String`
* **Default**: `tshock.sqlite`

## StatueSpawn200  
How many NPCs a statue can spawn within 200 pixels(?) before it stops spawning.
Default = 3.
* **Field type**: `Int32`
* **Default**: `3`

## StatueSpawn600  
How many NPCs a statue can spawn within 600 pixels(?) before it stops spawning.
Default = 6.
* **Field type**: `Int32`
* **Default**: `6`

## StatueSpawnWorld  
How many NPCs a statue can spawn before it stops spawning.
Default = 10.
* **Field type**: `Int32`
* **Default**: `10`

## StorageType  
The type of database to use when storing data (either "sqlite" or "mysql").
* **Field type**: `String`
* **Default**: `sqlite`

## SuperAdminChatPrefix  
The superadmin chat prefix.
* **Field type**: `String`
* **Default**: `(Super Admin) `

## SuperAdminChatRGB  
The chat color for the superadmin group.
#.#.# = Red/Blue/Green
Max value: 255
* **Field type**: `Int32[]`
* **Default**: `System.Int32[]`

## SuperAdminChatSuffix  
The superadmin chat suffix.
* **Field type**: `String`
* **Default**: ``

## SuppressPermissionFailureNotices  
Whether or not the server should suppress build permission failure warnings from regions, spawn point, or server edit failure.
* **Field type**: `Boolean`
* **Default**: `False`

## TileKillThreshold  
Disables a player and reverts their actions if this number of tile kills is exceeded within 1 second.
* **Field type**: `Int32`
* **Default**: `60`

## TileLiquidThreshold  
Disables a player if this number of liquid sets is exceeded within 1 second.
* **Field type**: `Int32`
* **Default**: `50`

## TilePaintThreshold  
Disables a player if this number of tiles is painted within 1 second.
* **Field type**: `Int32`
* **Default**: `15`

## TilePlaceThreshold  
Disables a player and reverts their actions if this number of tile places is exceeded within 1 second.
* **Field type**: `Int32`
* **Default**: `32`

## UseServerName  
Whether or not to use ServerName in place of the world name.
* **Field type**: `Boolean`
* **Default**: `False`

## UseSqlLogs  
Whether or not to save logs to the SQL database instead of a text file.
Default = false.
* **Field type**: `Boolean`
* **Default**: `False`

## WhitelistKickReason  
The reason given when kicking players for not being on the whitelist.
* **Field type**: `String`
* **Default**: `You are not on the whitelist.`


```
#### File: `temp_TShock-5.2.4/docs/docker.md`
```
# Docker Setup

In order to run TShock in a docker container, you would need to have mountpoints for
 - `/tshock` (TShock config files, logs and crash reports)
 - `/worlds`
 - `/plugins`
 - `/server` (optional, if you want to mount TShock's cwd)

These folders can be mounted using `-v <host_folder>:<container>`

Open ports can also be passed through using `-p <host_port>:<container_port>`.
 - `7777` for Terraria
 - `7878` for TShock's REST API

For Example:
```bash
docker run -p 7777:7777 -p 7878:7878 \
           -v /home/cider/tshock/:/tshock \
           -v /home/cider/.local/share/Terraria/Worlds:/worlds \
           -v /home/cider/tshock/plugins:/plugins \
           --rm -it ghcr.io/pryaxis/tshock:latest \
           -world /worlds/backflip.wld -motd "OMFG DOCKER"
```

## Building custom images

Occasionally, it may be necessary to adjust TShock with customizations that are not included in the upstream project.
Therefore, these changes are also not available in the officially provided Docker images.

To build and load a Docker image from your local checkout, use the following `buildx` command:

```bash
docker buildx build -t tshock:latest --load .
```

It is also possible to build [multi-platform images](https://docs.docker.com/build/building/multi-platform/) for TShock (e.g. an image targeting `arm64`, on a host that is not `arm64`):

```bash
docker buildx build -t tshock:linux-arm64 --platform linux/arm64 --load .
```

```
#### File: `temp_TShock-5.2.4/docs/i18n.md`
```
TShock supports the concept of multiple languages using `GetText.NET`.

CI is automatically designed to build and push updated `.po` files (the source for lang files) based on usage in TShock.

To use a localized string instead of a standard string, use `GetString()`. For example, `GetString("Invalid command!")` instead of `"Invalid command!"`.

A test language file has been added that converts a limited number of phrases to [Toki Pona](https://tokipona.org/), the language of good. To use this, you can set an environment variable called `TSHOCK_LANGUAGE` set to `tok`. For example, `TSHOCK_LANGUAGE=tok dotnet run --project TShockLauncher`. Then, run the `die` command.

The automatic `.po` to `.mo` compilation only works if you have `msgfmt` installed (part of Git Bash, or part of `gettext` itself). If you don't have this, when you run in debug mode, it will fail to compile the `.mo` file in the `i18n` folder. If this happens, you may want to download the latest artifacts from GitHub, and pull out the `.mo` file(s) of choice and place them into the `i18n` folder.

The base for the i18n system was built by Janet Blackquill ([@pontaoski](https://github.com/pontaoski)). A small donation in her honor was made to the [KDE project](https://kde.org/) as a thankyou for this work.

To help localize/internationalize TShock, you can contribute changes through [Crowdin](https://crowdin.com/project/tshock). Crowdin changes are merged in via @cardinal-system on GitHub automatically via pull-request. The current active language projects are: Chinese (Simplified), Russian, Russian (Ukraine), Spanish, Japanese, Turkish, German, French, French (Quebec), and Toki Pona. If you want a language project added, please notify someone in the TShock discord server to add it.

```
#### File: `temp_TShock-5.2.4/docs/index.html`
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>☕️⚡️ TShock for Terraria docs</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Documentation for TShock for Terraria! ✨☕️⚡️">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css">
</head>
<body>
  <div id="app"></div>
  <script>
    window.location.replace("https://github.com/Pryaxis/TShock/wiki");
  </script>
  <!-- Docsify v4 -->
  <script src="//cdn.jsdelivr.net/npm/docsify@4"></script>
</body>
</html>

```
#### File: `temp_TShock-5.2.4/docs/lang.md`
```
TShock supports automatic language detection based on your system regional settings. If you want to override this, set the `TSHOCK_LANGUAGE` environment variable to a different language, or pass the `-lang` command line argument to change the language.

If you can't load other languages, make sure that you still have a folder called `i18n` and that your language folder of choice contains a `.mo` file. If it does, those translations should load successfully if you override the language settings using `TSHOCK_LANGUAGE` or if you set your regional settings to the right language.

The base for the i18n system was built by Janet Blackquill ([@pontaoski](https://github.com/pontaoski)). A small donation in her honor was made to the [KDE project](https://kde.org/) as a thankyou for this work.

## Simplified Chinese (`zh_CN`)

We owe a very special thanks to our `zh_CN` translators. From the start of the project, we wanted `zh_CN` to be one of our best supported languages. Thank you to the following contributors of translations:

|Name|Translated (Words)|
|--------|--------|
|xml3344 has stopped making trouble (1212122222)|3176|
|Axeel (AxeelAnder)|2273|
|SGKoishi|2129|
|Leader-txt (Leader_txt)|1568|
|Cai233|1335|
|hufang 360 (hufang360)|892|
|StarCloud-cy|601|
|JJJJGGGG12345|454|
|Seele Vollerei (aaa1115910)|302|
|问心\|MiaoVPS (WenXin_MiaoVPS)|256|
|Jifeng|60|
|xml3344|27|
|kuaizhi|23|
|Muteduanxing|13|
|Xlink|8|
|Smelody|6|

For the most up-to-date list of translators, see the [top member report on Crowdin](https://crowdin.com/project/tshock/reports/top-members). You should adjust the date range to select from October 21, 2022 onward.

## Other language projects
The following languages have had significant progress:
* Russian (`ru_RU`)
* Spanish (`es_ES`)
* Indonesian (`id_ID`)

The following are active projects without significant progress:

* German (`de_DE`)
* Turkish (`tr_TR`)
* French (`fr_FR`)
* French, Quebec (`fr_QC`)
* Japanese (`ja_JP`)
* Russian (Ukraine) (`ru_UA`)
* Toki Pona (`tok`)

If you'd like your language to be supported, please let us know in Discord.

We are particularly interested in `zh_CN`, `ru_RU`, and `es_ES` because these are the most commonly used languages in conjunction with TShock.

```
#### File: `temp_TShock-5.2.4/docs/motd.md`
```
TShock provides a more configurable "message-of-the-day" (MOTD) system than the Terraria experience has by default. The "message-of-the-day" is displayed to users when the run the `/motd` command or when they join the server for the first time. You can configure this by adjusting the `motd.txt` file in the `tshock` configuration folder (near `config.json`). You can also use the `/reload` command to reload this configuration file after it has been changed, while the server is running.

The default message-of-the-day is this:

```
Welcome to [c/ffff00:%map%] on [c/7ddff8:T][c/81dbf6:S][c/86d7f4:h][c/8ad3f3:o][c/8ecef1:c][c/93caef:k] for [c/55d284:T][c/62d27a:e][c/6fd16f:r][c/7cd165:r][c/89d15a:a][c/95d150:r][c/a4d145:i][c/b1d03b:a].
[c/FFFFFF:Online players (%onlineplayers%/%serverslots%):] [c/FFFF00:%players%]
Type [c/55D284:%specifier%][c/62D27A:h][c/6FD16F:e][c/7CD165:l][c/89D15A:p] for a list of commands.
```

The following tokens are available for use in the MOTD:
* `%map%` - The name of the current map
* `%onlineplayers%` - The number of players currently online
* `%players%` - A comma-separated list of players currently online
* `%serverslots%` - The number of slots on the server
* `%specifier%` - The command specifier (e.g. `/` or `.`)

In addition, the Terraria color codes are supported. These are RGB colors in brackets. For example, `[c/FF0000:Red]` will display the word "Red" in red. [Terraria chat tags](https://terraria.fandom.com/wiki/Chat#Tags) are clientside rendered, meaning that they can be used too, even if more tags are added, without explicit TShock support.

```
#### File: `temp_TShock-5.2.4/docs/packages-help.txt`
```
Description:
  Manage plugins and their requirements

Usage:
  TShock.Server [command] [options]

Options:
  --version       Show version information
  -?, -h, --help  Show help and usage information

Commands:
  sync  Install the plugins as specified in the plugins.json


```
#### File: `temp_TShock-5.2.4/docs/packages.md`
```
TShock supports downloading and installing plugins from NuGet repositories.
This allows it to automatically download the plugin as well as all of the extra things that the plugin needs.
For developers, this makes distributing plugins easier.

This functionality is accessible via the TShock.Server executable used to run the server normally.

Under Linux:
```
./TShock.Server plugins
```

Under Windows (cmd.exe):
```
TShock.Server plugins
```

The documentation for the commands is included in the help functionality.
A copy of the help output in English can be found in [packages-help.txt](packages-help.txt).
This file primarily exists to document the `packages.json`.

The file format is currently simple, including only a single object, containing a key `packages` that has a map of package IDs to their versions.

An example `packages.json` is shown below:
```
{
    "packages": {
        "Commandy.20.10.22.Test": "0.0.1"
    }
}
```

The name of the plugin is specified as the key, with the version as the value.

```
#### File: `temp_TShock-5.2.4/docs/permission-descriptions.md`
```
## tshock.accountinfo.details
Player can see advanced information about any user account.
* **Commands**: `None`

## tshock.ignore.sendtilesquare
Allow unrestricted SendTileSquare usage, for client side world editing.
* **Commands**: `None`

## tshock.ignore.dropbanneditem
Allow dropping banned items without the item being eaten.
* **Commands**: `None`

## tshock.annoy
User can annoy others.
* **Commands**: `/annoy, /rocket, /firework`

## tshock.admin.antibuild
User can set build protection status.
* **Commands**: `/antibuild`

## tshock.admin.ban
User can ban others.
* **Commands**: `/ban`

## tshock.world.time.bloodmoon
User can force a blood moon.
* **Commands**: `None`

## tshock.admin.broadcast
User can broadcast messages.
* **Commands**: `/broadcast (/bc /say)`

## tshock.buff.self
User can buff self.
* **Commands**: `/buff`

## tshock.buff.others
User can buff other players.
* **Commands**: `/gbuff (/buffplayer)`

## tshock.npc.butcher
User can kill all enemy npcs.
* **Commands**: `/butcher`

## tshock.ignore.ssc
Bypass server side character checks.
* **Commands**: `None`

## tshock.world.modify
User can modify the world.
* **Commands**: `None`

## tshock.account.changepassword
User can change password in game.
* **Commands**: `/password`

## tshock.canchat
Player can chat.
* **Commands**: `None`

## tshock.account.login
User can login in game.
* **Commands**: `/login`

## tshock.account.logout
User can logout in game.
* **Commands**: `/logout`

## tshock.world.paint
User can paint tiles.
* **Commands**: `None`

## tshock.partychat
User can use party chat in game.
* **Commands**: `/party (/p)`

## tshock.account.register
User can register account in game.
* **Commands**: `/register`

## tshock.thirdperson
User can talk in third person.
* **Commands**: `/me`

## tshock.projectiles.usebanned
Player can use banned projectiles.
* **Commands**: `None`

## tshock.tiles.usebanned
Player can place banned tiles.
* **Commands**: `None`

## tshock.cfg.password
User can edit the server password.
* **Commands**: `/serverpassword`

## tshock.cfg.reload
User can reload the configurations file.
* **Commands**: `/reload`

## tshock.accountinfo.check
Player can check if a username is registered and see its last login time.
* **Commands**: `/accountinfo (/ai)`

## tshock.clear
User can clear items or projectiles.
* **Commands**: `/clear`

## tshock.npc.clearanglerquests
User can clear the list of users who have completed an angler quest that day.
* **Commands**: `/clearangler`

## tshock.world.converthardmode
User can convert hallow into corruption and vice-versa.
* **Commands**: `None`

## tshock.cfg.createdumps
User can create reference files of Terraria IDs and the permission matrix in the server folder.
* **Commands**: `/dump-reference-data`

## tshock.tp.demonconch
User can use the Demon Conch.
* **Commands**: `None`

## tshock.world.time.dropmeteor
User can drop a meteor.
* **Commands**: `None`

## tshock.world.setdungeon
User can set the dungeon's location.
* **Commands**: `/setdungeon`

## tshock.world.time.eclipse
User can force an eclipse.
* **Commands**: `None`

## tshock.world.editregion
Allows you to edit regions.
* **Commands**: `None`

## tshock.world.editspawn
Allows you to edit the spawn.
* **Commands**: `/protectspawn`

## tshock.world.time.fullmoon
User can force a full moon.
* **Commands**: `None`

## tshock.tp.getpos
User can get the position of players.
* **Commands**: `/pos`

## tshock.item.give
User can give items.
* **Commands**: `/give (/g)`

## tshock.godmode
Player recovers health as damage is taken.  Can be one shotted.
* **Commands**: `/godmode (/god)`

## tshock.godmode.other
User can godmode other players.
* **Commands**: `None`

## tshock.world.grow
User can grow plants.
* **Commands**: `/grow`

## tshock.world.growevil
User can grow evil biome plants.
* **Commands**: `None`

## tshock.world.sethalloween
User can force the server to Halloween mode.
* **Commands**: `/forcehalloween`

## tshock.world.hardmode
User can change hardmode state.
* **Commands**: `/hardmode`

## tshock.heal
User can heal players.
* **Commands**: `/heal`

## tshock.tp.home
User can use /home.
* **Commands**: `/home`

## tshock.npc.hurttown
User can hurt town NPCs.
* **Commands**: `None`

## tshock.ignore.damage
Prevents your actions from being ignored if damage is too high.
* **Commands**: `None`

## tshock.ignore.hp
Prevents you from being disabled by abnormal HP.
* **Commands**: `None`

## tshock.ignore.removetile
Prevents you from being reverted by kill tile abuse detection.
* **Commands**: `None`

## tshock.ignore.liquid
Prevents you from being disabled by liquid set abuse detection.
* **Commands**: `None`

## tshock.ignore.mp
Prevents you from being disabled by abnormal MP.
* **Commands**: `None`

## tshock.ignore.npcbuff
Prevents your from being kicked by npc buff hack detection.
* **Commands**: `None`

## tshock.ignore.paint
Prevents you from being disabled by paint abuse detection.
* **Commands**: `None`

## tshock.ignore.placetile
Prevents you from being reverted by place tile abuse detection.
* **Commands**: `None`

## tshock.ignore.projectile
Prevents you from being disabled by projectile abuse detection.
* **Commands**: `None`

## tshock.ignore.itemstack
Prevents you from being disabled by stack hack detection.
* **Commands**: `None`

## tshock.admin.noban
Prevents you from being banned.
* **Commands**: `None`

## tshock.admin.nokick
Prevents you from being kicked.
* **Commands**: `None`

## tshock.npc.invade
User can start an invasion. Warning: high network use. Easy to abuse.
* **Commands**: `None`

## tshock.item.spawn
User can spawn items.
* **Commands**: `/item (/i)`

## tshock.journey.biomespreadfreeze
User can use Creative UI to stop the biome spread of the world.
* **Commands**: `None`

## tshock.journey.research
User can contribute research by sacrificing items
* **Commands**: `None`

## tshock.journey.godmode
User can use Creative UI to toggle character godmode.
* **Commands**: `None`

## tshock.journey.placementrange
User can use Creative UI to toggle increased placement range.
* **Commands**: `None`

## tshock.journey.rain.freeze
User can use Creative UI to stop the world rain strength from changing.
* **Commands**: `None`

## tshock.journey.rain.strength
User can use Creative UI to set world rain strength/seed.
* **Commands**: `None`

## tshock.journey.setdifficulty
User can use Creative UI to set world difficulty/mode.
* **Commands**: `None`

## tshock.journey.setspawnrate
User can use Creative UI to set the NPC spawn rate of the world.
* **Commands**: `None`

## tshock.journey.time.freeze
User can use Creative UI freeze time.
* **Commands**: `None`

## tshock.journey.time.set
User can use Creative UI to set world time.
* **Commands**: `None`

## tshock.journey.time.setspeed
User can use Creative UI to set world time speed.
* **Commands**: `None`

## tshock.journey.wind.freeze
User can use Creative UI to stop the world wind strength from changing.
* **Commands**: `None`

## tshock.journey.wind.strength
User can use Creative UI to set world wind strength/seed.
* **Commands**: `None`

## tshock.admin.kick
User can kick others.
* **Commands**: `/kick`

## tshock.kill
User can kill others.
* **Commands**: `/kill (/slay)`

## tshock.admin.viewlogs
Specific log messages are sent to users with this permission.
* **Commands**: `/displaylogs`

## tshock.tp.magicconch
User can use the Magic Conch.
* **Commands**: `None`

## tshock.cfg.maintenance
User is notified when an update is available, user can turn off / restart the server.
* **Commands**: `/checkupdates, /off (/exit /stop), /off-nosave (/exit-nosave /stop-nosave), /version`

## tshock.world.events.bloodmoon
User can use the 'bloodmoon' subcommand of the 'worldevent' command
* **Commands**: `None`

## tshock.world.events.eclipse
User can use the 'eclipse' subcommand of the 'worldevent' command
* **Commands**: `None`

## tshock.world.events
User can use the 'worldevent' command
* **Commands**: `/worldevent`

## tshock.world.events.fullmoon
User can use the 'fullmoon' subcommand of the 'worldevent' command
* **Commands**: `None`

## tshock.admin.group
User can manage groups.
* **Commands**: `/group`

## tshock.world.events.invasion
User can use the 'invasion' subcommand of the 'worldevent' command
* **Commands**: `None`

## tshock.admin.itemban
User can manage item bans.
* **Commands**: `/itemban`

## tshock.world.events.lanternsnight
User can use the 'lanternsnight' subcommand of the 'worldevent' command
* **Commands**: `None`

## tshock.world.events.meteor
User can use the 'meteor' subcommand of the 'worldevent' command
* **Commands**: `None`

## tshock.admin.projectileban
User can manage projectile bans.
* **Commands**: `/projban`

## tshock.world.events.rain
User can use the 'rain' subcommand of the 'worldevent' command
* **Commands**: `None`

## tshock.admin.region
User can manage regions.
* **Commands**: `/region`

## tshock.world.events.sandstorm
User can use the 'sandstorm' subcommand of the 'worldevent' command
* **Commands**: `None`

## tshock.admin.tileban
User can manage tile bans.
* **Commands**: `/tileban`

## tshock.admin.warp
User can manage warps.
* **Commands**: `None`

## tshock.npc.maxspawns
User can edit the max spawns.
* **Commands**: `/maxspawns`

## tshock.world.movenpc
User can change the homes of NPCs.
* **Commands**: `None`

## tshock.admin.mute
User can mute and unmute users.
* **Commands**: `/mute (/unmute)`

## tshock.tp.pylon
User can use pylons to teleport
* **Commands**: `None`

## tshock.world.rain
User can turn on or off the rain.
* **Commands**: `None`

## tshock.npc.rename
User can rename NPCs.
* **Commands**: `/renamenpc`

## tshock.reservedslot
Allows you to bypass the max slots for up to 5 slots above your max.
* **Commands**: `None`

## tshock.respawn
Player can respawn themselves.
* **Commands**: `/respawn`

## tshock.respawn.other
Player can respawn others.
* **Commands**: `None`

## tshock.tp.rod
User can use the Rod of Discord.
* **Commands**: `None`

## tshock.world.sandstorm
User can turn on or off sandstorms.
* **Commands**: `None`

## tshock.admin.savessi
User can save all the players SSI (server side character) state.
* **Commands**: `/overridessc (/ossc), /savessc`

## tshock.admin.seeplayerids
User can see the id of players with /who.
* **Commands**: `None`

## tshock.sendemoji
Player can send emotes.
* **Commands**: `None`

## tshock.info
User can get the server info.
* **Commands**: `/serverinfo`

## tshock.admin.tempgroup
User can elevate other users' groups temporarily.
* **Commands**: `/tempgroup`

## tshock.slap
User can slap others.
* **Commands**: `/slap`

## tshock.tp.spawn
User can use /spawn.
* **Commands**: `/spawn`

## tshock.npc.spawnboss
User can spawn bosses.
* **Commands**: `/spawnboss (/sb)`

## tshock.npc.spawnmob
User can spawn npcs.
* **Commands**: `/spawnmob (/sm)`

## tshock.npc.spawnpets
User can spawn pets. Warning: high network use. Easy to abuse.
* **Commands**: `None`

## tshock.npc.spawnrate
User can edit the spawnrate.
* **Commands**: `/spawnrate`

## tshock.npc.startdd2
User can start the dd2 event.
* **Commands**: `None`

## tshock.npc.startinvasion
User can start invasions (Goblin/Snow Legion) using items.
* **Commands**: `None`

## tshock.su
Allows a user to elevate to superadmin for 10 minutes.
* **Commands**: `/su, /sudo`

## tshock.npc.summonboss
User can summon bosses using items.
* **Commands**: `None`

## tshock.synclocalarea
Player can resync themselves with server state.
* **Commands**: `/sync`

## tshock.world.time.set
User can set the time.
* **Commands**: `/time`

## tshock.world.toggleexpert
User can change expert state.
* **Commands**: `/worldmode (/gamemode)`

## tshock.world.toggleparty
Player can toggle party event.
* **Commands**: `None`

## tshock.tp.self
User can teleport to others.
* **Commands**: `/tp`

## tshock.tp.allothers
User can teleport *everyone* to them.
* **Commands**: `None`

## tshock.tp.block
Users can stop people from teleporting.
* **Commands**: `/tpallow`

## tshock.tp.npc
User can teleport to an NPC.
* **Commands**: `/tpnpc`

## tshock.tp.others
User can teleport other people.
* **Commands**: `/tphere`

## tshock.tp.override
Users can override teleport blocks.
* **Commands**: `None`

## tshock.tp.pos
User can teleport to tile positions.
* **Commands**: `/tppos`

## tshock.tp.tppotion
User can use Teleportation Potions.
* **Commands**: `None`

## tshock.tp.silent
Users can teleport to people without showing a notice
* **Commands**: `None`

## tshock.ssc.upload
User can upload their joined character data as SSC data.
* **Commands**: `/uploadssc`

## tshock.ssc.upload.others
User can upload other players join data to the SSC database.
* **Commands**: `None`

## tshock.item.usebanned
Allows you to use banned items.
* **Commands**: `None`

## tshock.superadmin.user
Meant for super admins only.
* **Commands**: `/user`

## tshock.admin.userinfo
User can get other users' info.
* **Commands**: `/userinfo (/ui)`

## tshock.world.time.usesundial
Player can use the Enchanted Sundial item.
* **Commands**: `None`

## tshock.warp
User can use warps.
* **Commands**: `/warp`

## tshock.whisper
User can whisper to others.
* **Commands**: `/reply (/r), /whisper (/w /tell /pm /dm), /wallow (/wa)`

## tshock.cfg.whitelist
User can modify the whitelist.
* **Commands**: `/whitelist`

## tshock.world.wind
User can modify the wind.
* **Commands**: `/wind`

## tshock.world.info
User can get the world info.
* **Commands**: `/worldinfo`

## tshock.world.save
User can save the world.
* **Commands**: `/save`

## tshock.world.settleliquids
User can settle liquids.
* **Commands**: `/settle`

## tshock.world.setspawn
User can set the world spawn.
* **Commands**: `/setspawn`

## tshock.tp.wormhole
User can use wormhole potions.
* **Commands**: `None`

## tshock.world.setxmas
User can force the server to Christmas mode.
* **Commands**: `/forcexmas`


```
#### File: `temp_TShock-5.2.4/docs/rest-fields.md`
```
## BanCreateV3
Create a new ban entry.
* **Permissions**: `tshock.rest.bans.manage`


**Nouns**:
* `identifier` (Required) `[String]` - The identifier to ban.
* `reason` (Optional) `[String]` - The reason to assign to the ban.
* `start` (Optional) `[String]` - The datetime at which the ban should start.
* `end` (Optional) `[String]` - The datetime at which the ban should end.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/bans/create?identifier=identifier&reason=reason&start=start&end=end&token=token`

## BanDestroyV3
Delete an existing ban entry.
* **Permissions**: `tshock.rest.bans.manage`


**Nouns**:
* `ticketNumber` (Required) `[String]` - The ticket number of the ban to delete.
* `fullDelete` (Optional) `[Boolean]` - Whether or not to completely remove the ban from the system.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/bans/destroy?ticketNumber=ticketNumber&fullDelete=fullDelete&token=token`

## BanInfoV3
View the details of a specific ban.
* **Permissions**: `tshock.rest.bans.view`


**Nouns**:
* `ticketNumber` (Required) `[String]` - The ticket number to search for.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/bans/read?ticketNumber=ticketNumber&token=token`

## BanListV3
View all bans in the TShock database.
* **Permissions**: `tshock.rest.bans.view`


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/bans/list?token=token`

## GroupCreate
Create a new group.
* **Permissions**: `tshock.rest.groups.manage`


**Nouns**:
* `group` (Required) `[String]` - The name of the new group.
* `parent` (Optional) `[String]` - The name of the parent group.
* `permissions` (Optional) `[String]` - A comma separated list of permissions for the new group.
* `chatcolor` (Optional) `[String]` - A r,g,b string representing the color for this groups chat.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/groups/create?group=group&parent=parent&permissions=permissions&chatcolor=chatcolor&token=token`

## GroupDestroy
Delete a group.
* **Permissions**: `tshock.rest.groups.manage`


**Nouns**:
* `group` (Required) `[String]` - The group name to delete.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/groups/destroy?group=group&token=token`

## GroupInfo
Display information of a group.
* **Permissions**: `tshock.rest.groups.view`


**Nouns**:
* `group` (Required) `[String]` - The group name to get information on.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/groups/read?group=group&token=token`

## GroupList
View all groups in the TShock database.
* **Permissions**: `tshock.rest.groups.view`


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/groups/list?token=token`

## PlayerKickV2
Kick a player off the server.
* **Permissions**: `tshock.rest.kick`


**Nouns**:
* `player` (Required) `[String]` - The player to kick.
* `reason` (Optional) `[String]` - The reason the player was kicked.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/players/kick?player=player&reason=reason&token=token`

## PlayerKill
Kill a player.
* **Permissions**: `tshock.rest.kill`


**Nouns**:
* `player` (Required) `[String]` - The player to kick.
* `from` (Optional) `[String]` - Who killed the player.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/players/kill?player=player&from=from&token=token`

## PlayerList
List all player names that are currently on the server.
No special permissions are required for this route.


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/lists/players?token=token`

## PlayerListV2
Fetches detailed user information on all connected users, and can be filtered by specifying a key value pair filter users where the key is a field and the value is a users field value.
No special permissions are required for this route.


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/players/list?token=token`

## PlayerMute
Mute a player.
* **Permissions**: `tshock.rest.mute`


**Nouns**:
* `player` (Required) `[String]` - The player to mute.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/players/mute?player=player&token=token`

## PlayerReadV3
Get information for a user.
* **Permissions**: `tshock.rest.users.info`


**Nouns**:
* `player` (Required) `[String]` - The player to lookup
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/players/read?player=player&token=token`

## PlayerReadV4
Get information for a user.
* **Permissions**: `tshock.rest.users.info`


**Nouns**:
* `player` (Required) `[String]` - The player to lookup
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v4/players/read?player=player&token=token`

## PlayerUnMute
Unmute a player.
* **Permissions**: `tshock.rest.mute`


**Nouns**:
* `player` (Required) `[String]` - The player to mute.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/players/unmute?player=player&token=token`

## ServerBroadcast
Broadcast a server wide message.
No special permissions are required for this route.


**Nouns**:
* `msg` (Required) `[String]` - The message to broadcast.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/server/broadcast?msg=msg&token=token`

## ServerCommandV3
Executes a remote command on the server, and returns the output of the command.
* **Permissions**: `tshock.rest.command`


**Nouns**:
* `cmd` (Required) `[String]` - The command and arguments to execute.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/server/rawcmd?cmd=cmd&token=token`

## ServerMotd
Returns the motd, if it exists.
No special permissions are required for this route.


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/server/motd?token=token`

## ServerOff
Turn the server off.
* **Permissions**: `tshock.rest.maintenance`


**Nouns**:
* `confirm` (Required) `[Boolean]` - Required to confirm that actually want to turn the server off.
* `message` (Optional) `[String]` - The shutdown message.
* `nosave` (Optional) `[Boolean]` - Shutdown without saving.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/server/off?confirm=confirm&message=message&nosave=nosave&token=token`

## ServerReload
Reload config files for the server.
* **Permissions**: `tshock.rest.cfg`


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/server/reload?token=token`

## ServerRules
Returns the rules, if they exist.
No special permissions are required for this route.


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/server/rules?token=token`

## ServerStatusV2
Get a list of information about the current TShock server.
No special permissions are required for this route.


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/server/status?token=token`

## ServerTokenTest
Test if a token is still valid.
No special permissions are required for this route.


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/tokentest?token=token`

## UserActiveListV2
Returns the list of user accounts that are currently in use on the server.
* **Permissions**: `tshock.rest.users.view`


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/users/activelist?token=token`

## UserCreateV2
Create a new TShock user account.
* **Permissions**: `tshock.rest.users.manage`


**Nouns**:
* `user` (Required) `[String]` - The user account name for the new account.
* `group` (Optional) `[String]` - The group the new account should be assigned.
* `password` (Required) `[String]` - The password for the new account.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/users/create?user=user&group=group&password=password&token=token`

## UserDestroyV2
Destroy a TShock user account.
* **Permissions**: `tshock.rest.users.manage`


**Nouns**:
* `user` (Required) `[String]` - The search criteria (name or id of account to lookup).
* `type` (Required) `[String]` - The search criteria type (name for name lookup, id for id lookup).
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/users/destroy?user=user&type=type&token=token`

## UserInfoV2
List detailed information for a user account.
* **Permissions**: `tshock.rest.users.view`


**Nouns**:
* `user` (Required) `[String]` - The search criteria (name or id of account to lookup).
* `type` (Required) `[String]` - The search criteria type (name for name lookup, id for id lookup).
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/users/read?user=user&type=type&token=token`

## UserListV2
Lists all user accounts in the TShock database.
* **Permissions**: `tshock.rest.users.view`


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/users/list?token=token`

## UserUpdateV2
Update a users information.
* **Permissions**: `tshock.rest.users.manage`


**Nouns**:
* `user` (Required) `[String]` - The search criteria (name or id of account to lookup).
* `type` (Required) `[String]` - The search criteria type (name for name lookup, id for id lookup).
* `password` (Optional) `[String]` - The users new password, and at least this or group must be defined.
* `group` (Optional) `[String]` - The new group for the user, at least this or password must be defined.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/users/update?user=user&type=type&password=password&group=group&token=token`

## WorldBloodmoon
Toggle the status of blood moon.
* **Permissions**: `tshock.rest.causeevents`

**Verbs**:
* `bloodmoon` (Required) `[Boolean]` - State of bloodmoon.

**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/world/bloodmoon/{bloodmoon}?token=token`

## WorldBloodmoonV3
Toggle the status of blood moon.
* **Permissions**: `tshock.rest.causeevents`


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v3/world/bloodmoon?token=token`

## WorldButcher
Butcher npcs.
* **Permissions**: `tshock.rest.butcher`


**Nouns**:
* `killfriendly` (Optional) `[Boolean]` - Should friendly npcs be butchered.
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/world/butcher?killfriendly=killfriendly&token=token`

## WorldMeteor
Drops a meteor on the world.
* **Permissions**: `tshock.rest.causeevents`


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/world/meteor?token=token`

## WorldRead
Get information regarding the world.
No special permissions are required for this route.


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/world/read?token=token`

## WorldSave
Save the world.
* **Permissions**: `tshock.rest.cfg`


**Nouns**:
* `token` (Required) `[String]` - The REST authentication token.

**Example Usage**: `/v2/world/save?token=token`


```
#### File: `temp_TShock-5.2.4/docs/ssc-config.md`
```
## Enabled  
Enable server side characters, causing client data to be saved on the server instead of the client.
* **Field type**: `Boolean`
* **Default**: `False`

## LogonDiscardThreshold  
Time, in milliseconds, to disallow discarding items after logging in when ServerSideCharacters is ON.
* **Field type**: `Int32`
* **Default**: `250`

## ServerSideCharacterSave  
How often SSC should save, in minutes.
* **Field type**: `Int32`
* **Default**: `5`

## StartingHealth  
The starting default health for new players when SSC is enabled.
* **Field type**: `Int32`
* **Default**: `100`

## StartingInventory  
The starting default inventory for new players when SSC is enabled.
* **Field type**: `List`1`
* **Default**: `System.Collections.Generic.Lis\`1[TShockAPI.NetItem]`

## StartingMana  
The starting default mana for new players when SSC is enabled.
* **Field type**: `Int32`
* **Default**: `20`

## WarnPlayersAboutBypassPermission  
Warns players and the console if a player has the tshock.ignore.ssc permission with data in the SSC table.
* **Field type**: `Boolean`
* **Default**: `True`


```
#### File: `temp_TShock-5.2.4/docs/ssc.md`
```
Unlike many games (e.g., Minecraft), Terraria, by default, allows players to bring characters from single-player or from other multiplayer servers with them server-to-server. This has benefits and drawbacks. While players can enjoy the freedom of finding items and working with their friends in co-op, it poses obvious security questions. After all, if a player can get items from anywhere, that means they can bring those items into worlds that haven't yet reached that point in game-progression yet. Worse still, they may have acquired the items through illicit means.

Introduced through a collaboration between Zidonuke and Re-Logic, Terraria supports the concept of server-side characters, with a compatible server replacement. The base game supports server-side characters, but does not implement the storage backend or synchronization system. When enabled, game clients no-longer persist data to disk, and give the server authority over many aspects (but not all) of the local data.

When enabled in TShock, SSC takes over control of inventory management for a player. In this mode, players are given a starting inventory, described by the server owner, and then they retain that inventory only as long as they're connected to the server. When they disconnect, their original character data will still be saved locally, ensuring they don't lose local data.

For developers, TShock's SSC implementation should be considered the reference implementation. More things are possible with this system than what TShock does.

## Limitations

In TShock 5 (Terraria 1.4.4.x), loadouts have some caveats. **Data loss or corruption may occur if you aren't careful.** If a player is de-buffed, crowd-controlled, or dead, and the player's client will ignore the loadout synchronization packet. TShock's `Disable()` method, webbing, and other de-buffs may cause desyncs between the server and client. Further, if players use items or otherwise become debuffed, they may also desynchronize. Because of this, we strongly advise telling players to be careful and not use items during loadout changes, or they risk data loss or corruption.

Admins that use `Dimensions` or other proxy tools that join multiple servers together may experience this if those proxies disable or de-buff players during the server switch window, before the player is logged in and synchronized.

## Setting up SSC

To setup SSC, simply change `Enabled` to `true` in `sscconfig.json` in the `tshock` config folder.

An example configuration file is provided:

```json
{
  "Settings": {
    "Enabled": true,
    "ServerSideCharacterSave": 5,
    "LogonDiscardThreshold": 250,
    "StartingHealth": 100,
    "StartingMana": 20,
    "StartingInventory": [
      {
        "netID": -15,
        "prefix": 0,
        "stack": 1
      },
      {
        "netID": -13,
        "prefix": 0,
        "stack": 1
      },
      {
        "netID": -16,
        "prefix": 0,
        "stack": 1
      }
    ],
    "WarnPlayersAboutBypassPermission": true
  }
}
```

In this example configuration, the `StartingInventory` manifest describes the starting items that each player has when they join. In this case, it's bronze equipment. You can customize this by adding additional entries. For example, the updated configuration file after this block adds the `Zenith` as a starting item for new players.

```json
{
  "Settings": {
    "Enabled": true,
    "ServerSideCharacterSave": 5,
    "LogonDiscardThreshold": 250,
    "StartingHealth": 100,
    "StartingMana": 20,
    "StartingInventory": [
      {
        "netID": -15,
        "prefix": 0,
        "stack": 1
      },
      {
        "netID": -13,
        "prefix": 0,
        "stack": 1
      },
      {
        "netID": -16,
        "prefix": 0,
        "stack": 1
      },
      {
        "netID": 4956,
        "prefix": 0,
        "stack": 1
      }
    ],
    "WarnPlayersAboutBypassPermission": true
  }
}
```

## Playing as an admin

If you're playing as an admin, make sure that you're in the `owner` group or a similar group. We really don't suggest playing as `superadmin`. `superadmin` and other users who have the `tshock.ignore.ssc` permission won't use server-side characters. This means that they'll be able to bring items in from their personal character files, and data won't be saved to the server at all.

If a TShock player has `tshock.ignore.ssc`, and `WarnPlayersAboutBypassPermission` is set to `true` in the configuration file, you'll see warnings in your server console indicating that players aren't being saved correctly.

## Uploading data

Sometimes, you want to import player data from players that join your server. For example, if you trust your friends not to bring hacked items in, you can import their data into the system. This is done with the `/uploadssc` command.

The `/overridessc` command can be used to upload SSC data from a given player. The difference between this command is that `/uploadssc` uploads their data from when they joined, whereas `/overridessc` will just save whatever their current state is to the database.

```
#### File: `temp_TShock-5.2.4/docs/tile-providers.md`
```
TShock ships with two tile providers, which replace the Terraria tile datastore with different systems. Additionally, one major plugin developer provides an additional set of tile providers. For developers, these providers implement the `ITile` interface and register themselves as Tile Providers. `ITile` is provided by `OTAPI`.

Terraria, by default, stores tiles in a relatively unoptimized way. Hypothetically, this is the fastest way to access tiles, but it does so at the cost of memory. If you're running a Terraria server with limited memory, you may want to get back memory and trade off processing power instead. That's what these providers do.

## Constileation

Constileation is the newest tile provider shipped by TShock. It's faster than HeapTile, and saves memory. It uses 14 bytes per tile. Start your TShock server with the `-c` or `-constileation` command line argument to use this provider.

## HeapTile

HeapTile is one of the earliest tile providers shipped by TShock. Again, it offers memory advantages, but is really slow compared to Constileation and Tiled. Start your TShock server with the `-heaptile` command line argument to use this provider.

## Tiled

The [tiled plugin for TShock](https://github.com/thanatos-tshock/Tiled) by [thanatos](https://github.com/thanatos-tshock) offers additional tile providers, including their `1d`, `2d`, and `struct` providers. We urge you to check out and compare all tile providers to find the one that best suits your needs. Tiled attempts to bring the best of both worlds, offering tile providers that minimize memory usage while offering modest performance.

## Tile provider benchmarks

[@SignatureBeef](https://github.com/SignatureBeef) did benchmarks of various tile providers. Some run examples from [TSAPI PR #231](https://github.com/Pryaxis/TSAPI/pull/231) are reproduced here. For these, these are the providers:

* `Stock` is the Terraria server stock configuration.
* `Heap` is `HeapTile`
* `Constileation` is `Constileation`
* `1d` is from Tiled
* `2d` is from Tiled
* `Struct` is from Tiled

Bench: how fast each provider can call .active, for every tile in a small world

|               Method |      Mean |    Error |   StdDev | Ratio | RatioSD |
|--------------------- |----------:|---------:|---------:|------:|--------:|
|         Active_Stock |  31.78 ms | 0.456 ms | 0.426 ms |  1.00 |    0.00 |
|          Active_Heap | 122.07 ms | 2.413 ms | 2.370 ms |  3.84 |    0.09 |
| Active_Constileation |  40.41 ms | 0.575 ms | 0.510 ms |  1.27 |    0.02 |
|            Active_1d |  52.94 ms | 0.731 ms | 0.648 ms |  1.66 |    0.03 |
|            Active_2d |  54.96 ms | 1.083 ms | 1.064 ms |  1.73 |    0.05 |
|        Active_Struct |  61.59 ms | 0.651 ms | 0.544 ms |  1.93 |    0.03 |

Bench: how fast the provider can issue and store its own data, for every tile in a small world

|                       Method |      Mean |    Error |   StdDev | Ratio | RatioSD |
|----------------------------- |----------:|---------:|---------:|------:|--------:|
|         AssignFromSelf_Stock |  34.30 ms | 0.486 ms | 0.454 ms |  1.00 |    0.00 |
|          AssignFromSelf_Heap | 267.03 ms | 3.455 ms | 3.062 ms |  7.79 |    0.15 |
| AssignFromSelf_Constileation |  42.30 ms | 0.664 ms | 0.621 ms |  1.23 |    0.03 |
|            AssignFromSelf_1d | 208.46 ms | 2.823 ms | 2.640 ms |  6.08 |    0.10 |
|            AssignFromSelf_2d | 242.42 ms | 4.669 ms | 6.234 ms |  7.11 |    0.24 |
|        AssignFromSelf_Struct | 278.45 ms | 4.580 ms | 4.284 ms |  8.12 |    0.13 |

Bench: how fast the provider can translate other tile data, such as Terraria.Tile, for every tile in a small world

|                       Method |     Mean |   Error |  StdDev | Ratio |
|----------------------------- |---------:|--------:|--------:|------:|
|         AssignFromTile_Stock | 433.3 ms | 7.22 ms | 6.40 ms |  1.00 |
|          AssignFromTile_Heap | 210.4 ms | 3.33 ms | 3.11 ms |  0.49 |
| AssignFromTile_Constileation | 195.7 ms | 2.45 ms | 2.29 ms |  0.45 |
|            AssignFromTile_1d | 239.0 ms | 2.07 ms | 1.83 ms |  0.55 |
|            AssignFromTile_2d | 240.5 ms | 3.03 ms | 2.69 ms |  0.56 |
|        AssignFromTile_Struct | 277.6 ms | 3.74 ms | 3.49 ms |  0.64 |

Bench: how fast a provider can clear tile data (using methods), for every tile in a small world

|            Method |     Mean |    Error |   StdDev | Ratio | RatioSD |
|------------------ |---------:|---------:|---------:|------:|--------:|
|         Clear_Stock | 308.8 ms |  3.90 ms |  3.65 ms |  1.00 |    0.00 |
|          Clear_Heap | 479.1 ms |  9.20 ms |  9.84 ms |  1.55 |    0.03 |
| Clear_Constileation | 331.2 ms |  2.16 ms |  1.92 ms |  1.07 |    0.01 |
|            Clear_1d | 557.8 ms |  3.24 ms |  3.03 ms |  1.81 |    0.03 |
|            Clear_2d | 692.9 ms | 20.61 ms | 59.78 ms |  2.14 |    0.16 |
|        Clear_Struct | 789.2 ms | 13.95 ms | 22.93 ms |  2.60 |    0.11 |

Bench: how fast a provider can run similar logic to the clear world function found in vanilla, for every tile in a small world

|                   Method |      Mean |    Error |   StdDev | Ratio | RatioSD |
|------------------------- |----------:|---------:|---------:|------:|--------:|
|         ClearWorld_Stock |  79.27 ms | 0.669 ms | 0.593 ms |  1.00 |    0.00 |
|          ClearWorld_Heap | 239.87 ms | 2.324 ms | 2.060 ms |  3.03 |    0.03 |
| ClearWorld_Constileation |  62.48 ms | 0.948 ms | 0.887 ms |  0.79 |    0.01 |
|            ClearWorld_1d | 139.73 ms | 1.621 ms | 1.516 ms |  1.76 |    0.02 |
|            ClearWorld_2d | 151.27 ms | 2.341 ms | 2.190 ms |  1.91 |    0.03 |
|        ClearWorld_Struct | 177.16 ms | 3.190 ms | 2.828 ms |  2.23 |    0.05 |

Bench: how fast a provider can issue tile data, for every tile in a small world

|             Method |      Mean |    Error |   StdDev | Ratio | RatioSD |
|------------------- |----------:|---------:|---------:|------:|--------:|
|         Gets_Stock |  17.49 ms | 0.224 ms | 0.210 ms |  1.00 |    0.00 |
|          Gets_Heap | 100.88 ms | 2.007 ms | 2.465 ms |  5.76 |    0.17 |
| Gets_Constileation |  27.15 ms | 0.513 ms | 0.455 ms |  1.55 |    0.03 |
|            Gets_1d |  29.46 ms | 0.431 ms | 0.403 ms |  1.68 |    0.03 |
|            Gets_2d |  27.93 ms | 0.258 ms | 0.242 ms |  1.60 |    0.02 |
|        Gets_Struct |  33.77 ms | 0.671 ms | 1.719 ms |  1.85 |    0.08 |

Bench: how fast a provider can change the type of a tile, for every tile in a small world

|             Method |      Mean |    Error |   StdDev | Ratio | RatioSD |
|------------------- |----------:|---------:|---------:|------:|--------:|
|         Type_Stock |  28.41 ms | 0.420 ms | 0.393 ms |  1.00 |    0.00 |
|          Type_Heap | 120.99 ms | 2.317 ms | 2.480 ms |  4.25 |    0.10 |
| Type_Constileation |  36.95 ms | 0.732 ms | 0.977 ms |  1.30 |    0.04 |
|            Type_1d |  38.65 ms | 0.686 ms | 1.027 ms |  1.38 |    0.04 |
|            Type_2d |  39.64 ms | 0.405 ms | 0.359 ms |  1.40 |    0.02 |
|             Type_Struct |  43.09 ms | 0.749 ms | 0.664 ms |  1.52 |    0.03 |

Bench: test how fast a provider can call basic actions, like clearing, type change and .active, for every tile in a small world

|            Method |       Mean |    Error |   StdDev | Ratio | RatioSD |
|------------------ |-----------:|---------:|---------:|------:|--------:|
|         Use_Stock |   359.4 ms |  4.67 ms |  4.14 ms |  1.00 |    0.00 |
|          Use_Heap |   666.4 ms | 10.78 ms | 10.08 ms |  1.86 |    0.04 |
| Use_Constileation |   407.3 ms |  5.87 ms |  5.20 ms |  1.13 |    0.02 |
|            Use_1d |   654.5 ms |  7.30 ms |  6.83 ms |  1.82 |    0.03 |
|            Use_2d |   741.7 ms |  8.19 ms |  7.66 ms |  2.07 |    0.03 |
|        Use_Struct | 1,235.3 ms |  7.60 ms |  7.11 ms |  3.44 |    0.03 |

```
### Folder: `temp_TShock-5.2.4/i18n/en_PT`
#### File: `temp_TShock-5.2.4/i18n/en_PT/TShockAPI.po`
```
msgid ""
msgstr ""
"Project-Id-Version: tshock\n"
"POT-Creation-Date: 2022-12-06 05:43:49+0000\n"
"PO-Revision-Date: 2022-12-06 05:52\n"
"Last-Translator: \n"
"Language-Team: Pirate English\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: GetText.NET Extractor\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: tshock\n"
"X-Crowdin-Project-ID: 544368\n"
"X-Crowdin-Language: en-PT\n"
"X-Crowdin-File: /general-devel/i18n/template.pot\n"
"X-Crowdin-File-ID: 6\n"
"Language: en_PT\n"

#: ../../TShockAPI/DB/CharacterManager.cs:194
#: ../../TShockAPI/DB/CharacterManager.cs:264
#, csharp-format
msgctxt "{0} is a player name"
msgid "Skipping SSC save (due to tshock.ignore.ssc) for {0}"
msgstr "Arr! Shiver me timbers! Skipping yer SSC save due to tshock.ignore.ssc for ye matey {0}"

#: ../../TShockAPI/DB/BanManager.cs:213
#, csharp-format
msgctxt "{0} is ban number, {1} is ban reason, {2} is a timestamp"
msgid "#{0} - You are banned: {1} ({2} remaining)"
msgstr "#{0} - Yer ship be blocked: {1} ({2} be left)"

#: ../../TShockAPI/DB/BanManager.cs:208
#, csharp-format
msgctxt "{0} is ban number, {1} is ban reason"
msgid "#{0} - You are banned: {1}"
msgstr "#{0} - Yer ship be blocked: {1}"

#: ../../TShockAPI/Commands.cs:6499
msgid "     'basic', 'sakura', 'willow', 'boreal', 'mahogany', 'ebonwood', 'shadewood', 'pearlwood'."
msgstr "     'basic', 'sakura', 'willow', 'boreal', 'mahogany', 'ebonwood', 'shadewood', 'pearlwood'."

#: ../../TShockAPI/Commands.cs:6505
msgid "     'cactus', 'herb', 'mushroom'."
msgstr "     'cactus', 'herb', 'mushroom'."

#: ../../TShockAPI/Commands.cs:6501
msgid "     'palm', 'corruptpalm', 'crimsonpalm', 'hallowpalm'."
msgstr "     'palm', 'corruptpalm', 'crimsonpalm', 'hallowpalm'."

#: ../../TShockAPI/Commands.cs:6503
msgid "     'topaz', 'amethyst', 'sapphire', 'emerald', 'ruby', 'diamond', 'amber'."
msgstr "     'topaz', 'amethyst', 'sapphire', 'emerald', 'ruby', 'diamond', 'amber'."

#: ../../TShockAPI/Commands.cs:1446
#, csharp-format
msgid "   {0}{1} \"{2}\" (Find the IP associated with the offline target's account)"
msgstr "   {0}{1} \"{2}\" (Find the IP associated with the offline target's account)"

#: ../../TShockAPI/Commands.cs:1444
#, csharp-format
msgid "   {0}{1} \"{2}{3}\" {4} {5} (Permanently bans this account name)"
msgstr "   {0}{1} \"{2}{3}\" {4} {5} (Permanently bans this account name)"

#: ../../TShockAPI/Commands.cs:1449
#, csharp-format
msgid "   {0}{1} {2} (Find the player index for the target)"
msgstr "   {0}{1} {2} (Find the player index for the target)"

#: ../../TShockAPI/Commands.cs:1450
#, csharp-format
msgid "   {0}{1} {2}{3} {4} {5} (Permanently bans the online player by Account, UUID, and IP)"
msgstr "   {0}{1} {2}{3} {4} {5} (Permanently bans the online player by Account, UUID, and IP)"

#: ../../TShockAPI/Commands.cs:1447
#, csharp-format
msgid "   {0}{1} {2}{3} {4} {5} (Permanently bans this IP address)"
msgstr "   {0}{1} {2}{3} {4} {5} (Permanently bans this IP address)"

#: ../../TShockAPI/Commands.cs:1386
#, csharp-format
msgid "   Eg a value of {0} would represent 10 days, 30 minutes, 0 seconds."
msgstr "   Eg a value of {0} would represent 10 days, 30 minutes, 0 seconds."

#: ../../TShockAPI/Commands.cs:1390
#, csharp-format
msgid "   If no {0} are specified, the command uses {1} by default."
msgstr "   If no {0} are specified, the command uses {1} by default."

#: ../../TShockAPI/Commands.cs:1387
msgid "   If no duration is provided, the ban will be permanent."
msgstr "   If no duration is provided, the ban will be permanent."

#: ../../TShockAPI/Commands.cs:1389
#, csharp-format
msgid "   Unless {0} is passed to the command, {1} is assumed to be a player or player index"
msgstr "   Unless {0} is passed to the command, {1} is assumed to be a player or player index"

#: ../../TShockAPI/Commands.cs:1262
#, csharp-format
msgid " -> Logged-in as: {0}; in group {1}."
msgstr " -> Logged-in as: {0}; in group {1}."

#: ../../TShockAPI/Commands.cs:1398
#, csharp-format
msgid "- {0} are provided when you add a ban, and can also be viewed with the {1} command."
msgstr "- {0} are provided when you add a ban, and can also be viewed with the {1} command."

#: ../../TShockAPI/Commands.cs:1414
#, csharp-format
msgid "- {0} are provided when you add a ban, and can be found with the {1} command."
msgstr "- {0} are provided when you add a ban, and can be found with the {1} command."

#: ../../TShockAPI/Commands.cs:1388
#, csharp-format
msgid "- {0}: -a (account name), -u (UUID), -n (character name), -ip (IP address), -e (exact, {1} will be treated as identifier)"
msgstr "- {0}: -a (account name), -u (UUID), -n (character name), -ip (IP address), -e (exact, {1} will be treated as identifier)"

#: ../../TShockAPI/Commands.cs:1385
#, csharp-format
msgid "- {0}: uses the format {1} to determine the length of the ban."
msgstr "- {0}: uses the format {1} to determine the length of the ban."

#: ../../TShockAPI/Commands.cs:1443
msgid "- Ban an offline player by account name"
msgstr "- Ban an offline player by account name"

#: ../../TShockAPI/Commands.cs:1445
msgid "- Ban an offline player by IP address"
msgstr "- Ban an offline player by IP address"

#: ../../TShockAPI/Commands.cs:1448
msgid "- Ban an online player by index (Useful for hard to type names)"
msgstr "- Ban an online player by index (Useful for hard to type names)"

#: ../../TShockAPI/Commands.cs:6498
msgid "- Default trees :"
msgstr "- Default trees :"

#: ../../TShockAPI/Commands.cs:6502
msgid "- Gem trees :"
msgstr "- Gem trees :"

#: ../../TShockAPI/Commands.cs:1406
msgid "- Lists active bans. Color trends towards green as the ban approaches expiration"
msgstr "- Lists active bans. Color trends towards green as the ban approaches expiration"

#: ../../TShockAPI/Commands.cs:6504
msgid "- Misc :"
msgstr "- Misc :"

#: ../../TShockAPI/Commands.cs:6500
msgid "- Palm trees :"
msgstr "- Palm trees :"

#: ../../TShockAPI/TShock.cs:963
msgid "!!! > Set DisableLoginBeforeJoin to true in the config file and /reload if this is a problem."
msgstr ""

#: ../../TShockAPI/TShock.cs:957
msgid "!!! > Set DisableUUIDLogin to true in the config file and /reload if this is a problem."
msgstr ""

#: ../../TShockAPI/TShock.cs:962
msgid "!!! Login before join is enabled. Existing accounts can login & the server password will be bypassed."
msgstr ""

#: ../../TShockAPI/TShock.cs:951
msgid "!!! The server password in config.json was overridden by the interactive prompt and will be ignored."
msgstr ""

#: ../../TShockAPI/TShock.cs:956
msgid "!!! UUID login is enabled. If a user's UUID matches an account, the server password will be bypassed."
msgstr ""

#: ../../TShockAPI/Commands.cs:6409
#, csharp-format
msgid "\"{0}\" is not a valid buff ID!"
msgstr "\"{0}\" is not a valid buff ID."

#: ../../TShockAPI/Commands.cs:5906
#, csharp-format
msgid "\"{0}\" is not a valid clear option."
msgstr ""

#: ../../TShockAPI/Commands.cs:6026
#, csharp-format
msgid "\"{0}\" is not a valid NPC."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:283
#, csharp-format
msgid "\"{0}\" is not a valid page number."
msgstr ""

#: ../../TShockAPI/Commands.cs:5826
#, csharp-format
msgid "\"{0}\" is not a valid radius."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:213
#, csharp-format
msgid "\"{0}\" requested REST endpoint: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2020
msgid "(Server Broadcast) "
msgstr "(Captain's Order)"

#: ../../TShockAPI/Configuration/TShockConfig.cs:496
msgid "(Super Admin) "
msgstr ""

#: ../../TShockAPI/Commands.cs:1461
#, csharp-format
msgid "{0} - Ticket Number: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2088
#, csharp-format
msgid "{0} ({1} tokens)"
msgstr ""

#: ../../TShockAPI/Commands.cs:976
#, csharp-format
msgid "{0} ({1}) changed the password for account {2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:986
#, csharp-format
msgid "{0} ({1}) failed to change the password for account {2}."
msgstr ""

#: ../../TShockAPI/TShock.cs:1659
#, csharp-format
msgid "{0} ({1}) from '{2}' group from '{3}' joined. ({4}/{5})"
msgstr ""

#: ../../TShockAPI/TShock.cs:1667
#, csharp-format
msgid "{0} ({1}) from '{2}' group joined. ({3}/{4})"
msgstr ""

#: ../../TShockAPI/Commands.cs:775
#, csharp-format
msgid "{0} ({1}) had {2} or more invalid login attempts and was kicked automatically."
msgstr ""

#: ../../TShockAPI/TShock.cs:1663
#, csharp-format
msgid "{0} ({1}) has joined."
msgstr ""

#: ../../TShockAPI/Commands.cs:5354
#, csharp-format
msgid "{0} (Index: {1}, Account ID: {2})"
msgstr ""

#: ../../TShockAPI/Commands.cs:5356
#, csharp-format
msgid "{0} (Index: {1})"
msgstr ""

#: ../../TShockAPI/Commands.cs:1405
#, csharp-format
msgid "{0} [{1}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:6011
#, csharp-format
msgid "{0} [{1}|{2}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1462
#: ../../TShockAPI/Commands.cs:1463
#, csharp-format
msgid "{0} {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1467
#, csharp-format
msgid "{0} {1} ({2} ago)"
msgstr ""

#: ../../TShockAPI/Commands.cs:1481
#, csharp-format
msgid "{0} {1} ({2})"
msgstr ""

#: ../../TShockAPI/Commands.cs:5328
#, csharp-format
msgid "{0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1464
#, csharp-format
msgid "{0} {1} on {2} ({3} ago)"
msgstr ""

#: ../../TShockAPI/Commands.cs:6368
#, csharp-format
msgid "{0} <\"{1}|{2}\"> [{3}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1397
#: ../../TShockAPI/Commands.cs:1413
#: ../../TShockAPI/Commands.cs:5628
#: ../../TShockAPI/Commands.cs:5918
#, csharp-format
msgid "{0} <{1}>"
msgstr ""

#: ../../TShockAPI/Commands.cs:5462
#: ../../TShockAPI/Commands.cs:6308
#, csharp-format
msgid "{0} <{1}> [{2}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1384
#, csharp-format
msgid "{0} <{1}> [{2}] [{3}] [{4}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:5684
#, csharp-format
msgid "{0} <{1}> [{2}|{3}|{4}|{5}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:5519
#: ../../TShockAPI/Commands.cs:5600
#, csharp-format
msgid "{0} <{1}> <{2}>"
msgstr ""

#: ../../TShockAPI/Commands.cs:6418
#, csharp-format
msgid "{0} <{1}> <{2}|{3}> [{4}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:5815
#, csharp-format
msgid "{0} <{1}|{2}|{3}> [{4}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1106
#, csharp-format
msgid "{0} added account {1} to group {2}."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3546
#, csharp-format
msgid "{0} applied advanced combat techniques volume 2!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3564
#, csharp-format
msgid "{0} applied advanced combat techniques!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3543
#, csharp-format
msgid "{0} applied traveling merchant's satchel!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1064
#, csharp-format
msgid "{0} attempted to register for the account {1} but it was already taken."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2637
#: ../../TShockAPI/GetDataHandlers.cs:3212
#, csharp-format
msgid "{0} authenticated successfully as user {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:905
#, csharp-format
msgid "{0} authenticated successfully as user: {1}."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1955
#, csharp-format
msgid "{0} banned {1} for '{2}'."
msgstr ""

#: ../../TShockAPI/Commands.cs:6051
#, csharp-format
msgid "{0} butchered {1} NPC."
msgid_plural "{0} butchered {1} NPCs."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2462
#, csharp-format
msgid "{0} caused it to rain slime."
msgstr ""

#: ../../TShockAPI/Commands.cs:2477
#, csharp-format
msgid "{0} caused it to rain."
msgstr ""

#: ../../TShockAPI/Commands.cs:1180
#, csharp-format
msgid "{0} changed account {1} to group {2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4466
#, csharp-format
msgid "{0} changed the maximum spawns to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4447
#, csharp-format
msgid "{0} changed the maximum spawns to 5."
msgstr ""

#: ../../TShockAPI/Commands.cs:1154
#, csharp-format
msgid "{0} changed the password for account {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:4505
#, csharp-format
msgid "{0} changed the spawn rate to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4487
#, csharp-format
msgid "{0} changed the spawn rate to 600."
msgstr ""

#: ../../TShockAPI/Commands.cs:4639
#, csharp-format
msgid "{0} changed the wind speed to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5853
#, csharp-format
msgid "{0} deleted {1} item within a radius of {2}."
msgid_plural "{0} deleted {1} items within a radius of {2}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:5877
#, csharp-format
msgid "{0} deleted {1} NPC within a radius of {2}."
msgid_plural "{0} deleted {1} NPCs within a radius of {2}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:5902
#, csharp-format
msgid "{0} deleted {1} projectile within a radius of {2}."
msgid_plural "{0} deleted {1} projectiles within a radius of {2}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:1887
#, csharp-format
msgid "{0} disabled halloween mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1907
#, csharp-format
msgid "{0} disabled xmas mode."
msgstr ""

#: ../../TShockAPI/TShock.cs:1398
#, csharp-format
msgid "{0} disconnected."
msgstr ""

#: ../../TShockAPI/Commands.cs:1885
#, csharp-format
msgid "{0} enabled halloween mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1905
#, csharp-format
msgid "{0} enabled xmas mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:2469
#, csharp-format
msgid "{0} ended the rain."
msgstr ""

#: ../../TShockAPI/Commands.cs:2454
#, csharp-format
msgid "{0} ended the slime rain."
msgstr ""

#: ../../TShockAPI/Commands.cs:706
#, csharp-format
msgid "{0} executed (args omitted): {1}{2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:704
#, csharp-format
msgid "{0} executed: {1}{2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:930
#, csharp-format
msgid "{0} failed to authenticate as user: {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6279
#, csharp-format
msgid "{0} gave you {1} {2}."
msgid_plural "{0} gave you {1} {2}s."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:4247
#, csharp-format
msgid "{0} has been allowed to place tile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3881
#, csharp-format
msgid "{0} has been allowed to use {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4071
#, csharp-format
msgid "{0} has been allowed to use projectile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4305
#, csharp-format
msgid "{0} has been disallowed from placing tile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4129
#, csharp-format
msgid "{0} has been disallowed from using projectile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3952
#, csharp-format
msgid "{0} has been disallowed to use {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6467
#, csharp-format
msgid "{0} has buffed you with {1} ({2}) for {3} seconds!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1186
#, csharp-format
msgid "{0} has changed your group to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2949
#: ../../TShockAPI/Commands.cs:3020
#: ../../TShockAPI/Commands.cs:3026
#, csharp-format
msgid "{0} has disabled incoming teleports."
msgstr ""

#: ../../TShockAPI/Commands.cs:2412
#, csharp-format
msgid "{0} has ended the current invasion event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2408
#, csharp-format
msgid "{0} has ended the Old One's Army event."
msgstr ""

#: ../../TShockAPI/TShock.cs:1670
#, csharp-format
msgid "{0} has joined."
msgstr ""

#: ../../TShockAPI/TShock.cs:1674
#, csharp-format
msgid "{0} has joined. IP: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5655
#, csharp-format
msgid "{0} has launched {1} into space."
msgstr ""

#: ../../TShockAPI/Commands.cs:5653
#, csharp-format
msgid "{0} has launched herself into space."
msgstr ""

#: ../../TShockAPI/Commands.cs:5651
#, csharp-format
msgid "{0} has launched himself into space."
msgstr ""

#: ../../TShockAPI/TShock.cs:1397
#, csharp-format
msgid "{0} has left."
msgstr ""

#: ../../TShockAPI/Commands.cs:5500
#, csharp-format
msgid "{0} has muted {1} for {2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5999
#, csharp-format
msgid "{0} has respawned you."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3555
#, csharp-format
msgid "{0} has sent a request to the bunny delivery service!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3561
#, csharp-format
msgid "{0} has sent a request to the cat delivery service!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3558
#, csharp-format
msgid "{0} has sent a request to the dog delivery service!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3552
#, csharp-format
msgid "{0} has sent a request to the slime delivery service!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2878
#, csharp-format
msgid "{0} has spawned {1} {2} time."
msgid_plural "{0} has spawned {1} {2} times."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2895
#, csharp-format
msgid "{0} has spawned a Wall of Flesh."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2620
#, csharp-format
msgid "{0} has SSC data in the database, but has the tshock.ignore.ssc permission. This means their SSC data is being ignored."
msgstr ""

#: ../../TShockAPI/Commands.cs:2342
#, csharp-format
msgid "{0} has started a goblin army invasion."
msgstr ""

#: ../../TShockAPI/Commands.cs:2396
#, csharp-format
msgid "{0} has started a martian invasion."
msgstr ""

#: ../../TShockAPI/Commands.cs:2354
#, csharp-format
msgid "{0} has started a pirate invasion."
msgstr ""

#: ../../TShockAPI/Commands.cs:2348
#, csharp-format
msgid "{0} has started a snow legion invasion."
msgstr ""

#: ../../TShockAPI/Commands.cs:5488
#, csharp-format
msgid "{0} has unmuted {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6356
#, csharp-format
msgid "{0} healed {1} for {2} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:6354
#, csharp-format
msgid "{0} healed herself for {1} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:6352
#, csharp-format
msgid "{0} healed himself for {1} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:4250
#, csharp-format
msgid "{0} is already allowed to place tile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3885
#, csharp-format
msgid "{0} is already allowed to use {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4074
#, csharp-format
msgid "{0} is already allowed to use projectile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5940
#, csharp-format
msgid "{0} is already dead!"
msgstr ""

#: ../../TShockAPI/Commands.cs:3956
#, csharp-format
msgid "{0} is already disallowed to use {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4309
#, csharp-format
msgid "{0} is already prevented from placing tile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4133
#, csharp-format
msgid "{0} is already prevented from using projectile {1}."
msgstr ""

#: ../../TShockAPI/ItemBans.cs:234
#, csharp-format
msgid "{0} is banned! Remove it!"
msgstr ""

#: ../../TShockAPI/Commands.cs:6751
#, csharp-format
msgid "{0} is no longer in god mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:5546
#: ../../TShockAPI/Commands.cs:5577
#, csharp-format
msgid "{0} is not accepting whispers."
msgstr ""

#: ../../TShockAPI/Commands.cs:3875
#: ../../TShockAPI/Commands.cs:3946
#, csharp-format
msgid "{0} is not banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:5990
#, csharp-format
msgid "{0} is not dead!"
msgstr ""

#: ../../TShockAPI/Commands.cs:6750
#, csharp-format
msgid "{0} is now in god mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:5586
#, csharp-format
msgid "{0} is offline and cannot receive your reply."
msgstr ""

#: ../../TShockAPI/Commands.cs:5949
#: ../../TShockAPI/Rest/RestManager.cs:1068
#, csharp-format
msgid "{0} just killed you!"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1926
#, csharp-format
msgid "{0} kicked {1} for '{2}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:5746
#, csharp-format
msgid "{0} launched fireworks on you."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:847
#, csharp-format
msgid "{0} NPC has been killed."
msgid_plural "{0} NPCs have been killed."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:1058
#, csharp-format
msgid "{0} registered an account: \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:1478
#, csharp-format
msgid "{0} remaining."
msgstr ""

#: ../../TShockAPI/Commands.cs:6196
#, csharp-format
msgid "{0} renamed the {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4574
#, csharp-format
msgid "{0} set the time to {1}:{2:D2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4542
#, csharp-format
msgid "{0} set the time to 00:00."
msgstr ""

#: ../../TShockAPI/Commands.cs:4530
#, csharp-format
msgid "{0} set the time to 04:30."
msgstr ""

#: ../../TShockAPI/Commands.cs:4538
#, csharp-format
msgid "{0} set the time to 12:00."
msgstr ""

#: ../../TShockAPI/Commands.cs:4534
#, csharp-format
msgid "{0} set the time to 19:30."
msgstr ""

#: ../../TShockAPI/Commands.cs:4616
#: ../../TShockAPI/Commands.cs:4617
#, csharp-format
msgid "{0} slapped {1} for {2} damage."
msgstr ""

#: ../../TShockAPI/Commands.cs:2831
#, csharp-format
msgid "{0} spawned {1} {2} time."
msgid_plural "{0} spawned {1} {2} times."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2290
#, csharp-format
msgid "{0} started a blood moon event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2268
#, csharp-format
msgid "{0} started a full moon event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2500
#, csharp-format
msgid "{0} started a lantern night."
msgstr ""

#: ../../TShockAPI/Commands.cs:2427
#, csharp-format
msgid "{0} started a sandstorm event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2317
#, csharp-format
msgid "{0} started an eclipse."
msgstr ""

#: ../../TShockAPI/Commands.cs:2391
#, csharp-format
msgid "{0} started the frost moon at wave {1}!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4150
#: ../../TShockAPI/GetDataHandlers.cs:4152
#, csharp-format
msgid "{0} started the Old One's Army event!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2373
#, csharp-format
msgid "{0} started the pumpkin moon at wave {1}!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2321
#, csharp-format
msgid "{0} stopped an eclipse."
msgstr ""

#: ../../TShockAPI/Commands.cs:2294
#, csharp-format
msgid "{0} stopped the current blood moon."
msgstr ""

#: ../../TShockAPI/Commands.cs:2422
#, csharp-format
msgid "{0} stopped the current sandstorm event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2504
#, csharp-format
msgid "{0} stopped the lantern night."
msgstr ""

#: ../../TShockAPI/Commands.cs:1132
#, csharp-format
msgid "{0} successfully deleted account: {1}."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3567
#, csharp-format
msgid "{0} summoned a Blood Moon!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3579
#, csharp-format
msgid "{0} summoned a frost moon!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3591
#, csharp-format
msgid "{0} summoned a Goblin Invasion!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3573
#, csharp-format
msgid "{0} summoned a Martian invasion!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3549
#, csharp-format
msgid "{0} summoned a Mechdusa!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3570
#, csharp-format
msgid "{0} summoned a Moon Lord!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3582
#, csharp-format
msgid "{0} summoned a pumpkin moon!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3576
#, csharp-format
msgid "{0} summoned an eclipse!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3598
#, csharp-format
msgid "{0} summoned the {1}!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2977
#: ../../TShockAPI/GetDataHandlers.cs:2980
#, csharp-format
msgid "{0} summoned the Empress of Light!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3585
#, csharp-format
msgid "{0} summoned the Pirates!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3588
#, csharp-format
msgid "{0} summoned the Snow Legion!"
msgstr ""

#: ../../TShockAPI/Commands.cs:3004
#: ../../TShockAPI/Commands.cs:3044
#, csharp-format
msgid "{0} teleported {1} to you."
msgstr ""

#: ../../TShockAPI/Commands.cs:2956
#, csharp-format
msgid "{0} teleported to you."
msgstr ""

#: ../../TShockAPI/Commands.cs:2997
#: ../../TShockAPI/Commands.cs:3037
#, csharp-format
msgid "{0} teleported you to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:690
#, csharp-format
msgid "{0} tried to execute (args omitted) {1}{2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:688
#, csharp-format
msgid "{0} tried to execute {1}{2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2255
#, csharp-format
msgid "{0} triggered a meteor."
msgstr ""

#: ../../TShockAPI/Commands.cs:3328
#, csharp-format
msgid "{0} warped you to {1}."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1953
#, csharp-format
msgid "{0} was banned for '{1}'."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1924
#, csharp-format
msgid "{0} was kicked for '{1}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:3002
#: ../../TShockAPI/Commands.cs:3042
#, csharp-format
msgid "{0} was teleported to you."
msgstr ""

#: ../../TShockAPI/Commands.cs:1296
#, csharp-format
msgid "{0}'s group is {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1297
#, csharp-format
msgid "{0}'s last known IP is {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1286
#, csharp-format
msgid "{0}'s last login occurred {1} {2} UTC{3}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1298
#, csharp-format
msgid "{0}'s register date is {1} {2} UTC{3}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5778
#, csharp-format
msgid "{0}{1} defines no aliases."
msgstr ""

#: ../../TShockAPI/Commands.cs:5284
#, csharp-format
msgid "{0}{1} help: "
msgstr ""

#: ../../TShockAPI/Utils.cs:1152
#, csharp-format
msgid "{0}{1}/{2} on {3} @ {4}:{5} (TShock for Terraria v{6})"
msgstr ""

#: ../../TShockAPI/Commands.cs:850
#, csharp-format
msgid "{0}login - Authenticates you using your UUID and character name."
msgstr ""

#: ../../TShockAPI/Commands.cs:855
#, csharp-format
msgid "{0}login <password> - Authenticates you using your password and character name."
msgstr ""

#: ../../TShockAPI/Commands.cs:853
#, csharp-format
msgid "{0}login <username> <password> - Authenticates you using your username and password."
msgstr ""

#: ../../TShockAPI/Commands.cs:5413
#, csharp-format
msgid "{0}user add <username> <password> owner"
msgstr ""

#: ../../TShockAPI/Commands.cs:1205
#, csharp-format
msgid "{0}user add username password group   -- Adds a specified user"
msgstr ""

#: ../../TShockAPI/Commands.cs:1206
#, csharp-format
msgid "{0}user del username                  -- Removes a specified user"
msgstr ""

#: ../../TShockAPI/Commands.cs:1208
#, csharp-format
msgid "{0}user group username newgroup       -- Changes a user's group"
msgstr ""

#: ../../TShockAPI/Commands.cs:1207
#, csharp-format
msgid "{0}user password username newpassword -- Changes a user's password"
msgstr ""

#: ../../TShockAPI/Permissions.cs:547
#, csharp-format
msgid "* **Commands**: `{0}`"
msgstr ""

#: ../../TShockAPI/Configuration/ServerSideConfig.cs:123
#: ../../TShockAPI/Configuration/TShockConfig.cs:645
#, csharp-format
msgid "* **Default**: `{0}`"
msgstr ""

#: ../../TShockAPI/Configuration/ServerSideConfig.cs:122
#: ../../TShockAPI/Configuration/TShockConfig.cs:644
#, csharp-format
msgid "* **Field type**: `{0}`"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1220
#, csharp-format
msgid "* **Permissions**: `{0}`"
msgstr ""

#: ../../TShockAPI/Commands.cs:5430
#, csharp-format
msgid "*{0} {1}"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1253
#, csharp-format
msgid "**Example Usage**: `{0}?{1}`"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1243
msgid "**Nouns**:"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1230
msgid "**Verbs**:"
msgstr ""

#: ../../TShockAPI/Commands.cs:1613
#, csharp-format
msgid "#{0} - You have been banned: {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5446
#, csharp-format
msgid "<{0}> {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5550
#: ../../TShockAPI/Commands.cs:5581
#, csharp-format
msgid "<From {0}> {1}"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:187
#, csharp-format
msgid "<green>{0} <black>from <blue>{1} <black>[{2}]"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:178
#, csharp-format
msgid "<green>{0}<black> from <blue>{1} <black>[{2}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:5551
#: ../../TShockAPI/Commands.cs:5582
#, csharp-format
msgid "<To {0}> {1}"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:136
#, csharp-format
msgid "=== Dependency ==="
msgid_plural "=== Dependencies ==="
msgstr[0] ""
msgstr[1] ""

#: ../../TShockPluginManager/NugetCLI.cs:133
#, csharp-format
msgid "=== Requested Plugin ==="
msgid_plural "=== Requested Plugins ==="
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2818
msgid "a Deerclops"
msgstr ""

#: ../../TShockAPI/Commands.cs:3384
msgid "A group with the same name already exists."
msgstr ""

#: ../../TShockAPI/DB/RegionManager.cs:108
msgid "A lot of things will fail because of this. You must manually delete and re-create the allowed field."
msgstr ""

#: ../../TShockAPI/TShock.cs:986
msgid "A malicious server can easily steal a user's UUID. You may consider turning this option off if you run a public server."
msgstr ""

#: ../../TShockAPI/Commands.cs:2793
msgid "a Martian Saucer"
msgstr ""

#: ../../TShockAPI/Commands.cs:2251
msgid "A meteor has been triggered."
msgstr ""

#: ../../TShockAPI/Commands.cs:2803
msgid "a Nebula Pillar"
msgstr ""

#: ../../TShockAPI/TShock.cs:974
msgid "A password for this server was set in config.json and is being used."
msgstr ""

#: ../../TShockAPI/Commands.cs:1316
msgid "A player name must be provided to kick a player. Please provide one."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2451
msgid "A plugin on this server stopped your login."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:120
#, csharp-format
msgid "A REST login from {0} was blocked as it currently has {1} rate-limit tokens and is at the RESTMaximumRequestsPerInterval threshold."
msgstr ""

#: ../../TShockAPI/Commands.cs:2798
msgid "a Solar Pillar"
msgstr ""

#: ../../TShockAPI/Commands.cs:2813
msgid "a Stardust Pillar"
msgstr ""

#: ../../TShockAPI/Commands.cs:864
msgid "A user account by that name does not exist."
msgstr ""

#: ../../TShockAPI/Commands.cs:2808
msgid "a Vortex Pillar"
msgstr ""

#: ../../TShockAPI/Commands.cs:1159
#, csharp-format
msgid "Account {0} does not exist! Therefore, the password cannot be changed."
msgstr ""

#: ../../TShockAPI/Commands.cs:1105
#, csharp-format
msgid "Account {0} has been added to group {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1181
#, csharp-format
msgid "Account {0} has been changed to group {1}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:547
#, csharp-format
msgid "Account needed! Please {0}register or {0}login to play!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1131
msgid "Account removed successfully."
msgstr ""

#: ../../TShockAPI/Commands.cs:2094
msgid "Active REST Users ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:3971
msgid "add <item> - Adds an item ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:3438
msgid "add <name> <permissions...> - Adds a new group."
msgstr ""

#: ../../TShockAPI/Commands.cs:4149
msgid "add <projectile ID> - Adds a projectile ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:4325
msgid "add <tile ID> - Adds a tile ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:1737
#, csharp-format
msgid "Added {0} to the whitelist."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2041
#, csharp-format
msgid "Added buff to {0} NPC abnormally."
msgstr ""

#: ../../TShockAPI/Commands.cs:4855
#, csharp-format
msgid "Added group {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4785
#, csharp-format
msgid "Added user {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3439
msgid "addperm <group> <permissions...> - Adds permissions to a group."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:81
#, csharp-format
msgid "AddUser SQL returned an error ({0})"
msgstr ""

#: ../../TShockAPI/Commands.cs:5776
#, csharp-format
msgid "Aliases of {0}{1}: {0}{2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6013
msgid "All alive NPCs (excluding town NPCs) on the server will be killed if you do not input a name or ID."
msgstr ""

#: ../../TShockAPI/Commands.cs:2626
msgid "all bosses"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:169
msgid "All done! :)"
msgstr ""

#: ../../TShockAPI/Commands.cs:2104
msgid "All REST tokens have been destroyed."
msgstr ""

#: ../../TShockAPI/Commands.cs:1223
#, csharp-format
msgid "Allocated memory: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3972
msgid "allow <item> <group> - Allows a group to use an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:4150
msgid "allow <projectile ID> <group> - Allows a group to use a projectile."
msgstr ""

#: ../../TShockAPI/Commands.cs:4326
msgid "allow <tile ID> <group> - Allows a group to place a tile."
msgstr ""

#: ../../TShockAPI/Commands.cs:5193
msgid "allow <user> <region> - Allows a user to a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:5195
msgid "allowg <group> <region> - Allows a user group to a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:6670
msgid "Amber Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:6650
msgid "Amethyst Gemtree"
msgstr ""

#: ../../TShockAPI/TShock.cs:996
msgid "An account has been detected in the user database, but setup-code.txt is still present."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:474
#, csharp-format
msgid "An exception has occurred during database rollback: {0}"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:467
#, csharp-format
msgid "An exception has occurred during database transaction: {0}"
msgstr ""

#: ../../TShockAPI/TShock.cs:1489
msgid "An exception occurred executing a command."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:644
msgid "An identifier for a character name."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:648
msgid "An identifier for a TShock User Account name."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:640
msgid "An identifier for a UUID."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:636
#, csharp-format
msgid "An identifier for an IP Address in octet format. e.g., '{0}'."
msgstr ""

#: ../../TShockAPI/Commands.cs:2052
msgid "An update check has been queued. If an update is available, you will be notified shortly."
msgstr ""

#: ../../TShockAPI/Commands.cs:5599
msgid "Annoy Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:5616
#, csharp-format
msgid "Annoying {0} for {1} seconds."
msgstr ""

#: ../../TShockAPI/Commands.cs:338
msgid "Annoys a player for an amount of time."
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:452
#, csharp-format
msgid "Anonymous requested REST endpoint: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5224
msgid "Anti-build is now off."
msgstr ""

#: ../../TShockAPI/Commands.cs:5224
msgid "Anti-build is now on."
msgstr ""

#: ../../TShockAPI/Commands.cs:3204
msgid "Arguments: add [warp name], del [warp name], list [page]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3205
msgid "Arguments: send [player] [warp name], hide [warp name] [Enable(true/false)]."
msgstr ""

#: ../../TShockAPI/Commands.cs:903
#: ../../TShockAPI/GetDataHandlers.cs:2636
#: ../../TShockAPI/GetDataHandlers.cs:3211
#, csharp-format
msgid "Authenticated as {0} successfully."
msgstr ""

#: ../../TShockAPI/TShock.cs:440
#: ../../TShockAPI/TShock.cs:1590
msgid "AutoSave Disabled"
msgstr ""

#: ../../TShockAPI/TShock.cs:438
#: ../../TShockAPI/TShock.cs:1588
msgid "AutoSave Enabled"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:811
msgid "AutoSave has been disabled"
msgstr "Ahoy! Auto-save has been disabled!"

#: ../../TShockAPI/Rest/RestManager.cs:807
msgid "AutoSave has been enabled"
msgstr "Ahoy! Auto-save has been enabled!"

#: ../../TShockAPI/Rest/RestManager.cs:800
msgid "Autosave is currently disabled"
msgstr "Ahoy! Auto-save is currently disabled."

#: ../../TShockAPI/Rest/RestManager.cs:796
msgid "Autosave is currently enabled"
msgstr "Ahoy! Auto-save is currently enabled!"

#: ../../TShockAPI/Commands.cs:1368
msgid "Available Ban commands:"
msgstr ""

#: ../../TShockAPI/Commands.cs:1432
msgid "Available identifiers ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:5208
msgid "Available Region Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:2109
msgid "Available REST Sub-Commands:"
msgstr ""

#: ../../TShockAPI/BackupManager.cs:75
msgid "Backing up world..."
msgstr ""

#: ../../TShockAPI/BackupManager.cs:87
#: ../../TShockAPI/BackupManager.cs:89
msgid "Backup failed!"
msgstr ""

#: ../../TShockAPI/BackupManager.cs:51
msgid "Backup Thread"
msgstr ""

#: ../../TShockAPI/TShock.cs:444
msgid "Backups Disabled"
msgstr ""

#: ../../TShockAPI/TShock.cs:442
msgid "Backups Enabled"
msgstr ""

#: ../../TShockAPI/Commands.cs:837
msgid "Bad login attempt."
msgstr ""

#: ../../TShockAPI/Commands.cs:1371
#, csharp-format
msgid "ban {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1370
#: ../../TShockAPI/Commands.cs:1372
#, csharp-format
msgid "ban {0} <Ban ID>"
msgstr ""

#: ../../TShockAPI/Commands.cs:1369
#, csharp-format
msgid "ban {0} <Target> [Flags]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1633
#, csharp-format
msgid "Ban {0} has been revoked by {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1634
#, csharp-format
msgid "Ban {0} has now been marked as expired."
msgstr ""

#: ../../TShockAPI/Commands.cs:1383
msgid "Ban Add Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1490
#, csharp-format
msgid "Ban added. Ticket Number {0} was created for identifier {1}."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:668
#, csharp-format
msgid "Ban added. Ticket number: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1396
msgid "Ban Del Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1412
msgid "Ban Details Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1404
msgid "Ban List Syntax"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:695
msgid "Ban removed."
msgstr ""

#: ../../TShockAPI/Commands.cs:1442
msgid "Ban Usage Examples"
msgstr ""

#: ../../TShockAPI/Commands.cs:3841
#, csharp-format
msgid "Banned {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4037
#, csharp-format
msgid "Banned projectile {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4213
#, csharp-format
msgid "Banned tile {0}."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1950
#, csharp-format
msgid "Banned: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1517
msgid "Banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:1670
msgid "Bans ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:6592
msgid "Basic Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:2755
msgid "Betsy"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:889
#, csharp-format
msgid "Blood Moon has been set to {0}"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:904
#, csharp-format
msgid "Bloodmoon state: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6596
msgid "Boreal Tree"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3264
#, csharp-format
msgid "Bouncer / HandleNpcTalk rejected from bouncer out of bounds from {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3257
#, csharp-format
msgid "Bouncer / HandleNpcTalk rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1465
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from chest mismatch from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1472
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from disable from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1487
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1480
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from region protection? from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1500
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1507
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1514
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from region check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2735
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected for not finding active bobber projectile! - From {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2729
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected for not using a fishing rod! - From {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2741
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected for the NPC not being on the fishable NPCs list! - From {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2753
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2747
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected summon boss permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2781
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2774
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected item not placed by hand from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2792
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2803
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2767
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected tile placement valid from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2508
#, csharp-format
msgid "Bouncer / OnGemLockToggle invalid placement/deadmod from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2501
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected boundaries check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2515
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2524
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected permissions check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:453
msgid "Bouncer / OnGetSection rejected empty player name."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:445
#, csharp-format
msgid "Bouncer / OnGetSection rejected GetSection packet from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2096
#, csharp-format
msgid "Bouncer / OnHealOtherPlayer 0.2 check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2120
#, csharp-format
msgid "Bouncer / OnHealOtherPlayer rejected disabled/throttled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2112
#, csharp-format
msgid "Bouncer / OnHealOtherPlayer rejected heal other threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2086
msgid "Bouncer / OnHealOtherPlayer rejected null checks"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1074
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from attempt crash from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1150
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1130
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from drop item ban check / max stack check / min stack check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1099
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from dupe range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1120
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from item drop/pickup check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1084
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from prefix check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1110
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1141
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from sneaky from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2703
#, csharp-format
msgid "Bouncer / OnKillMe rejected bad length death text from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2710
#, csharp-format
msgid "Bouncer / OnKillMe rejected custom death message from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2684
#, csharp-format
msgid "Bouncer / OnKillMe rejected high damage from {0} {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2693
#, csharp-format
msgid "Bouncer / OnKillMe rejected index check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1832
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected build permission from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1676
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1694
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected from liquid threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1669
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected invalid check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1731
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected liquid type {0} from {1} holding {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1840
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1848
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2573
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected build perms from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2566
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2559
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected valid placement from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1274
#, csharp-format
msgid "Bouncer / OnNewProjectile please report to tshock about this! normally this is a reject from {0} {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1230
#, csharp-format
msgid "Bouncer / OnNewProjectile please report to tshock about this! normally this is a reject from {0} {1} (golf)"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1174
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from above projectile limit from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1315
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from bouncer modified AI from {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1331
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from bouncer modified Zenith projectile from {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1302
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1201
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1238
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from hostile projectile from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1183
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from permission check from {0} {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1294
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from projectile create threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1193
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from projectile damage limit from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1249
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from tombstones from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1269
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from weird check from {0} {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2040
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected abnormal buff ({0}, last for {4}) added to {1} ({2}) from {3}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1994
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1987
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected null npc from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1978
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected out of bounds NPC update from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1416
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1391
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from damage threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1399
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1408
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1550
#, csharp-format
msgid "Bouncer / OnPlaceChest / rejected from invalid place style from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1542
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1535
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from invalid check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1583
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from invalid permission from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1591
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1562
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from weird check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1573
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from weird placement check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2440
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2448
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2456
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2433
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected tile placement valid from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2313
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected awkward tile creation/selection from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2300
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected Axe of Regrowth only places saplings {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2261
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected banned tiles from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2270
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected dead people don't do things from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2278
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2252
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected fake containers from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2351
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected mad loop from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2336
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected null tile data from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2325
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected object placement with invalid style {1} (expected {2}) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2229
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2236
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile x from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2243
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile y from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2367
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2289
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected rubblemaker I can't believe it's not rubble! from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2375
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected tile place threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2222
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected valid placements from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2406
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2413
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2420
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2399
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected tile placement valid from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1642
#, csharp-format
msgid "Bouncer / OnPlayerAnimation rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1650
#, csharp-format
msgid "Bouncer / OnPlayerAnimation rejected from throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1960
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied for that long"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1942
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied to non-senders"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1951
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied without pvp"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1933
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff is not whitelisted"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1893
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: invalid buff type"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1902
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is being disabled"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1911
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is being throttled"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1924
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is not in range of target"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1875
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: target ID out of bounds"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1884
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: target is null"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2667
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected custom death message from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2603
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected damage threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2610
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected damage threshold2 from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2630
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2621
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected hostile from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2594
msgid "Bouncer / OnPlayerDamage rejected null check"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2639
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2648
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected throttled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2488
#, csharp-format
msgid "Bouncer / OnPlayerPortalTeleport rejected disabled/throttled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2480
#, csharp-format
msgid "Bouncer / OnPlayerPortalTeleport rejected teleport out of bounds from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2469
#, csharp-format
msgid "Bouncer / OnPlayerPortalTeleport rejected untargetable teleport from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:517
#, csharp-format
msgid "Bouncer / OnPlayerUpdate *would have rejected* from (last network position zero) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:495
#, csharp-format
msgid "Bouncer / OnPlayerUpdate force kicked (attempted to set velocity +/- 50000) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:479
#, csharp-format
msgid "Bouncer / OnPlayerUpdate force kicked (attempted to set velocity to infinity) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:487
#, csharp-format
msgid "Bouncer / OnPlayerUpdate force kicked (attempted to set velocity to NaN) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:561
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (??) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:565
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (below ??) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:573
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (corpses don't move) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:510
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (inventory length) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:503
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (position check) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1628
#, csharp-format
msgid "Bouncer / OnPlayerZone rejected from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1445
#, csharp-format
msgid "Bouncer / OnProjectileKill rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1437
#, csharp-format
msgid "Bouncer / OnProjectileKill rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1430
#, csharp-format
msgid "Bouncer / OnProjectileKill rejected from negative projectile index from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2153
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected npc release from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2145
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected out of bounds from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2204
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2160
#, csharp-format
msgid "Bouncer / OnReleaseNPC released different critter from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:700
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (axe) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:804
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (chestcap) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:708
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (hammer) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:737
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (hammer2) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:756
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (inconceivable rope coil) {0} {1} {2} selectedItem:{3} itemCreateTile:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:767
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (ms1) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:639
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (pdm) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:725
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (pick) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:675
#: ../../TShockAPI/Bouncer.cs:686
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (placestyle) {0} {1} {2} placeStyle: {3} expectedStyle: {4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:653
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (tb) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:603
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (tile placement valid) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:848
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from actuator/presserator from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:612
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from build from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:869
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from disable from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:624
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from editData out of bounds {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:908
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from explosives/fuses from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:878
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from ice/build from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:823
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from place wire from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:858
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from sts allow cut from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:952
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from throttled from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:926
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from tile kill threshold from {0}, (value: {1})"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:944
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from tile place threshold from {0}, (value: {1})"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:786
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from tile placement not matching selected item createTile {0} {1} {2} selectedItemID:{3} createTile:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:776
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from using ice rod but not placing ice block {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:795
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from wall placement not matching selected item createWall {0} {1} {2} selectedItemID:{3} createWall:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:985
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from weird confusing flow control from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:837
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from wire cutter from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:632
#, csharp-format
msgid "Bouncer / OnTileEdit super accepted from (ice block) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2060
#, csharp-format
msgid "Bouncer / OnUpdateNPCHome rejected npc home build permission from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2070
#, csharp-format
msgid "Bouncer / OnUpdateNPCHome rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:558
#, csharp-format
msgid "Bouncer / SendTileRect accepted clientside world edit from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:414
#, csharp-format
msgid "Bouncer / SendTileRect processing a tile conversion update - [{0}] -> [{1}]"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:429
#, csharp-format
msgid "Bouncer / SendTileRect processing a wall conversion update - [{0}] -> [{1}]"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:129
#, csharp-format
msgid "Bouncer / SendTileRect reimplemented from carbonara from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:299
msgid "Bouncer / SendTileRect rejected for banned tile"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:578
#, csharp-format
msgid "Bouncer / SendTileRect rejected from being disabled from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:293
#, csharp-format
msgid "Bouncer / SendTileRect rejected from no permission for tile object from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:565
#, csharp-format
msgid "Bouncer / SendTileRect rejected from non-vanilla tilemod from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:571
#, csharp-format
msgid "Bouncer / SendTileRect rejected from throttle from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:610
msgid "Bouncer / SendTileRectHandler - rejected tile object because object dimensions fall outside the tile rect (excessive size)"
msgstr ""

#: ../../TShockAPI/Utils.cs:136
#, csharp-format
msgid "Broadcast: {0}"
msgstr ""

#: ../../TShockAPI/Utils.cs:159
#, csharp-format
msgid "Broadcast: {0}: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:272
msgid "Broadcasts a message to everyone on the server."
msgstr ""

#: ../../TShockAPI/Commands.cs:6367
msgid "Buff Syntax and Example"
msgstr ""

#: ../../TShockAPI/Commands.cs:6010
msgid "Butcher Syntax and Example"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2619
msgid "Bypass SSC is enabled for your account. SSC data will not be loaded or saved."
msgstr ""

#: ../../TShockAPI/Commands.cs:6676
msgid "Cactus"
msgstr ""

#: ../../TShockAPI/DB/IQueryBuilder.cs:319
msgid "Can't set to true SqlColumn.DefaultCurrentTimestamp when the MySqlDbType is not DateTime"
msgstr ""

#: ../../TShockAPI/Modules/ModuleManager.cs:56
#, csharp-format
msgid "Cannot load module {0} as it does not derive from {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1270
msgid "Certain projectiles have been ignored for cheat detection."
msgstr ""

#: ../../TShockAPI/Commands.cs:4462
#, csharp-format
msgid "Changed the maximum spawns to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4443
msgid "Changed the maximum spawns to 5."
msgstr ""

#: ../../TShockAPI/Commands.cs:4501
#, csharp-format
msgid "Changed the spawn rate to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4483
msgid "Changed the spawn rate to 600."
msgstr ""

#: ../../TShockAPI/Commands.cs:368
msgid "Changes the server password."
msgstr ""

#: ../../TShockAPI/Commands.cs:522
msgid "Changes the wind speed."
msgstr ""

#: ../../TShockAPI/Commands.cs:467
msgid "Changes the world mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:252
msgid "Changes your account's password."
msgstr ""

#: ../../TShockAPI/Commands.cs:3646
#, csharp-format
msgid "Chat color for \"{0}\" is \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3632
#, csharp-format
msgid "Chat color for group \"{0}\" set to \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:352
msgid "Checks for TShock updates."
msgstr ""

#: ../../TShockAPI/Commands.cs:5186
msgid "clear - Clears the temporary region points."
msgstr ""

#: ../../TShockAPI/Commands.cs:5814
msgid "Clear Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:2531
msgid "Cleared all users from the angler quest completion list for today."
msgstr ""

#: ../../TShockAPI/Commands.cs:537
msgid "Clears item drops or projectiles."
msgstr ""

#: ../../TShockAPI/Commands.cs:3440
msgid "color <group> <rrr,ggg,bbb> - Changes a group's chat color."
msgstr ""

#: ../../TShockAPI/Commands.cs:5329
#, csharp-format
msgid "Command aliases: {0}, {1}, {2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:162
msgid "Command failed, check logs for more details."
msgstr ""

#: ../../TShockAPI/Commands.cs:5260
msgid "Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:3203
msgid "Commands: add, del, hide, list, send, [warpname]."
msgstr ""

#: ../../TShockAPI/TShock.cs:765
#, csharp-format
msgid "Config path has been set to {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:4395
msgid "Configuration, permissions, and regions reload complete. Some changes may require a server restart."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:100
msgid "Connect to the internet to figure out what to download?"
msgstr ""

#: ../../TShockAPI/TShock.cs:1329
msgid "Connecting via a proxy is not allowed."
msgstr ""

#: ../../TShockAPI/Commands.cs:1778
#, csharp-format
msgid "Correct usage: {0}overridessc|{0}ossc <player name>"
msgstr ""

#: ../../TShockAPI/Commands.cs:6641
msgid "Corruption Palm"
msgstr ""

#: ../../TShockAPI/TShock.cs:296
#, csharp-format
msgid "Could not apply the given log path / log format, defaults will be used. Exception details:\n"
"{0}"
msgstr ""

#: ../../TShockAPI/DB/ResearchDatastore.cs:54
#: ../../TShockAPI/DB/BanManager.cs:82
msgid "Could not find a database library (probably Sqlite3.dll)"
msgstr ""

#: ../../TShockAPI/Commands.cs:3268
#, csharp-format
msgid "Could not find a warp named {0} to remove."
msgstr ""

#: ../../TShockAPI/Commands.cs:5526
#: ../../TShockAPI/Commands.cs:5610
#: ../../TShockAPI/Commands.cs:5635
#: ../../TShockAPI/Commands.cs:5691
#: ../../TShockAPI/Commands.cs:5972
#, csharp-format
msgid "Could not find any player named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:5928
#, csharp-format
msgid "Could not find any player named \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:5471
#, csharp-format
msgid "Could not find any players named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:1934
#, csharp-format
msgid "Could not find group {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1923
#, csharp-format
msgid "Could not find player {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5044
msgid "Could not find specified region"
msgstr ""

#: ../../TShockAPI/Commands.cs:3291
msgid "Could not find specified warp."
msgstr ""

#: ../../TShockAPI/Commands.cs:4723
#: ../../TShockAPI/Commands.cs:4730
#: ../../TShockAPI/Commands.cs:4749
#: ../../TShockAPI/Commands.cs:4788
#: ../../TShockAPI/Commands.cs:4823
#: ../../TShockAPI/Commands.cs:4858
#: ../../TShockAPI/Commands.cs:4893
#: ../../TShockAPI/Commands.cs:4937
#, csharp-format
msgid "Could not find the region {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1581
msgid "Could not find the target specified. Check that you have the correct spelling."
msgstr ""

#: ../../TShockAPI/Commands.cs:6200
#, csharp-format
msgid "Could not rename {0}!"
msgstr ""

#: ../../TShockAPI/TShock.cs:1448
msgid "Crash attempt via long chat packet."
msgstr ""

#: ../../TShockAPI/Commands.cs:595
msgid "Creates a reference tables for Terraria data types and the TShock permission system in the server folder."
msgstr ""

#: ../../TShockAPI/Commands.cs:5414
msgid "Creates: <username> with the password <password> as part of the owner group."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:53
msgid "CreativePowerHandler received permission check request for unknown creative power"
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:65
#, csharp-format
msgid "CreativeUnlocksHandler received non-vanilla unlock request. Random field value: {0} but should be 0 from {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6636
msgid "Crimson Palm"
msgstr ""

#: ../../TShockAPI/Commands.cs:4434
#, csharp-format
msgid "Current maximum spawns: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4474
#, csharp-format
msgid "Current spawn rate: {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2686
#, csharp-format
msgid "Death Exploit Attempt: Damage {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2704
msgid "Death reason outside of normal bounds."
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:321
#: ../../TShockAPI/Configuration/TShockConfig.cs:357
msgid "Death results in a ban"
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:349
msgid "Death results in a kick"
msgstr ""

#: ../../TShockAPI/Commands.cs:5187
msgid "define <name> - Defines the region with the given name."
msgstr ""

#: ../../TShockAPI/Commands.cs:3442
msgid "del <group> - Deletes a group."
msgstr ""

#: ../../TShockAPI/Commands.cs:3973
msgid "del <item> - Deletes an item ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:4151
msgid "del <projectile ID> - Deletes an projectile ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:4327
msgid "del <tile ID> - Deletes a tile ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:5188
msgid "delete <name> - Deletes the given region."
msgstr ""

#: ../../TShockAPI/Commands.cs:4746
#, csharp-format
msgid "Deleted region \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3443
msgid "delperm <group> <permissions...> - Removes permissions from a group."
msgstr ""

#: ../../TShockAPI/Commands.cs:6627
msgid "Desert Palm"
msgstr ""

#: ../../TShockAPI/Commands.cs:2111
msgid "destroytokens - Destroys all current REST tokens."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:480
#: ../../TShockAPI/Bouncer.cs:488
#: ../../TShockAPI/Bouncer.cs:496
msgid "Detected DOOM set to ON position."
msgstr ""

#: ../../TShockAPI/Commands.cs:6666
msgid "Diamond Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:1881
msgid "Disabled halloween mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1900
msgid "Disabled xmas mode."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:543
#, csharp-format
msgid "Disabled. You need to {0}login to load your saved data."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:539
msgid "Disabled. You went too far with banned armor."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:535
msgid "Disabled. You went too far with hacked item stacks."
msgstr ""

#: ../../TShockAPI/Commands.cs:3974
msgid "disallow <item> <group> - Disallows a group from using an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:4152
msgid "disallow <projectile ID> <group> - Disallows a group from using a projectile."
msgstr ""

#: ../../TShockAPI/Commands.cs:4328
msgid "disallow <tile ID> <group> - Disallows a group from place a tile."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:140
#: ../../TShockPluginManager/NugetCLI.cs:161
msgid "Download and install the given packages?"
msgstr ""

#: ../../TShockAPI/Commands.cs:2648
msgid "Duke Fishron"
msgstr ""

#: ../../TShockAPI/Commands.cs:6617
msgid "Ebonwood Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:6658
msgid "Emerald Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:1879
msgid "Enabled halloween mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1898
msgid "Enabled xmas mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:488
msgid "Enables starting and stopping various world events."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:665
#, csharp-format
msgid "Error on reloading groups: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5119
msgid "Error: both names are the same."
msgstr ""

#: ../../TShockAPI/Commands.cs:2777
msgid "Everscream"
msgstr ""

#: ../../TShockAPI/Commands.cs:1407
#, csharp-format
msgid "Example usage: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5463
#, csharp-format
msgid "Example usage: {0} \"{1}\" \"{2}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:6369
#, csharp-format
msgid "Example usage: {0} \"{1}\" {2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1399
#: ../../TShockAPI/Commands.cs:1415
#: ../../TShockAPI/Commands.cs:5330
#: ../../TShockAPI/Commands.cs:5629
#: ../../TShockAPI/Commands.cs:5919
#: ../../TShockAPI/Commands.cs:6012
#, csharp-format
msgid "Example usage: {0} {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5520
#: ../../TShockAPI/Commands.cs:5685
#: ../../TShockAPI/Commands.cs:5816
#: ../../TShockAPI/Commands.cs:6309
#, csharp-format
msgid "Example usage: {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6419
#, csharp-format
msgid "Example usage: {0} {1} {2} {3}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1391
#, csharp-format
msgid "Example usage: {0} {1} {2} {3} {4}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5601
#, csharp-format
msgid "Example usage: {0} <{1}> <{2}>"
msgstr ""

#: ../../TShockAPI/Commands.cs:2002
msgid "Example: /sudo /ban add particles 2d Hacking."
msgstr ""

#: ../../TShockAPI/Commands.cs:3206
#, csharp-format
msgid "Examples: {0}warp add foobar, {0}warp hide foobar true, {0}warp foobar."
msgstr ""

#: ../../TShockAPI/Commands.cs:328
msgid "Executes a command as the super admin."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4371
msgid "Exploit attempt detected!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1494
#, csharp-format
msgid "Failed to add ban for identifier: {0}."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:671
#, csharp-format
msgid "Failed to add ban. {0}"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:324
#, csharp-format
msgid "Failed to add group {0}."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:512
#: ../../TShockAPI/DB/GroupManager.cs:513
#, csharp-format
msgid "Failed to delete group {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2524
msgid "Failed to find any users by that name on the list."
msgstr ""

#: ../../TShockAPI/Commands.cs:1638
#: ../../TShockAPI/Rest/RestManager.cs:698
msgid "Failed to remove ban."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:480
#, csharp-format
msgid "Failed to rename group {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5145
msgid "Failed to rename the region."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2685
msgid "Failed to shade polygon normals."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:369
#, csharp-format
msgid "Failed to update group \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:1864
msgid "Failed to upload your character data to the server. Are you logged-in to an account?"
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:245
msgid "Fatal Startup Exception"
msgstr ""

#: ../../TShockAPI/Extensions/DbExt.cs:79
msgid "Fatal TShock initialization exception: failed to connect to MySQL database. See inner exception for details."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:218
#, csharp-format
msgid "FetchHashedPasswordAndGroup SQL returned an error: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5683
msgid "Firework Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1944
msgid "For example, 1d and 10h-30m+2m are both valid time strings, but 2 is not."
msgstr ""

#: ../../TShockAPI/Commands.cs:1374
#, csharp-format
msgid "For more info, use {0} {1} or {2} {3}"
msgstr ""

#: ../../TShockAPI/Commands.cs:514
msgid "Forces all liquids to update immediately."
msgstr ""

#: ../../TShockAPI/Commands.cs:6278
#, csharp-format
msgid "Gave {0} {1} {2}."
msgid_plural "Gave {0} {1} {2}s."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:6140
#, csharp-format
msgid "Gave {0} {1}."
msgid_plural "Gave {0} {1}s."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/GetDataHandlers.cs:3796
#, csharp-format
msgid "GetDataHandlers / HandleCatchNpc catch zero {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3804
#, csharp-format
msgid "GetDataHandlers / HandleCatchNpc rejected catch npc {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3119
#, csharp-format
msgid "GetDataHandlers / HandleChestActive rejected build permission and region check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3094
#, csharp-format
msgid "GetDataHandlers / HandleChestItem rejected max stacks {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2844
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected door gap check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2829
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected out of range door {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2835
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected type 0 5 check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2669
msgid "GetDataHandlers / HandleGetSection rejected reserve slot"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4042
#, csharp-format
msgid "GetDataHandlers / HandleKillPortal rejected owner mismatch check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2989
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected Cultist summon from {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2972
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected EoL summon from {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2962
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected npc strike {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3250
#, csharp-format
msgid "GetDataHandlers / HandleNpcTalk rejected npc talk {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4086
#, csharp-format
msgid "GetDataHandlers / HandleNpcTeleportPortal rejected not thinking with portals {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4079
#, csharp-format
msgid "GetDataHandlers / HandleNpcTeleportPortal rejected null check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3920
#, csharp-format
msgid "GetDataHandlers / HandleNumberOfAnglerQuestsCompleted surprise packet! Someone tell the TShock team! {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4144
#, csharp-format
msgid "GetDataHandlers / HandleOldOnesArmy rejected permissions {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4138
#, csharp-format
msgid "GetDataHandlers / HandleOldOnesArmy rejected throttled {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3622
#, csharp-format
msgid "GetDataHandlers / HandlePaintTile rejected range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3640
#, csharp-format
msgid "GetDataHandlers / HandlePaintTile rejected select consistency {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3649
#, csharp-format
msgid "GetDataHandlers / HandlePaintTile rejected throttle/permission/range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3669
#, csharp-format
msgid "GetDataHandlers / HandlePaintWall rejected range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3687
#, csharp-format
msgid "GetDataHandlers / HandlePaintWall rejected selector consistency {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3696
#, csharp-format
msgid "GetDataHandlers / HandlePaintWall rejected throttle/permission/range {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3411
#, csharp-format
msgid "GetDataHandlers / HandlePlayerBuffList handled event and sent data {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3396
#, csharp-format
msgid "GetDataHandlers / HandlePlayerBuffList zeroed player buff due to below state 2 {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2777
#, csharp-format
msgid "GetDataHandlers / HandlePlayerHp rejected over max hp {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2522
msgid "GetDataHandlers / HandlePlayerInfo rejected hardcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2516
msgid "GetDataHandlers / HandlePlayerInfo rejected mediumcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2457
msgid "GetDataHandlers / HandlePlayerInfo rejected name length 0"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2450
#, csharp-format
msgid "GetDataHandlers / HandlePlayerInfo rejected plugin phase {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2510
msgid "GetDataHandlers / HandlePlayerInfo rejected softcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4210
#: ../../TShockAPI/GetDataHandlers.cs:4216
#, csharp-format
msgid "GetDataHandlers / HandlePlayerKillMeV2 kicked with difficulty {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4225
#, csharp-format
msgid "GetDataHandlers / HandlePlayerKillMeV2 ssc delete {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3289
#, csharp-format
msgid "GetDataHandlers / HandlePlayerMana rejected max mana {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2554
msgid "GetDataHandlers / HandlePlayerSlot rejected ignore ssc packets"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3316
#, csharp-format
msgid "GetDataHandlers / HandlePlayerTeam rejected team fastswitch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2757
#, csharp-format
msgid "GetDataHandlers / HandlePlayerUpdate home position delta {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3144
msgid "GetDataHandlers / HandlePlayerZone rejected null check"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3025
#, csharp-format
msgid "GetDataHandlers / HandleProjectileKill permitted skeletron prime exemption {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3029
#, csharp-format
msgid "GetDataHandlers / HandleProjectileKill rejected banned projectile {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3014
#, csharp-format
msgid "GetDataHandlers / HandleProjectileKill rejected tombstone {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3354
#, csharp-format
msgid "GetDataHandlers / HandleSign rejected sign on build permission {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3361
#, csharp-format
msgid "GetDataHandlers / HandleSign rejected sign range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3334
#, csharp-format
msgid "GetDataHandlers / HandleSignRead rejected out of bounds {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2700
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport 'vanilla spawn' {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2711
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport phase 1 {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2720
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport phase 2 {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2682
#, csharp-format
msgid "GetDataHandlers / HandleSpawn rejected dead player spawn request {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3517
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected boss {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3507
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected bouner throttled {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3524
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected invasion {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3531
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected pet {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3442
#, csharp-format
msgid "GetDataHandlers / HandleSpecial rejected enchanted sundial permission (ForceTime) {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3436
#, csharp-format
msgid "GetDataHandlers / HandleSpecial rejected enchanted sundial permission {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3426
#, csharp-format
msgid "GetDataHandlers / HandleSpecial rejected type 1 for {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4005
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected expert/master mode check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3999
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected extents check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4011
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected npc id out of bounds check - NPC ID: {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4018
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected npc is null - NPC ID: {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4025
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected range check {0},{1} vs {2},{3} which is {4}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4397
#, csharp-format
msgid "GetDataHandlers / HandleSyncLoadout rejected loadout index sync {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4388
#, csharp-format
msgid "GetDataHandlers / HandleSyncLoadout rejected loadout index sync out of bounds {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3753
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected npc teleport {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3762
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected p2p extents {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3768
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected p2p wormhole permission {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3744
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected rod type {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3842
#: ../../TShockAPI/GetDataHandlers.cs:3858
#: ../../TShockAPI/GetDataHandlers.cs:3881
#: ../../TShockAPI/GetDataHandlers.cs:3901
#, csharp-format
msgid "GetDataHandlers / HandleTeleportationPotion rejected not holding the correct item {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3832
#, csharp-format
msgid "GetDataHandlers / HandleTeleportationPotion rejected permissions {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4126
#, csharp-format
msgid "GetDataHandlers / HandleToggleParty rejected no party {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3059
#, csharp-format
msgid "GetDataHandlers / HandleTogglePvp rejected fastswitch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3052
#, csharp-format
msgid "GetDataHandlers / HandleTogglePvp rejected index mismatch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2735
msgid "GetDataHandlers / OnPlayerUpdate rejected from null player."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2464
msgid "GetDataHandlers / rejecting player for name prefix starting with tsi: or tsn:."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3492
#, csharp-format
msgid "GetDataHandlers / UpdateNPCHome rejected no permission {0}"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:291
#, csharp-format
msgid "GetUser SQL returned an error {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6417
msgid "Give Buff Syntax and Example"
msgstr ""

#: ../../TShockAPI/Commands.cs:541
msgid "Gives another player a buff or debuff for an amount of time. Putting -1 for time will set it to 415 days."
msgstr ""

#: ../../TShockAPI/Commands.cs:382
msgid "Gives another player an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:533
msgid "Gives yourself a buff or debuff for an amount of time. Putting -1 for time will set it to 415 days."
msgstr ""

#: ../../TShockAPI/Commands.cs:387
msgid "Gives yourself an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:6690
msgid "Glowing Mushroom Tree"
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:123
#, csharp-format
msgid "GolfPacketHandler: Player did not have create a golf club projectile the last 5 seconds! - From {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3506
#, csharp-format
msgid "Group \"{0}\" has no parent."
msgstr ""

#: ../../TShockAPI/Commands.cs:3596
#, csharp-format
msgid "Group \"{0}\" has no prefix."
msgstr ""

#: ../../TShockAPI/Commands.cs:3551
#, csharp-format
msgid "Group \"{0}\" has no suffix."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:646
#, csharp-format
msgid "Group \"{0}\" is referencing parent group {1} which is already part of the parent chain. Parent reference removed."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:578
msgid "Group \"superadmin\" is defined in the database even though it's a reserved group name."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:708
#, csharp-format
msgid "Group {0} already exists"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1158
#, csharp-format
msgid "Group {0} created successfully"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1133
#, csharp-format
msgid "Group {0} deleted successfully"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:638
#: ../../TShockAPI/DB/GroupManager.cs:725
#, csharp-format
msgid "Group {0} does not exist"
msgstr ""

#: ../../TShockAPI/Commands.cs:1110
#, csharp-format
msgid "Group {0} does not exist."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1354
#, csharp-format
msgid "Group {0} doesn't exist"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:495
#: ../../TShockAPI/DB/GroupManager.cs:525
#: ../../TShockAPI/DB/GroupManager.cs:548
#, csharp-format
msgid "Group {0} doesn't exist."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:508
#, csharp-format
msgid "Group {0} has been deleted successfully."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:463
#, csharp-format
msgid "Group {0} has been renamed to {1}."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:631
#, csharp-format
msgid "Group {0} is referencing a non existent parent group {1}, parent reference was removed."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:637
#, csharp-format
msgid "Group {0} is referencing itself as parent group; parent reference was removed."
msgstr ""

#: ../../TShockAPI/Commands.cs:4862
#: ../../TShockAPI/Commands.cs:4897
#, csharp-format
msgid "Group {0} not found."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1187
#, csharp-format
msgid "Group {0} updated successfully"
msgstr ""

#: ../../TShockAPI/Commands.cs:3380
#, csharp-format
msgid "Group {0} was added successfully."
msgstr ""

#: ../../TShockAPI/Commands.cs:3454
msgid "Group Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:3745
msgid "Groups ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:476
msgid "Grows plants at your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:6631
msgid "Hallow Palm"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4372
#, csharp-format
msgid "HandleSyncCavernMonsterType: Player is trying to modify NPC cavernMonsterType; this is a crafted packet! - From {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2593
msgid "Hardmode is disabled in the server configuration file."
msgstr ""

#: ../../TShockAPI/Commands.cs:2584
msgid "Hardmode is now off."
msgstr ""

#: ../../TShockAPI/Commands.cs:2589
msgid "Hardmode is now on."
msgstr ""

#: ../../TShockAPI/Commands.cs:6307
msgid "Heal Syntax and Example"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2097
msgid "HealOtherPlayer cheat attempt!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2106
#, csharp-format
msgid "HealOtherPlayer threshold exceeded {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:549
msgid "Heals a player in HP and MP."
msgstr ""

#: ../../TShockAPI/Commands.cs:6684
msgid "Herb"
msgstr ""

#: ../../TShockAPI/Commands.cs:4658
msgid "Hit a block to get the name of the region."
msgstr ""

#: ../../TShockAPI/Commands.cs:4671
#, csharp-format
msgid "Hit a block to set point {0}."
msgstr ""

#: ../../TShockAPI/ItemBans.cs:94
#: ../../TShockAPI/ItemBans.cs:163
#, csharp-format
msgid "holding banned item: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1235
#, csharp-format
msgid "ID: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6310
msgid "If no amount is specified, it will default to healing the target player by their max HP."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1392
msgid "If this player wasn't hacking, please report the damage threshold they were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2113
msgid "If this player wasn't hacking, please report the HealOtherPlayer threshold they were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1295
msgid "If this player wasn't hacking, please report the projectile create threshold they were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:927
msgid "If this player wasn't hacking, please report the tile kill threshold they were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1695
msgid "If this player wasn't hacking, please report the tile liquid threshold they were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:945
msgid "If this player wasn't hacking, please report the tile place threshold they were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3026
msgid "If this was not skeletron prime related, please report to TShock what happened."
msgstr ""

#: ../../TShockAPI/Commands.cs:5377
msgid "If you are locked out of all admin accounts, ask for help on https://tshock.co/"
msgstr ""

#: ../../TShockAPI/Commands.cs:5817
#, csharp-format
msgid "If you do not specify a radius, it will use a default radius of {0} around your character."
msgstr ""

#: ../../TShockAPI/Commands.cs:6370
#, csharp-format
msgid "If you don't specify the duration, it will default to {0} seconds."
msgstr ""

#: ../../TShockAPI/Commands.cs:857
msgid "If you forgot your password, contact the administrator for help."
msgstr ""

#: ../../TShockAPI/Commands.cs:6371
#, csharp-format
msgid "If you put {0} as the duration, it will use the max possible time of 415 days."
msgstr ""

#: ../../TShockAPI/Commands.cs:5416
#, csharp-format
msgid "If you understand, please {0}login <username> <password> now, and then type {0}setup."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:142
msgid "If you want to know which plugins need which dependencies, press E."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:162
msgid "If you'd like to see which plugins need which dependencies again, press E."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:986
msgid "If you're seeing this message and you know what that player did, please report it to TShock for further investigation."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1341
msgid "Ignoring shrapnel per config.."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2465
msgid "Illegal name: prefixes tsi: and tsn: are forbidden."
msgstr ""

#: ../../TShockAPI/Handlers/IllegalPerSe/EmojiPlayerMismatch.cs:19
#, csharp-format
msgid "IllegalPerSe: Emoji packet rejected for ID spoofing. Expected {0}, received {1} from {2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3189
msgid "Incoming teleports are now allowed."
msgstr ""

#: ../../TShockAPI/Commands.cs:3191
msgid "Incoming teleports are now disabled."
msgstr ""

#: ../../TShockAPI/Commands.cs:5403
msgid "Incorrect setup code. This incident has been logged."
msgstr ""

#: ../../TShockAPI/DB/TileManager.cs:223
#: ../../TShockAPI/DB/ProjectileManager.cs:223
#, csharp-format
msgid "Infinite group parenting ({0})"
msgstr ""

#: ../../TShockAPI/Commands.cs:5197
msgid "info <region> [-d] - Displays several information about the given region."
msgstr ""

#: ../../TShockAPI/Commands.cs:4986
#, csharp-format
msgid "Information About Region \"{0}\" ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:1232
msgid "Information about the currently running world"
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:314
msgid "Inserting the ban into the database failed."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:39
msgid "Install the plugins as specified in the plugins.json"
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:426
msgid "Internal server error."
msgstr ""

#: ../../TShockAPI/Commands.cs:1505
#, csharp-format
msgid "Invalid Ban Add syntax. Refer to {0} for details on how to use the {1} command"
msgstr ""

#: ../../TShockAPI/Commands.cs:1621
#, csharp-format
msgid "Invalid Ban Del syntax. Refer to {0} for details on how to use the {1} command"
msgstr ""

#: ../../TShockAPI/Commands.cs:1680
#, csharp-format
msgid "Invalid Ban Details syntax. Refer to {0} for details on how to use the {1} command"
msgstr ""

#: ../../TShockAPI/Commands.cs:1658
#, csharp-format
msgid "Invalid Ban List syntax. Refer to {0} for details on how to use the {1} command"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:500
msgid "Invalid BCrypt work factor in config file! Creating new hash using default work factor."
msgstr ""

#: ../../TShockAPI/Commands.cs:2608
msgid "Invalid boss amount."
msgstr ""

#: ../../TShockAPI/Commands.cs:2821
msgid "Invalid boss type!"
msgstr ""

#: ../../TShockAPI/Commands.cs:6470
msgid "Invalid buff ID!"
msgstr ""

#: ../../TShockAPI/Commands.cs:680
#, csharp-format
msgid "Invalid command entered. Type {0}help for a list of valid commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:5275
msgid "Invalid command."
msgstr ""

#: ../../TShockAPI/Commands.cs:3131
msgid "Invalid destination NPC."
msgstr ""

#: ../../TShockAPI/Commands.cs:2941
#: ../../TShockAPI/Commands.cs:2972
#: ../../TShockAPI/Commands.cs:3011
#: ../../TShockAPI/Commands.cs:3084
msgid "Invalid destination player."
msgstr ""

#: ../../TShockAPI/Commands.cs:2240
#, csharp-format
msgid "Invalid event type. Valid event types: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2382
msgid "Invalid frost moon event wave."
msgstr ""

#: ../../TShockAPI/Commands.cs:3765
#: ../../TShockAPI/Commands.cs:3868
#: ../../TShockAPI/Commands.cs:3939
#: ../../TShockAPI/Commands.cs:4058
#: ../../TShockAPI/Commands.cs:4116
#: ../../TShockAPI/Commands.cs:4234
#: ../../TShockAPI/Commands.cs:4292
msgid "Invalid group."
msgstr ""

#: ../../TShockAPI/Commands.cs:2401
#, csharp-format
msgid "Invalid invasion type. Valid invasion types: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6083
#: ../../TShockAPI/Commands.cs:6232
#: ../../TShockAPI/Commands.cs:6295
msgid "Invalid item type!"
msgstr ""

#: ../../TShockAPI/Commands.cs:3807
#: ../../TShockAPI/Commands.cs:3858
#: ../../TShockAPI/Commands.cs:3903
#: ../../TShockAPI/Commands.cs:3929
msgid "Invalid item."
msgstr ""

#: ../../TShockAPI/Commands.cs:4455
#, csharp-format
msgid "Invalid maximum spawns.  Acceptable range is {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2860
#: ../../TShockAPI/Commands.cs:6166
msgid "Invalid mob type!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2844
#: ../../TShockAPI/Commands.cs:2900
msgid "Invalid mob type."
msgstr ""

#: ../../TShockAPI/Commands.cs:2569
#, csharp-format
msgid "Invalid mode world mode. Valid modes: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1421
msgid "Invalid page number. Page number must be numeric."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:309
#, csharp-format
msgid "Invalid parent group {0} for group {1}"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:347
#, csharp-format
msgid "Invalid parent group {0} for group {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:928
msgid "Invalid password."
msgstr ""

#: ../../TShockAPI/Commands.cs:6263
#: ../../TShockAPI/Commands.cs:6718
msgid "Invalid player!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1255
msgid "Invalid player."
msgstr ""

#: ../../TShockAPI/Commands.cs:4040
msgid "Invalid projectile ID!"
msgstr ""

#: ../../TShockAPI/Commands.cs:4077
#: ../../TShockAPI/Commands.cs:4098
#: ../../TShockAPI/Commands.cs:4136
msgid "Invalid projectile ID."
msgstr ""

#: ../../TShockAPI/Commands.cs:2364
msgid "Invalid pumpkin moon event wave."
msgstr ""

#: ../../TShockAPI/Commands.cs:5127
#, csharp-format
msgid "Invalid region \"{0}\"."
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:247
#, csharp-format
msgid "Invalid REST configuration: \n"
"You may already have a REST service bound to port {0}. \n"
"Please adjust your configuration and restart the server. \n"
"Press any key to exit."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3231
msgid "Invalid server password."
msgstr ""

#: ../../TShockAPI/Commands.cs:3782
#, csharp-format
msgid "Invalid subcommand! Type {0}group help for more information on valid commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4009
#, csharp-format
msgid "Invalid subcommand. Type {0}itemban help for more information on valid subcommands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4187
#, csharp-format
msgid "Invalid subcommand. Type {0}projban help for more information on valid subcommands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4363
#, csharp-format
msgid "Invalid subcommand. Type {0}tileban help for more information on valid subcommands."
msgstr ""

#: ../../TShockAPI/Commands.cs:3641
msgid "Invalid syntax for color, expected \"rrr,ggg,bbb\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:1915
msgid "Invalid syntax."
msgstr ""

#: ../../TShockAPI/Commands.cs:2332
#, csharp-format
msgid "Invalid syntax. Proper syntax:  {0}worldevent invasion [invasion type] [invasion wave]."
msgstr ""

#: ../../TShockAPI/Commands.cs:1270
#: ../../TShockAPI/Commands.cs:1304
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}accountinfo <username>."
msgstr ""

#: ../../TShockAPI/Commands.cs:5754
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}aliases <command or alias>"
msgstr ""

#: ../../TShockAPI/Commands.cs:3369
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group add <group name> [permissions]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3398
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group addperm <group name> <permissions...>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3606
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group color <group name> [new color(000,000,000)]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3679
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group del <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3703
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group delperm <group name> <permissions...>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3756
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group listperm <group name> [page]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3466
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group parent <group name> [new parent group name]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3561
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group prefix <group name> [new prefix]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3656
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group rename <group> <new name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3516
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group suffix <group name> [new suffix]."
msgstr ""

#: ../../TShockAPI/Commands.cs:5241
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}help <command/page>"
msgstr ""

#: ../../TShockAPI/Commands.cs:6058
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}item <item name/id> [item amount] [prefix id/name]"
msgstr ""

#: ../../TShockAPI/Commands.cs:3800
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban add <item name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3851
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban allow <item name> <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3896
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban del <item name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3922
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban disallow <item name> <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:1311
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}kick <player> [reason]."
msgstr ""

#: ../../TShockAPI/Commands.cs:5424
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}me <text>"
msgstr ""

#: ../../TShockAPI/Commands.cs:5437
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}p <team chat text>"
msgstr ""

#: ../../TShockAPI/Commands.cs:4030
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban add <proj id>"
msgstr ""

#: ../../TShockAPI/Commands.cs:4049
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban allow <id> <group>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4086
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban del <id>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4107
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban disallow <id> <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4796
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region allow <name> <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4866
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region allowg <group> <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4710
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region define <name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4752
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region delete <name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4925
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region info <region> [-d] [page]."
msgstr ""

#: ../../TShockAPI/Commands.cs:4733
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region protect <name> <true/false>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4831
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region remove <name> <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4901
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region removeg <group> <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:5109
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region rename <region> <new name>"
msgstr ""

#: ../../TShockAPI/Commands.cs:5099
#: ../../TShockAPI/Commands.cs:5102
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"
msgstr ""

#: ../../TShockAPI/Commands.cs:5159
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region tp <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:5047
#: ../../TShockAPI/Commands.cs:5050
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region z <name> <#>"
msgstr ""

#: ../../TShockAPI/Commands.cs:1037
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}register <password>."
msgstr ""

#: ../../TShockAPI/Commands.cs:6157
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}renameNPC <guide, nurse, etc.> <newname>"
msgstr ""

#: ../../TShockAPI/Commands.cs:4402
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}serverpassword \"<new password>\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:4583
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}slap <player> [damage]."
msgstr ""

#: ../../TShockAPI/Commands.cs:2601
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}spawnboss <boss type> [amount]."
msgstr ""

#: ../../TShockAPI/Commands.cs:2839
#: ../../TShockAPI/Commands.cs:2851
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}spawnmob <mob type> [amount]."
msgstr ""

#: ../../TShockAPI/Commands.cs:4206
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban add <tile id>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4225
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban allow <id> <group>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4262
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban del <id>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4283
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban disallow <id> <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:2931
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tp <player> [player 2]."
msgstr ""

#: ../../TShockAPI/Commands.cs:2933
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tp <player>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3058
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tphere <player>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3056
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tphere <player|*>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3103
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tpnpc <NPC>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3167
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tppos <tile x> <tile y>."
msgstr ""

#: ../../TShockAPI/Commands.cs:1249
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}userinfo <player>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3202
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp [command] [arguments]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3211
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp [name] or {0}warp list <page>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3254
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp add [name]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3271
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp del [name]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3294
#: ../../TShockAPI/Commands.cs:3297
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp hide [name] <true/false>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3305
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp send [player] [warpname]."
msgstr ""

#: ../../TShockAPI/Commands.cs:4625
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}wind <speed>."
msgstr ""

#: ../../TShockAPI/Commands.cs:2146
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}worldevent <event type>."
msgstr ""

#: ../../TShockAPI/Commands.cs:2548
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}worldmode <mode>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4736
#, csharp-format
msgid "Invalid syntax. Proper syntax: /region protect <name> <true/false>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4676
msgid "Invalid syntax. Proper syntax: /region set <1/2>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3151
#: ../../TShockAPI/Commands.cs:3312
#: ../../TShockAPI/Commands.cs:4589
#: ../../TShockAPI/Commands.cs:4597
msgid "Invalid target player."
msgstr ""

#: ../../TShockAPI/Commands.cs:1627
#: ../../TShockAPI/Commands.cs:1686
#, csharp-format
msgid "Invalid Ticket Number. Refer to {0} for details on how to use the {1} command"
msgstr ""

#: ../../TShockAPI/Commands.cs:4216
#: ../../TShockAPI/Commands.cs:4253
#: ../../TShockAPI/Commands.cs:4274
#: ../../TShockAPI/Commands.cs:4312
msgid "Invalid tile ID."
msgstr ""

#: ../../TShockAPI/Commands.cs:1943
msgid "Invalid time string! Proper format: _d_h_m_s, with at least one time specifier."
msgstr ""

#: ../../TShockAPI/Commands.cs:4548
#: ../../TShockAPI/Commands.cs:4557
msgid "Invalid time string. Proper format: hh:mm, in 24-hour time."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1332
#, csharp-format
msgid "Invalid Type: '{0}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:1079
#: ../../TShockAPI/Commands.cs:1212
#, csharp-format
msgid "Invalid user syntax. Try {0}user help."
msgstr ""

#: ../../TShockAPI/Commands.cs:3242
msgid "Invalid warp name. The names 'list', 'hide', 'del' and 'add' are reserved for commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4632
msgid "Invalid wind speed."
msgstr ""

#: ../../TShockAPI/Commands.cs:2559
#, csharp-format
msgid "Invalid world mode. Valid world modes: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1260
#, csharp-format
msgid "IP Address: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3981
msgid "Item Ban Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:3999
msgid "Item bans ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1920
#, csharp-format
msgid "Kicked {0} for : '{1}'"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1049
msgid "Kicked via web"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1919
#, csharp-format
msgid "Kicked: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5917
msgid "Kill syntax and example"
msgstr ""

#: ../../TShockAPI/Commands.cs:553
msgid "Kills another player."
msgstr ""

#: ../../TShockAPI/Commands.cs:393
msgid "Kills hostile NPCs or NPCs of a certain type."
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:114
#, csharp-format
msgid "LandGolfBallInCupHandler: Invalid golf ball projectile ID {0}! - From {1}"
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:130
#, csharp-format
msgid "LandGolfBallInCupHandler: Item selected is not a golf club! - From {0}"
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:92
#, csharp-format
msgid "LandGolfBallInCupHandler: Packet rejected for ID spoofing. Expected {0}, received {1} from {2}."
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:107
#, csharp-format
msgid "LandGolfBallInCupHandler: Tile at packet position X:{0} Y:{1} is not a golf hole! - From {2}"
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:100
#, csharp-format
msgid "LandGolfBallInCupHandler: X and Y position is out of world bounds! - From {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2493
msgid "Lanterns are now down."
msgstr ""

#: ../../TShockAPI/Commands.cs:2489
msgid "Lanterns are now up."
msgstr ""

#: ../../TShockAPI/Commands.cs:4423
msgid "Liquids are already settling."
msgstr ""

#: ../../TShockAPI/Commands.cs:5191
msgid "list - Lists all regions."
msgstr ""

#: ../../TShockAPI/Commands.cs:3975
msgid "list [page] - Lists all item bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:4153
msgid "list [page] - Lists all projectile bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:4329
msgid "list [page] - Lists all tile bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:3444
msgid "list [page] - Lists groups."
msgstr ""

#: ../../TShockAPI/Commands.cs:5327
msgid "List Online Players Syntax"
msgstr ""

#: ../../TShockAPI/TShock.cs:828
#, csharp-format
msgid "Listening on IP {0}."
msgstr ""

#: ../../TShockAPI/TShock.cs:809
#, csharp-format
msgid "Listening on port {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3445
msgid "listperm <group> [page] - Lists a group's permissions."
msgstr ""

#: ../../TShockAPI/Commands.cs:613
msgid "Lists commands or gives help on them."
msgstr ""

#: ../../TShockAPI/Commands.cs:2110
msgid "listusers - Lists all REST users and their current active tokens."
msgstr ""

#: ../../TShockAPI/TShock.cs:798
#, csharp-format
msgid "Loading dedicated config file: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3159
#, csharp-format
msgid "Location of {0} is ({1}, {2})."
msgstr ""

#: ../../TShockAPI/Commands.cs:1750
msgid "Log display disabled."
msgstr ""

#: ../../TShockAPI/Commands.cs:1746
msgid "Log display enabled."
msgstr ""

#: ../../TShockAPI/TShock.cs:785
#, csharp-format
msgid "Log path has been set to {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:874
msgid "Login attempt failed - see the message above."
msgstr ""

#: ../../TShockAPI/TShock.cs:980
msgid "Login before join enabled. Users may be prompted for an account specific password instead of a server password on connect."
msgstr ""

#: ../../TShockAPI/TShock.cs:985
msgid "Login using UUID enabled. Users automatically login via UUID."
msgstr ""

#: ../../TShockAPI/Commands.cs:240
msgid "Logs you into an account."
msgstr ""

#: ../../TShockAPI/Commands.cs:246
msgid "Logs you out of your current account."
msgstr ""

#: ../../TShockAPI/Commands.cs:1227
#, csharp-format
msgid "Machine name: {0}"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:141
msgid "Make sure that you trust the plugins you're installing."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2471
msgid "Malicious portal attempt."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:35
msgid "Manage plugins and their requirements"
msgstr ""

#: ../../TShockAPI/Commands.cs:280
msgid "Manages groups."
msgstr ""

#: ../../TShockAPI/Commands.cs:284
msgid "Manages item bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:268
msgid "Manages player bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:288
msgid "Manages projectile bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:296
msgid "Manages regions."
msgstr ""

#: ../../TShockAPI/Commands.cs:570
msgid "Manages the REST API."
msgstr ""

#: ../../TShockAPI/Commands.cs:376
msgid "Manages the server whitelist."
msgstr ""

#: ../../TShockAPI/Commands.cs:292
msgid "Manages tile bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:232
msgid "Manages user accounts."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1775
msgid "Manipulating unknown liquid type"
msgstr ""

#: ../../TShockAPI/Commands.cs:4721
#, csharp-format
msgid "Marked region {0} as protected."
msgstr ""

#: ../../TShockAPI/Commands.cs:4728
#, csharp-format
msgid "Marked region {0} as unprotected."
msgstr ""

#: ../../TShockAPI/Commands.cs:1222
#, csharp-format
msgid "Memory usage: {0}"
msgstr ""

#: ../../TShockAPI/SqlLog.cs:39
#, csharp-format
msgid "Message: {0}: {1}: {2}"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:874
msgid "Meteor has been spawned"
msgstr ""

#: ../../TShockAPI/Commands.cs:1334
msgid "Misbehaviour."
msgstr ""

#: ../../TShockAPI/Commands.cs:6214
msgid "Missing item name/id."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1274
#, csharp-format
msgid "Missing or empty {0} parameter"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1284
#, csharp-format
msgid "Missing or invalid {0} parameter"
msgstr ""

#: ../../TShockAPI/Commands.cs:6219
msgid "Missing player name."
msgstr ""

#: ../../TShockAPI/Commands.cs:1237
#, csharp-format
msgid "Mode: {0}"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1966
msgid "More than one match found -- unable to decide which is correct: "
msgstr ""

#: ../../TShockAPI/Commands.cs:2767
msgid "Mourning Wood"
msgstr ""

#: ../../TShockAPI/Net/BaseMsg.cs:29
msgid "Msg ID not implemented"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:294
#, csharp-format
msgid "Multiple user accounts found for {0} '{1}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:5461
msgid "Mute Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1293
msgid "N/A"
msgstr ""

#: ../../TShockAPI/Commands.cs:5189
msgid "name [-u][-z][-p] - Shows the name of the region at the given point."
msgstr ""

#: ../../TShockAPI/Commands.cs:1233
#, csharp-format
msgid "Name: {0}"
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:55
#, csharp-format
msgid "NetModuleHandler received attempt to unlock sacrifice while not in journey mode from {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1474
msgid "Never."
msgstr ""

#: ../../TShockAPI/Commands.cs:6176
msgid "New name is too large!"
msgstr ""

#: ../../TShockAPI/TShock.cs:864
#, csharp-format
msgid "New worlds will be generated with the {0} world evil type!"
msgstr ""

#: ../../TShockAPI/Permissions.cs:547
msgid "No associated commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:1694
msgid "No bans found matching the provided ticket number."
msgstr ""

#: ../../TShockAPI/Commands.cs:5784
#, csharp-format
msgid "No command or command alias matching \"{0}\" found."
msgstr ""

#: ../../TShockAPI/Permissions.cs:530
msgid "No description available."
msgstr ""

#: ../../TShockAPI/Commands.cs:145
msgid "No help available."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:721
msgid "No matching bans found."
msgstr ""

#: ../../TShockAPI/Commands.cs:1829
#, csharp-format
msgid "No player was found matching '{0}'."
msgstr ""

#: ../../TShockAPI/Commands.cs:1786
#, csharp-format
msgid "No players matched \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:6123
#, csharp-format
msgid "No prefix matched \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:5492
msgid "No reason specified."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1224
msgid "No special permissions are required for this route."
msgstr ""

#: ../../TShockAPI/Commands.cs:3474
#: ../../TShockAPI/Commands.cs:3483
#: ../../TShockAPI/Commands.cs:3524
#: ../../TShockAPI/Commands.cs:3569
#: ../../TShockAPI/Commands.cs:3614
#, csharp-format
msgid "No such group \"{0}\"."
msgstr ""

#: ../../TShockAPI/DB/IQueryBuilder.cs:345
msgid "No values supplied"
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:194
msgid "Not authorized. The provided token became invalid due to group changes, please create a new token."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:186
msgid "Not authorized. The specified API endpoint requires a token, but the provided token was not valid."
msgstr ""

#: ../../TShockAPI/Rest/RestCommand.cs:95
#: ../../TShockAPI/Rest/RestCommand.cs:101
#: ../../TShockAPI/Rest/SecureRest.cs:180
msgid "Not authorized. The specified API endpoint requires a token."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:200
#, csharp-format
msgid "Not authorized. User \"{0}\" has no access to use the specified API endpoint."
msgstr ""

#: ../../TShockAPI/Commands.cs:991
#, csharp-format
msgid "Not logged in or Invalid syntax. Proper syntax: {0}password <oldpassword> <newpassword>."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:468
msgid "Not upgrading work factor because bcrypt hash in an invalid format."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1383
#: ../../TShockAPI/Bouncer.cs:1387
#, csharp-format
msgid "NPC damage exceeded {0}."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:103
msgid "One moment..."
msgstr ""

#: ../../TShockAPI/DB/RegionManager.cs:102
#, csharp-format
msgid "One of your UserIDs is not a usable integer: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5344
#, csharp-format
msgid "Online Players ({0}/{1})"
msgstr ""

#: ../../TShockAPI/Commands.cs:1225
#, csharp-format
msgid "Operating system: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:308
msgid "Overrides serverside characters for a player, temporarily."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:105
msgid "Page {{0}} of {{1}}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3446
msgid "parent <group> <parent group> - Changes a group's parent group."
msgstr ""

#: ../../TShockAPI/Commands.cs:3504
#, csharp-format
msgid "Parent of \"{0}\" is \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3492
#, csharp-format
msgid "Parent of group \"{0}\" set to \"{1}\"."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:356
#, csharp-format
msgid "Parenting group {0} to {1} would cause loops in the parent chain."
msgstr ""

#: ../../TShockAPI/Commands.cs:1163
#, csharp-format
msgid "Password change attempt for {0} failed for an unknown reason. Check the server console for more details."
msgstr ""

#: ../../TShockAPI/Commands.cs:1155
#, csharp-format
msgid "Password change succeeded for {0}."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:492
#: ../../TShockAPI/DB/UserManager.cs:513
#, csharp-format
msgid "Password must be at least {0} characters."
msgstr ""

#: ../../TShockAPI/Commands.cs:980
#: ../../TShockAPI/Commands.cs:1017
#: ../../TShockAPI/Commands.cs:1031
#: ../../TShockAPI/Commands.cs:1097
#: ../../TShockAPI/Commands.cs:1168
#, csharp-format
msgid "Password must be greater than or equal to {0} characters."
msgstr ""

#: ../../TShockAPI/Commands.cs:997
#, csharp-format
msgid "PasswordUser returned an error: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1238
#, csharp-format
msgid "Path: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6622
msgid "Pearlwood Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:3774
#, csharp-format
msgid "Permissions for {0} ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:2680
msgid "Plantera"
msgstr ""

#: ../../TShockAPI/Commands.cs:1803
#, csharp-format
msgid "Player \"{0}\" has to perform a /login attempt first."
msgstr ""

#: ../../TShockAPI/Commands.cs:1808
#, csharp-format
msgid "Player \"{0}\" has to reconnect first, because they need to delete their trash."
msgstr ""

#: ../../TShockAPI/Commands.cs:1798
#, csharp-format
msgid "Player \"{0}\" is already logged in."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1883
#: ../../TShockAPI/TSPlayer.cs:1887
#, csharp-format
msgid "Player {0} has been disabled for {1}."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1394
#, csharp-format
msgid "Player {0} has been muted"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1399
#, csharp-format
msgid "Player {0} has been unmuted"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1307
#, csharp-format
msgid "Player {0} matches {1} player"
msgid_plural "Player {0} matches {1} players"
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:4792
#: ../../TShockAPI/Commands.cs:4827
#, csharp-format
msgid "Player {0} not found."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1140
#, csharp-format
msgid "Player {0} tried to sneak {1} onto the server!"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1069
#, csharp-format
msgid "Player {0} was killed"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1305
#, csharp-format
msgid "Player {0} was not found"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2604
#: ../../TShockAPI/Bouncer.cs:2611
#, csharp-format
msgid "Player damage exceeded {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6289
msgid "Player does not have free slots!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1182
#, csharp-format
msgid "Player does not have permission to create projectile {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1324
msgid "Player not found. Unable to kick the player."
msgstr ""

#: ../../TShockAPI/TShock.cs:1696
#, csharp-format
msgid "Please {0}register or {0}login to play!"
msgstr ""

#: ../../TShockAPI/Commands.cs:951
msgid "Please close NPC windows before logging out."
msgstr ""

#: ../../TShockAPI/Commands.cs:5761
msgid "Please enter a proper command name or alias."
msgstr ""

#: ../../TShockAPI/Commands.cs:1063
msgid "Please try a different username."
msgstr ""

#: ../../TShockAPI/Commands.cs:5415
#, csharp-format
msgid "Please use {0}login <username> <password> after this process."
msgstr ""

#: ../../TShockAPI/Commands.cs:5412
msgid "Please use the following to create a permanent account for you."
msgstr ""

#: ../../TShockAPI/TShock.cs:895
#, csharp-format
msgid "Port overridden by startup argument. Set to {0}"
msgstr ""

#: ../../TShockAPI/DB/ResearchDatastore.cs:53
#: ../../TShockAPI/DB/BanManager.cs:81
msgid "Possible problem with your database - is Sqlite3.dll present?"
msgstr ""

#: ../../TShockAPI/Commands.cs:3447
msgid "prefix <group> <prefix> - Changes a group's prefix."
msgstr ""

#: ../../TShockAPI/Commands.cs:3594
#, csharp-format
msgid "Prefix of \"{0}\" is \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3582
#, csharp-format
msgid "Prefix of group \"{0}\" set to \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:304
msgid "Prevents a player from talking."
msgstr ""

#: ../../TShockAPI/Commands.cs:1226
#, csharp-format
msgid "Proc count: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:4065
#: ../../TShockAPI/Commands.cs:4123
#, csharp-format
msgid "Projectile {0} is not banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:4159
msgid "Projectile Ban Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:4177
msgid "Projectile bans ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1286
#, csharp-format
msgid "Projectile create threshold exceeded {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1192
#, csharp-format
msgid "Projectile damage is higher than {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5198
msgid "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:159
msgid "Protected regions at this point: "
msgstr ""

#: ../../TShockAPI/Commands.cs:4950
#, csharp-format
msgid "Protected: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1373
#, csharp-format
msgid "Quick usage: {0} {1} \"Griefing\""
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:758
#, csharp-format
msgid "Rangecheck failed for {0} ({1}, {2}) (rg: {3}/{5}, {4}/{5})"
msgstr ""

#: ../../TShockAPI/TShock.cs:1196
msgid "Reached HealOtherPlayer threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2110
msgid "Reached HealOtherPlayer threshold."
msgstr ""

#: ../../TShockAPI/TShock.cs:1187
msgid "Reached paint threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1290
msgid "Reached projectile create threshold."
msgstr ""

#: ../../TShockAPI/TShock.cs:1178
msgid "Reached projectile threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:922
#: ../../TShockAPI/TShock.cs:1108
msgid "Reached TileKill threshold."
msgstr ""

#: ../../TShockAPI/TShock.cs:1169
msgid "Reached TileLiquid threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1686
#, csharp-format
msgid "Reached TileLiquid threshold {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1690
msgid "Reached TileLiquid threshold."
msgstr ""

#: ../../TShockAPI/TShock.cs:1125
msgid "Reached TilePlace threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:940
#: ../../TShockAPI/Bouncer.cs:2376
msgid "Reached TilePlace threshold."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:128
msgid "Read the message below to find out more."
msgstr ""

#: ../../TShockAPI/Commands.cs:1495
#, csharp-format
msgid "Reason: {0}."
msgstr ""

#: ../../TShockAPI/Extensions/DbExt.cs:254
#, csharp-format
msgid "Received type '{0}', however column '{1}' expects type '{2}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:5135
#, csharp-format
msgid "Region \"{0}\" already exists."
msgstr ""

#: ../../TShockAPI/Commands.cs:5167
#, csharp-format
msgid "Region \"{0}\" does not exist."
msgstr ""

#: ../../TShockAPI/Commands.cs:4701
#, csharp-format
msgid "Region {0} already exists."
msgstr ""

#: ../../TShockAPI/Commands.cs:4980
msgid "Region is not shared with any groups."
msgstr ""

#: ../../TShockAPI/Commands.cs:4969
msgid "Region is not shared with any users."
msgstr ""

#: ../../TShockAPI/Commands.cs:4949
#, csharp-format
msgid "Region owner: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4706
msgid "Region points need to be defined first. Use /region set 1 and /region set 2."
msgstr ""

#: ../../TShockAPI/Commands.cs:5141
msgid "Region renamed successfully!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5095
msgid "Region Resized Successfully!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5042
#, csharp-format
msgid "Region's z is now {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:4915
msgid "Regions ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:159
msgid "Regions at this point: "
msgstr ""

#: ../../TShockAPI/Commands.cs:258
msgid "Registers you an account."
msgstr ""

#: ../../TShockAPI/Commands.cs:1070
#, csharp-format
msgid "RegisterUser returned an error: {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2161
msgid "Released critter was not from its item."
msgstr ""

#: ../../TShockAPI/Commands.cs:364
msgid "Reloads the server configuration file."
msgstr ""

#: ../../TShockAPI/Commands.cs:5194
msgid "remove <user> <region> - Removes a user from a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:2521
#, csharp-format
msgid "Removed {0} players from the angler quest completion list for today."
msgstr ""

#: ../../TShockAPI/Commands.cs:4890
#, csharp-format
msgid "Removed group {0} from {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3494
#, csharp-format
msgid "Removed parent of group \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3584
#, csharp-format
msgid "Removed prefix of group \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3539
#, csharp-format
msgid "Removed suffix of group \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:4820
#, csharp-format
msgid "Removed user {0} from {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5196
msgid "removeg <group> <region> - Removes a user group from a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:300
msgid "Removes a player from the server."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:112
msgid "RemoveUser SQL returned an error"
msgstr ""

#: ../../TShockAPI/Commands.cs:3441
msgid "rename <group> <new name> - Changes a group's name."
msgstr ""

#: ../../TShockAPI/Commands.cs:5190
msgid "rename <region> <new name> - Renames the given region."
msgstr ""

#: ../../TShockAPI/Commands.cs:397
msgid "Renames an NPC."
msgstr ""

#: ../../TShockAPI/Commands.cs:566
msgid "Replies to a PM sent to you."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:93
msgid "Requested token was successfully destroyed."
msgstr ""

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:35
#, csharp-format
msgid "RequestTileEntityInteractionHandler: Rejected packet due to lack of building permissions! - From {0} | Position X:{1} Y:{2}, TileEntity type: {3}, Tile type: {4}"
msgstr ""

#: ../../TShockAPI/Commands.cs:419
msgid "Resets the list of users who have completed an angler quest that day."
msgstr ""

#: ../../TShockAPI/SaveManager.cs:163
#, csharp-format
msgid "resetTime {0}, direct {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5192
msgid "resize <region> <u/d/l/r> <amount> - Resizes a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:603
msgid "Respawn yourself or another player."
msgstr ""

#: ../../TShockAPI/UpdateManager.cs:87
msgid "Retrying in 5 minutes."
msgstr ""

#: ../../TShockAPI/Commands.cs:456
msgid "Returns the user's or specified user's current position."
msgstr ""

#: ../../TShockAPI/Commands.cs:6600
msgid "Rich Mahogany"
msgstr ""

#: ../../TShockAPI/Commands.cs:5627
msgid "Rocket Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:342
msgid "Rockets a player upwards. Requires SSC."
msgstr ""

#: ../../TShockAPI/Commands.cs:6662
msgid "Ruby Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:6604
msgid "Sakura Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:2783
msgid "Santa-NK1"
msgstr ""

#: ../../TShockAPI/Commands.cs:6654
msgid "Sapphire Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:312
msgid "Saves all serverside characters."
msgstr ""

#: ../../TShockAPI/Commands.cs:500
msgid "Saves the world file."
msgstr ""

#: ../../TShockAPI/SaveManager.cs:58
msgid "Saving world..."
msgstr ""

#: ../../TShockAPI/Commands.cs:1236
#, csharp-format
msgid "Seed: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:562
msgid "Sends a message to everyone on your team."
msgstr ""

#: ../../TShockAPI/Commands.cs:586
msgid "Sends a PM to a player."
msgstr ""

#: ../../TShockAPI/Commands.cs:599
msgid "Sends all tiles from the server to the player to resync the client with the actual world state."
msgstr ""

#: ../../TShockAPI/Commands.cs:557
msgid "Sends an action message to everyone."
msgstr ""

#: ../../TShockAPI/Commands.cs:431
msgid "Sends you to the world's spawn point."
msgstr ""

#: ../../TShockAPI/Commands.cs:426
msgid "Sends you to your spawn point."
msgstr ""

#: ../../TShockAPI/TShock.cs:738
msgid "Server console interrupted!"
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:337
msgid "Server is full"
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:341
msgid "Server is full. No reserved slots open."
msgstr ""

#: ../../TShockAPI/TShock.cs:1300
msgid "Server is shutting down..."
msgstr ""

#: ../../TShockAPI/BackupManager.cs:73
msgid "Server map saving..."
msgstr ""

#: ../../TShockAPI/Commands.cs:4407
#, csharp-format
msgid "Server password has been changed to: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2040
#: ../../TShockAPI/Commands.cs:2046
msgid "Server shutting down: "
msgstr ""

#: ../../TShockAPI/Commands.cs:2040
msgid "Server shutting down!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2046
msgid "Server shutting down."
msgstr ""

#: ../../TShockAPI/Commands.cs:959
msgid "Server side characters are enabled. You need to be logged-in to play."
msgstr ""

#: ../../TShockAPI/TShock.cs:1691
#, csharp-format
msgid "Server side characters is enabled! Please {0}register or {0}login to play!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1813
#, csharp-format
msgid "Server-side character data from \"{0}\" has been replaced by their current local data."
msgstr ""

#: ../../TShockAPI/Commands.cs:1773
msgid "Server-side characters is disabled."
msgstr ""

#: ../../TShockAPI/Commands.cs:5185
msgid "set <1/2> - Sets the temporary region points."
msgstr ""

#: ../../TShockAPI/Commands.cs:4697
#, csharp-format
msgid "Set region {0}."
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:187
#, csharp-format
msgid "Set temp point {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:510
msgid "Sets the dungeon's position to your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:401
msgid "Sets the maximum number of NPCs."
msgstr ""

#: ../../TShockAPI/Commands.cs:415
msgid "Sets the spawn rate of NPCs."
msgstr ""

#: ../../TShockAPI/Commands.cs:518
msgid "Sets the world time."
msgstr ""

#: ../../TShockAPI/Commands.cs:505
msgid "Sets the world's spawn point to your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:4427
msgid "Settling liquids."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:182
msgid "SetUserGroup SQL returned an error"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:134
msgid "SetUserPassword SQL returned an error"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:154
msgid "SetUserUUID SQL returned an error"
msgstr ""

#: ../../TShockAPI/Commands.cs:6612
msgid "Shadewood Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:5386
msgid "Share your server, talk with admins, and chill on GitHub & Discord. -- https://tshock.co/"
msgstr ""

#: ../../TShockAPI/Commands.cs:4975
msgid "Shared with groups: "
msgstr ""

#: ../../TShockAPI/Commands.cs:4964
msgid "Shared with: "
msgstr ""

#: ../../TShockAPI/Commands.cs:609
msgid "Shows a command's aliases."
msgstr ""

#: ../../TShockAPI/Commands.cs:332
msgid "Shows information about a player."
msgstr ""

#: ../../TShockAPI/Commands.cs:262
msgid "Shows information about a user."
msgstr ""

#: ../../TShockAPI/Commands.cs:526
msgid "Shows information about the current world."
msgstr ""

#: ../../TShockAPI/Commands.cs:621
msgid "Shows the currently connected players."
msgstr ""

#: ../../TShockAPI/Commands.cs:617
msgid "Shows the message of the day."
msgstr ""

#: ../../TShockAPI/Commands.cs:578
msgid "Shows the server information."
msgstr ""

#: ../../TShockAPI/Commands.cs:625
msgid "Shows the server's rules."
msgstr ""

#: ../../TShockAPI/Commands.cs:372
msgid "Shows the TShock version."
msgstr ""

#: ../../TShockAPI/Commands.cs:356
msgid "Shuts down the server while saving."
msgstr ""

#: ../../TShockAPI/Commands.cs:360
msgid "Shuts down the server without saving."
msgstr ""

#: ../../TShockAPI/TShock.cs:735
msgid "Shutting down safely. To force shutdown, send SIGINT (CTRL + C) again."
msgstr ""

#: ../../TShockAPI/Commands.cs:1234
#, csharp-format
msgid "Size: {0}x{1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2699
msgid "Skeletron"
msgstr ""

#: ../../TShockAPI/Commands.cs:2687
msgid "Skeletron Prime"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1069
#, csharp-format
msgid "Skipping SSC save (due to tshock.ignore.ssc) for {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:574
msgid "Slaps a player, dealing damage."
msgstr ""

#: ../../TShockAPI/Commands.cs:2446
msgid "Slime rain cannot be activated during normal rain. Stop the normal rainstorm and try again."
msgstr ""

#: ../../TShockAPI/Commands.cs:1062
#, csharp-format
msgid "Sorry, {0} was already taken by another person."
msgstr ""

#: ../../TShockAPI/Commands.cs:996
#: ../../TShockAPI/Commands.cs:1069
#, csharp-format
msgid "Sorry, an error occurred: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4378
msgid "Spawn has now been set at your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:5230
msgid "Spawn is now open."
msgstr ""

#: ../../TShockAPI/Commands.cs:5230
msgid "Spawn is now protected."
msgstr ""

#: ../../TShockAPI/Commands.cs:2874
#, csharp-format
msgid "Spawned {0} {1} time."
msgid_plural "Spawned {0} {1} times."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2891
msgid "Spawned a Wall of Flesh."
msgstr ""

#: ../../TShockAPI/Commands.cs:406
msgid "Spawns a number of bosses around you."
msgstr ""

#: ../../TShockAPI/Commands.cs:411
msgid "Spawns a number of mobs around you."
msgstr ""

#: ../../TShockAPI/Commands.cs:346
msgid "Spawns fireworks at a player."
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:433
msgid "Specified API endpoint doesn't exist. Refer to the documentation for a list of valid endpoints."
msgstr ""

#: ../../TShockAPI/SqlLog.cs:346
#, csharp-format
msgid "SQL log failed at: {0}. {1}"
msgstr ""

#: ../../TShockAPI/SqlLog.cs:317
#, csharp-format
msgid "SQL Log insert query failed: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5667
msgid "SSC must be enabled to use this command."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:434
#, csharp-format
msgid "Stack cheat detected. Remove armor {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:577
#, csharp-format
msgid "Stack cheat detected. Remove Defender's Forge item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:454
#, csharp-format
msgid "Stack cheat detected. Remove dye {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:414
#: ../../TShockAPI/TSPlayer.cs:474
#, csharp-format
msgid "Stack cheat detected. Remove item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:494
#, csharp-format
msgid "Stack cheat detected. Remove item dye {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:618
#: ../../TShockAPI/TSPlayer.cs:638
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 1 item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:658
#: ../../TShockAPI/TSPlayer.cs:678
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 2 item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:698
#: ../../TShockAPI/TSPlayer.cs:718
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 3 item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:515
#, csharp-format
msgid "Stack cheat detected. Remove piggy-bank item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:536
#, csharp-format
msgid "Stack cheat detected. Remove safe item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:556
#, csharp-format
msgid "Stack cheat detected. Remove trash item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:598
#, csharp-format
msgid "Stack cheat detected. Remove Void Vault item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/Commands.cs:2279
msgid "Started a blood moon event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2264
msgid "Started a full moon event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2306
msgid "Started an eclipse."
msgstr ""

#: ../../TShockAPI/TShock.cs:927
msgid "Startup parameter overrode maximum player slot configuration value."
msgstr ""

#: ../../TShockAPI/TShock.cs:909
msgid "Startup parameter overrode REST enable."
msgstr ""

#: ../../TShockAPI/TShock.cs:918
msgid "Startup parameter overrode REST port."
msgstr ""

#: ../../TShockAPI/TShock.cs:901
msgid "Startup parameter overrode REST token."
msgstr ""

#: ../../TShockAPI/Commands.cs:2310
msgid "Stopped an eclipse."
msgstr ""

#: ../../TShockAPI/Commands.cs:2283
msgid "Stopped the current blood moon event."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:167
msgid "Successful login"
msgstr ""

#: ../../TShockAPI/Commands.cs:3448
msgid "suffix <group> <suffix> - Changes a group's suffix."
msgstr ""

#: ../../TShockAPI/Commands.cs:3549
#, csharp-format
msgid "Suffix of \"{0}\" is \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3537
#, csharp-format
msgid "Suffix of group \"{0}\" set to \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:5798
msgid "Sync'd!"
msgstr ""

#: ../../TShockAPI/Handlers/SyncTilePickingHandler.cs:23
#, csharp-format
msgid "SyncTilePickingHandler: X and Y position is out of world bounds! - From {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3029
#, csharp-format
msgid "Teleported {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3094
#, csharp-format
msgid "Teleported {0} to yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:3008
#, csharp-format
msgid "Teleported everyone to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3081
msgid "Teleported everyone to yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:3183
#, csharp-format
msgid "Teleported to {0}, {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2954
#, csharp-format
msgid "Teleported to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3137
#, csharp-format
msgid "Teleported to the '{0}'."
msgstr ""

#: ../../TShockAPI/Commands.cs:2923
msgid "Teleported to the map's spawn point."
msgstr ""

#: ../../TShockAPI/Commands.cs:2917
msgid "Teleported to your spawn point (home)."
msgstr ""

#: ../../TShockAPI/Commands.cs:436
msgid "Teleports a player to another player."
msgstr ""

#: ../../TShockAPI/Commands.cs:441
msgid "Teleports a player to yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:582
msgid "Teleports you to a warp point or manages warps."
msgstr ""

#: ../../TShockAPI/Commands.cs:446
msgid "Teleports you to an npc."
msgstr ""

#: ../../TShockAPI/Commands.cs:451
msgid "Teleports you to tile coordinates."
msgstr ""

#: ../../TShockAPI/Commands.cs:324
msgid "Temporarily elevates you to Super Admin."
msgstr ""

#: ../../TShockAPI/Commands.cs:320
msgid "Temporarily sets another player's group."
msgstr ""

#: ../../TShockAPI/Commands.cs:4759
msgid "Temporary region set points have been removed."
msgstr ""

#: ../../TShockAPI/Commands.cs:5411
msgid "Temporary system access has been given to you, so you can run one command."
msgstr ""

#: ../../TShockAPI/Commands.cs:5387
msgid "Thank you for using TShock for Terraria!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1190
msgid "That group does not exist."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:258
msgid "The ban is invalid because a current ban for this identifier already exists."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:295
msgid "The ban was not valid for an unknown reason."
msgstr ""

#: ../../TShockAPI/Commands.cs:2634
msgid "the Brain of Cthulhu"
msgstr ""

#: ../../TShockAPI/Commands.cs:4522
#, csharp-format
msgid "The current time is {0}:{1:D2}."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:218
msgid "The default usergroup could not be found."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:217
msgid "The default usergroup could not be found. This may indicate a typo in the configuration file, or that the group was renamed or deleted."
msgstr ""

#: ../../TShockAPI/Commands.cs:3174
msgid "The destination coordinates provided don't look like valid numbers."
msgstr ""

#: ../../TShockAPI/Commands.cs:3334
#: ../../TShockAPI/Commands.cs:3349
#, csharp-format
msgid "The destination warp, {0}, was not found."
msgstr ""

#: ../../TShockAPI/Commands.cs:2641
msgid "the Destroyer"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3427
msgid "The Dungeon Guardian returned you to your spawn point."
msgstr ""

#: ../../TShockAPI/Commands.cs:4386
msgid "The dungeon's position has now been set at your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:2655
msgid "the Eater of Worlds"
msgstr ""

#: ../../TShockAPI/Commands.cs:2736
msgid "the Empress of Light"
msgstr ""

#: ../../TShockAPI/Commands.cs:2663
msgid "the Eye of Cthulhu"
msgstr ""

#: ../../TShockAPI/Commands.cs:2762
msgid "the Flying Dutchman"
msgstr ""

#: ../../TShockAPI/Commands.cs:2668
msgid "the Golem"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:595
#, csharp-format
msgid "The group {0} appeared more than once. Keeping current group settings."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:212
msgid "The guest group could not be found."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:211
msgid "The guest group could not be found. This may indicate a typo in the configuration file, or that the group was renamed or deleted."
msgstr ""

#: ../../TShockAPI/Commands.cs:2788
msgid "the Ice Queen"
msgstr ""

#: ../../TShockAPI/Commands.cs:5376
msgid "The initial setup system is disabled. This incident has been logged."
msgstr ""

#: ../../TShockAPI/Commands.cs:6097
#, csharp-format
msgid "The item type {0} is invalid."
msgstr ""

#: ../../TShockAPI/Commands.cs:2675
msgid "the King Slime"
msgstr ""

#: ../../TShockAPI/Commands.cs:2750
msgid "the Lunatic Cultist"
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:185
msgid "The method referenced by LineFormatter has thrown an exception. See inner exception for details."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:247
msgid "The method represented by termFormatter has thrown an exception. See inner exception for details."
msgstr ""

#: ../../TShockAPI/Commands.cs:2729
msgid "the Moon Lord"
msgstr ""

#: ../../TShockAPI/Commands.cs:3410
msgid "The permissions have been added to all of the groups in the system."
msgstr ""

#: ../../TShockAPI/Commands.cs:3715
msgid "The permissions have been removed from all of the groups in the system."
msgstr ""

#: ../../TShockAPI/Commands.cs:1860
msgid "The player's character data was successfully uploaded from their initial connection."
msgstr ""

#: ../../TShockAPI/Commands.cs:2772
msgid "the Pumpking"
msgstr ""

#: ../../TShockAPI/Commands.cs:2693
msgid "the Queen Bee"
msgstr ""

#: ../../TShockAPI/Commands.cs:2742
msgid "the Queen Slime"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:158
msgid "The REST authentication token."
msgstr ""

#: ../../TShockAPI/UpdateManager.cs:150
msgid "The server is out of date. Latest version: "
msgstr ""

#: ../../TShockAPI/Commands.cs:4495
msgid "The spawn rate you provided is out-of-range or not a number."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:90
msgid "The specified token queued for destruction failed to be deleted."
msgstr ""

#: ../../TShockAPI/Commands.cs:1869
msgid "The target player has not logged in yet."
msgstr ""

#: ../../TShockAPI/Commands.cs:1849
msgid "The targeted user cannot have their data uploaded, because they are not a player."
msgstr ""

#: ../../TShockAPI/Commands.cs:2707
msgid "the Twins"
msgstr ""

#: ../../TShockAPI/Commands.cs:1136
#, csharp-format
msgid "The user {0} does not exist! Therefore, the account was not deleted."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:95
msgid "The value has to be greater than or equal to zero."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:81
msgid "The value has to be greater than zero."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:127
msgid "The versions of plugins you requested aren't compatible with eachother."
msgstr ""

#: ../../TShockAPI/Commands.cs:2722
msgid "the Wall of Flesh"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:805
msgid "The world's chest limit has been reached - unable to place more."
msgstr ""

#: ../../TShockAPI/Commands.cs:1672
msgid "There are currently no active bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:2093
msgid "There are currently no active REST users."
msgstr ""

#: ../../TShockAPI/Commands.cs:1434
msgid "There are currently no available identifiers."
msgstr ""

#: ../../TShockAPI/Commands.cs:4001
msgid "There are currently no banned items."
msgstr ""

#: ../../TShockAPI/Commands.cs:4179
msgid "There are currently no banned projectiles."
msgstr ""

#: ../../TShockAPI/Commands.cs:4355
msgid "There are currently no banned tiles."
msgstr ""

#: ../../TShockAPI/Commands.cs:3776
#, csharp-format
msgid "There are currently no permissions for {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5341
msgid "There are currently no players online."
msgstr ""

#: ../../TShockAPI/Commands.cs:4917
msgid "There are currently no regions defined."
msgstr ""

#: ../../TShockAPI/Commands.cs:3230
msgid "There are currently no warps defined."
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:155
msgid "There are no regions at this point, or they are not protected."
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:154
msgid "There are no regions at this point."
msgstr ""

#: ../../TShockAPI/Commands.cs:2713
msgid "There is already a Wall of Flesh."
msgstr ""

#: ../../TShockAPI/Commands.cs:936
msgid "There was an error processing your login or authentication related request."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:121
msgid "There was an issue figuring out what to download."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:90
msgid "There was an issue reading the packages.json."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:99
#, csharp-format
msgid "This is the plugin you requested to install."
msgid_plural "These are the plugins you requested to install"
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/TShock.cs:1013
#: ../../TShockAPI/TShock.cs:1023
#, csharp-format
msgid "This token will display until disabled by verification. ({0}setup)"
msgstr ""

#: ../../TShockAPI/Commands.cs:4241
#: ../../TShockAPI/Commands.cs:4299
#, csharp-format
msgid "Tile {0} is not banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:4335
msgid "Tile Ban Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:4353
msgid "Tile bans ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:918
#, csharp-format
msgid "Tile kill threshold exceeded {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:936
#, csharp-format
msgid "Tile place threshold exceeded {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6420
#, csharp-format
msgid "To buff a player without them knowing, use {0} instead of {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6015
#: ../../TShockAPI/Commands.cs:6311
#, csharp-format
msgid "To execute this command silently, use {0} instead of {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6014
#, csharp-format
msgid "To get rid of NPCs without making them drop items, use the {0} command instead."
msgstr ""

#: ../../TShockAPI/Commands.cs:5464
#, csharp-format
msgid "To mute a player without broadcasting to chat, use the command with {0} instead of {1}"
msgstr ""

#: ../../TShockAPI/TShock.cs:1012
#: ../../TShockAPI/TShock.cs:1022
#, csharp-format
msgid "To setup the server, join the game and type {0}setup {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:471
msgid "Toggles build protection."
msgstr ""

#: ../../TShockAPI/Commands.cs:484
msgid "Toggles christmas mode (present spawning, santa, etc)."
msgstr ""

#: ../../TShockAPI/Commands.cs:545
msgid "Toggles godmode on a player."
msgstr ""

#: ../../TShockAPI/Commands.cs:480
msgid "Toggles halloween mode (goodie bags, pumpkins, etc)."
msgstr ""

#: ../../TShockAPI/Commands.cs:496
msgid "Toggles spawn protection."
msgstr ""

#: ../../TShockAPI/Commands.cs:492
msgid "Toggles the world's hardmode status."
msgstr ""

#: ../../TShockAPI/Commands.cs:591
msgid "Toggles to either ignore or recieve whispers from other players."
msgstr ""

#: ../../TShockAPI/Commands.cs:461
msgid "Toggles whether other people can teleport you."
msgstr ""

#: ../../TShockAPI/Commands.cs:276
msgid "Toggles whether you receive server logs."
msgstr ""

#: ../../TShockAPI/Commands.cs:777
msgid "Too many invalid login attempts."
msgstr ""

#: ../../TShockAPI/Commands.cs:6646
msgid "Topaz Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:1224
#, csharp-format
msgid "Total processor time: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5202
msgid "tp <region> - Teleports you to the given region's center."
msgstr ""

#: ../../TShockAPI/Commands.cs:6511
msgid "Trees types & misc available to use. ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:6700
#, csharp-format
msgid "Tried to grow a {0}."
msgstr ""

#: ../../TShockAPI/TShock.cs:399
#, csharp-format
msgid "TShock {0} ({1}) now running."
msgstr ""

#: ../../TShockAPI/Commands.cs:1367
msgid "TShock Ban Help"
msgstr ""

#: ../../TShockAPI/TShock.cs:449
msgid "TShock comes with no warranty & is free software."
msgstr ""

#: ../../TShockAPI/TShock.cs:461
msgid "TShock encountered a problem from which it cannot recover. The following message may help diagnose the problem."
msgstr ""

#: ../../TShockAPI/TShock.cs:1021
msgid "TShock Notice: setup-code.txt is still present, and the code located in that file will be used."
msgstr ""

#: ../../TShockAPI/TShock.cs:353
msgid "TShock was improperly shut down. Please use the exit command in the future to prevent this."
msgstr ""

#: ../../TShockAPI/TShock.cs:997
msgid "TShock will now disable the initial setup system and remove setup-code.txt as it is no longer needed."
msgstr ""

#: ../../TShockAPI/Commands.cs:5299
#, csharp-format
msgid "TShock: {0} {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1433
#, csharp-format
msgid "Type {0}ban help identifiers {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:1671
#, csharp-format
msgid "Type {0}ban list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:3455
#, csharp-format
msgid "Type {0}group help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:3746
#, csharp-format
msgid "Type {0}group list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:3775
#, csharp-format
msgid "Type {0}group listperm {1} {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:6512
#, csharp-format
msgid "Type {0}grow help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:5261
#, csharp-format
msgid "Type {0}help {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:3982
#, csharp-format
msgid "Type {0}itemban help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4000
#, csharp-format
msgid "Type {0}itemban list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:1053
#, csharp-format
msgid "Type {0}login \"{1}\" {2} to log-in to your account."
msgstr ""

#: ../../TShockAPI/Commands.cs:1055
#, csharp-format
msgid "Type {0}login {1} to log-in to your account."
msgstr ""

#: ../../TShockAPI/Commands.cs:1050
#, csharp-format
msgid "Type {0}login to log-in to your account using your UUID."
msgstr ""

#: ../../TShockAPI/Commands.cs:4160
#, csharp-format
msgid "Type {0}projban help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4178
#, csharp-format
msgid "Type {0}projban list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:5209
#, csharp-format
msgid "Type {0}region {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4987
#, csharp-format
msgid "Type {0}region info {1} {{0}} for more information."
msgstr ""

#: ../../TShockAPI/Commands.cs:4916
#, csharp-format
msgid "Type {0}region list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:2095
#, csharp-format
msgid "Type {0}rest listusers {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:4336
#, csharp-format
msgid "Type {0}tileban help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4354
#, csharp-format
msgid "Type {0}tileban list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:3229
#, csharp-format
msgid "Type {0}warp list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:5367
#, csharp-format
msgid "Type {0}who {1} for more."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:108
msgid "Type /<command> {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:6444
#, csharp-format
msgid "Unable to find any buff named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:6385
#, csharp-format
msgid "Unable to find any buffs named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:6429
#, csharp-format
msgid "Unable to find any player named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:6323
#, csharp-format
msgid "Unable to find any players named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:5670
#, csharp-format
msgid "Unable to launch {0} because he is not logged in."
msgstr ""

#: ../../TShockAPI/Commands.cs:5672
#, csharp-format
msgid "Unable to launch {0} because she is not logged in."
msgstr ""

#: ../../TShockAPI/TShock.cs:1484
msgid "Unable to parse command '{0}' from player {1}."
msgstr ""

#: ../../TShockAPI/TShock.cs:1483
msgid "Unable to parse command. Please contact an administrator for assistance."
msgstr ""

#: ../../TShockAPI/Commands.cs:2885
msgid "Unable to spawn a Wall of Flesh based on its current state or your current location."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:450
#, csharp-format
msgid "Unable to verify the password hash for user {0} ({1})"
msgstr ""

#: ../../TShockAPI/Commands.cs:3912
#, csharp-format
msgid "Unbanned {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4094
#, csharp-format
msgid "Unbanned projectile {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4270
#, csharp-format
msgid "Unbanned tile {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1455
#, csharp-format
msgid "Unknown ban command. Try {0} {1}, {2}, {3}, {4}, {5}, or {6}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6694
msgid "Unknown plant!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:246
msgid "Unrecognized player direction"
msgstr ""

#: ../../TShockAPI/TShock.cs:462
msgid "Until the problem is resolved, TShock will not be able to start (and will crash on startup)."
msgstr ""

#: ../../TShockAPI/UpdateManager.cs:120
#, csharp-format
msgid "Update server did not respond with an OK. Server message: [error {0}] {1}"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:197
msgid "UpdateLogin SQL returned an error"
msgstr ""

#: ../../TShockAPI/UpdateManager.cs:83
#: ../../TShockAPI/UpdateManager.cs:86
#, csharp-format
msgid "UpdateManager warning: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:316
msgid "Upload the account information when you joined the server as your Server Side Character data."
msgstr ""

#: ../../TShockAPI/Commands.cs:1916
#, csharp-format
msgid "Usage: {0}tempgroup <username> <new group> [time]"
msgstr ""

#: ../../TShockAPI/Commands.cs:2001
msgid "Usage: /sudo [command]."
msgstr ""

#: ../../TShockAPI/Commands.cs:1844
#: ../../TShockAPI/Commands.cs:1850
msgid "Usage: /uploadssc [playername]."
msgstr ""

#: ../../TShockAPI/Commands.cs:2441
#, csharp-format
msgid "Use \"{0}worldevent rain slime\" to start slime rain!"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1971
msgid "Use \"my query\" for items with spaces."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1972
msgid "Use tsi:[number] or tsn:[username] to distinguish between user IDs and usernames."
msgstr ""

#: ../../TShockAPI/Commands.cs:227
msgid "Used to authenticate as superadmin when first setting up TShock."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1341
#, csharp-format
msgid "User {0} '{1}' doesn't exist"
msgstr ""

#: ../../TShockAPI/Commands.cs:1114
#, csharp-format
msgid "User {0} already exists."
msgstr ""

#: ../../TShockAPI/Commands.cs:1118
#, csharp-format
msgid "User {0} could not be added, check console for details."
msgstr ""

#: ../../TShockAPI/Commands.cs:1198
#, csharp-format
msgid "User {0} could not be added. Check console for details."
msgstr ""

#: ../../TShockAPI/Commands.cs:1194
#: ../../TShockAPI/Commands.cs:1302
#, csharp-format
msgid "User {0} does not exist."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:612
#, csharp-format
msgid "User account {0} already exists"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:625
#, csharp-format
msgid "User account {0} does not exist"
msgstr ""

#: ../../TShockAPI/Commands.cs:1204
msgid "User management command help:"
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:138
#: ../../TShockAPI/Rest/SecureRest.cs:144
#: ../../TShockAPI/Rest/SecureRest.cs:152
msgid "Username or password may be incorrect or this account may not have sufficient privileges."
msgstr ""

#: ../../TShockAPI/TShock.cs:390
#: ../../TShockAPI/TShock.cs:394
#, csharp-format
msgid "Using {0} for tile implementation"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1794
#, csharp-format
msgid "Using {0} on non-honey"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1803
#, csharp-format
msgid "Using {0} on non-lava"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1810
#, csharp-format
msgid "Using {0} on non-shimmer"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1785
#, csharp-format
msgid "Using {0} on non-water"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1817
#, csharp-format
msgid "Using {0} on non-water or shimmer"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1825
#, csharp-format
msgid "Using {0} to manipulate unknown liquid {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1740
#, csharp-format
msgid "Using banned {0} to manipulate liquid"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1763
msgid "Using banned honey bucket without permissions"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1756
msgid "Using banned lava bucket without permissions"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1770
msgid "Using banned shimmering water bucket without permissions"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1749
msgid "Using banned water bucket without permissions"
msgstr ""

#: ../../TShockAPI/Commands.cs:924
msgid "UUID does not match this character."
msgstr ""

#: ../../TShockAPI/Commands.cs:2147
#, csharp-format
msgid "Valid event types: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2148
#, csharp-format
msgid "Valid invasion types if spawning an invasion: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2333
#, csharp-format
msgid "Valid invasion types: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2549
#, csharp-format
msgid "Valid world modes: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3250
#, csharp-format
msgid "Warp {0} already exists."
msgstr ""

#: ../../TShockAPI/Commands.cs:3286
#, csharp-format
msgid "Warp {0} is now private."
msgstr ""

#: ../../TShockAPI/Commands.cs:3288
#, csharp-format
msgid "Warp {0} is now public."
msgstr ""

#: ../../TShockAPI/Commands.cs:3246
#, csharp-format
msgid "Warp added: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3265
#, csharp-format
msgid "Warp deleted: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3345
#, csharp-format
msgid "Warped to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3228
msgid "Warps ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/TShock.cs:448
msgid "Welcome to TShock for Terraria!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5518
msgid "Whisper Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:6608
msgid "Willow Tree"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:85
msgid "Without a list of plugins to install, no plugins can be installed."
msgstr ""

#: ../../TShockAPI/BackupManager.cs:80
#, csharp-format
msgid "World backed up ({0})."
msgstr ""

#: ../../TShockAPI/BackupManager.cs:78
msgid "World backed up."
msgstr ""

#: ../../TShockAPI/Commands.cs:2574
#, csharp-format
msgid "World mode set to {0}."
msgstr ""

#: ../../TShockAPI/TShock.cs:818
#, csharp-format
msgid "World name will be overridden by: {0}"
msgstr ""

#: ../../TShockAPI/TShock.cs:775
#, csharp-format
msgid "World path has been set to {0}"
msgstr ""

#: ../../TShockAPI/SaveManager.cs:137
#, csharp-format
msgid "World saved at ({0})"
msgstr ""

#: ../../TShockAPI/SaveManager.cs:135
msgid "World saved."
msgstr ""

#: ../../TShockAPI/Commands.cs:4948
#, csharp-format
msgid "X: {0}; Y: {1}; W: {2}; H: {3}, Z: {4}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5938
msgid "You are already dead!"
msgstr ""

#: ../../TShockAPI/Commands.cs:783
msgid "You are already logged in, and cannot login again."
msgstr ""

#: ../../TShockAPI/Commands.cs:2913
msgid "You are dead. Dead players can't go home."
msgstr ""

#: ../../TShockAPI/TShock.cs:1501
msgid "You are muted!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5428
#: ../../TShockAPI/Commands.cs:5443
#: ../../TShockAPI/Commands.cs:5534
#: ../../TShockAPI/Commands.cs:5571
msgid "You are muted."
msgstr ""

#: ../../TShockAPI/Commands.cs:6758
#, csharp-format
msgid "You are no longer in god mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:5988
msgid "You are not dead!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5454
msgid "You are not in a party!"
msgstr ""

#: ../../TShockAPI/Commands.cs:945
msgid "You are not logged-in. Therefore, you cannot logout."
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:333
msgid "You are not on the whitelist."
msgstr ""

#: ../../TShockAPI/Commands.cs:5618
msgid "You are now being annoyed."
msgstr ""

#: ../../TShockAPI/Commands.cs:6757
#, csharp-format
msgid "You are now in god mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:6406
#: ../../TShockAPI/Commands.cs:6463
#, csharp-format
msgid "You buffed yourself with {0} ({1}) for {2} seconds."
msgstr ""

#: ../../TShockAPI/Commands.cs:6049
#, csharp-format
msgid "You butchered {0} NPC."
msgid_plural "You butchered {0} NPCs."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/TShock.cs:450
msgid "You can modify & distribute it under the terms of the GNU GPLv3."
msgstr ""

#: ../../TShockAPI/Commands.cs:694
#, csharp-format
msgid "You can use '{0}sudo {0}{1}' to override this check."
msgstr ""

#: ../../TShockAPI/Commands.cs:5602
#, csharp-format
msgid "You can use {0} instead of {1} to annoy a player silently."
msgstr ""

#: ../../TShockAPI/Commands.cs:5818
#: ../../TShockAPI/Commands.cs:5920
#, csharp-format
msgid "You can use {0} instead of {1} to execute this command silently."
msgstr ""

#: ../../TShockAPI/Commands.cs:5686
#, csharp-format
msgid "You can use {0} instead of {1} to launch a firework silently."
msgstr ""

#: ../../TShockAPI/Commands.cs:5630
#, csharp-format
msgid "You can use {0} instead of {1} to rocket a player silently."
msgstr ""

#: ../../TShockAPI/Commands.cs:5564
#, csharp-format
msgid "You can use {0}{1} to toggle this setting."
msgstr ""

#: ../../TShockAPI/Commands.cs:5591
#, csharp-format
msgid "You can use {0}{1} to whisper to other players."
msgstr ""

#: ../../TShockAPI/Commands.cs:6733
msgid "You can't god mode a non player!"
msgstr ""

#: ../../TShockAPI/Commands.cs:6333
msgid "You can't heal a dead player!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1337
msgid "You can't kick another admin."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:501
#: ../../TShockAPI/DB/GroupManager.cs:502
msgid "You can't remove the default guest group."
msgstr ""

#: ../../TShockAPI/Commands.cs:5957
msgid "You can't respawn the server console!"
msgstr ""

#: ../../TShockAPI/Commands.cs:814
msgid "You cannot login whilst crowd controlled."
msgstr ""

#: ../../TShockAPI/Commands.cs:800
msgid "You cannot login whilst dead."
msgstr ""

#: ../../TShockAPI/Commands.cs:808
msgid "You cannot login whilst using an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:6144
#: ../../TShockAPI/Commands.cs:6283
msgid "You cannot spawn banned items."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3445
msgid "You cannot use the Enchanted Sundial because time is stopped."
msgstr ""

#: ../../TShockAPI/Commands.cs:5541
msgid "You cannot whisper to yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:5851
#, csharp-format
msgid "You deleted {0} item within a radius of {1}."
msgid_plural "You deleted {0} items within a radius of {1}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:5875
#, csharp-format
msgid "You deleted {0} NPC within a radius of {1}."
msgid_plural "You deleted {0} NPCs within a radius of {1}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:5900
#, csharp-format
msgid "You deleted {0} projectile within a radius of {1}."
msgid_plural "You deleted {0} projectiles within a radius of {1}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:6316
msgid "You didn't put a player name."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4211
msgid "You died! Normally, you'd be banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:691
#: ../../TShockAPI/Commands.cs:5280
msgid "You do not have access to this command."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:828
msgid "You do not have permission to build in the spawn point."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:831
msgid "You do not have permission to build in this region."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:825
msgid "You do not have permission to build on this server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:74
msgid "You do not have permission to contribute research."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1184
msgid "You do not have permission to create that projectile."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:113
msgid "You do not have permission to freeze the biome spread of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:109
msgid "You do not have permission to freeze the rain strength of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:103
msgid "You do not have permission to freeze the time of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:110
msgid "You do not have permission to freeze the wind strength of the server."
msgstr ""

#: ../../TShockAPI/Commands.cs:6711
msgid "You do not have permission to god mode another player."
msgstr ""

#: ../../TShockAPI/Commands.cs:6522
msgid "You do not have permission to grow this tree type"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2960
msgid "You do not have permission to hurt Town NPCs."
msgstr ""

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:22
msgid "You do not have permission to modify a Hat Rack in a protected area!"
msgstr ""

#: ../../TShockAPI/Handlers/DisplayDollItemSyncHandler.cs:21
#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:28
msgid "You do not have permission to modify a Mannequin in a protected area!"
msgstr ""

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:34
msgid "You do not have permission to modify a TileEntity in a protected area!"
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:114
msgid "You do not have permission to modify the NPC spawn rate of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:107
msgid "You do not have permission to modify the rain strength of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:111
msgid "You do not have permission to modify the tile placement range of your character."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:104
msgid "You do not have permission to modify the time of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:108
msgid "You do not have permission to modify the time speed of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:106
msgid "You do not have permission to modify the wind strength of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:112
msgid "You do not have permission to modify the world difficulty of the server."
msgstr ""

#: ../../TShockAPI/Commands.cs:5479
#, csharp-format
msgid "You do not have permission to mute {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1732
msgid "You do not have permission to perform this action."
msgstr ""

#: ../../TShockAPI/ItemBans.cs:202
msgid "You do not have permission to place actuators."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3967
msgid "You do not have permission to place Logic Sensors."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:655
#: ../../TShockAPI/Bouncer.cs:2263
msgid "You do not have permission to place this tile."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3493
msgid "You do not have permission to relocate Town NPCs."
msgstr ""

#: ../../TShockAPI/Commands.cs:5965
msgid "You do not have permission to respawn another player."
msgstr ""

#: ../../TShockAPI/Commands.cs:5335
msgid "You do not have permission to see player IDs."
msgstr ""

#: ../../TShockAPI/Handlers/EmojiHandler.cs:19
msgid "You do not have permission to send emotes!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3532
msgid "You do not have permission to spawn pets."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4127
msgid "You do not have permission to start a party."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3525
msgid "You do not have permission to start invasions."
msgstr ""

#: ../../TShockAPI/Commands.cs:2156
#, csharp-format
msgid "You do not have permission to start the {0} event."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4145
msgid "You do not have permission to start the Old One's Army."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3518
msgid "You do not have permission to summon bosses."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2970
msgid "You do not have permission to summon the Empress of Light."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2987
msgid "You do not have permission to summon the Lunatic Cultist!"
msgstr ""

#: ../../TShockAPI/Commands.cs:3070
msgid "You do not have permission to teleport all other players."
msgstr ""

#: ../../TShockAPI/Commands.cs:2981
msgid "You do not have permission to teleport all players."
msgstr ""

#: ../../TShockAPI/Commands.cs:2964
msgid "You do not have permission to teleport other players."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3833
#, csharp-format
msgid "You do not have permission to teleport using {0}."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3745
msgid "You do not have permission to teleport using items."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/PylonHandler.cs:54
msgid "You do not have permission to teleport using pylons."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3769
msgid "You do not have permission to teleport using Wormhole Potions."
msgstr ""

#: ../../TShockAPI/Commands.cs:5154
msgid "You do not have permission to teleport."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:105
msgid "You do not have permission to toggle godmode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1839
msgid "You do not have permission to upload another player's character join-state server-side-character data."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3437
msgid "You do not have permission to use the Enchanted Sundial."
msgstr ""

#: ../../TShockAPI/Commands.cs:652
#, csharp-format
msgid "You entered a space after {0} instead of a command. Type {0}help for a list of valid commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:985
msgid "You failed to change your password."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2458
msgid "You have been Bounced."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1393
msgid "You have been remotely muted"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1398
msgid "You have been remotely unmmuted"
msgstr ""

#: ../../TShockAPI/Commands.cs:956
msgid "You have been successfully logged out of your account."
msgstr ""

#: ../../TShockAPI/Commands.cs:6465
#, csharp-format
msgid "You have buffed {0} with {1} ({2}) for {3} seconds!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1959
#, csharp-format
msgid "You have changed {0}'s group to {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1964
#, csharp-format
msgid "You have changed {0}'s group to {1} for {2}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4226
msgid "You have fallen in hardcore mode, and your items have been lost forever."
msgstr ""

#: ../../TShockAPI/Commands.cs:5662
#, csharp-format
msgid "You have launched {0} into space."
msgstr ""

#: ../../TShockAPI/Commands.cs:5660
msgid "You have launched yourself into space."
msgstr ""

#: ../../TShockAPI/Commands.cs:5498
#, csharp-format
msgid "You have muted {0} for {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5997
#, csharp-format
msgid "You have respawned {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6002
msgid "You have respawned yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:974
msgid "You have successfully changed your password."
msgstr ""

#: ../../TShockAPI/Commands.cs:5486
#, csharp-format
msgid "You have unmuted {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5590
msgid "You haven't previously received any whispers."
msgstr ""

#: ../../TShockAPI/Commands.cs:6347
#, csharp-format
msgid "You healed {0} for {1} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:6345
#, csharp-format
msgid "You healed yourself for {0} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:5947
#, csharp-format
msgid "You just killed {0}!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5945
msgid "You just killed yourself!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5744
#, csharp-format
msgid "You launched fireworks on {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5742
msgid "You launched fireworks on yourself."
msgstr ""

#: ../../TShockAPI/TShock.cs:608
msgid "You logged in from another location."
msgstr ""

#: ../../TShockAPI/TShock.cs:599
msgid "You logged in from the same IP."
msgstr ""

#: ../../TShockAPI/Commands.cs:5561
msgid "You may now receive whispers from other players."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2621
msgid "You may wish to consider removing the tshock.ignore.ssc permission or negating it for this player."
msgstr ""

#: ../../TShockAPI/DB/RegionManager.cs:788
msgid "You must be logged in to take advantage of protected regions."
msgstr ""

#: ../../TShockAPI/Commands.cs:5396
msgid "You must provide a setup code!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3448
msgid "You must set ForceTime to normal via config to use the Enchanted Sundial."
msgstr ""

#: ../../TShockAPI/Commands.cs:2718
msgid "You must spawn the Wall of Flesh in hell."
msgstr ""

#: ../../TShockAPI/Commands.cs:699
msgid "You must use this command in-game."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2523
msgid "You need to join with a hardcore player."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2517
msgid "You need to join with a mediumcore player or higher."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2511
msgid "You need to join with a softcore player."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:551
msgid "You need to rejoin to ensure your trash can is cleared!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2827
#, csharp-format
msgid "You spawned {0} {1} time."
msgid_plural "You spawned {0} {1} times."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:3329
#, csharp-format
msgid "You warped {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2995
#: ../../TShockAPI/Commands.cs:3035
#: ../../TShockAPI/Commands.cs:3078
#: ../../TShockAPI/Commands.cs:3093
#, csharp-format
msgid "You were teleported to {0}."
msgstr ""

#: ../../TShockAPI/TShock.cs:1706
msgid "You will be teleported to your last known location..."
msgstr ""

#: ../../TShockAPI/Commands.cs:5563
msgid "You will no longer receive whispers from other players."
msgstr ""

#: ../../TShockAPI/Commands.cs:6485
msgid "You're not allowed to change tiles here!"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:84
msgid "You're trying to sync, but you don't have a packages.json file."
msgstr ""

#: ../../TShockAPI/Commands.cs:1987
msgid "Your account has been elevated to superadmin for 10 minutes."
msgstr ""

#: ../../TShockAPI/Commands.cs:1046
#, csharp-format
msgid "Your account, \"{0}\", has been registered."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:235
#: ../../TShockAPI/DB/GroupManager.cs:237
msgid "Your account's group could not be loaded. Please contact server administrators about this."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:454
msgid "Your client sent a blank character name."
msgstr ""

#: ../../TShockAPI/TShock.cs:1351
msgid "Your client sent a blank UUID. Configure it to send one or use a different client."
msgstr ""

#: ../../TShockAPI/DB/RegionManager.cs:107
msgid "Your database contains invalid UserIDs (they should be integers)."
msgstr ""

#: ../../TShockAPI/Commands.cs:1966
#, csharp-format
msgid "Your group has been changed to {0} for {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1960
#, csharp-format
msgid "Your group has temporarily been changed to {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6149
msgid "Your inventory seems full."
msgstr ""

#: ../../TShockAPI/Commands.cs:1859
msgid "Your local character data, from your initial connection, has been uploaded to the server."
msgstr ""

#: ../../TShockAPI/Commands.cs:5385
#, csharp-format
msgid "Your new account has been verified, and the {0}setup system has been turned off."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3217
msgid "Your password did not match this character's password."
msgstr ""

#: ../../TShockAPI/Commands.cs:1047
#, csharp-format
msgid "Your password is {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1978
msgid "Your previous permission set has been restored."
msgstr ""

#: ../../TShockAPI/Commands.cs:5791
msgid "Your reference dumps have been created in the server folder."
msgstr ""

#: ../../TShockAPI/Commands.cs:1758
msgid "Your server-side character data has been saved."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1325
msgid "Your temporary group access has expired."
msgstr ""

#: ../../TShockAPI/Commands.cs:5199
msgid "z <name> <#> - Sets the z-order of the region."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3235
msgctxt "Likely non-vanilla client send zero-length password"
msgid "You have been Bounced for invalid password."
msgstr ""

#: ../../TShockAPI/TSServerPlayer.cs:34
msgctxt "The account name of server console."
msgid "ServerConsole"
msgstr ""


```
### Folder: `temp_TShock-5.2.4/i18n/es_ES`
#### File: `temp_TShock-5.2.4/i18n/es_ES/TShockAPI.po`
```
msgid ""
msgstr ""
"Project-Id-Version: tshock\n"
"POT-Creation-Date: 2022-12-06 05:43:49+0000\n"
"PO-Revision-Date: 2023-01-18 17:58\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: GetText.NET Extractor\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: tshock\n"
"X-Crowdin-Project-ID: 544368\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /general-devel/i18n/template.pot\n"
"X-Crowdin-File-ID: 6\n"
"Language: es_ES\n"

#: ../../TShockAPI/DB/CharacterManager.cs:194
#: ../../TShockAPI/DB/CharacterManager.cs:264
#, csharp-format
msgctxt "{0} is a player name"
msgid "Skipping SSC save (due to tshock.ignore.ssc) for {0}"
msgstr "Omitiendo guardado SSC (debido a tshock.ignore.ssc) para {0}"

#: ../../TShockAPI/DB/BanManager.cs:213
#, csharp-format
msgctxt "{0} is ban number, {1} is ban reason, {2} is a timestamp"
msgid "#{0} - You are banned: {1} ({2} remaining)"
msgstr "#{0} - Estás baneado: {1} ({2} restantes)"

#: ../../TShockAPI/DB/BanManager.cs:208
#, csharp-format
msgctxt "{0} is ban number, {1} is ban reason"
msgid "#{0} - You are banned: {1}"
msgstr "#{0} - Estás baneado: {1}"

#: ../../TShockAPI/Commands.cs:6499
msgid "     'basic', 'sakura', 'willow', 'boreal', 'mahogany', 'ebonwood', 'shadewood', 'pearlwood'."
msgstr "     'basic', 'sakura', 'willow', 'boreal', 'mahogany', 'ebonwood', 'shadewood', 'pearlwood'."

#: ../../TShockAPI/Commands.cs:6505
msgid "     'cactus', 'herb', 'mushroom'."
msgstr "     'cactus', 'herb', 'mushroom'."

#: ../../TShockAPI/Commands.cs:6501
msgid "     'palm', 'corruptpalm', 'crimsonpalm', 'hallowpalm'."
msgstr "     'palm', 'corruptpalm', 'crimsonpalm', 'hallowpalm'."

#: ../../TShockAPI/Commands.cs:6503
msgid "     'topaz', 'amethyst', 'sapphire', 'emerald', 'ruby', 'diamond', 'amber'."
msgstr "     'topaz', 'amethyst', 'sapphire', 'emerald', 'ruby', 'diamond', 'amber'."

#: ../../TShockAPI/Commands.cs:1446
#, csharp-format
msgid "   {0}{1} \"{2}\" (Find the IP associated with the offline target's account)"
msgstr "   {0}{1} \"{2}\" (Encuentre la IP asociada con la cuenta del objetivo desconectado)"

#: ../../TShockAPI/Commands.cs:1444
#, csharp-format
msgid "   {0}{1} \"{2}{3}\" {4} {5} (Permanently bans this account name)"
msgstr "   {0}{1} \"{2}{3}\" {4} {5} (Banea permanentemente este nombre de cuenta)"

#: ../../TShockAPI/Commands.cs:1449
#, csharp-format
msgid "   {0}{1} {2} (Find the player index for the target)"
msgstr "   {0}{1} {2} (Buscar el índice de jugador para el objetivo)"

#: ../../TShockAPI/Commands.cs:1450
#, csharp-format
msgid "   {0}{1} {2}{3} {4} {5} (Permanently bans the online player by Account, UUID, and IP)"
msgstr "   {0}{1} {2}{3} {4} {5} (Banea permanentemente al jugador conectado por cuenta, UUID, e IP)"

#: ../../TShockAPI/Commands.cs:1447
#, csharp-format
msgid "   {0}{1} {2}{3} {4} {5} (Permanently bans this IP address)"
msgstr "   {0}{1} {2}{3} {4} {5} (Banea de forma permanente esta dirección IP)"

#: ../../TShockAPI/Commands.cs:1386
#, csharp-format
msgid "   Eg a value of {0} would represent 10 days, 30 minutes, 0 seconds."
msgstr "   Por ejemplo, un valor de {0} representaría 10 días, 30 minutos, 0 segundos."

#: ../../TShockAPI/Commands.cs:1390
#, csharp-format
msgid "   If no {0} are specified, the command uses {1} by default."
msgstr "   Si no se especifican {0}, el comando utiliza {1} por defecto."

#: ../../TShockAPI/Commands.cs:1387
msgid "   If no duration is provided, the ban will be permanent."
msgstr "   Si no se indica la duración, el baneo será permanente."

#: ../../TShockAPI/Commands.cs:1389
#, csharp-format
msgid "   Unless {0} is passed to the command, {1} is assumed to be a player or player index"
msgstr "   A menos que se pase {0} al comando, se asume que {1} es un jugador o índice de jugador"

#: ../../TShockAPI/Commands.cs:1262
#, csharp-format
msgid " -> Logged-in as: {0}; in group {1}."
msgstr " -> Sesión iniciada como: {0}; en grupo {1}."

#: ../../TShockAPI/Commands.cs:1398
#, csharp-format
msgid "- {0} are provided when you add a ban, and can also be viewed with the {1} command."
msgstr "- {0} se proporcionan cuando se añade un baneo, y también se pueden ver con el comando {1}."

#: ../../TShockAPI/Commands.cs:1414
#, csharp-format
msgid "- {0} are provided when you add a ban, and can be found with the {1} command."
msgstr "- {0} se proporcionan cuando se añade un baneo, y se pueden encontrar con el comando {1}."

#: ../../TShockAPI/Commands.cs:1388
#, csharp-format
msgid "- {0}: -a (account name), -u (UUID), -n (character name), -ip (IP address), -e (exact, {1} will be treated as identifier)"
msgstr "- {0}: -a (nombre de la cuenta), -u (UUID), -n (nombre del jugador), -ip (dirección IP), -e (exacto, {1} será tratado como identificador)"

#: ../../TShockAPI/Commands.cs:1385
#, csharp-format
msgid "- {0}: uses the format {1} to determine the length of the ban."
msgstr "- {0}: utiliza el formato {1} para determinar la longitud del baneo."

#: ../../TShockAPI/Commands.cs:1443
msgid "- Ban an offline player by account name"
msgstr "- Banea a un jugador desconectado por su nombre de cuenta"

#: ../../TShockAPI/Commands.cs:1445
msgid "- Ban an offline player by IP address"
msgstr "- Banea a un jugador desconectado por su dirección IP"

#: ../../TShockAPI/Commands.cs:1448
msgid "- Ban an online player by index (Useful for hard to type names)"
msgstr "- Banea a un jugador conectado por índice (Útil para nombres difíciles de escribir)"

#: ../../TShockAPI/Commands.cs:6498
msgid "- Default trees :"
msgstr "- Árboles por defecto :"

#: ../../TShockAPI/Commands.cs:6502
msgid "- Gem trees :"
msgstr "- Árboles de gemas :"

#: ../../TShockAPI/Commands.cs:1406
msgid "- Lists active bans. Color trends towards green as the ban approaches expiration"
msgstr "- Enumera los baneos activos. El color tiende al verde a medida que el ban se aproxima a su vencimiento"

#: ../../TShockAPI/Commands.cs:6504
msgid "- Misc :"
msgstr "- Varios :"

#: ../../TShockAPI/Commands.cs:6500
msgid "- Palm trees :"
msgstr "- Palmeras :"

#: ../../TShockAPI/TShock.cs:963
msgid "!!! > Set DisableLoginBeforeJoin to true in the config file and /reload if this is a problem."
msgstr "!!! > En el archivo de configuración marca DisableLoginBeforeJoin como true y usa /reload si esto es un problema."

#: ../../TShockAPI/TShock.cs:957
msgid "!!! > Set DisableUUIDLogin to true in the config file and /reload if this is a problem."
msgstr "!!! > En el archivo de configuración marca DisableUUIDLogin como true y usa /reload si esto es un problema."

#: ../../TShockAPI/TShock.cs:962
msgid "!!! Login before join is enabled. Existing accounts can login & the server password will be bypassed."
msgstr "!!! Activado inicio de sesión antes de entrar. Las cuentas ya existentes pueden iniciar sesión omitiendo la contraseña del servidor."

#: ../../TShockAPI/TShock.cs:951
msgid "!!! The server password in config.json was overridden by the interactive prompt and will be ignored."
msgstr "!!! La contraseña del servidor en config.json fue anulada por el diálogo interactivo, y será ignorada."

#: ../../TShockAPI/TShock.cs:956
msgid "!!! UUID login is enabled. If a user's UUID matches an account, the server password will be bypassed."
msgstr "!!! El inicio de sesión UUID está habilitado. Si el UUID de un usuario coincide con una cuenta, la contraseña del servidor será omitida."

#: ../../TShockAPI/Commands.cs:6409
#, csharp-format
msgid "\"{0}\" is not a valid buff ID!"
msgstr "¡\"{0}\" no es un ID de buff válido!"

#: ../../TShockAPI/Commands.cs:5906
#, csharp-format
msgid "\"{0}\" is not a valid clear option."
msgstr "\"{0}\" no es una opción de eliminación válida."

#: ../../TShockAPI/Commands.cs:6026
#, csharp-format
msgid "\"{0}\" is not a valid NPC."
msgstr "\"{0}\" no es un PNJ válido."

#: ../../TShockAPI/PaginationTools.cs:283
#, csharp-format
msgid "\"{0}\" is not a valid page number."
msgstr "\"{0}\" no es un número de página válido."

#: ../../TShockAPI/Commands.cs:5826
#, csharp-format
msgid "\"{0}\" is not a valid radius."
msgstr "\"{0}\" no es un radio válido."

#: ../../TShockAPI/Rest/SecureRest.cs:213
#, csharp-format
msgid "\"{0}\" requested REST endpoint: {1}"
msgstr "\"{0}\" solicitó el punto final REST: {1}"

#: ../../TShockAPI/Commands.cs:2020
msgid "(Server Broadcast) "
msgstr "(Anuncio de Servidor) "

#: ../../TShockAPI/Configuration/TShockConfig.cs:496
msgid "(Super Admin) "
msgstr "(Super Admin) "

#: ../../TShockAPI/Commands.cs:1461
#, csharp-format
msgid "{0} - Ticket Number: {1}"
msgstr "{0} - Número de Ticket: {1}"

#: ../../TShockAPI/Commands.cs:2088
#, csharp-format
msgid "{0} ({1} tokens)"
msgstr "{0} ({1} tókens)"

#: ../../TShockAPI/Commands.cs:976
#, csharp-format
msgid "{0} ({1}) changed the password for account {2}."
msgstr "{0} ({1}) ha cambiado la contraseña de la cuenta {2}."

#: ../../TShockAPI/Commands.cs:986
#, csharp-format
msgid "{0} ({1}) failed to change the password for account {2}."
msgstr "{0} ({1}) no pudo cambiar la contraseña de la cuenta {2}."

#: ../../TShockAPI/TShock.cs:1659
#, csharp-format
msgid "{0} ({1}) from '{2}' group from '{3}' joined. ({4}/{5})"
msgstr "{0} ({1}) del grupo '{2}' desde '{3}' se ha conectado. ({4}/{5})"

#: ../../TShockAPI/TShock.cs:1667
#, csharp-format
msgid "{0} ({1}) from '{2}' group joined. ({3}/{4})"
msgstr "{0} ({1}) del grupo '{2}' se ha conectado. ({3}/{4})"

#: ../../TShockAPI/Commands.cs:775
#, csharp-format
msgid "{0} ({1}) had {2} or more invalid login attempts and was kicked automatically."
msgstr "{0} ({1}) tuvo {2} o más intentos de inicio de sesión no válidos y fue expulsado automáticamente."

#: ../../TShockAPI/TShock.cs:1663
#, csharp-format
msgid "{0} ({1}) has joined."
msgstr "{0} ({1}) se ha conectado."

#: ../../TShockAPI/Commands.cs:5354
#, csharp-format
msgid "{0} (Index: {1}, Account ID: {2})"
msgstr "{0} (Índice: {1}, ID de cuenta: {2})"

#: ../../TShockAPI/Commands.cs:5356
#, csharp-format
msgid "{0} (Index: {1})"
msgstr "{0} (Índice: {1})"

#: ../../TShockAPI/Commands.cs:1405
#, csharp-format
msgid "{0} [{1}]"
msgstr "{0} [{1}]"

#: ../../TShockAPI/Commands.cs:6011
#, csharp-format
msgid "{0} [{1}|{2}]"
msgstr "{0} [{1}|{2}]"

#: ../../TShockAPI/Commands.cs:1462
#: ../../TShockAPI/Commands.cs:1463
#, csharp-format
msgid "{0} {1}"
msgstr "{0} {1}"

#: ../../TShockAPI/Commands.cs:1467
#, csharp-format
msgid "{0} {1} ({2} ago)"
msgstr "{0} {1} (hace {2})"

#: ../../TShockAPI/Commands.cs:1481
#, csharp-format
msgid "{0} {1} ({2})"
msgstr "{0} {1} ({2})"

#: ../../TShockAPI/Commands.cs:5328
#, csharp-format
msgid "{0} {1} {2}"
msgstr "{0} {1} {2}"

#: ../../TShockAPI/Commands.cs:1464
#, csharp-format
msgid "{0} {1} on {2} ({3} ago)"
msgstr "{0} {1} el {2} (hace {3})"

#: ../../TShockAPI/Commands.cs:6368
#, csharp-format
msgid "{0} <\"{1}|{2}\"> [{3}]"
msgstr "{0} <\"{1}|{2}\"> [{3}]"

#: ../../TShockAPI/Commands.cs:1397
#: ../../TShockAPI/Commands.cs:1413
#: ../../TShockAPI/Commands.cs:5628
#: ../../TShockAPI/Commands.cs:5918
#, csharp-format
msgid "{0} <{1}>"
msgstr "{0} <{1}>"

#: ../../TShockAPI/Commands.cs:5462
#: ../../TShockAPI/Commands.cs:6308
#, csharp-format
msgid "{0} <{1}> [{2}]"
msgstr "{0} <{1}> [{2}]"

#: ../../TShockAPI/Commands.cs:1384
#, csharp-format
msgid "{0} <{1}> [{2}] [{3}] [{4}]"
msgstr "{0} <{1}> [{2}] [{3}] [{4}]"

#: ../../TShockAPI/Commands.cs:5684
#, csharp-format
msgid "{0} <{1}> [{2}|{3}|{4}|{5}]"
msgstr "{0} <{1}> [{2}|{3}|{4}|{5}]"

#: ../../TShockAPI/Commands.cs:5519
#: ../../TShockAPI/Commands.cs:5600
#, csharp-format
msgid "{0} <{1}> <{2}>"
msgstr "{0} <{1}> <{2}>"

#: ../../TShockAPI/Commands.cs:6418
#, csharp-format
msgid "{0} <{1}> <{2}|{3}> [{4}]"
msgstr "{0} <{1}> <{2}|{3}> [{4}]"

#: ../../TShockAPI/Commands.cs:5815
#, csharp-format
msgid "{0} <{1}|{2}|{3}> [{4}]"
msgstr "{0} <{1}|{2}|{3}> [{4}]"

#: ../../TShockAPI/Commands.cs:1106
#, csharp-format
msgid "{0} added account {1} to group {2}."
msgstr "{0} añadió la cuenta {1} al grupo {2}."

#: ../../TShockAPI/GetDataHandlers.cs:3546
#, csharp-format
msgid "{0} applied advanced combat techniques volume 2!"
msgstr "¡{0} aplicó el volumen 2 de Técnicas Avanzadas de Combate!"

#: ../../TShockAPI/GetDataHandlers.cs:3564
#, csharp-format
msgid "{0} applied advanced combat techniques!"
msgstr "¡{0} aplicó Técnicas Avanzadas de Combate!"

#: ../../TShockAPI/GetDataHandlers.cs:3543
#, csharp-format
msgid "{0} applied traveling merchant's satchel!"
msgstr "¡{0} ha aplicado el sachet del mercader ambulante!"

#: ../../TShockAPI/Commands.cs:1064
#, csharp-format
msgid "{0} attempted to register for the account {1} but it was already taken."
msgstr "{0} intentó registrar la cuenta {1} pero ya está en uso."

#: ../../TShockAPI/GetDataHandlers.cs:2637
#: ../../TShockAPI/GetDataHandlers.cs:3212
#, csharp-format
msgid "{0} authenticated successfully as user {1}."
msgstr "{0} se ha autenticado correctamente como el usuario {1}."

#: ../../TShockAPI/Commands.cs:905
#, csharp-format
msgid "{0} authenticated successfully as user: {1}."
msgstr "{0} se ha autenticado correctamente como el usuario: {1}."

#: ../../TShockAPI/TSPlayer.cs:1955
#, csharp-format
msgid "{0} banned {1} for '{2}'."
msgstr "{0} baneó a {1} por '{2}'."

#: ../../TShockAPI/Commands.cs:6051
#, csharp-format
msgid "{0} butchered {1} NPC."
msgid_plural "{0} butchered {1} NPCs."
msgstr[0] "{0} mató {1} PNJ."
msgstr[1] "{0} mató a {1} PNJ."

#: ../../TShockAPI/Commands.cs:2462
#, csharp-format
msgid "{0} caused it to rain slime."
msgstr "{0} inició una lluvia de slimes."

#: ../../TShockAPI/Commands.cs:2477
#, csharp-format
msgid "{0} caused it to rain."
msgstr "{0} inició una lluvia."

#: ../../TShockAPI/Commands.cs:1180
#, csharp-format
msgid "{0} changed account {1} to group {2}."
msgstr "{0} cambió la cuenta {1} al grupo {2}."

#: ../../TShockAPI/Commands.cs:4466
#, csharp-format
msgid "{0} changed the maximum spawns to {1}."
msgstr "{0} cambió la cantidad máxima de enemigos generados a {1}."

#: ../../TShockAPI/Commands.cs:4447
#, csharp-format
msgid "{0} changed the maximum spawns to 5."
msgstr "{0} cambió la cantidad máxima de enemigos generados a 5."

#: ../../TShockAPI/Commands.cs:1154
#, csharp-format
msgid "{0} changed the password for account {1}"
msgstr "{0} cambió la contraseña de la cuenta {1}"

#: ../../TShockAPI/Commands.cs:4505
#, csharp-format
msgid "{0} changed the spawn rate to {1}."
msgstr "{0} cambió la tasa de aparición de enemigos a {1}."

#: ../../TShockAPI/Commands.cs:4487
#, csharp-format
msgid "{0} changed the spawn rate to 600."
msgstr "{0} cambió la tasa de aparición de enemigos a 600."

#: ../../TShockAPI/Commands.cs:4639
#, csharp-format
msgid "{0} changed the wind speed to {1}."
msgstr "{0} cambió la velocidad del viento a {1}."

#: ../../TShockAPI/Commands.cs:5853
#, csharp-format
msgid "{0} deleted {1} item within a radius of {2}."
msgid_plural "{0} deleted {1} items within a radius of {2}."
msgstr[0] "{0} eliminó {1} objeto en un radio de {2}."
msgstr[1] "{0} eliminó {1} objetos en un radio de {2}."

#: ../../TShockAPI/Commands.cs:5877
#, csharp-format
msgid "{0} deleted {1} NPC within a radius of {2}."
msgid_plural "{0} deleted {1} NPCs within a radius of {2}."
msgstr[0] "{0} eliminó {1} PNJ en un radio de {2}."
msgstr[1] "{0} eliminó a {1} PNJ en un radio de {2}."

#: ../../TShockAPI/Commands.cs:5902
#, csharp-format
msgid "{0} deleted {1} projectile within a radius of {2}."
msgid_plural "{0} deleted {1} projectiles within a radius of {2}."
msgstr[0] "{0} eliminó {1} proyectil en un radio de {2}."
msgstr[1] "{0} eliminó {1} proyectiles en un radio de {2}."

#: ../../TShockAPI/Commands.cs:1887
#, csharp-format
msgid "{0} disabled halloween mode."
msgstr "{0} ha desactivado el modo halloween."

#: ../../TShockAPI/Commands.cs:1907
#, csharp-format
msgid "{0} disabled xmas mode."
msgstr "{0} ha desactivado el modo navidad."

#: ../../TShockAPI/TShock.cs:1398
#, csharp-format
msgid "{0} disconnected."
msgstr "{0} se desconectó."

#: ../../TShockAPI/Commands.cs:1885
#, csharp-format
msgid "{0} enabled halloween mode."
msgstr "{0} ha activado el modo halloween."

#: ../../TShockAPI/Commands.cs:1905
#, csharp-format
msgid "{0} enabled xmas mode."
msgstr "{0} ha activado el modo navidad."

#: ../../TShockAPI/Commands.cs:2469
#, csharp-format
msgid "{0} ended the rain."
msgstr "{0} detuvo la lluvia."

#: ../../TShockAPI/Commands.cs:2454
#, csharp-format
msgid "{0} ended the slime rain."
msgstr "{0} detuvo la lluvia de slimes."

#: ../../TShockAPI/Commands.cs:706
#, csharp-format
msgid "{0} executed (args omitted): {1}{2}."
msgstr "{0} ejecutó (argumentos omitidos): {1}{2}."

#: ../../TShockAPI/Commands.cs:704
#, csharp-format
msgid "{0} executed: {1}{2}."
msgstr "{0} ejecutó: {1}{2}."

#: ../../TShockAPI/Commands.cs:930
#, csharp-format
msgid "{0} failed to authenticate as user: {1}."
msgstr "{0} falló en identificarse como el usuario: {1}."

#: ../../TShockAPI/Commands.cs:6279
#, csharp-format
msgid "{0} gave you {1} {2}."
msgid_plural "{0} gave you {1} {2}s."
msgstr[0] "{0} te ha dado {1} {2}."
msgstr[1] "{0} te ha dado {1} {2}s."

#: ../../TShockAPI/Commands.cs:4247
#, csharp-format
msgid "{0} has been allowed to place tile {1}."
msgstr "A {0} se le ha permitido colocar el bloque {1}."

#: ../../TShockAPI/Commands.cs:3881
#, csharp-format
msgid "{0} has been allowed to use {1}."
msgstr "A {0} se le ha permitido usar {1}."

#: ../../TShockAPI/Commands.cs:4071
#, csharp-format
msgid "{0} has been allowed to use projectile {1}."
msgstr "A {0} se le ha permitido usar el proyectil {1}."

#: ../../TShockAPI/Commands.cs:4305
#, csharp-format
msgid "{0} has been disallowed from placing tile {1}."
msgstr "A {0} se le ha prohibido colocar el bloque {1}."

#: ../../TShockAPI/Commands.cs:4129
#, csharp-format
msgid "{0} has been disallowed from using projectile {1}."
msgstr "A {0} se le ha prohibido usar el proyectil {1}."

#: ../../TShockAPI/Commands.cs:3952
#, csharp-format
msgid "{0} has been disallowed to use {1}."
msgstr "A {0} se le ha prohibido usar {1}."

#: ../../TShockAPI/Commands.cs:6467
#, csharp-format
msgid "{0} has buffed you with {1} ({2}) for {3} seconds!"
msgstr "¡{0} te ha potenciado con {1} ({2}) por {3} segundos!"

#: ../../TShockAPI/Commands.cs:1186
#, csharp-format
msgid "{0} has changed your group to {1}."
msgstr "{0} ha cambiado tu grupo a {1}."

#: ../../TShockAPI/Commands.cs:2949
#: ../../TShockAPI/Commands.cs:3020
#: ../../TShockAPI/Commands.cs:3026
#, csharp-format
msgid "{0} has disabled incoming teleports."
msgstr "{0} ha desactivado los teletransportes entrantes."

#: ../../TShockAPI/Commands.cs:2412
#, csharp-format
msgid "{0} has ended the current invasion event."
msgstr "{0} finalizó la invasión en curso."

#: ../../TShockAPI/Commands.cs:2408
#, csharp-format
msgid "{0} has ended the Old One's Army event."
msgstr "{0} ha finalizado la invasión del Ejército del Antiguo."

#: ../../TShockAPI/TShock.cs:1670
#, csharp-format
msgid "{0} has joined."
msgstr "{0} se ha conectado."

#: ../../TShockAPI/TShock.cs:1674
#, csharp-format
msgid "{0} has joined. IP: {1}"
msgstr "{0} se ha conectado. IP: {1}"

#: ../../TShockAPI/Commands.cs:5655
#, csharp-format
msgid "{0} has launched {1} into space."
msgstr "{0} ha lanzado a {1} a la estratosfera."

#: ../../TShockAPI/Commands.cs:5653
#, csharp-format
msgid "{0} has launched herself into space."
msgstr "{0} se lanzó ella misma a la estratosfera."

#: ../../TShockAPI/Commands.cs:5651
#, csharp-format
msgid "{0} has launched himself into space."
msgstr "{0} se lanzó el mismo a la estratosfera."

#: ../../TShockAPI/TShock.cs:1397
#, csharp-format
msgid "{0} has left."
msgstr "{0} se desconectó."

#: ../../TShockAPI/Commands.cs:5500
#, csharp-format
msgid "{0} has muted {1} for {2}."
msgstr "{0} ha silenciado a {1} por {2}."

#: ../../TShockAPI/Commands.cs:5999
#, csharp-format
msgid "{0} has respawned you."
msgstr "{0} te ha reaparecido."

#: ../../TShockAPI/GetDataHandlers.cs:3555
#, csharp-format
msgid "{0} has sent a request to the bunny delivery service!"
msgstr "¡{0} ha enviado una solicitud al servicio de entrega de conejos!"

#: ../../TShockAPI/GetDataHandlers.cs:3561
#, csharp-format
msgid "{0} has sent a request to the cat delivery service!"
msgstr "¡{0} ha enviado una solicitud al servicio de entrega de gatos!"

#: ../../TShockAPI/GetDataHandlers.cs:3558
#, csharp-format
msgid "{0} has sent a request to the dog delivery service!"
msgstr "¡{0} ha enviado una solicitud al servicio de entrega de perros!"

#: ../../TShockAPI/GetDataHandlers.cs:3552
#, csharp-format
msgid "{0} has sent a request to the slime delivery service!"
msgstr "¡{0} ha enviado una solicitud al servicio de entrega de slimes!"

#: ../../TShockAPI/Commands.cs:2878
#, csharp-format
msgid "{0} has spawned {1} {2} time."
msgid_plural "{0} has spawned {1} {2} times."
msgstr[0] "{0} ha invocado a {1} {2} vez."
msgstr[1] "{0} ha invocado a {1} {2} veces."

#: ../../TShockAPI/Commands.cs:2895
#, csharp-format
msgid "{0} has spawned a Wall of Flesh."
msgstr "{0} ha invocado un Muro Carnoso."

#: ../../TShockAPI/GetDataHandlers.cs:2620
#, csharp-format
msgid "{0} has SSC data in the database, but has the tshock.ignore.ssc permission. This means their SSC data is being ignored."
msgstr "{0} tiene datos SSC en la base de datos, mas tiene el permiso tshock.ignore.ssc; sus datos SSC están siendo ignorados."

#: ../../TShockAPI/Commands.cs:2342
#, csharp-format
msgid "{0} has started a goblin army invasion."
msgstr "{0} inició la invasión del ejército de duendes."

#: ../../TShockAPI/Commands.cs:2396
#, csharp-format
msgid "{0} has started a martian invasion."
msgstr "{0} inició la invasión marciana."

#: ../../TShockAPI/Commands.cs:2354
#, csharp-format
msgid "{0} has started a pirate invasion."
msgstr "{0} inició la invasión pirata."

#: ../../TShockAPI/Commands.cs:2348
#, csharp-format
msgid "{0} has started a snow legion invasion."
msgstr "{0} inició la invasión de la legión de escarcha."

#: ../../TShockAPI/Commands.cs:5488
#, csharp-format
msgid "{0} has unmuted {1}."
msgstr "{0} ha desmuteado a {1}."

#: ../../TShockAPI/Commands.cs:6356
#, csharp-format
msgid "{0} healed {1} for {2} HP."
msgstr "{0} ha curado a {1} por {2} HP."

#: ../../TShockAPI/Commands.cs:6354
#, csharp-format
msgid "{0} healed herself for {1} HP."
msgstr "{0} se curó a sí misma por {1} HP."

#: ../../TShockAPI/Commands.cs:6352
#, csharp-format
msgid "{0} healed himself for {1} HP."
msgstr "{0} se curó a sí mismo por {1} HP."

#: ../../TShockAPI/Commands.cs:4250
#, csharp-format
msgid "{0} is already allowed to place tile {1}."
msgstr "{0} ya tenía permiso de colocar el bloque {1}."

#: ../../TShockAPI/Commands.cs:3885
#, csharp-format
msgid "{0} is already allowed to use {1}."
msgstr "{0} ya tenía permiso de usar {1}."

#: ../../TShockAPI/Commands.cs:4074
#, csharp-format
msgid "{0} is already allowed to use projectile {1}."
msgstr "{0} ya tenía permiso de usar el proyectil {1}."

#: ../../TShockAPI/Commands.cs:5940
#, csharp-format
msgid "{0} is already dead!"
msgstr "¡{0} ya había muerto!"

#: ../../TShockAPI/Commands.cs:3956
#, csharp-format
msgid "{0} is already disallowed to use {1}."
msgstr "{0} ya tenía prohibido usar {1}."

#: ../../TShockAPI/Commands.cs:4309
#, csharp-format
msgid "{0} is already prevented from placing tile {1}."
msgstr "A {0} ya se le había prohibido colocar el bloque {1}."

#: ../../TShockAPI/Commands.cs:4133
#, csharp-format
msgid "{0} is already prevented from using projectile {1}."
msgstr "A {0} ya se le había prohibido usar el proyectil {1}."

#: ../../TShockAPI/ItemBans.cs:234
#, csharp-format
msgid "{0} is banned! Remove it!"
msgstr "¡{0} es un objeto prohibido! ¡Desequípalo!"

#: ../../TShockAPI/Commands.cs:6751
#, csharp-format
msgid "{0} is no longer in god mode."
msgstr "{0} ya no está en modo dios."

#: ../../TShockAPI/Commands.cs:5546
#: ../../TShockAPI/Commands.cs:5577
#, csharp-format
msgid "{0} is not accepting whispers."
msgstr "{0} no está aceptando susurros."

#: ../../TShockAPI/Commands.cs:3875
#: ../../TShockAPI/Commands.cs:3946
#, csharp-format
msgid "{0} is not banned."
msgstr "{0} no está baneado(a)."

#: ../../TShockAPI/Commands.cs:5990
#, csharp-format
msgid "{0} is not dead!"
msgstr "¡{0} no ha muerto!"

#: ../../TShockAPI/Commands.cs:6750
#, csharp-format
msgid "{0} is now in god mode."
msgstr "{0} está ahora en modo dios."

#: ../../TShockAPI/Commands.cs:5586
#, csharp-format
msgid "{0} is offline and cannot receive your reply."
msgstr "{0} está desconectado(a) y no puede recibir tu respuesta."

#: ../../TShockAPI/Commands.cs:5949
#: ../../TShockAPI/Rest/RestManager.cs:1068
#, csharp-format
msgid "{0} just killed you!"
msgstr "¡{0} te acaba de matar!"

#: ../../TShockAPI/TSPlayer.cs:1926
#, csharp-format
msgid "{0} kicked {1} for '{2}'"
msgstr "{0} expulsó a {1} por '{2}'"

#: ../../TShockAPI/Commands.cs:5746
#, csharp-format
msgid "{0} launched fireworks on you."
msgstr "{0} lanzó fuegos artificiales sobre ti."

#: ../../TShockAPI/Rest/RestManager.cs:847
#, csharp-format
msgid "{0} NPC has been killed."
msgid_plural "{0} NPCs have been killed."
msgstr[0] "Se ha matado a {0} NPC."
msgstr[1] "Se han matado {killcount} NPC."

#: ../../TShockAPI/Commands.cs:1058
#, csharp-format
msgid "{0} registered an account: \"{1}\"."
msgstr "{0} registró una cuenta: \"{1}\"."

#: ../../TShockAPI/Commands.cs:1478
#, csharp-format
msgid "{0} remaining."
msgstr "{0} restante(s)."

#: ../../TShockAPI/Commands.cs:6196
#, csharp-format
msgid "{0} renamed the {1}."
msgstr "{0} renombró a {1}."

#: ../../TShockAPI/Commands.cs:4574
#, csharp-format
msgid "{0} set the time to {1}:{2:D2}."
msgstr "{0} cambió el tiempo a {1}:{2:D2}."

#: ../../TShockAPI/Commands.cs:4542
#, csharp-format
msgid "{0} set the time to 00:00."
msgstr "{0} cambió el tiempo a 00:00."

#: ../../TShockAPI/Commands.cs:4530
#, csharp-format
msgid "{0} set the time to 04:30."
msgstr "{0} cambió el tiempo a 04:30."

#: ../../TShockAPI/Commands.cs:4538
#, csharp-format
msgid "{0} set the time to 12:00."
msgstr "{0} cambió el tiempo a 12:00."

#: ../../TShockAPI/Commands.cs:4534
#, csharp-format
msgid "{0} set the time to 19:30."
msgstr "{0} cambió el tiempo a 19:30."

#: ../../TShockAPI/Commands.cs:4616
#: ../../TShockAPI/Commands.cs:4617
#, csharp-format
msgid "{0} slapped {1} for {2} damage."
msgstr "{0} abofeteó por {2} de daño a {1}."

#: ../../TShockAPI/Commands.cs:2831
#, csharp-format
msgid "{0} spawned {1} {2} time."
msgid_plural "{0} spawned {1} {2} times."
msgstr[0] "{0} invocó a {1} {2} vez."
msgstr[1] "{0} invocó a {1} {2} veces."

#: ../../TShockAPI/Commands.cs:2290
#, csharp-format
msgid "{0} started a blood moon event."
msgstr "{0} inició una luna sangrienta."

#: ../../TShockAPI/Commands.cs:2268
#, csharp-format
msgid "{0} started a full moon event."
msgstr "{0} inició una luna llena."

#: ../../TShockAPI/Commands.cs:2500
#, csharp-format
msgid "{0} started a lantern night."
msgstr "{0} inició una noche de faroles."

#: ../../TShockAPI/Commands.cs:2427
#, csharp-format
msgid "{0} started a sandstorm event."
msgstr "{0} inició una tormenta de arena."

#: ../../TShockAPI/Commands.cs:2317
#, csharp-format
msgid "{0} started an eclipse."
msgstr "{0} inició un eclipse."

#: ../../TShockAPI/Commands.cs:2391
#, csharp-format
msgid "{0} started the frost moon at wave {1}!"
msgstr "¡{0} inició la luna helada en la ronda {1}!"

#: ../../TShockAPI/GetDataHandlers.cs:4150
#: ../../TShockAPI/GetDataHandlers.cs:4152
#, csharp-format
msgid "{0} started the Old One's Army event!"
msgstr "¡{0} inició el evento del Ejército del Antiguo!"

#: ../../TShockAPI/Commands.cs:2373
#, csharp-format
msgid "{0} started the pumpkin moon at wave {1}!"
msgstr "¡{0} inició la luna calabaza en la ronda {1}!"

#: ../../TShockAPI/Commands.cs:2321
#, csharp-format
msgid "{0} stopped an eclipse."
msgstr "{0} detuvo un eclipse."

#: ../../TShockAPI/Commands.cs:2294
#, csharp-format
msgid "{0} stopped the current blood moon."
msgstr "{0} detuvo la luna sangrienta en curso."

#: ../../TShockAPI/Commands.cs:2422
#, csharp-format
msgid "{0} stopped the current sandstorm event."
msgstr "{0} detuvo la tormenta de arena en curso."

#: ../../TShockAPI/Commands.cs:2504
#, csharp-format
msgid "{0} stopped the lantern night."
msgstr "{0} detuvo la noche de faroles."

#: ../../TShockAPI/Commands.cs:1132
#, csharp-format
msgid "{0} successfully deleted account: {1}."
msgstr "{0} eliminó exitosamente la cuenta: {1}."

#: ../../TShockAPI/GetDataHandlers.cs:3567
#, csharp-format
msgid "{0} summoned a Blood Moon!"
msgstr "¡{0} invocó una Luna Sangrienta!"

#: ../../TShockAPI/GetDataHandlers.cs:3579
#, csharp-format
msgid "{0} summoned a frost moon!"
msgstr "¡{0} invocó una Luna Helada!"

#: ../../TShockAPI/GetDataHandlers.cs:3591
#, csharp-format
msgid "{0} summoned a Goblin Invasion!"
msgstr "¡{0} ha invocado una Invasión de Duendes!"

#: ../../TShockAPI/GetDataHandlers.cs:3573
#, csharp-format
msgid "{0} summoned a Martian invasion!"
msgstr "¡{0} invocó una invasión Marciana!"

#: ../../TShockAPI/GetDataHandlers.cs:3549
#, csharp-format
msgid "{0} summoned a Mechdusa!"
msgstr "¡{0} ha invocado a Mechdusa!"

#: ../../TShockAPI/GetDataHandlers.cs:3570
#, csharp-format
msgid "{0} summoned a Moon Lord!"
msgstr "¡{0} ha invocado al Señor de la Luna!"

#: ../../TShockAPI/GetDataHandlers.cs:3582
#, csharp-format
msgid "{0} summoned a pumpkin moon!"
msgstr "¡{0} invocó una Luna Calabaza!"

#: ../../TShockAPI/GetDataHandlers.cs:3576
#, csharp-format
msgid "{0} summoned an eclipse!"
msgstr "¡{0} invocó un eclipse!"

#: ../../TShockAPI/GetDataHandlers.cs:3598
#, csharp-format
msgid "{0} summoned the {1}!"
msgstr "¡{0} ha invocado a {1}"

#: ../../TShockAPI/GetDataHandlers.cs:2977
#: ../../TShockAPI/GetDataHandlers.cs:2980
#, csharp-format
msgid "{0} summoned the Empress of Light!"
msgstr "¡{0} ha invocado a la Emperatriz de la Luz!"

#: ../../TShockAPI/GetDataHandlers.cs:3585
#, csharp-format
msgid "{0} summoned the Pirates!"
msgstr "¡{0} ha invocado los Piratas!"

#: ../../TShockAPI/GetDataHandlers.cs:3588
#, csharp-format
msgid "{0} summoned the Snow Legion!"
msgstr "¡{0} ha invocado a la Legión de Escarcha!"

#: ../../TShockAPI/Commands.cs:3004
#: ../../TShockAPI/Commands.cs:3044
#, csharp-format
msgid "{0} teleported {1} to you."
msgstr "{0} teletransportó a {1} hacia ti."

#: ../../TShockAPI/Commands.cs:2956
#, csharp-format
msgid "{0} teleported to you."
msgstr "{0} se teletransportó hacia ti."

#: ../../TShockAPI/Commands.cs:2997
#: ../../TShockAPI/Commands.cs:3037
#, csharp-format
msgid "{0} teleported you to {1}."
msgstr "{0} te teletransportó hacia {1}."

#: ../../TShockAPI/Commands.cs:690
#, csharp-format
msgid "{0} tried to execute (args omitted) {1}{2}."
msgstr "{0} intentó ejecutar (argumentos omitidos) {1}{2}."

#: ../../TShockAPI/Commands.cs:688
#, csharp-format
msgid "{0} tried to execute {1}{2}."
msgstr "{0} intentó ejecutar {1}{2}."

#: ../../TShockAPI/Commands.cs:2255
#, csharp-format
msgid "{0} triggered a meteor."
msgstr "{0} desencadenó un meteoro."

#: ../../TShockAPI/Commands.cs:3328
#, csharp-format
msgid "{0} warped you to {1}."
msgstr "{0} te transportó hacia {1}."

#: ../../TShockAPI/TSPlayer.cs:1953
#, csharp-format
msgid "{0} was banned for '{1}'."
msgstr "{0} fue baneado por '{1}'."

#: ../../TShockAPI/TSPlayer.cs:1924
#, csharp-format
msgid "{0} was kicked for '{1}'"
msgstr "Se expulsó a {0} por '{1}'"

#: ../../TShockAPI/Commands.cs:3002
#: ../../TShockAPI/Commands.cs:3042
#, csharp-format
msgid "{0} was teleported to you."
msgstr "Se teletransportó a {0} hacia ti."

#: ../../TShockAPI/Commands.cs:1296
#, csharp-format
msgid "{0}'s group is {1}."
msgstr "El grupo de {0} es {1}."

#: ../../TShockAPI/Commands.cs:1297
#, csharp-format
msgid "{0}'s last known IP is {1}."
msgstr "La última IP conocida de {0} es {1}."

#: ../../TShockAPI/Commands.cs:1286
#, csharp-format
msgid "{0}'s last login occurred {1} {2} UTC{3}."
msgstr "El último inicio de sesión de {0} fue el {1} {2} UTC{3}."

#: ../../TShockAPI/Commands.cs:1298
#, csharp-format
msgid "{0}'s register date is {1} {2} UTC{3}."
msgstr "La fecha de registro de {0} es el {1} {2} UTC{3}."

#: ../../TShockAPI/Commands.cs:5778
#, csharp-format
msgid "{0}{1} defines no aliases."
msgstr "{0}{1} no define ningún alias."

#: ../../TShockAPI/Commands.cs:5284
#, csharp-format
msgid "{0}{1} help: "
msgstr "Ayuda de {0}{1}: "

#: ../../TShockAPI/Utils.cs:1152
#, csharp-format
msgid "{0}{1}/{2} on {3} @ {4}:{5} (TShock for Terraria v{6})"
msgstr "{0}{1}/{2} en {3} @ {4}:{5} (TShock para Terraria v{6})"

#: ../../TShockAPI/Commands.cs:850
#, csharp-format
msgid "{0}login - Authenticates you using your UUID and character name."
msgstr "{0}login - Inicia tu sesión usando tu UUID y nombre de personaje."

#: ../../TShockAPI/Commands.cs:855
#, csharp-format
msgid "{0}login <password> - Authenticates you using your password and character name."
msgstr "{0}login <contraseña> - Inicias sesión usando tu contraseña y el nombre del personaje."

#: ../../TShockAPI/Commands.cs:853
#, csharp-format
msgid "{0}login <username> <password> - Authenticates you using your username and password."
msgstr "{0}login <nombreUsuario> <contraseña> - Inicias sesión usando tu nombre de usuario y contraseña."

#: ../../TShockAPI/Commands.cs:5413
#, csharp-format
msgid "{0}user add <username> <password> owner"
msgstr "{0}user add <usuario> <contraseña> owner"

#: ../../TShockAPI/Commands.cs:1205
#, csharp-format
msgid "{0}user add username password group   -- Adds a specified user"
msgstr "{0}user add username password group   -- Agrega al usuario especificado"

#: ../../TShockAPI/Commands.cs:1206
#, csharp-format
msgid "{0}user del username                  -- Removes a specified user"
msgstr "{0}user del username                  -- Elimina al usuario especificado"

#: ../../TShockAPI/Commands.cs:1208
#, csharp-format
msgid "{0}user group username newgroup       -- Changes a user's group"
msgstr "{0}user group username newgroup       -- Cambia el grupo de un usuario"

#: ../../TShockAPI/Commands.cs:1207
#, csharp-format
msgid "{0}user password username newpassword -- Changes a user's password"
msgstr "{0}user password username newpassword -- Cambia la contraseña de un usuario"

#: ../../TShockAPI/Permissions.cs:547
#, csharp-format
msgid "* **Commands**: `{0}`"
msgstr "* **Comandos**: `{0}`"

#: ../../TShockAPI/Configuration/ServerSideConfig.cs:123
#: ../../TShockAPI/Configuration/TShockConfig.cs:645
#, csharp-format
msgid "* **Default**: `{0}`"
msgstr "* **Predeterminado**: `{0}`"

#: ../../TShockAPI/Configuration/ServerSideConfig.cs:122
#: ../../TShockAPI/Configuration/TShockConfig.cs:644
#, csharp-format
msgid "* **Field type**: `{0}`"
msgstr "* **Tipo de campo**: `{0}`"

#: ../../TShockAPI/Rest/RestManager.cs:1220
#, csharp-format
msgid "* **Permissions**: `{0}`"
msgstr "* **Permisos**: `{0}`"

#: ../../TShockAPI/Commands.cs:5430
#, csharp-format
msgid "*{0} {1}"
msgstr "*{0} {1}"

#: ../../TShockAPI/Rest/RestManager.cs:1253
#, csharp-format
msgid "**Example Usage**: `{0}?{1}`"
msgstr "**Ejemplo de Uso**: `{0}?{1}`"

#: ../../TShockAPI/Rest/RestManager.cs:1243
msgid "**Nouns**:"
msgstr "**Sustantivos**:"

#: ../../TShockAPI/Rest/RestManager.cs:1230
msgid "**Verbs**:"
msgstr "**Verbos**:"

#: ../../TShockAPI/Commands.cs:1613
#, csharp-format
msgid "#{0} - You have been banned: {1}."
msgstr "#{0} - Has sido baneado(a): {1}."

#: ../../TShockAPI/Commands.cs:5446
#, csharp-format
msgid "<{0}> {1}"
msgstr "<{0}> {1}"

#: ../../TShockAPI/Commands.cs:5550
#: ../../TShockAPI/Commands.cs:5581
#, csharp-format
msgid "<From {0}> {1}"
msgstr "<De {0}> {1}"

#: ../../TShockPluginManager/NugetCLI.cs:187
#, csharp-format
msgid "<green>{0} <black>from <blue>{1} <black>[{2}]"
msgstr "<verde>{0} <negro>de <azul>{1} <negro>[{2}]"

#: ../../TShockPluginManager/NugetCLI.cs:178
#, csharp-format
msgid "<green>{0}<black> from <blue>{1} <black>[{2}]"
msgstr "<verde>{0}<negro> de <azul>{1} <negro>[{2}]"

#: ../../TShockAPI/Commands.cs:5551
#: ../../TShockAPI/Commands.cs:5582
#, csharp-format
msgid "<To {0}> {1}"
msgstr "<A {0}> {1}"

#: ../../TShockPluginManager/NugetCLI.cs:136
#, csharp-format
msgid "=== Dependency ==="
msgid_plural "=== Dependencies ==="
msgstr[0] "=== Dependencia ==="
msgstr[1] "=== Dependencias ==="

#: ../../TShockPluginManager/NugetCLI.cs:133
#, csharp-format
msgid "=== Requested Plugin ==="
msgid_plural "=== Requested Plugins ==="
msgstr[0] "=== Plugin Solicitado ==="
msgstr[1] "=== Plugins Solicitados ==="

#: ../../TShockAPI/Commands.cs:2818
msgid "a Deerclops"
msgstr "un Ciervíclope"

#: ../../TShockAPI/Commands.cs:3384
msgid "A group with the same name already exists."
msgstr "Ya existe un grupo con el mismo nombre."

#: ../../TShockAPI/DB/RegionManager.cs:108
msgid "A lot of things will fail because of this. You must manually delete and re-create the allowed field."
msgstr "Esto causará muchos fallos. Debes borrar y recrear manualmente el campo permitido."

#: ../../TShockAPI/TShock.cs:986
msgid "A malicious server can easily steal a user's UUID. You may consider turning this option off if you run a public server."
msgstr "Un servidor malicioso puede robar fácilmente la UUID de un usuario. Considera desactivar esta opción si tienes un servidor público."

#: ../../TShockAPI/Commands.cs:2793
msgid "a Martian Saucer"
msgstr "un Platillo Marciano"

#: ../../TShockAPI/Commands.cs:2251
msgid "A meteor has been triggered."
msgstr "Un meteoro ha sido desencadenado."

#: ../../TShockAPI/Commands.cs:2803
msgid "a Nebula Pillar"
msgstr "una Columna de Nebulosa"

#: ../../TShockAPI/TShock.cs:974
msgid "A password for this server was set in config.json and is being used."
msgstr "Se estableció una contraseña para este servidor en config.json y está en uso."

#: ../../TShockAPI/Commands.cs:1316
msgid "A player name must be provided to kick a player. Please provide one."
msgstr "Debes escribir el nombre del jugador para poder expulsarlo. Por favor escribe su nombre."

#: ../../TShockAPI/GetDataHandlers.cs:2451
msgid "A plugin on this server stopped your login."
msgstr "Un plugin en el servidor detuvo tu inicio de sesión."

#: ../../TShockAPI/Rest/SecureRest.cs:120
#, csharp-format
msgid "A REST login from {0} was blocked as it currently has {1} rate-limit tokens and is at the RESTMaximumRequestsPerInterval threshold."
msgstr "Se bloqueó un inicio de sesión REST de {0} dado que ya tiene {1} tókens restringidos por frecuencia, alcanzando el umbral de RESTMaximumRequestsPerInterval."

#: ../../TShockAPI/Commands.cs:2798
msgid "a Solar Pillar"
msgstr "una Columna Solar"

#: ../../TShockAPI/Commands.cs:2813
msgid "a Stardust Pillar"
msgstr "una Columna de Polvo Estelar"

#: ../../TShockAPI/Commands.cs:864
msgid "A user account by that name does not exist."
msgstr "Una cuenta de usuario con ese nombre no existe."

#: ../../TShockAPI/Commands.cs:2808
msgid "a Vortex Pillar"
msgstr "una Columna de Vórtice"

#: ../../TShockAPI/Commands.cs:1159
#, csharp-format
msgid "Account {0} does not exist! Therefore, the password cannot be changed."
msgstr "¡La cuenta {0} no existe! Por lo tanto, no se puede cambiar la contraseña."

#: ../../TShockAPI/Commands.cs:1105
#, csharp-format
msgid "Account {0} has been added to group {1}."
msgstr "Se añadió la cuenta {0} al grupo {1}."

#: ../../TShockAPI/Commands.cs:1181
#, csharp-format
msgid "Account {0} has been changed to group {1}."
msgstr "La cuenta {0} ha sido cambiada al grupo {1}."

#: ../../TShockAPI/Bouncer.cs:547
#, csharp-format
msgid "Account needed! Please {0}register or {0}login to play!"
msgstr "¡Se requiere una cuenta! ¡Por favor, {0}register o {0}login para jugar!"

#: ../../TShockAPI/Commands.cs:1131
msgid "Account removed successfully."
msgstr "Cuenta eliminada con éxito."

#: ../../TShockAPI/Commands.cs:2094
msgid "Active REST Users ({{0}}/{{1}}):"
msgstr "Usuarios REST activos ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:3971
msgid "add <item> - Adds an item ban."
msgstr "add <objeto> - Añade una prohibición de objeto."

#: ../../TShockAPI/Commands.cs:3438
msgid "add <name> <permissions...> - Adds a new group."
msgstr "add <nombre> <permisos...> - Añade un nuevo grupo."

#: ../../TShockAPI/Commands.cs:4149
msgid "add <projectile ID> - Adds a projectile ban."
msgstr "add <ID de Proyectil> - Agrega una prohibición de proyectil."

#: ../../TShockAPI/Commands.cs:4325
msgid "add <tile ID> - Adds a tile ban."
msgstr "add <ID de bloque> - Agrega una prohibición de bloque."

#: ../../TShockAPI/Commands.cs:1737
#, csharp-format
msgid "Added {0} to the whitelist."
msgstr "{0} añadido a la lista blanca."

#: ../../TShockAPI/Bouncer.cs:2041
#, csharp-format
msgid "Added buff to {0} NPC abnormally."
msgstr "Añadido buff al PNJ {0} de forma anormal."

#: ../../TShockAPI/Commands.cs:4855
#, csharp-format
msgid "Added group {0} to {1}."
msgstr "Se añadió el grupo {0} a {1}."

#: ../../TShockAPI/Commands.cs:4785
#, csharp-format
msgid "Added user {0} to {1}."
msgstr "Se añadió el usuario {0} a {1}."

#: ../../TShockAPI/Commands.cs:3439
msgid "addperm <group> <permissions...> - Adds permissions to a group."
msgstr "addperm <grupo> <permisos...> - Concede permisos a un grupo."

#: ../../TShockAPI/DB/UserManager.cs:81
#, csharp-format
msgid "AddUser SQL returned an error ({0})"
msgstr "SQL AddUser devolvió un error ({0})"

#: ../../TShockAPI/Commands.cs:5776
#, csharp-format
msgid "Aliases of {0}{1}: {0}{2}"
msgstr "Alias de {0}{1}: {0}{2}"

#: ../../TShockAPI/Commands.cs:6013
msgid "All alive NPCs (excluding town NPCs) on the server will be killed if you do not input a name or ID."
msgstr "Se matará a todos los PNJ vivos (excepto los ciudadanos) en el servidor si no introduces un nombre o ID."

#: ../../TShockAPI/Commands.cs:2626
msgid "all bosses"
msgstr "todos los jefes"

#: ../../TShockPluginManager/NugetCLI.cs:169
msgid "All done! :)"
msgstr "¡Todo listo! :)"

#: ../../TShockAPI/Commands.cs:2104
msgid "All REST tokens have been destroyed."
msgstr "Todos los tókens REST han sido destruidos."

#: ../../TShockAPI/Commands.cs:1223
#, csharp-format
msgid "Allocated memory: {0}"
msgstr "Memoria reservada: {0}"

#: ../../TShockAPI/Commands.cs:3972
msgid "allow <item> <group> - Allows a group to use an item."
msgstr "allow <objeto> <grupo> - Permite a un grupo usar un objeto."

#: ../../TShockAPI/Commands.cs:4150
msgid "allow <projectile ID> <group> - Allows a group to use a projectile."
msgstr "allow <ID de proyectil> <grupo> - Permite a un grupo usar un proyectil."

#: ../../TShockAPI/Commands.cs:4326
msgid "allow <tile ID> <group> - Allows a group to place a tile."
msgstr "allow <ID de bloque> <grupo> - Permite a un grupo colocar un bloque."

#: ../../TShockAPI/Commands.cs:5193
msgid "allow <user> <region> - Allows a user to a region."
msgstr "allow <usuario> <región> - Permite a un usuario acceder a dicha región."

#: ../../TShockAPI/Commands.cs:5195
msgid "allowg <group> <region> - Allows a user group to a region."
msgstr "allowg <grupo> <región> - Permite a un grupo acceder a dicha región."

#: ../../TShockAPI/Commands.cs:6670
msgid "Amber Gemtree"
msgstr "Arbolgema de Ámbar"

#: ../../TShockAPI/Commands.cs:6650
msgid "Amethyst Gemtree"
msgstr "Arbolgema de Amatista"

#: ../../TShockAPI/TShock.cs:996
msgid "An account has been detected in the user database, but setup-code.txt is still present."
msgstr "Se ha detectado una cuenta de usuario en la base de datos, pero setup-code.txt sigue presente."

#: ../../TShockAPI/DB/GroupManager.cs:474
#, csharp-format
msgid "An exception has occurred during database rollback: {0}"
msgstr "Ha ocurrido una excepción durante la restauración de la base de datos: {0}"

#: ../../TShockAPI/DB/GroupManager.cs:467
#, csharp-format
msgid "An exception has occurred during database transaction: {0}"
msgstr "Ha ocurrido una excepción durante la transacción de la base de datos: {0}"

#: ../../TShockAPI/TShock.cs:1489
msgid "An exception occurred executing a command."
msgstr "Se ha producido una excepción al ejecutar un comando."

#: ../../TShockAPI/DB/BanManager.cs:644
msgid "An identifier for a character name."
msgstr "Un identificador para un nombre de personaje."

#: ../../TShockAPI/DB/BanManager.cs:648
msgid "An identifier for a TShock User Account name."
msgstr "Un identificador para un nombre de Cuenta de Usuario de TShock."

#: ../../TShockAPI/DB/BanManager.cs:640
msgid "An identifier for a UUID."
msgstr "Un identificador para un UUID."

#: ../../TShockAPI/DB/BanManager.cs:636
#, csharp-format
msgid "An identifier for an IP Address in octet format. e.g., '{0}'."
msgstr "Un identificador para una dirección IP en formato de octeto. Por ejemplo, '{0}'."

#: ../../TShockAPI/Commands.cs:2052
msgid "An update check has been queued. If an update is available, you will be notified shortly."
msgstr "Se pidió comprobar si hay actualizaciones. De haber una se te notificará en breve."

#: ../../TShockAPI/Commands.cs:5599
msgid "Annoy Syntax"
msgstr "Sintaxis de Molestar"

#: ../../TShockAPI/Commands.cs:5616
#, csharp-format
msgid "Annoying {0} for {1} seconds."
msgstr "Molestando a {0} por {1} segundos."

#: ../../TShockAPI/Commands.cs:338
msgid "Annoys a player for an amount of time."
msgstr "Molesta a un jugador durante un período de tiempo."

#: ../../TShockAPI/Rest/Rest.cs:452
#, csharp-format
msgid "Anonymous requested REST endpoint: {0}"
msgstr "Anónimo solicitó un punto final REST: {0}"

#: ../../TShockAPI/Commands.cs:5224
msgid "Anti-build is now off."
msgstr "Anti-construcción ha sido desactivado."

#: ../../TShockAPI/Commands.cs:5224
msgid "Anti-build is now on."
msgstr "Anti-construcción ha sido activado."

#: ../../TShockAPI/Commands.cs:3204
msgid "Arguments: add [warp name], del [warp name], list [page]."
msgstr "Parámetros: add [nombre de warp], del [nombre de warp], list [página]."

#: ../../TShockAPI/Commands.cs:3205
msgid "Arguments: send [player] [warp name], hide [warp name] [Enable(true/false)]."
msgstr "Parámetros: send [jugador] [nombre de warp], hide [nombre de warp] [Activar(true/false)]."

#: ../../TShockAPI/Commands.cs:903
#: ../../TShockAPI/GetDataHandlers.cs:2636
#: ../../TShockAPI/GetDataHandlers.cs:3211
#, csharp-format
msgid "Authenticated as {0} successfully."
msgstr "Autenticado como {0} correctamente."

#: ../../TShockAPI/TShock.cs:440
#: ../../TShockAPI/TShock.cs:1590
msgid "AutoSave Disabled"
msgstr "AutoGuardado Desactivado"

#: ../../TShockAPI/TShock.cs:438
#: ../../TShockAPI/TShock.cs:1588
msgid "AutoSave Enabled"
msgstr "AutoGuardado Activado"

#: ../../TShockAPI/Rest/RestManager.cs:811
msgid "AutoSave has been disabled"
msgstr "Se ha desactivado el AutoGuardado"

#: ../../TShockAPI/Rest/RestManager.cs:807
msgid "AutoSave has been enabled"
msgstr "Se ha activado el AutoGuardado"

#: ../../TShockAPI/Rest/RestManager.cs:800
msgid "Autosave is currently disabled"
msgstr "El autoguardado esta actualmente desactivado"

#: ../../TShockAPI/Rest/RestManager.cs:796
msgid "Autosave is currently enabled"
msgstr "El autoguardado está actualmente activado"

#: ../../TShockAPI/Commands.cs:1368
msgid "Available Ban commands:"
msgstr "Comandos de Baneo disponibles:"

#: ../../TShockAPI/Commands.cs:1432
msgid "Available identifiers ({{0}}/{{1}}):"
msgstr "Identificadores disponibles ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:5208
msgid "Available Region Sub-Commands ({{0}}/{{1}}):"
msgstr "Sub-Comandos de Región Disponibles ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:2109
msgid "Available REST Sub-Commands:"
msgstr "Sub-Comandos REST Disponibles:"

#: ../../TShockAPI/BackupManager.cs:75
msgid "Backing up world..."
msgstr "Respaldando mundo..."

#: ../../TShockAPI/BackupManager.cs:87
#: ../../TShockAPI/BackupManager.cs:89
msgid "Backup failed!"
msgstr "¡Respaldo fallido!"

#: ../../TShockAPI/BackupManager.cs:51
msgid "Backup Thread"
msgstr "Hilo de Respaldo"

#: ../../TShockAPI/TShock.cs:444
msgid "Backups Disabled"
msgstr "Respaldos Desactivados"

#: ../../TShockAPI/TShock.cs:442
msgid "Backups Enabled"
msgstr "Respaldos Activados"

#: ../../TShockAPI/Commands.cs:837
msgid "Bad login attempt."
msgstr "Intento de inicio de sesión inválido."

#: ../../TShockAPI/Commands.cs:1371
#, csharp-format
msgid "ban {0}"
msgstr "ban {0}"

#: ../../TShockAPI/Commands.cs:1370
#: ../../TShockAPI/Commands.cs:1372
#, csharp-format
msgid "ban {0} <Ban ID>"
msgstr "ban {0} <ID del baneo>"

#: ../../TShockAPI/Commands.cs:1369
#, csharp-format
msgid "ban {0} <Target> [Flags]"
msgstr "ban {0} <Objetivo> [Parámetros]"

#: ../../TShockAPI/Commands.cs:1633
#, csharp-format
msgid "Ban {0} has been revoked by {1}."
msgstr "El ban {0} ha sido revocado por {1}."

#: ../../TShockAPI/Commands.cs:1634
#, csharp-format
msgid "Ban {0} has now been marked as expired."
msgstr "El ban {0} acaba de marcarse como expirado."

#: ../../TShockAPI/Commands.cs:1383
msgid "Ban Add Syntax"
msgstr "Sintaxis de Ban Add"

#: ../../TShockAPI/Commands.cs:1490
#, csharp-format
msgid "Ban added. Ticket Number {0} was created for identifier {1}."
msgstr "Ban añadido. Se creó el Número de Ticket {0} para el identificador {1}."

#: ../../TShockAPI/Rest/RestManager.cs:668
#, csharp-format
msgid "Ban added. Ticket number: {0}"
msgstr "Ban añadido. Número de ticket: {0}"

#: ../../TShockAPI/Commands.cs:1396
msgid "Ban Del Syntax"
msgstr "Sintaxis de Ban Del"

#: ../../TShockAPI/Commands.cs:1412
msgid "Ban Details Syntax"
msgstr "Sintaxis de Ban Details"

#: ../../TShockAPI/Commands.cs:1404
msgid "Ban List Syntax"
msgstr "Sintaxis de Ban List"

#: ../../TShockAPI/Rest/RestManager.cs:695
msgid "Ban removed."
msgstr "Ban revocado."

#: ../../TShockAPI/Commands.cs:1442
msgid "Ban Usage Examples"
msgstr "Ejemplos del Uso de Ban"

#: ../../TShockAPI/Commands.cs:3841
#, csharp-format
msgid "Banned {0}."
msgstr "Se ha baneado a {0}."

#: ../../TShockAPI/Commands.cs:4037
#, csharp-format
msgid "Banned projectile {0}."
msgstr "Se ha prohibido el proyectil {0}."

#: ../../TShockAPI/Commands.cs:4213
#, csharp-format
msgid "Banned tile {0}."
msgstr "Se ha prohibido el bloque {0}."

#: ../../TShockAPI/TSPlayer.cs:1950
#, csharp-format
msgid "Banned: {0}"
msgstr "Baneado: {0}"

#: ../../TShockAPI/Commands.cs:1517
msgid "Banned."
msgstr "Baneado."

#: ../../TShockAPI/Commands.cs:1670
msgid "Bans ({{0}}/{{1}}):"
msgstr "Baneos ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:6592
msgid "Basic Tree"
msgstr "Árbol Básico"

#: ../../TShockAPI/Commands.cs:2755
msgid "Betsy"
msgstr "Betsy"

#: ../../TShockAPI/Rest/RestManager.cs:889
#, csharp-format
msgid "Blood Moon has been set to {0}"
msgstr "La Luna Sangrienta fue marcada como {0}"

#: ../../TShockAPI/Rest/RestManager.cs:904
#, csharp-format
msgid "Bloodmoon state: {0}"
msgstr "Estado de la Luna Sangrienta: {0}"

#: ../../TShockAPI/Commands.cs:6596
msgid "Boreal Tree"
msgstr "Árbol Boreal"

#: ../../TShockAPI/GetDataHandlers.cs:3264
#, csharp-format
msgid "Bouncer / HandleNpcTalk rejected from bouncer out of bounds from {0}"
msgstr "Bouncer / HandleNpcTalk rechazó desde el bouncer fuera de area de {0}"

#: ../../TShockAPI/GetDataHandlers.cs:3257
#, csharp-format
msgid "Bouncer / HandleNpcTalk rejected from bouncer throttle from {0}"
msgstr "Bouncer / HandleNpcTalk rechazó desde el bouncer limitado de {0}"

#: ../../TShockAPI/Bouncer.cs:1465
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from chest mismatch from {0}"
msgstr "Bouncer / OnChestItemChange rechazo desde cofre no coincidente de {0}"

#: ../../TShockAPI/Bouncer.cs:1472
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from disable from {0}"
msgstr "Bouncer / OnChestItemChange rechazo desde desactivación de {0}"

#: ../../TShockAPI/Bouncer.cs:1487
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from range check from {0}"
msgstr "Bouncer / OnChestItemChange rechazo desde la comprobación de rango de {0}"

#: ../../TShockAPI/Bouncer.cs:1480
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from region protection? from {0}"
msgstr "Bouncer / OnChestItemChange rechazo desde ¿protección de región? de {0}"

#: ../../TShockAPI/Bouncer.cs:1500
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from disabled from {0}"
msgstr "Bouncer / OnChestOpen rechazo desde desactivación de {0}"

#: ../../TShockAPI/Bouncer.cs:1507
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from range check from {0}"
msgstr "Bouncer / OnChestOpen rechazo desde comprobación de rango de {0}"

#: ../../TShockAPI/Bouncer.cs:1514
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from region check from {0}"
msgstr "Bouncer / OnChestOpen rechazo desde comprobación de región de {0}"

#: ../../TShockAPI/Bouncer.cs:2735
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected for not finding active bobber projectile! - From {0}"
msgstr "Bouncer / OnFishOutNPC rechazo ¡por no encontrar proyectil de señuelo activo! - De {0}"

#: ../../TShockAPI/Bouncer.cs:2729
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected for not using a fishing rod! - From {0}"
msgstr "Bouncer / OnFishOutNPC rechazo ¡por no usar una caña de pescar! - De {0}"

#: ../../TShockAPI/Bouncer.cs:2741
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected for the NPC not being on the fishable NPCs list! - From {0}"
msgstr "Bouncer / OnFishOutNPC rechazo ¡por no estar el NPC en la lista de NPC que pueden ser pescados! - De {0}"

#: ../../TShockAPI/Bouncer.cs:2753
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected range checks from {0}"
msgstr "Bouncer / OnFishOutNPC rechazo comprobaciones de rango de {0}"

#: ../../TShockAPI/Bouncer.cs:2747
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected summon boss permissions from {0}"
msgstr "Bouncer / OnFishOutNPC rechazó permisos de invocación de jefe de {0}"

#: ../../TShockAPI/Bouncer.cs:2781
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected disabled from {0}"
msgstr "Bouncer / OnFoodPlatterTryPlacing rechazó desactivación de {0}"

#: ../../TShockAPI/Bouncer.cs:2774
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected item not placed by hand from {0}"
msgstr "Bouncer / OnFoodPlatterTryPlacing rechazó objeto no puesto manualmente de {0}"

#: ../../TShockAPI/Bouncer.cs:2792
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected permissions from {0}"
msgstr "Bouncer / OnFoodPlatterTryPlacing rechazó los permisos de {0}"

#: ../../TShockAPI/Bouncer.cs:2803
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected range checks from {0}"
msgstr "Bouncer / OnFoodPlatterTryPlacing rechazó las comprobaciones de rango de {0}"

#: ../../TShockAPI/Bouncer.cs:2767
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected tile placement valid from {0}"
msgstr "Bouncer / OnFoodPlatterTryPlacing rechazó la colocación de bloques válidos desde {0}"

#: ../../TShockAPI/Bouncer.cs:2508
#, csharp-format
msgid "Bouncer / OnGemLockToggle invalid placement/deadmod from {0}"
msgstr "Bouncer / OnGemLockToggle colocación inválida/deadmod de {0}"

#: ../../TShockAPI/Bouncer.cs:2501
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected boundaries check from {0}"
msgstr "Bouncer / OnGemLockToggle rechazada la comprobación de umbral de {0}"

#: ../../TShockAPI/Bouncer.cs:2515
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected disabled from {0}"
msgstr "Bouncer / OnGemLockToggle rechazó el estado deshabilitado desde {0}"

#: ../../TShockAPI/Bouncer.cs:2524
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected permissions check from {0}"
msgstr "Bouncer / OnGemLockToggle rechazó la comprobación de permisos de {0}"

#: ../../TShockAPI/Bouncer.cs:453
msgid "Bouncer / OnGetSection rejected empty player name."
msgstr "Bouncer / OnGetSection rechazó un nombre de jugador vacío."

#: ../../TShockAPI/Bouncer.cs:445
#, csharp-format
msgid "Bouncer / OnGetSection rejected GetSection packet from {0}"
msgstr "Bouncer / OnGetSection rechazó el paquete GetSection de {0}"

#: ../../TShockAPI/Bouncer.cs:2096
#, csharp-format
msgid "Bouncer / OnHealOtherPlayer 0.2 check from {0}"
msgstr "Bouncer / OnHealOtherPlayer 0.2 comprobar desde {0}"

#: ../../TShockAPI/Bouncer.cs:2120
#, csharp-format
msgid "Bouncer / OnHealOtherPlayer rejected disabled/throttled from {0}"
msgstr "Bouncer / OnHealOtherPlayer rechazó el estado deshabilitado/limitado desde {0}"

#: ../../TShockAPI/Bouncer.cs:2112
#, csharp-format
msgid "Bouncer / OnHealOtherPlayer rejected heal other threshold from {0} {1}/{2}"
msgstr "Bouncer / OnHealOtherPlayer rechazó el umbral de sanar a otro desde {0} {1}/{2}"

#: ../../TShockAPI/Bouncer.cs:2086
msgid "Bouncer / OnHealOtherPlayer rejected null checks"
msgstr "Bouncer / OnHealOtherPlayer rechazó comprobaciones nulas"

#: ../../TShockAPI/Bouncer.cs:1074
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from attempt crash from {0}"
msgstr "Bouncer / OnItemDrop rechazó desde un intento de crasheo desde {0}"

#: ../../TShockAPI/Bouncer.cs:1150
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from disabled from {0}"
msgstr "Bouncer / OnItemDrop rechazó desde estado deshabilitado de {0}"

#: ../../TShockAPI/Bouncer.cs:1130
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from drop item ban check / max stack check / min stack check from {0}"
msgstr "Bouncer / OnItemDrop rechazó la comprobación de objeto prohibido arrojado / comprobación de stack máximo / comprobación de stack mínimo desde {0}"

#: ../../TShockAPI/Bouncer.cs:1099
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from dupe range check from {0}"
msgstr "Bouncer / OnItemDrop rechazó desde la comprobación de rango de duplicación de {0}"

#: ../../TShockAPI/Bouncer.cs:1120
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from item drop/pickup check from {0}"
msgstr "Bouncer / OnItemDrop rechazó desde la comprobación de objeto arrojado/recogido de {0}"

#: ../../TShockAPI/Bouncer.cs:1084
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from prefix check from {0}"
msgstr "Bouncer / OnItemDrop rechazado desde la comprobación de prefijo de {0}"

#: ../../TShockAPI/Bouncer.cs:1110
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from range check from {0}"
msgstr "Bouncer / OnItemDrop rechazado desde la comprobación de rango de {0}"

#: ../../TShockAPI/Bouncer.cs:1141
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from sneaky from {0}"
msgstr "Bouncer / OnItemDrop rechazado desde un sospechoso de {0}"

#: ../../TShockAPI/Bouncer.cs:2703
#, csharp-format
msgid "Bouncer / OnKillMe rejected bad length death text from {0}"
msgstr "Bouncer / OnKillMe rechazó el texto de muerte de longitud incorrecta de {0}"

#: ../../TShockAPI/Bouncer.cs:2710
#, csharp-format
msgid "Bouncer / OnKillMe rejected custom death message from {0}"
msgstr "Bouncer / OnKillMe rechazó el mensaje personalizado de muerte de {0}"

#: ../../TShockAPI/Bouncer.cs:2684
#, csharp-format
msgid "Bouncer / OnKillMe rejected high damage from {0} {1}"
msgstr "Bouncer / OnKillMe rechazó el daño elevado de {0} {1}"

#: ../../TShockAPI/Bouncer.cs:2693
#, csharp-format
msgid "Bouncer / OnKillMe rejected index check from {0}"
msgstr "Bouncer / OnKillMe rechazó la comprobación de índice de {0}"

#: ../../TShockAPI/Bouncer.cs:1832
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected build permission from {0}"
msgstr "Bouncer / OnLiquidSet rechazó el permiso de construcción de {0}"

#: ../../TShockAPI/Bouncer.cs:1676
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected disabled from {0}"
msgstr "Bouncer / OnLiquidSet rechazo por deshabilitamiento de {0}"

#: ../../TShockAPI/Bouncer.cs:1694
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected from liquid threshold from {0} {1}/{2}"
msgstr "Bouncer / OnLiquidSet rechazado desde el umbral de líquido de {0} {1}/{2}"

#: ../../TShockAPI/Bouncer.cs:1669
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected invalid check from {0}"
msgstr "Bouncer / OnLiquidSet rechazó comprobación inválida desde {0}"

#: ../../TShockAPI/Bouncer.cs:1731
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected liquid type {0} from {1} holding {2}"
msgstr "Bouncer / OnLiquidSet rechazó el tipo de líquido {0} de {1} sosteniendo {2}"

#: ../../TShockAPI/Bouncer.cs:1840
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected range checks from {0}"
msgstr "Bouncer / OnLiquidSet rechazó las comprobaciones de rango de {0}"

#: ../../TShockAPI/Bouncer.cs:1848
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected throttle from {0}"
msgstr "Bouncer / OnLiquidSet rechazó limitación desde {0}"

#: ../../TShockAPI/Bouncer.cs:2573
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected build perms from {0}"
msgstr "Bouncer / OnMassWireOperation rechazó los permisos de construcción desde {0}"

#: ../../TShockAPI/Bouncer.cs:2566
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected disabled from {0}"
msgstr "Bouncer / OnMassWireOperation rechazó por deshabilitación desde {0}"

#: ../../TShockAPI/Bouncer.cs:2559
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected valid placement from {0}"
msgstr "Bouncer / OnMassWireOperation rechazó la colocación válida desde {0}"

#: ../../TShockAPI/Bouncer.cs:1274
#, csharp-format
msgid "Bouncer / OnNewProjectile please report to tshock about this! normally this is a reject from {0} {1}"
msgstr "Bouncer / OnNewProjectile ¡Favor reportar esto a TShock! Normalmente esto es un rechazo desde {0} {1}"

#: ../../TShockAPI/Bouncer.cs:1230
#, csharp-format
msgid "Bouncer / OnNewProjectile please report to tshock about this! normally this is a reject from {0} {1} (golf)"
msgstr "Bouncer / OnNewProjectile ¡Favor reportar esto a TShock! Normalmente esto es un rechazo desde {0} {1} (golf)"

#: ../../TShockAPI/Bouncer.cs:1174
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from above projectile limit from {0}"
msgstr "Bouncer / OnNewProjectile rechazado por estar sobre el límite de proyectil desde {0}"

#: ../../TShockAPI/Bouncer.cs:1315
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from bouncer modified AI from {0}."
msgstr "Bouncer / OnNewProjectile rechazado desde el bouncer por IA modificada de {0}."

#: ../../TShockAPI/Bouncer.cs:1331
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from bouncer modified Zenith projectile from {0}."
msgstr "Bouncer / OnNewProjectile rechazado desde el bouncer por proyectil Cenit modificado de {0}."

#: ../../TShockAPI/Bouncer.cs:1302
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from bouncer throttle from {0}"
msgstr "Bouncer / OnNewProjectile rechazado desde el bouncer por limitación de {0}"

#: ../../TShockAPI/Bouncer.cs:1201
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from disabled from {0}"
msgstr "Bouncer / OnNewProjectile rechazó desde estado deshabilitado de {0}"

#: ../../TShockAPI/Bouncer.cs:1238
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from hostile projectile from {0}"
msgstr "Bouncer / OnNewProjectile rechazado por uso de proyectil hostil de {0}"

#: ../../TShockAPI/Bouncer.cs:1183
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from permission check from {0} {1}"
msgstr "Bouncer / OnNewProjectile rechazado por comprobación de permisos de {0} {1}"

#: ../../TShockAPI/Bouncer.cs:1294
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from projectile create threshold from {0} {1}/{2}"
msgstr "Bouncer / OnNewProjectile rechazado por umbral de creación de proyectil desde {0} {1}/{2}"

#: ../../TShockAPI/Bouncer.cs:1193
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from projectile damage limit from {0} {1}/{2}"
msgstr "Bouncer / OnNewProjectile rechazado por límite de daño de proyectil desde {0} {1}/{2}"

#: ../../TShockAPI/Bouncer.cs:1249
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from tombstones from {0}"
msgstr "Bouncer / OnNewProjectile rechazado por lápidas de {0}"

#: ../../TShockAPI/Bouncer.cs:1269
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from weird check from {0} {1}"
msgstr "Bouncer / OnNewProjectile rechazado por comprobación extraña de {0} {1}"

#: ../../TShockAPI/Bouncer.cs:2040
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected abnormal buff ({0}, last for {4}) added to {1} ({2}) from {3}."
msgstr "Bouncer / OnNPCAddBuff rechazó un buff anormal ({0}, de duración {4}) aplicado a {1} ({2}) por {3}."

#: ../../TShockAPI/Bouncer.cs:1994
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected disabled from {0}"
msgstr "Bouncer / OnNPCAddBuff rechazó el estado deshabilitado desde {0}"

#: ../../TShockAPI/Bouncer.cs:1987
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected null npc from {0}"
msgstr "Bouncer / OnNPCAddBuff rechazó PNJ nulo de {0}"

#: ../../TShockAPI/Bouncer.cs:1978
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected out of bounds NPC update from {0}"
msgstr "Bouncer / OnNPCAddBuff rechazó actualización de PNJ fuera de los bordes desde {0}"

#: ../../TShockAPI/Bouncer.cs:1416
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1391
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from damage threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1399
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1408
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1550
#, csharp-format
msgid "Bouncer / OnPlaceChest / rejected from invalid place style from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1542
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1535
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from invalid check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1583
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from invalid permission from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1591
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1562
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from weird check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1573
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from weird placement check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2440
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2448
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2456
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2433
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected tile placement valid from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2313
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected awkward tile creation/selection from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2300
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected Axe of Regrowth only places saplings {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2261
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected banned tiles from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2270
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected dead people don't do things from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2278
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2252
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected fake containers from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2351
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected mad loop from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2336
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected null tile data from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2325
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected object placement with invalid style {1} (expected {2}) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2229
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2236
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile x from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2243
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile y from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2367
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2289
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected rubblemaker I can't believe it's not rubble! from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2375
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected tile place threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2222
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected valid placements from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2406
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2413
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2420
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2399
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected tile placement valid from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1642
#, csharp-format
msgid "Bouncer / OnPlayerAnimation rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1650
#, csharp-format
msgid "Bouncer / OnPlayerAnimation rejected from throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1960
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied for that long"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1942
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied to non-senders"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1951
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff cannot be applied without pvp"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1933
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: buff is not whitelisted"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1893
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: invalid buff type"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1902
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is being disabled"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1911
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is being throttled"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1924
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: sender is not in range of target"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1875
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: target ID out of bounds"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1884
#, csharp-format
msgid "Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} ticks: target is null"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2667
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected custom death message from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2603
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected damage threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2610
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected damage threshold2 from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2630
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2621
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected hostile from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2594
msgid "Bouncer / OnPlayerDamage rejected null check"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2639
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2648
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected throttled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2488
#, csharp-format
msgid "Bouncer / OnPlayerPortalTeleport rejected disabled/throttled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2480
#, csharp-format
msgid "Bouncer / OnPlayerPortalTeleport rejected teleport out of bounds from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2469
#, csharp-format
msgid "Bouncer / OnPlayerPortalTeleport rejected untargetable teleport from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:517
#, csharp-format
msgid "Bouncer / OnPlayerUpdate *would have rejected* from (last network position zero) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:495
#, csharp-format
msgid "Bouncer / OnPlayerUpdate force kicked (attempted to set velocity +/- 50000) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:479
#, csharp-format
msgid "Bouncer / OnPlayerUpdate force kicked (attempted to set velocity to infinity) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:487
#, csharp-format
msgid "Bouncer / OnPlayerUpdate force kicked (attempted to set velocity to NaN) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:561
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (??) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:565
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (below ??) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:573
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (corpses don't move) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:510
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (inventory length) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:503
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (position check) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1628
#, csharp-format
msgid "Bouncer / OnPlayerZone rejected from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1445
#, csharp-format
msgid "Bouncer / OnProjectileKill rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1437
#, csharp-format
msgid "Bouncer / OnProjectileKill rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1430
#, csharp-format
msgid "Bouncer / OnProjectileKill rejected from negative projectile index from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2153
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected npc release from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2145
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected out of bounds from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2204
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2160
#, csharp-format
msgid "Bouncer / OnReleaseNPC released different critter from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:700
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (axe) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:804
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (chestcap) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:708
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (hammer) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:737
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (hammer2) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:756
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (inconceivable rope coil) {0} {1} {2} selectedItem:{3} itemCreateTile:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:767
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (ms1) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:639
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (pdm) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:725
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (pick) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:675
#: ../../TShockAPI/Bouncer.cs:686
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (placestyle) {0} {1} {2} placeStyle: {3} expectedStyle: {4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:653
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (tb) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:603
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (tile placement valid) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:848
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from actuator/presserator from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:612
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from build from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:869
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from disable from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:624
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from editData out of bounds {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:908
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from explosives/fuses from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:878
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from ice/build from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:823
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from place wire from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:858
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from sts allow cut from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:952
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from throttled from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:926
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from tile kill threshold from {0}, (value: {1})"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:944
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from tile place threshold from {0}, (value: {1})"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:786
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from tile placement not matching selected item createTile {0} {1} {2} selectedItemID:{3} createTile:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:776
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from using ice rod but not placing ice block {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:795
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from wall placement not matching selected item createWall {0} {1} {2} selectedItemID:{3} createWall:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:985
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from weird confusing flow control from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:837
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from wire cutter from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:632
#, csharp-format
msgid "Bouncer / OnTileEdit super accepted from (ice block) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2060
#, csharp-format
msgid "Bouncer / OnUpdateNPCHome rejected npc home build permission from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2070
#, csharp-format
msgid "Bouncer / OnUpdateNPCHome rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:558
#, csharp-format
msgid "Bouncer / SendTileRect accepted clientside world edit from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:414
#, csharp-format
msgid "Bouncer / SendTileRect processing a tile conversion update - [{0}] -> [{1}]"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:429
#, csharp-format
msgid "Bouncer / SendTileRect processing a wall conversion update - [{0}] -> [{1}]"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:129
#, csharp-format
msgid "Bouncer / SendTileRect reimplemented from carbonara from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:299
msgid "Bouncer / SendTileRect rejected for banned tile"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:578
#, csharp-format
msgid "Bouncer / SendTileRect rejected from being disabled from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:293
#, csharp-format
msgid "Bouncer / SendTileRect rejected from no permission for tile object from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:565
#, csharp-format
msgid "Bouncer / SendTileRect rejected from non-vanilla tilemod from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:571
#, csharp-format
msgid "Bouncer / SendTileRect rejected from throttle from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:610
msgid "Bouncer / SendTileRectHandler - rejected tile object because object dimensions fall outside the tile rect (excessive size)"
msgstr ""

#: ../../TShockAPI/Utils.cs:136
#, csharp-format
msgid "Broadcast: {0}"
msgstr "Anuncio: {0}"

#: ../../TShockAPI/Utils.cs:159
#, csharp-format
msgid "Broadcast: {0}: {1}"
msgstr "Anuncio: {0}: {1}"

#: ../../TShockAPI/Commands.cs:272
msgid "Broadcasts a message to everyone on the server."
msgstr "Transmite un mensaje a todo el servidor."

#: ../../TShockAPI/Commands.cs:6367
msgid "Buff Syntax and Example"
msgstr "Sintaxis y Ejemplo de Buff"

#: ../../TShockAPI/Commands.cs:6010
msgid "Butcher Syntax and Example"
msgstr "Sintaxis y Ejemplo de Butcher"

#: ../../TShockAPI/GetDataHandlers.cs:2619
msgid "Bypass SSC is enabled for your account. SSC data will not be loaded or saved."
msgstr "Tu cuenta tiene activado el bypass de SSC. Los datos SSC no serán cargados ni guardados."

#: ../../TShockAPI/Commands.cs:6676
msgid "Cactus"
msgstr "Cactus"

#: ../../TShockAPI/DB/IQueryBuilder.cs:319
msgid "Can't set to true SqlColumn.DefaultCurrentTimestamp when the MySqlDbType is not DateTime"
msgstr "SqlColumn.DefaultCurrentTimestamp no puede marcarse como true (verdadero) cuando el MySqlDbType no es DateTime"

#: ../../TShockAPI/Modules/ModuleManager.cs:56
#, csharp-format
msgid "Cannot load module {0} as it does not derive from {1}"
msgstr "No se puede cargar el módulo {0} ya que no se deriva de {1}"

#: ../../TShockAPI/Bouncer.cs:1270
msgid "Certain projectiles have been ignored for cheat detection."
msgstr "Algunos proyectiles fueron ignorados por detección de trampas."

#: ../../TShockAPI/Commands.cs:4462
#, csharp-format
msgid "Changed the maximum spawns to {0}."
msgstr "Se cambió la generación máxima de enemigos a {0}."

#: ../../TShockAPI/Commands.cs:4443
msgid "Changed the maximum spawns to 5."
msgstr "Se cambió la generación máxima de enemigos a 5."

#: ../../TShockAPI/Commands.cs:4501
#, csharp-format
msgid "Changed the spawn rate to {0}."
msgstr "Se cambió la tasa de aparición de enemigos a {0}."

#: ../../TShockAPI/Commands.cs:4483
msgid "Changed the spawn rate to 600."
msgstr "Se cambió la tasa de aparición de enemigos a 600."

#: ../../TShockAPI/Commands.cs:368
msgid "Changes the server password."
msgstr "Cambia la contraseña del servidor."

#: ../../TShockAPI/Commands.cs:522
msgid "Changes the wind speed."
msgstr "Cambia la velocidad del viento."

#: ../../TShockAPI/Commands.cs:467
msgid "Changes the world mode."
msgstr "Cambia el tipo de mundo."

#: ../../TShockAPI/Commands.cs:252
msgid "Changes your account's password."
msgstr "Cambia la contraseña de tu cuenta."

#: ../../TShockAPI/Commands.cs:3646
#, csharp-format
msgid "Chat color for \"{0}\" is \"{1}\"."
msgstr "El color de chat para \"{0}\" es \"{1}\"."

#: ../../TShockAPI/Commands.cs:3632
#, csharp-format
msgid "Chat color for group \"{0}\" set to \"{1}\"."
msgstr "Color de chat para grupo \"{0}\" establecido como \"{1}\"."

#: ../../TShockAPI/Commands.cs:352
msgid "Checks for TShock updates."
msgstr "Busca actualizaciones de TShock."

#: ../../TShockAPI/Commands.cs:5186
msgid "clear - Clears the temporary region points."
msgstr "clear - Elimina los puntos de región temporales."

#: ../../TShockAPI/Commands.cs:5814
msgid "Clear Syntax"
msgstr "Sintaxis de Clear"

#: ../../TShockAPI/Commands.cs:2531
msgid "Cleared all users from the angler quest completion list for today."
msgstr "Eliminados todos los usuarios de la lista de misiones completadas hoy del pescador."

#: ../../TShockAPI/Commands.cs:537
msgid "Clears item drops or projectiles."
msgstr "Elimina objetos o proyectiles."

#: ../../TShockAPI/Commands.cs:3440
msgid "color <group> <rrr,ggg,bbb> - Changes a group's chat color."
msgstr "color <group> <rrr,ggg,bbb> - Cambia el color de chat de un grupo."

#: ../../TShockAPI/Commands.cs:5329
#, csharp-format
msgid "Command aliases: {0}, {1}, {2}"
msgstr "Alias del comando: {0}, {1}, {2}"

#: ../../TShockAPI/Commands.cs:162
msgid "Command failed, check logs for more details."
msgstr "Comando fallido, compruebe los registros para más detalles."

#: ../../TShockAPI/Commands.cs:5260
msgid "Commands ({{0}}/{{1}}):"
msgstr "Comandos ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:3203
msgid "Commands: add, del, hide, list, send, [warpname]."
msgstr "Comandos: add, del, hide, list, send, [nombre de warp]."

#: ../../TShockAPI/TShock.cs:765
#, csharp-format
msgid "Config path has been set to {0}"
msgstr "La ruta de configuración se ha establecido en {0}"

#: ../../TShockAPI/Commands.cs:4395
msgid "Configuration, permissions, and regions reload complete. Some changes may require a server restart."
msgstr "Recarga de configuración, permisos y regiones completada. Algunos cambios pueden requerir un reinicio del servidor."

#: ../../TShockPluginManager/NugetCLI.cs:100
msgid "Connect to the internet to figure out what to download?"
msgstr "¿Conectarse a Internet para averiguar qué descargar?"

#: ../../TShockAPI/TShock.cs:1329
msgid "Connecting via a proxy is not allowed."
msgstr "No se permite la conexión a través de un proxy."

#: ../../TShockAPI/Commands.cs:1778
#, csharp-format
msgid "Correct usage: {0}overridessc|{0}ossc <player name>"
msgstr "Uso correcto: {0}overridessc|{0}ossc <nombre del jugador>"

#: ../../TShockAPI/Commands.cs:6641
msgid "Corruption Palm"
msgstr "Palmera Corrupta"

#: ../../TShockAPI/TShock.cs:296
#, csharp-format
msgid "Could not apply the given log path / log format, defaults will be used. Exception details:\n"
"{0}"
msgstr "No se pudo usar la ruta / formato de logs dado; se usarán los valores predeterminados. Detalles de la excepción: {0}"

#: ../../TShockAPI/DB/ResearchDatastore.cs:54
#: ../../TShockAPI/DB/BanManager.cs:82
msgid "Could not find a database library (probably Sqlite3.dll)"
msgstr "No se encontró una biblioteca de base de datos (probablemente Sqlite3.dll)"

#: ../../TShockAPI/Commands.cs:3268
#, csharp-format
msgid "Could not find a warp named {0} to remove."
msgstr "No se pudo encontrar un warp llamado {0} para eliminarlo."

#: ../../TShockAPI/Commands.cs:5526
#: ../../TShockAPI/Commands.cs:5610
#: ../../TShockAPI/Commands.cs:5635
#: ../../TShockAPI/Commands.cs:5691
#: ../../TShockAPI/Commands.cs:5972
#, csharp-format
msgid "Could not find any player named \"{0}\""
msgstr "No se encontró ningún jugador llamado \"{0}\""

#: ../../TShockAPI/Commands.cs:5928
#, csharp-format
msgid "Could not find any player named \"{0}\"."
msgstr "No se encontró ningún jugador llamado \"{0}\"."

#: ../../TShockAPI/Commands.cs:5471
#, csharp-format
msgid "Could not find any players named \"{0}\""
msgstr "Ninguno de los jugadores se llama \"{0}\""

#: ../../TShockAPI/Commands.cs:1934
#, csharp-format
msgid "Could not find group {0}"
msgstr "No se pudo encontrar el grupo {0}"

#: ../../TShockAPI/Commands.cs:1923
#, csharp-format
msgid "Could not find player {0}."
msgstr "No se pudo encontrar al jugador {0}."

#: ../../TShockAPI/Commands.cs:5044
msgid "Could not find specified region"
msgstr "No se pudo encontrar la región especificada"

#: ../../TShockAPI/Commands.cs:3291
msgid "Could not find specified warp."
msgstr "No se pudo encontrar el warp especificado."

#: ../../TShockAPI/Commands.cs:4723
#: ../../TShockAPI/Commands.cs:4730
#: ../../TShockAPI/Commands.cs:4749
#: ../../TShockAPI/Commands.cs:4788
#: ../../TShockAPI/Commands.cs:4823
#: ../../TShockAPI/Commands.cs:4858
#: ../../TShockAPI/Commands.cs:4893
#: ../../TShockAPI/Commands.cs:4937
#, csharp-format
msgid "Could not find the region {0}."
msgstr "No se pudo encontrar la región {0}."

#: ../../TShockAPI/Commands.cs:1581
msgid "Could not find the target specified. Check that you have the correct spelling."
msgstr "No se pudo encontrar el objetivo especificado. Revise que esté bien escrito."

#: ../../TShockAPI/Commands.cs:6200
#, csharp-format
msgid "Could not rename {0}!"
msgstr "¡No se pudo renombrar a {0}!"

#: ../../TShockAPI/TShock.cs:1448
msgid "Crash attempt via long chat packet."
msgstr "Intento de crasheo a través de un paquete de chat largo."

#: ../../TShockAPI/Commands.cs:595
msgid "Creates a reference tables for Terraria data types and the TShock permission system in the server folder."
msgstr "Crea tablas de referencia para datos de tipo Terraria y el sistema de permisos TShock en la carpeta del servidor."

#: ../../TShockAPI/Commands.cs:5414
msgid "Creates: <username> with the password <password> as part of the owner group."
msgstr "Crea: <username> con la contraseña <password> como parte del grupo owner."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:53
msgid "CreativePowerHandler received permission check request for unknown creative power"
msgstr "CreativePowerHandler recibió una petición de comprobación de permiso para un poder creativo desconocido"

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:65
#, csharp-format
msgid "CreativeUnlocksHandler received non-vanilla unlock request. Random field value: {0} but should be 0 from {1}"
msgstr "CreativeUnlocksHandler recibió una petición de apertura no-vainilla. Valor de campo al azar: {0} pero debería ser 0 de {1}"

#: ../../TShockAPI/Commands.cs:6636
msgid "Crimson Palm"
msgstr "Palmera Carmesí"

#: ../../TShockAPI/Commands.cs:4434
#, csharp-format
msgid "Current maximum spawns: {0}."
msgstr "Número máximo actual de enemigos generados: {0}."

#: ../../TShockAPI/Commands.cs:4474
#, csharp-format
msgid "Current spawn rate: {0}."
msgstr "Tasa actual de generación de enemigos: {0}."

#: ../../TShockAPI/Bouncer.cs:2686
#, csharp-format
msgid "Death Exploit Attempt: Damage {0}"
msgstr "Intento de Exploit de Muerte: Daño {0}"

#: ../../TShockAPI/Bouncer.cs:2704
msgid "Death reason outside of normal bounds."
msgstr "Razón de muerte fuera de los límites normales."

#: ../../TShockAPI/Configuration/TShockConfig.cs:321
#: ../../TShockAPI/Configuration/TShockConfig.cs:357
msgid "Death results in a ban"
msgstr "Morir resulta en un baneo"

#: ../../TShockAPI/Configuration/TShockConfig.cs:349
msgid "Death results in a kick"
msgstr "Morir resulta en una expulsión"

#: ../../TShockAPI/Commands.cs:5187
msgid "define <name> - Defines the region with the given name."
msgstr "define <nombre> - Establece la región con el nombre otorgado."

#: ../../TShockAPI/Commands.cs:3442
msgid "del <group> - Deletes a group."
msgstr "del <grupo> - Elimina un grupo."

#: ../../TShockAPI/Commands.cs:3973
msgid "del <item> - Deletes an item ban."
msgstr "del <objeto> - Elimina una prohibición de objeto."

#: ../../TShockAPI/Commands.cs:4151
msgid "del <projectile ID> - Deletes an projectile ban."
msgstr "del <ID de proyectil> - Elimina una prohibición de proyectil."

#: ../../TShockAPI/Commands.cs:4327
msgid "del <tile ID> - Deletes a tile ban."
msgstr "del <ID de bloque> - Elimina una prohibición de bloque."

#: ../../TShockAPI/Commands.cs:5188
msgid "delete <name> - Deletes the given region."
msgstr "delete <nombre> - Elimina la región especificada."

#: ../../TShockAPI/Commands.cs:4746
#, csharp-format
msgid "Deleted region \"{0}\"."
msgstr "Región \"{0}\" eliminada."

#: ../../TShockAPI/Commands.cs:3443
msgid "delperm <group> <permissions...> - Removes permissions from a group."
msgstr "delperm <grupo> <permisos...> - Quita permisos a un grupo."

#: ../../TShockAPI/Commands.cs:6627
msgid "Desert Palm"
msgstr "Palmera Desértica"

#: ../../TShockAPI/Commands.cs:2111
msgid "destroytokens - Destroys all current REST tokens."
msgstr "destroytokens - Destruye todos los tókens REST actuales."

#: ../../TShockAPI/Bouncer.cs:480
#: ../../TShockAPI/Bouncer.cs:488
#: ../../TShockAPI/Bouncer.cs:496
msgid "Detected DOOM set to ON position."
msgstr "Detectado DOOM establecido en la posición ON."

#: ../../TShockAPI/Commands.cs:6666
msgid "Diamond Gemtree"
msgstr "Arbolgema de Diamante"

#: ../../TShockAPI/Commands.cs:1881
msgid "Disabled halloween mode."
msgstr "Modo halloween desactivado."

#: ../../TShockAPI/Commands.cs:1900
msgid "Disabled xmas mode."
msgstr "Modo navideño desactivado."

#: ../../TShockAPI/Bouncer.cs:543
#, csharp-format
msgid "Disabled. You need to {0}login to load your saved data."
msgstr "Deshabilitado. Debes iniciar sesión con {0}login para cargar tus datos guardados."

#: ../../TShockAPI/Bouncer.cs:539
msgid "Disabled. You went too far with banned armor."
msgstr "Deshabilitado. Has ido demasiado lejos usando armadura prohibida."

#: ../../TShockAPI/Bouncer.cs:535
msgid "Disabled. You went too far with hacked item stacks."
msgstr "Deshabilitado. Has ido demasiado lejos con pilas de objetos hackeados."

#: ../../TShockAPI/Commands.cs:3974
msgid "disallow <item> <group> - Disallows a group from using an item."
msgstr "disallow <objeto> <grupo> - Le prohíbe a un grupo usar el objeto."

#: ../../TShockAPI/Commands.cs:4152
msgid "disallow <projectile ID> <group> - Disallows a group from using a projectile."
msgstr "disallow <ID de proyectil> <grupo> - Le prohíbe a un grupo usar el proyectil."

#: ../../TShockAPI/Commands.cs:4328
msgid "disallow <tile ID> <group> - Disallows a group from place a tile."
msgstr "disallow <ID de bloque> <grupo> - Le prohíbe a un grupo colocar el bloque."

#: ../../TShockPluginManager/NugetCLI.cs:140
#: ../../TShockPluginManager/NugetCLI.cs:161
msgid "Download and install the given packages?"
msgstr "¿Descargar e instalar los paquetes en cuestión?"

#: ../../TShockAPI/Commands.cs:2648
msgid "Duke Fishron"
msgstr "Duque Fishron"

#: ../../TShockAPI/Commands.cs:6617
msgid "Ebonwood Tree"
msgstr "Árbol de Ébano"

#: ../../TShockAPI/Commands.cs:6658
msgid "Emerald Gemtree"
msgstr "Arbolgema de Esmeralda"

#: ../../TShockAPI/Commands.cs:1879
msgid "Enabled halloween mode."
msgstr "Modo halloween activado."

#: ../../TShockAPI/Commands.cs:1898
msgid "Enabled xmas mode."
msgstr "Modo navideño activado."

#: ../../TShockAPI/Commands.cs:488
msgid "Enables starting and stopping various world events."
msgstr "Permite iniciar y detener varios eventos del mundo."

#: ../../TShockAPI/DB/GroupManager.cs:665
#, csharp-format
msgid "Error on reloading groups: {0}"
msgstr "Error al recargar los grupos: {0}"

#: ../../TShockAPI/Commands.cs:5119
msgid "Error: both names are the same."
msgstr "Error: los dos nombres son iguales."

#: ../../TShockAPI/Commands.cs:2777
msgid "Everscream"
msgstr "Gritoeterno"

#: ../../TShockAPI/Commands.cs:1407
#, csharp-format
msgid "Example usage: {0}"
msgstr "Ejemplo de uso: {0}"

#: ../../TShockAPI/Commands.cs:5463
#, csharp-format
msgid "Example usage: {0} \"{1}\" \"{2}\""
msgstr "Ejemplo de uso: {0} \"{1}\" \"{2}\""

#: ../../TShockAPI/Commands.cs:6369
#, csharp-format
msgid "Example usage: {0} \"{1}\" {2}"
msgstr "Ejemplo de uso: {0} \"{1}\" {2}"

#: ../../TShockAPI/Commands.cs:1399
#: ../../TShockAPI/Commands.cs:1415
#: ../../TShockAPI/Commands.cs:5330
#: ../../TShockAPI/Commands.cs:5629
#: ../../TShockAPI/Commands.cs:5919
#: ../../TShockAPI/Commands.cs:6012
#, csharp-format
msgid "Example usage: {0} {1}"
msgstr "Ejemplo de uso: {0} {1}"

#: ../../TShockAPI/Commands.cs:5520
#: ../../TShockAPI/Commands.cs:5685
#: ../../TShockAPI/Commands.cs:5816
#: ../../TShockAPI/Commands.cs:6309
#, csharp-format
msgid "Example usage: {0} {1} {2}"
msgstr "Ejemplo de uso: {0} {1} {2}"

#: ../../TShockAPI/Commands.cs:6419
#, csharp-format
msgid "Example usage: {0} {1} {2} {3}"
msgstr "Ejemplo de uso: {0} {1} {2} {3}"

#: ../../TShockAPI/Commands.cs:1391
#, csharp-format
msgid "Example usage: {0} {1} {2} {3} {4}"
msgstr "Ejemplo de uso: {0} {1} {2} {3} {4}"

#: ../../TShockAPI/Commands.cs:5601
#, csharp-format
msgid "Example usage: {0} <{1}> <{2}>"
msgstr "Ejemplo de uso: {0} <{1}> <{2}>"

#: ../../TShockAPI/Commands.cs:2002
msgid "Example: /sudo /ban add particles 2d Hacking."
msgstr "Ejemplo: /sudo /ban add particles 2d Hackeando."

#: ../../TShockAPI/Commands.cs:3206
#, csharp-format
msgid "Examples: {0}warp add foobar, {0}warp hide foobar true, {0}warp foobar."
msgstr "Ejemplos: {0}warp add foobar, {0}warp hide foobar true, {0}warp foobar."

#: ../../TShockAPI/Commands.cs:328
msgid "Executes a command as the super admin."
msgstr "Ejecuta un comando como súper admin."

#: ../../TShockAPI/GetDataHandlers.cs:4371
msgid "Exploit attempt detected!"
msgstr "¡Intento de exploit detectado!"

#: ../../TShockAPI/Commands.cs:1494
#, csharp-format
msgid "Failed to add ban for identifier: {0}."
msgstr "No se pudo agregar el ban para el identificador {0}."

#: ../../TShockAPI/Rest/RestManager.cs:671
#, csharp-format
msgid "Failed to add ban. {0}"
msgstr "No se pudo agregar el ban. {0}"

#: ../../TShockAPI/DB/GroupManager.cs:324
#, csharp-format
msgid "Failed to add group {0}."
msgstr "No se pudo agregar el grupo {0}."

#: ../../TShockAPI/DB/GroupManager.cs:512
#: ../../TShockAPI/DB/GroupManager.cs:513
#, csharp-format
msgid "Failed to delete group {0}."
msgstr "No se pudo eliminar el grupo {0}."

#: ../../TShockAPI/Commands.cs:2524
msgid "Failed to find any users by that name on the list."
msgstr "No se pudo encontrar ningún usuario con ese nombre en la lista."

#: ../../TShockAPI/Commands.cs:1638
#: ../../TShockAPI/Rest/RestManager.cs:698
msgid "Failed to remove ban."
msgstr "No se pudo eliminar el baneo."

#: ../../TShockAPI/DB/GroupManager.cs:480
#, csharp-format
msgid "Failed to rename group {0}."
msgstr "No se pudo renombrar el grupo {0}."

#: ../../TShockAPI/Commands.cs:5145
msgid "Failed to rename the region."
msgstr "No se pudo renombrar la región."

#: ../../TShockAPI/Bouncer.cs:2685
msgid "Failed to shade polygon normals."
msgstr "Error al sombrear las normales del polígono."

#: ../../TShockAPI/DB/GroupManager.cs:369
#, csharp-format
msgid "Failed to update group \"{0}\"."
msgstr "No se pudo actualizar el grupo \"{0}\"."

#: ../../TShockAPI/Commands.cs:1864
msgid "Failed to upload your character data to the server. Are you logged-in to an account?"
msgstr "No se pudo subir tus datos de personaje al servidor. ¿Iniciaste sesión en una cuenta?"

#: ../../TShockAPI/Rest/Rest.cs:245
msgid "Fatal Startup Exception"
msgstr "Excepción fatal de arranque."

#: ../../TShockAPI/Extensions/DbExt.cs:79
msgid "Fatal TShock initialization exception: failed to connect to MySQL database. See inner exception for details."
msgstr "Excepción fatal en la inicialización de TShock: no se pudo conectar a la base de datos MySQL. Vea la excepción interna para más detalles."

#: ../../TShockAPI/DB/UserManager.cs:218
#, csharp-format
msgid "FetchHashedPasswordAndGroup SQL returned an error: {0}"
msgstr "SQL FetchHashedPasswordAndGroup devolvió un error: {0}"

#: ../../TShockAPI/Commands.cs:5683
msgid "Firework Syntax"
msgstr "Sintaxis de Firework"

#: ../../TShockAPI/Commands.cs:1944
msgid "For example, 1d and 10h-30m+2m are both valid time strings, but 2 is not."
msgstr "Por ejemplo, 1d y 10h-30m+2m son ambas cadenas de tiempo válidas, pero 2 no lo es."

#: ../../TShockAPI/Commands.cs:1374
#, csharp-format
msgid "For more info, use {0} {1} or {2} {3}"
msgstr "Para más información, usa {0} {1} o {2} {3}"

#: ../../TShockAPI/Commands.cs:514
msgid "Forces all liquids to update immediately."
msgstr "Hace que todos los líquidos se actualicen inmediatamente."

#: ../../TShockAPI/Commands.cs:6278
#, csharp-format
msgid "Gave {0} {1} {2}."
msgid_plural "Gave {0} {1} {2}s."
msgstr[0] "Dio {0} {1} {2}."
msgstr[1] "Dio {0} {1} {2}s."

#: ../../TShockAPI/Commands.cs:6140
#, csharp-format
msgid "Gave {0} {1}."
msgid_plural "Gave {0} {1}s."
msgstr[0] "Dio {0} {1}."
msgstr[1] "Dio {0} {1}s."

#: ../../TShockAPI/GetDataHandlers.cs:3796
#, csharp-format
msgid "GetDataHandlers / HandleCatchNpc catch zero {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3804
#, csharp-format
msgid "GetDataHandlers / HandleCatchNpc rejected catch npc {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3119
#, csharp-format
msgid "GetDataHandlers / HandleChestActive rejected build permission and region check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3094
#, csharp-format
msgid "GetDataHandlers / HandleChestItem rejected max stacks {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2844
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected door gap check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2829
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected out of range door {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2835
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected type 0 5 check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2669
msgid "GetDataHandlers / HandleGetSection rejected reserve slot"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4042
#, csharp-format
msgid "GetDataHandlers / HandleKillPortal rejected owner mismatch check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2989
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected Cultist summon from {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2972
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected EoL summon from {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2962
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected npc strike {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3250
#, csharp-format
msgid "GetDataHandlers / HandleNpcTalk rejected npc talk {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4086
#, csharp-format
msgid "GetDataHandlers / HandleNpcTeleportPortal rejected not thinking with portals {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4079
#, csharp-format
msgid "GetDataHandlers / HandleNpcTeleportPortal rejected null check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3920
#, csharp-format
msgid "GetDataHandlers / HandleNumberOfAnglerQuestsCompleted surprise packet! Someone tell the TShock team! {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4144
#, csharp-format
msgid "GetDataHandlers / HandleOldOnesArmy rejected permissions {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4138
#, csharp-format
msgid "GetDataHandlers / HandleOldOnesArmy rejected throttled {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3622
#, csharp-format
msgid "GetDataHandlers / HandlePaintTile rejected range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3640
#, csharp-format
msgid "GetDataHandlers / HandlePaintTile rejected select consistency {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3649
#, csharp-format
msgid "GetDataHandlers / HandlePaintTile rejected throttle/permission/range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3669
#, csharp-format
msgid "GetDataHandlers / HandlePaintWall rejected range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3687
#, csharp-format
msgid "GetDataHandlers / HandlePaintWall rejected selector consistency {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3696
#, csharp-format
msgid "GetDataHandlers / HandlePaintWall rejected throttle/permission/range {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3411
#, csharp-format
msgid "GetDataHandlers / HandlePlayerBuffList handled event and sent data {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3396
#, csharp-format
msgid "GetDataHandlers / HandlePlayerBuffList zeroed player buff due to below state 2 {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2777
#, csharp-format
msgid "GetDataHandlers / HandlePlayerHp rejected over max hp {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2522
msgid "GetDataHandlers / HandlePlayerInfo rejected hardcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2516
msgid "GetDataHandlers / HandlePlayerInfo rejected mediumcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2457
msgid "GetDataHandlers / HandlePlayerInfo rejected name length 0"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2450
#, csharp-format
msgid "GetDataHandlers / HandlePlayerInfo rejected plugin phase {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2510
msgid "GetDataHandlers / HandlePlayerInfo rejected softcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4210
#: ../../TShockAPI/GetDataHandlers.cs:4216
#, csharp-format
msgid "GetDataHandlers / HandlePlayerKillMeV2 kicked with difficulty {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4225
#, csharp-format
msgid "GetDataHandlers / HandlePlayerKillMeV2 ssc delete {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3289
#, csharp-format
msgid "GetDataHandlers / HandlePlayerMana rejected max mana {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2554
msgid "GetDataHandlers / HandlePlayerSlot rejected ignore ssc packets"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3316
#, csharp-format
msgid "GetDataHandlers / HandlePlayerTeam rejected team fastswitch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2757
#, csharp-format
msgid "GetDataHandlers / HandlePlayerUpdate home position delta {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3144
msgid "GetDataHandlers / HandlePlayerZone rejected null check"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3025
#, csharp-format
msgid "GetDataHandlers / HandleProjectileKill permitted skeletron prime exemption {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3029
#, csharp-format
msgid "GetDataHandlers / HandleProjectileKill rejected banned projectile {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3014
#, csharp-format
msgid "GetDataHandlers / HandleProjectileKill rejected tombstone {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3354
#, csharp-format
msgid "GetDataHandlers / HandleSign rejected sign on build permission {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3361
#, csharp-format
msgid "GetDataHandlers / HandleSign rejected sign range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3334
#, csharp-format
msgid "GetDataHandlers / HandleSignRead rejected out of bounds {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2700
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport 'vanilla spawn' {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2711
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport phase 1 {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2720
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport phase 2 {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2682
#, csharp-format
msgid "GetDataHandlers / HandleSpawn rejected dead player spawn request {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3517
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected boss {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3507
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected bouner throttled {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3524
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected invasion {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3531
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected pet {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3442
#, csharp-format
msgid "GetDataHandlers / HandleSpecial rejected enchanted sundial permission (ForceTime) {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3436
#, csharp-format
msgid "GetDataHandlers / HandleSpecial rejected enchanted sundial permission {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3426
#, csharp-format
msgid "GetDataHandlers / HandleSpecial rejected type 1 for {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4005
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected expert/master mode check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3999
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected extents check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4011
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected npc id out of bounds check - NPC ID: {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4018
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected npc is null - NPC ID: {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4025
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected range check {0},{1} vs {2},{3} which is {4}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4397
#, csharp-format
msgid "GetDataHandlers / HandleSyncLoadout rejected loadout index sync {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4388
#, csharp-format
msgid "GetDataHandlers / HandleSyncLoadout rejected loadout index sync out of bounds {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3753
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected npc teleport {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3762
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected p2p extents {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3768
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected p2p wormhole permission {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3744
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected rod type {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3842
#: ../../TShockAPI/GetDataHandlers.cs:3858
#: ../../TShockAPI/GetDataHandlers.cs:3881
#: ../../TShockAPI/GetDataHandlers.cs:3901
#, csharp-format
msgid "GetDataHandlers / HandleTeleportationPotion rejected not holding the correct item {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3832
#, csharp-format
msgid "GetDataHandlers / HandleTeleportationPotion rejected permissions {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4126
#, csharp-format
msgid "GetDataHandlers / HandleToggleParty rejected no party {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3059
#, csharp-format
msgid "GetDataHandlers / HandleTogglePvp rejected fastswitch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3052
#, csharp-format
msgid "GetDataHandlers / HandleTogglePvp rejected index mismatch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2735
msgid "GetDataHandlers / OnPlayerUpdate rejected from null player."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2464
msgid "GetDataHandlers / rejecting player for name prefix starting with tsi: or tsn:."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3492
#, csharp-format
msgid "GetDataHandlers / UpdateNPCHome rejected no permission {0}"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:291
#, csharp-format
msgid "GetUser SQL returned an error {0}"
msgstr "SQL GetUser devolvió un error {0}"

#: ../../TShockAPI/Commands.cs:6417
msgid "Give Buff Syntax and Example"
msgstr "Sintaxis y Ejemplo de Give Buff"

#: ../../TShockAPI/Commands.cs:541
msgid "Gives another player a buff or debuff for an amount of time. Putting -1 for time will set it to 415 days."
msgstr "Da a otro jugador un buff o debuff por un tiempo determinado. Si pones -1 para el tiempo, será de 415 días."

#: ../../TShockAPI/Commands.cs:382
msgid "Gives another player an item."
msgstr "Da un objeto a otro jugador."

#: ../../TShockAPI/Commands.cs:533
msgid "Gives yourself a buff or debuff for an amount of time. Putting -1 for time will set it to 415 days."
msgstr "Te da un buff o debuff por un tiempo determinado. Si pones -1 para el tiempo, será de 415 días."

#: ../../TShockAPI/Commands.cs:387
msgid "Gives yourself an item."
msgstr "Te da un objeto."

#: ../../TShockAPI/Commands.cs:6690
msgid "Glowing Mushroom Tree"
msgstr "Árbol de Champiñón Brillante"

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:123
#, csharp-format
msgid "GolfPacketHandler: Player did not have create a golf club projectile the last 5 seconds! - From {0}"
msgstr "GolfPacketHandler: ¡El jugador no había creado un proyectil de palo de golf en los últimos 5 segundos! - De {0}"

#: ../../TShockAPI/Commands.cs:3506
#, csharp-format
msgid "Group \"{0}\" has no parent."
msgstr "El grupo \"{0}\" no tiene padre."

#: ../../TShockAPI/Commands.cs:3596
#, csharp-format
msgid "Group \"{0}\" has no prefix."
msgstr "El grupo \"{0}\" no tiene prefijo."

#: ../../TShockAPI/Commands.cs:3551
#, csharp-format
msgid "Group \"{0}\" has no suffix."
msgstr "El grupo \"{0}\" no tiene sufijo."

#: ../../TShockAPI/DB/GroupManager.cs:646
#, csharp-format
msgid "Group \"{0}\" is referencing parent group {1} which is already part of the parent chain. Parent reference removed."
msgstr "El grupo \"{0}\" hace referencia al grupo padre {1} que ya forma parte de la cadena de parentesco. Se ha eliminado esta referencia."

#: ../../TShockAPI/DB/GroupManager.cs:578
msgid "Group \"superadmin\" is defined in the database even though it's a reserved group name."
msgstr "El grupo \"superadmin\" está definido en la base de datos aunque es un nombre de grupo reservado."

#: ../../TShockAPI/DB/GroupManager.cs:708
#, csharp-format
msgid "Group {0} already exists"
msgstr "El grupo {0} ya existe"

#: ../../TShockAPI/Rest/RestManager.cs:1158
#, csharp-format
msgid "Group {0} created successfully"
msgstr "Grupo {0} creado con éxito"

#: ../../TShockAPI/Rest/RestManager.cs:1133
#, csharp-format
msgid "Group {0} deleted successfully"
msgstr "Grupo {0} eliminado con éxito"

#: ../../TShockAPI/DB/UserManager.cs:638
#: ../../TShockAPI/DB/GroupManager.cs:725
#, csharp-format
msgid "Group {0} does not exist"
msgstr "El grupo {0} no existe"

#: ../../TShockAPI/Commands.cs:1110
#, csharp-format
msgid "Group {0} does not exist."
msgstr "El grupo {0} no existe."

#: ../../TShockAPI/Rest/RestManager.cs:1354
#, csharp-format
msgid "Group {0} doesn't exist"
msgstr "El grupo {0} no existe"

#: ../../TShockAPI/DB/GroupManager.cs:495
#: ../../TShockAPI/DB/GroupManager.cs:525
#: ../../TShockAPI/DB/GroupManager.cs:548
#, csharp-format
msgid "Group {0} doesn't exist."
msgstr "El grupo {0} no existe."

#: ../../TShockAPI/DB/GroupManager.cs:508
#, csharp-format
msgid "Group {0} has been deleted successfully."
msgstr "El grupo {0} fue eliminado exitosamente."

#: ../../TShockAPI/DB/GroupManager.cs:463
#, csharp-format
msgid "Group {0} has been renamed to {1}."
msgstr "El grupo {0} fue renombrado a {1}."

#: ../../TShockAPI/DB/GroupManager.cs:631
#, csharp-format
msgid "Group {0} is referencing a non existent parent group {1}, parent reference was removed."
msgstr "El grupo {0} hace referencia a un grupo padre {1} que no existe. Se ha eliminado esta referencia."

#: ../../TShockAPI/DB/GroupManager.cs:637
#, csharp-format
msgid "Group {0} is referencing itself as parent group; parent reference was removed."
msgstr "El grupo {0} se está referenciando a sí mismo como grupo padre. Se ha eliminado esta referencia."

#: ../../TShockAPI/Commands.cs:4862
#: ../../TShockAPI/Commands.cs:4897
#, csharp-format
msgid "Group {0} not found."
msgstr "No se encuentra el grupo {0}."

#: ../../TShockAPI/Rest/RestManager.cs:1187
#, csharp-format
msgid "Group {0} updated successfully"
msgstr "Grupo {0} actualizado exitosamente"

#: ../../TShockAPI/Commands.cs:3380
#, csharp-format
msgid "Group {0} was added successfully."
msgstr "El grupo {0} se agregó correctamente."

#: ../../TShockAPI/Commands.cs:3454
msgid "Group Sub-Commands ({{0}}/{{1}}):"
msgstr "Sub-Comandos de Group ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:3745
msgid "Groups ({{0}}/{{1}}):"
msgstr "Grupos ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:476
msgid "Grows plants at your location."
msgstr "Crece plantas en tu ubicación."

#: ../../TShockAPI/Commands.cs:6631
msgid "Hallow Palm"
msgstr "Palmera Sagrada"

#: ../../TShockAPI/GetDataHandlers.cs:4372
#, csharp-format
msgid "HandleSyncCavernMonsterType: Player is trying to modify NPC cavernMonsterType; this is a crafted packet! - From {0}"
msgstr "HandleSyncCavernMonsterType: El jugador está intentando modificar el cavernMonsterType de PNJ; ¡este es un paquete creado artificialmente! - De {0}"

#: ../../TShockAPI/Commands.cs:2593
msgid "Hardmode is disabled in the server configuration file."
msgstr "El modo difícil está deshabilitado en el archivo de configuración del servidor."

#: ../../TShockAPI/Commands.cs:2584
msgid "Hardmode is now off."
msgstr "Se ha desactivado el modo difícil."

#: ../../TShockAPI/Commands.cs:2589
msgid "Hardmode is now on."
msgstr "Se ha activado el modo difícil."

#: ../../TShockAPI/Commands.cs:6307
msgid "Heal Syntax and Example"
msgstr "Sintaxis y Ejemplo de Heal"

#: ../../TShockAPI/Bouncer.cs:2097
msgid "HealOtherPlayer cheat attempt!"
msgstr "¡Intento de trampa con HealOtherPlayer!"

#: ../../TShockAPI/Bouncer.cs:2106
#, csharp-format
msgid "HealOtherPlayer threshold exceeded {0}."
msgstr "Umbral de HealOtherPlayer excedió {0}."

#: ../../TShockAPI/Commands.cs:549
msgid "Heals a player in HP and MP."
msgstr "Restaura los HP y MP del jugador."

#: ../../TShockAPI/Commands.cs:6684
msgid "Herb"
msgstr "Hierba"

#: ../../TShockAPI/Commands.cs:4658
msgid "Hit a block to get the name of the region."
msgstr "Golpea un bloque para ver el nombre de la región."

#: ../../TShockAPI/Commands.cs:4671
#, csharp-format
msgid "Hit a block to set point {0}."
msgstr "Golpea un bloque para definir el punto {0}."

#: ../../TShockAPI/ItemBans.cs:94
#: ../../TShockAPI/ItemBans.cs:163
#, csharp-format
msgid "holding banned item: {0}"
msgstr "sosteniendo un objeto prohibido: {0}"

#: ../../TShockAPI/Commands.cs:1235
#, csharp-format
msgid "ID: {0}"
msgstr "ID: {0}"

#: ../../TShockAPI/Commands.cs:6310
msgid "If no amount is specified, it will default to healing the target player by their max HP."
msgstr "Si no se especifica una cantidad el jugador curará toda su vida."

#: ../../TShockAPI/Bouncer.cs:1392
msgid "If this player wasn't hacking, please report the damage threshold they were disabled for to TShock so we can improve this!"
msgstr "Si este jugador no estaba haciendo trampa, ¡favor reportar a TShock el umbral de daño por el que fue deshabilitado para mejorar el sistema!"

#: ../../TShockAPI/Bouncer.cs:2113
msgid "If this player wasn't hacking, please report the HealOtherPlayer threshold they were disabled for to TShock so we can improve this!"
msgstr "Si este jugador no estaba haciendo trampa, ¡favor reportar a TShock el umbral de HealOtherPlayer por el que fue deshabilitado para mejorar el sistema!"

#: ../../TShockAPI/Bouncer.cs:1295
msgid "If this player wasn't hacking, please report the projectile create threshold they were disabled for to TShock so we can improve this!"
msgstr "Si este jugador no estaba haciendo trampa, ¡favor reportar a TShock el umbral de proyectiles creados por el que fue deshabilitado para mejorar el sistema!"

#: ../../TShockAPI/Bouncer.cs:927
msgid "If this player wasn't hacking, please report the tile kill threshold they were disabled for to TShock so we can improve this!"
msgstr "Si este jugador no estaba haciendo trampa, ¡favor reportar a TShock el umbral de destrucción de bloques por el que fue deshabilitado para mejorar el sistema!"

#: ../../TShockAPI/Bouncer.cs:1695
msgid "If this player wasn't hacking, please report the tile liquid threshold they were disabled for to TShock so we can improve this!"
msgstr "Si este jugador no estaba haciendo trampa, ¡favor reportar a TShock el umbral de bloques líquidos por el que fue deshabilitado para mejorar el sistema!"

#: ../../TShockAPI/Bouncer.cs:945
msgid "If this player wasn't hacking, please report the tile place threshold they were disabled for to TShock so we can improve this!"
msgstr "Si este jugador no estaba haciendo trampa, ¡favor reportar a TShock el umbral de colocación de bloques por el que fue deshabilitado para mejorar el sistema!"

#: ../../TShockAPI/GetDataHandlers.cs:3026
msgid "If this was not skeletron prime related, please report to TShock what happened."
msgstr "Si esto no estaba relacionado con Esqueletrón Prime, por favor reporta a TShock lo ocurrido."

#: ../../TShockAPI/Commands.cs:5377
msgid "If you are locked out of all admin accounts, ask for help on https://tshock.co/"
msgstr "Si perdiste el acceso a todas las cuentas de administrador, pide ayuda en https://tshock.co/"

#: ../../TShockAPI/Commands.cs:5817
#, csharp-format
msgid "If you do not specify a radius, it will use a default radius of {0} around your character."
msgstr "Si no especificas un radio, usará uno predeterminado de {0} alrededor de tu personaje."

#: ../../TShockAPI/Commands.cs:6370
#, csharp-format
msgid "If you don't specify the duration, it will default to {0} seconds."
msgstr "Si no especificas una duración, se usara la predeterminada de {0} segundos."

#: ../../TShockAPI/Commands.cs:857
msgid "If you forgot your password, contact the administrator for help."
msgstr "Si olvidaste tu contraseña, pide ayuda al administrador."

#: ../../TShockAPI/Commands.cs:6371
#, csharp-format
msgid "If you put {0} as the duration, it will use the max possible time of 415 days."
msgstr "Si estableces {0} como la duración, usará el máximo tiempo posible que es 415 días."

#: ../../TShockAPI/Commands.cs:5416
#, csharp-format
msgid "If you understand, please {0}login <username> <password> now, and then type {0}setup."
msgstr "Si has entendido, por favor usa {0}login <nombre de usuario> <contraseña>, y a continuación teclea {0}setup."

#: ../../TShockPluginManager/NugetCLI.cs:142
msgid "If you want to know which plugins need which dependencies, press E."
msgstr "Si deseas saber qué plugins necesitan qué dependencias, pulsa E."

#: ../../TShockPluginManager/NugetCLI.cs:162
msgid "If you'd like to see which plugins need which dependencies again, press E."
msgstr "Si deseas ver nuevamente qué plugins necesitan qué dependencias, pulsa E."

#: ../../TShockAPI/Bouncer.cs:986
msgid "If you're seeing this message and you know what that player did, please report it to TShock for further investigation."
msgstr "Si ves este mensaje y sabes lo que hizo ese jugador, favor reportar a TShock para investigar más a fondo."

#: ../../TShockAPI/Bouncer.cs:1341
msgid "Ignoring shrapnel per config.."
msgstr "Ignorando esquirlas de acuerdo a la configuración.."

#: ../../TShockAPI/GetDataHandlers.cs:2465
msgid "Illegal name: prefixes tsi: and tsn: are forbidden."
msgstr "Nombre ilegal: los prefijos tsi: y tsn: están prohibidos."

#: ../../TShockAPI/Handlers/IllegalPerSe/EmojiPlayerMismatch.cs:19
#, csharp-format
msgid "IllegalPerSe: Emoji packet rejected for ID spoofing. Expected {0}, received {1} from {2}."
msgstr "IllegalPerSe: Paquete de emoji rechazado por falsificación de ID. Esperado {0}, recibido {1} de {2}."

#: ../../TShockAPI/Commands.cs:3189
msgid "Incoming teleports are now allowed."
msgstr "Ahora se permiten teletransportes entrantes."

#: ../../TShockAPI/Commands.cs:3191
msgid "Incoming teleports are now disabled."
msgstr "Ahora se bloquean teletransportes entrantes."

#: ../../TShockAPI/Commands.cs:5403
msgid "Incorrect setup code. This incident has been logged."
msgstr "Código de configuración incorrecto. Incidente archivado en el registro."

#: ../../TShockAPI/DB/TileManager.cs:223
#: ../../TShockAPI/DB/ProjectileManager.cs:223
#, csharp-format
msgid "Infinite group parenting ({0})"
msgstr "Grupo infinito de jerarquía ({0})"

#: ../../TShockAPI/Commands.cs:5197
msgid "info <region> [-d] - Displays several information about the given region."
msgstr "info <región> [-d] - Muestra bastante información sobre la región dada."

#: ../../TShockAPI/Commands.cs:4986
#, csharp-format
msgid "Information About Region \"{0}\" ({{0}}/{{1}}):"
msgstr "Información Sobre la Región \"{0}\" ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:1232
msgid "Information about the currently running world"
msgstr "Información sobre el mundo actual"

#: ../../TShockAPI/DB/BanManager.cs:314
msgid "Inserting the ban into the database failed."
msgstr "Se ha producido un error al insertar el ban en la base de datos."

#: ../../TShockPluginManager/NugetCLI.cs:39
msgid "Install the plugins as specified in the plugins.json"
msgstr "Instala los plugins como se especifica en plugins.json"

#: ../../TShockAPI/Rest/Rest.cs:426
msgid "Internal server error."
msgstr "Error interno del servidor."

#: ../../TShockAPI/Commands.cs:1505
#, csharp-format
msgid "Invalid Ban Add syntax. Refer to {0} for details on how to use the {1} command"
msgstr "Sintaxis de Ban Add inválida. Revisa {0} para ver detalles de uso para el comando {1}"

#: ../../TShockAPI/Commands.cs:1621
#, csharp-format
msgid "Invalid Ban Del syntax. Refer to {0} for details on how to use the {1} command"
msgstr "Sintaxis de Ban Del inválida. Revisa {0} para ver detalles de uso para el comando {1}"

#: ../../TShockAPI/Commands.cs:1680
#, csharp-format
msgid "Invalid Ban Details syntax. Refer to {0} for details on how to use the {1} command"
msgstr "Sintaxis de Ban Details inválida. Revisa {0} para ver detalles de uso para el comando {1}"

#: ../../TShockAPI/Commands.cs:1658
#, csharp-format
msgid "Invalid Ban List syntax. Refer to {0} for details on how to use the {1} command"
msgstr "Sintaxis de Ban List inválida. Revisa {0} para ver detalles de uso para el comando {1}"

#: ../../TShockAPI/DB/UserManager.cs:500
msgid "Invalid BCrypt work factor in config file! Creating new hash using default work factor."
msgstr "¡Factor de trabajo BCrypt inválido en el archivo de configuración! Creando nuevo hash usando el factor de trabajo predeterminado."

#: ../../TShockAPI/Commands.cs:2608
msgid "Invalid boss amount."
msgstr "La cantidad de jefes no es válida."

#: ../../TShockAPI/Commands.cs:2821
msgid "Invalid boss type!"
msgstr "¡El tipo de jefe no es válido!"

#: ../../TShockAPI/Commands.cs:6470
msgid "Invalid buff ID!"
msgstr "¡El ID de buff no es válido!"

#: ../../TShockAPI/Commands.cs:680
#, csharp-format
msgid "Invalid command entered. Type {0}help for a list of valid commands."
msgstr "Se ha introducido un comando inválido. Escriba {0}help para obtener una lista de comandos válidos."

#: ../../TShockAPI/Commands.cs:5275
msgid "Invalid command."
msgstr "Comando inválido."

#: ../../TShockAPI/Commands.cs:3131
msgid "Invalid destination NPC."
msgstr "El PNJ destino no es válido."

#: ../../TShockAPI/Commands.cs:2941
#: ../../TShockAPI/Commands.cs:2972
#: ../../TShockAPI/Commands.cs:3011
#: ../../TShockAPI/Commands.cs:3084
msgid "Invalid destination player."
msgstr "El jugador destino no es válido."

#: ../../TShockAPI/Commands.cs:2240
#, csharp-format
msgid "Invalid event type. Valid event types: {0}."
msgstr "Tipo de evento inválido. Tipos de eventos válidos: {0}."

#: ../../TShockAPI/Commands.cs:2382
msgid "Invalid frost moon event wave."
msgstr "Ronda inválida para el evento de luna helada."

#: ../../TShockAPI/Commands.cs:3765
#: ../../TShockAPI/Commands.cs:3868
#: ../../TShockAPI/Commands.cs:3939
#: ../../TShockAPI/Commands.cs:4058
#: ../../TShockAPI/Commands.cs:4116
#: ../../TShockAPI/Commands.cs:4234
#: ../../TShockAPI/Commands.cs:4292
msgid "Invalid group."
msgstr "Grupo inválido."

#: ../../TShockAPI/Commands.cs:2401
#, csharp-format
msgid "Invalid invasion type. Valid invasion types: {0}."
msgstr "Tipo de invasión inválido. Tipos válidos de invasión: {0}."

#: ../../TShockAPI/Commands.cs:6083
#: ../../TShockAPI/Commands.cs:6232
#: ../../TShockAPI/Commands.cs:6295
msgid "Invalid item type!"
msgstr "¡Tipo de objeto inválido!"

#: ../../TShockAPI/Commands.cs:3807
#: ../../TShockAPI/Commands.cs:3858
#: ../../TShockAPI/Commands.cs:3903
#: ../../TShockAPI/Commands.cs:3929
msgid "Invalid item."
msgstr "Objeto inválido."

#: ../../TShockAPI/Commands.cs:4455
#, csharp-format
msgid "Invalid maximum spawns.  Acceptable range is {0} to {1}."
msgstr "Máximo de enemigos generados inválido. El rango aceptable es de {0} a {1}."

#: ../../TShockAPI/Commands.cs:2860
#: ../../TShockAPI/Commands.cs:6166
msgid "Invalid mob type!"
msgstr "¡Tipo de enemigo inválido!"

#: ../../TShockAPI/Commands.cs:2844
#: ../../TShockAPI/Commands.cs:2900
msgid "Invalid mob type."
msgstr "Tipo de enemigo inválido."

#: ../../TShockAPI/Commands.cs:2569
#, csharp-format
msgid "Invalid mode world mode. Valid modes: {0}"
msgstr "Modo de mundo inválido. Modos válidos: {0}"

#: ../../TShockAPI/Commands.cs:1421
msgid "Invalid page number. Page number must be numeric."
msgstr "Número de página inválido. La cifra debe ser numérica."

#: ../../TShockAPI/DB/GroupManager.cs:309
#, csharp-format
msgid "Invalid parent group {0} for group {1}"
msgstr "Grupo padre {0} inválido para el grupo {1}"

#: ../../TShockAPI/DB/GroupManager.cs:347
#, csharp-format
msgid "Invalid parent group {0} for group {1}."
msgstr "Grupo padre {0} inválido para el grupo {1}."

#: ../../TShockAPI/Commands.cs:928
msgid "Invalid password."
msgstr "Contraseña inválida."

#: ../../TShockAPI/Commands.cs:6263
#: ../../TShockAPI/Commands.cs:6718
msgid "Invalid player!"
msgstr "¡Jugador inválido!"

#: ../../TShockAPI/Commands.cs:1255
msgid "Invalid player."
msgstr "Jugador inválido."

#: ../../TShockAPI/Commands.cs:4040
msgid "Invalid projectile ID!"
msgstr "¡ID de proyectil inválido!"

#: ../../TShockAPI/Commands.cs:4077
#: ../../TShockAPI/Commands.cs:4098
#: ../../TShockAPI/Commands.cs:4136
msgid "Invalid projectile ID."
msgstr "ID de proyectil inválido."

#: ../../TShockAPI/Commands.cs:2364
msgid "Invalid pumpkin moon event wave."
msgstr "Ronda inválida para el evento de luna calabaza."

#: ../../TShockAPI/Commands.cs:5127
#, csharp-format
msgid "Invalid region \"{0}\"."
msgstr "Región \"{0}\" inválida."

#: ../../TShockAPI/Rest/Rest.cs:247
#, csharp-format
msgid "Invalid REST configuration: \n"
"You may already have a REST service bound to port {0}. \n"
"Please adjust your configuration and restart the server. \n"
"Press any key to exit."
msgstr "Configuración REST inválida: \n"
"Puede que tengas un servicio REST enlazado al puerto {0}. \n"
"Por favor ajusta tu configuración y reinicia el servidor. \n"
"Presiona cualquier tecla para salir."

#: ../../TShockAPI/GetDataHandlers.cs:3231
msgid "Invalid server password."
msgstr "Contraseña de servidor inválida."

#: ../../TShockAPI/Commands.cs:3782
#, csharp-format
msgid "Invalid subcommand! Type {0}group help for more information on valid commands."
msgstr "¡Subcomando inválido! Teclea {0}group help para más información sobre comandos válidos."

#: ../../TShockAPI/Commands.cs:4009
#, csharp-format
msgid "Invalid subcommand. Type {0}itemban help for more information on valid subcommands."
msgstr "¡Subcomando inválido! Teclea {0}itemban help para más información sobre subcomandos válidos."

#: ../../TShockAPI/Commands.cs:4187
#, csharp-format
msgid "Invalid subcommand. Type {0}projban help for more information on valid subcommands."
msgstr "¡Subcomando inválido! Teclea {0}projban help para más información sobre subcomandos válidos."

#: ../../TShockAPI/Commands.cs:4363
#, csharp-format
msgid "Invalid subcommand. Type {0}tileban help for more information on valid subcommands."
msgstr "¡Subcomando inválido! Teclea {0}tileban help para más información sobre subcomandos válidos."

#: ../../TShockAPI/Commands.cs:3641
msgid "Invalid syntax for color, expected \"rrr,ggg,bbb\"."
msgstr "Sintaxis incorrecta para color, se esperaba \"rrr,vvv,aaa\" (rojo, verde, azul)."

#: ../../TShockAPI/Commands.cs:1915
msgid "Invalid syntax."
msgstr "Sintaxis inválida."

#: ../../TShockAPI/Commands.cs:2332
#, csharp-format
msgid "Invalid syntax. Proper syntax:  {0}worldevent invasion [invasion type] [invasion wave]."
msgstr "Sintaxis inválida. Sintaxis correcta:  {0}worldevent invasion [tipo de invasión] [ronda de invasión]."

#: ../../TShockAPI/Commands.cs:1270
#: ../../TShockAPI/Commands.cs:1304
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}accountinfo <username>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}accountinfo <nombre de usuario>."

#: ../../TShockAPI/Commands.cs:5754
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}aliases <command or alias>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}aliases <comando o alias>"

#: ../../TShockAPI/Commands.cs:3369
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group add <group name> [permissions]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group add <nombre de grupo> [permisos]."

#: ../../TShockAPI/Commands.cs:3398
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group addperm <group name> <permissions...>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group addperm <nombre de grupo> <permisos...>."

#: ../../TShockAPI/Commands.cs:3606
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group color <group name> [new color(000,000,000)]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group color <nombre de grupo> [color nuevo(000,000,000)]."

#: ../../TShockAPI/Commands.cs:3679
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group del <group name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group del <nombre del grupo>."

#: ../../TShockAPI/Commands.cs:3703
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group delperm <group name> <permissions...>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group delperm <nombre del grupo> <permisos...>."

#: ../../TShockAPI/Commands.cs:3756
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group listperm <group name> [page]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group listperm <nombre del grupo> [página]."

#: ../../TShockAPI/Commands.cs:3466
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group parent <group name> [new parent group name]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group parent <nombre de grupo> [nuevo nombre del grupo padre]."

#: ../../TShockAPI/Commands.cs:3561
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group prefix <group name> [new prefix]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group prefix <nombre de grupo> [prefijo nuevo]."

#: ../../TShockAPI/Commands.cs:3656
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group rename <group> <new name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group rename <grupo> <nombre nuevo>."

#: ../../TShockAPI/Commands.cs:3516
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group suffix <group name> [new suffix]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}group suffix <nombre de grupo> [sufijo nuevo]."

#: ../../TShockAPI/Commands.cs:5241
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}help <command/page>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}help <comando/página>"

#: ../../TShockAPI/Commands.cs:6058
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}item <item name/id> [item amount] [prefix id/name]"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}item <nombre/id de objeto> [cantidad del objeto] [id/nombre del prefijo]"

#: ../../TShockAPI/Commands.cs:3800
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban add <item name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}itemban add <nombre de objeto>."

#: ../../TShockAPI/Commands.cs:3851
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban allow <item name> <group name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}itemban allow <nombre de objeto> <nombre de grupo>."

#: ../../TShockAPI/Commands.cs:3896
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban del <item name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}itemban del <nombre de objeto>."

#: ../../TShockAPI/Commands.cs:3922
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban disallow <item name> <group name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}itemban disallow <nombre de objeto> <nombre de grupo>."

#: ../../TShockAPI/Commands.cs:1311
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}kick <player> [reason]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}kick <jugador> [motivo]."

#: ../../TShockAPI/Commands.cs:5424
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}me <text>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}me <texto>"

#: ../../TShockAPI/Commands.cs:5437
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}p <team chat text>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}p <texto del chat de equipo>"

#: ../../TShockAPI/Commands.cs:4030
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban add <proj id>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}projban add <id de proyectil>"

#: ../../TShockAPI/Commands.cs:4049
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban allow <id> <group>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}projban allow <id> <grupo>."

#: ../../TShockAPI/Commands.cs:4086
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban del <id>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}projban del <id>."

#: ../../TShockAPI/Commands.cs:4107
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban disallow <id> <group name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}projban disallow <id> <nombre del grupo>."

#: ../../TShockAPI/Commands.cs:4796
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region allow <name> <region>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region allow <nombre> <región>."

#: ../../TShockAPI/Commands.cs:4866
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region allowg <group> <region>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region allowg <grupo> <región>."

#: ../../TShockAPI/Commands.cs:4710
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region define <name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region define <nombre>."

#: ../../TShockAPI/Commands.cs:4752
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region delete <name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region delete <nombre>."

#: ../../TShockAPI/Commands.cs:4925
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region info <region> [-d] [page]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region info <región> [-d] [página]."

#: ../../TShockAPI/Commands.cs:4733
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region protect <name> <true/false>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region protect <nombre> <true/false>."

#: ../../TShockAPI/Commands.cs:4831
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region remove <name> <region>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region remove <nombre> <región>."

#: ../../TShockAPI/Commands.cs:4901
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region removeg <group> <region>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region removeg <grupo> <región>."

#: ../../TShockAPI/Commands.cs:5109
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region rename <region> <new name>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region rename <región> <nombre nuevo>"

#: ../../TShockAPI/Commands.cs:5099
#: ../../TShockAPI/Commands.cs:5102
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region resize <región> <u/d/l/r> <cantidad>"

#: ../../TShockAPI/Commands.cs:5159
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region tp <region>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region tp <región>."

#: ../../TShockAPI/Commands.cs:5047
#: ../../TShockAPI/Commands.cs:5050
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region z <name> <#>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}region z <nombre> <#>"

#: ../../TShockAPI/Commands.cs:1037
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}register <password>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}register <contraseña>."

#: ../../TShockAPI/Commands.cs:6157
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}renameNPC <guide, nurse, etc.> <newname>"
msgstr "Sintaxis inválida. Sintaxis correcta: {0}renameNPC <guía, enfermera, etc.> <nombreNuevo>"

#: ../../TShockAPI/Commands.cs:4402
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}serverpassword \"<new password>\"."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}serverpassword \"<contraseña nueva>\"."

#: ../../TShockAPI/Commands.cs:4583
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}slap <player> [damage]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}slap <jugador> [daño]."

#: ../../TShockAPI/Commands.cs:2601
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}spawnboss <boss type> [amount]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}spawnboss <tipo de jefe> [cantidad]."

#: ../../TShockAPI/Commands.cs:2839
#: ../../TShockAPI/Commands.cs:2851
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}spawnmob <mob type> [amount]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}spawnmob <tipo de enemigo> [cantidad]."

#: ../../TShockAPI/Commands.cs:4206
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban add <tile id>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tileban add <id de bloque>."

#: ../../TShockAPI/Commands.cs:4225
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban allow <id> <group>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tileban allow <id> <grupo>."

#: ../../TShockAPI/Commands.cs:4262
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban del <id>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tileban del <id>."

#: ../../TShockAPI/Commands.cs:4283
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban disallow <id> <group name>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tileban disallow <id> <nombre del grupo>."

#: ../../TShockAPI/Commands.cs:2931
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tp <player> [player 2]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tp <jugador> [jugador 2]."

#: ../../TShockAPI/Commands.cs:2933
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tp <player>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tp <jugador>."

#: ../../TShockAPI/Commands.cs:3058
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tphere <player>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tphere <jugador>."

#: ../../TShockAPI/Commands.cs:3056
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tphere <player|*>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tphere <jugador|*>."

#: ../../TShockAPI/Commands.cs:3103
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tpnpc <NPC>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tpnpc <PNJ>."

#: ../../TShockAPI/Commands.cs:3167
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tppos <tile x> <tile y>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}tppos <casilla x> <casilla y>."

#: ../../TShockAPI/Commands.cs:1249
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}userinfo <player>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}userinfo <jugador>."

#: ../../TShockAPI/Commands.cs:3202
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp [command] [arguments]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}warp [comando] [argumentos]."

#: ../../TShockAPI/Commands.cs:3211
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp [name] or {0}warp list <page>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}warp [nombre] o {0}warp list <página>."

#: ../../TShockAPI/Commands.cs:3254
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp add [name]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}warp add [nombre]."

#: ../../TShockAPI/Commands.cs:3271
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp del [name]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}warp del [nombre]."

#: ../../TShockAPI/Commands.cs:3294
#: ../../TShockAPI/Commands.cs:3297
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp hide [name] <true/false>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}warp hide [nombre] <true/false>."

#: ../../TShockAPI/Commands.cs:3305
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp send [player] [warpname]."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}warp send [jugador] [nombreDeWarp]."

#: ../../TShockAPI/Commands.cs:4625
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}wind <speed>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}wind <velocidad>."

#: ../../TShockAPI/Commands.cs:2146
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}worldevent <event type>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}worldevent <tipo de evento>."

#: ../../TShockAPI/Commands.cs:2548
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}worldmode <mode>."
msgstr "Sintaxis inválida. Sintaxis correcta: {0}worldmode <modo/dificultad>."

#: ../../TShockAPI/Commands.cs:4736
#, csharp-format
msgid "Invalid syntax. Proper syntax: /region protect <name> <true/false>."
msgstr "Sintaxis inválida. Sintaxis correcta: /region protect <nombre> <true/false>."

#: ../../TShockAPI/Commands.cs:4676
msgid "Invalid syntax. Proper syntax: /region set <1/2>."
msgstr "Sintaxis inválida. Sintaxis correcta: /region set <1/2>."

#: ../../TShockAPI/Commands.cs:3151
#: ../../TShockAPI/Commands.cs:3312
#: ../../TShockAPI/Commands.cs:4589
#: ../../TShockAPI/Commands.cs:4597
msgid "Invalid target player."
msgstr "Jugador destino inválido."

#: ../../TShockAPI/Commands.cs:1627
#: ../../TShockAPI/Commands.cs:1686
#, csharp-format
msgid "Invalid Ticket Number. Refer to {0} for details on how to use the {1} command"
msgstr "Número de Ticket inválido. Consulte {0} para más detalles sobre cómo utilizar el comando {1}"

#: ../../TShockAPI/Commands.cs:4216
#: ../../TShockAPI/Commands.cs:4253
#: ../../TShockAPI/Commands.cs:4274
#: ../../TShockAPI/Commands.cs:4312
msgid "Invalid tile ID."
msgstr "ID de bloque inválido."

#: ../../TShockAPI/Commands.cs:1943
msgid "Invalid time string! Proper format: _d_h_m_s, with at least one time specifier."
msgstr "¡Cadena de tiempo inválida! Formato correcto: _d_h_m_s, con al menos un especificador de hora."

#: ../../TShockAPI/Commands.cs:4548
#: ../../TShockAPI/Commands.cs:4557
msgid "Invalid time string. Proper format: hh:mm, in 24-hour time."
msgstr "Cadena de tiempo inválida. Formato correcto: hh:mm, en formato de 24 horas."

#: ../../TShockAPI/Rest/RestManager.cs:1332
#, csharp-format
msgid "Invalid Type: '{0}'"
msgstr "Tipo Inválido: '{0}'"

#: ../../TShockAPI/Commands.cs:1079
#: ../../TShockAPI/Commands.cs:1212
#, csharp-format
msgid "Invalid user syntax. Try {0}user help."
msgstr "Sintaxis de user inválida. Prueba {0}user help."

#: ../../TShockAPI/Commands.cs:3242
msgid "Invalid warp name. The names 'list', 'hide', 'del' and 'add' are reserved for commands."
msgstr "Nombre de warp inválido. Los nombres 'list', 'hide', 'del' y 'add' están reservados para comandos."

#: ../../TShockAPI/Commands.cs:4632
msgid "Invalid wind speed."
msgstr "Velocidad de viento inválida."

#: ../../TShockAPI/Commands.cs:2559
#, csharp-format
msgid "Invalid world mode. Valid world modes: {0}"
msgstr "Modo de mundo inválido. Modos válidos: {0}"

#: ../../TShockAPI/Commands.cs:1260
#, csharp-format
msgid "IP Address: {0}."
msgstr "Dirección IP: {0}."

#: ../../TShockAPI/Commands.cs:3981
msgid "Item Ban Sub-Commands ({{0}}/{{1}}):"
msgstr "Sub-Comandos de Item Ban ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:3999
msgid "Item bans ({{0}}/{{1}}):"
msgstr "Objetos prohibidos ({{0}}/{{1}}):"

#: ../../TShockAPI/TSPlayer.cs:1920
#, csharp-format
msgid "Kicked {0} for : '{1}'"
msgstr "Se expulsó a {0} por : '{1}'"

#: ../../TShockAPI/Rest/RestManager.cs:1049
msgid "Kicked via web"
msgstr "Expulsado vía web"

#: ../../TShockAPI/TSPlayer.cs:1919
#, csharp-format
msgid "Kicked: {0}"
msgstr "Expulsado: {0}"

#: ../../TShockAPI/Commands.cs:5917
msgid "Kill syntax and example"
msgstr "Sintaxis y ejemplo de Kill"

#: ../../TShockAPI/Commands.cs:553
msgid "Kills another player."
msgstr "Mata a otro jugador."

#: ../../TShockAPI/Commands.cs:393
msgid "Kills hostile NPCs or NPCs of a certain type."
msgstr "Mata PNJ hostiles o a un tipo específico de PNJ."

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:114
#, csharp-format
msgid "LandGolfBallInCupHandler: Invalid golf ball projectile ID {0}! - From {1}"
msgstr "LandGolfBallInCupHandler: ¡ID de proyectil de pelota de golf inválida! - De {1}"

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:130
#, csharp-format
msgid "LandGolfBallInCupHandler: Item selected is not a golf club! - From {0}"
msgstr "LandGolfBallInCupHandler: ¡El objeto seleccionado no es un palo de golf! - De {0}"

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:92
#, csharp-format
msgid "LandGolfBallInCupHandler: Packet rejected for ID spoofing. Expected {0}, received {1} from {2}."
msgstr "LandGolfBallInCupHandler: Paquete rechazado por falsificación de ID. Se esperaba {0}, se recibió {1} de {2}."

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:107
#, csharp-format
msgid "LandGolfBallInCupHandler: Tile at packet position X:{0} Y:{1} is not a golf hole! - From {2}"
msgstr "LandGolfBallInCupHandler: ¡La casilla en la posición del paquete X:{0} Y:{1} no tiene un hoyo de golf! - De {2}"

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:100
#, csharp-format
msgid "LandGolfBallInCupHandler: X and Y position is out of world bounds! - From {0}"
msgstr "LandGolfBallInCupHandler: ¡Las posiciones X e Y están fuera de los bordes del mundo! - De {0}"

#: ../../TShockAPI/Commands.cs:2493
msgid "Lanterns are now down."
msgstr "Los faroles ahora están deshabilitados."

#: ../../TShockAPI/Commands.cs:2489
msgid "Lanterns are now up."
msgstr "Los faroles ahora están habilitados."

#: ../../TShockAPI/Commands.cs:4423
msgid "Liquids are already settling."
msgstr "Los líquidos ya se están estabilizando."

#: ../../TShockAPI/Commands.cs:5191
msgid "list - Lists all regions."
msgstr "list - Da una lista de todas las regiones."

#: ../../TShockAPI/Commands.cs:3975
msgid "list [page] - Lists all item bans."
msgstr "list [página] - Da una lista de todos los ítems prohibidos."

#: ../../TShockAPI/Commands.cs:4153
msgid "list [page] - Lists all projectile bans."
msgstr "list [página] - Da una lista de todos los proyectiles prohibidos."

#: ../../TShockAPI/Commands.cs:4329
msgid "list [page] - Lists all tile bans."
msgstr "list [página] - Da una lista de todos los bloques prohibidos."

#: ../../TShockAPI/Commands.cs:3444
msgid "list [page] - Lists groups."
msgstr "list [página] - Muestra los grupos."

#: ../../TShockAPI/Commands.cs:5327
msgid "List Online Players Syntax"
msgstr "Sintaxis de List Online Players"

#: ../../TShockAPI/TShock.cs:828
#, csharp-format
msgid "Listening on IP {0}."
msgstr "Escuchando IP {0}."

#: ../../TShockAPI/TShock.cs:809
#, csharp-format
msgid "Listening on port {0}."
msgstr "Escuchando puerto {0}."

#: ../../TShockAPI/Commands.cs:3445
msgid "listperm <group> [page] - Lists a group's permissions."
msgstr "listperm <grupo> [página] - Muestra los permisos de un grupo."

#: ../../TShockAPI/Commands.cs:613
msgid "Lists commands or gives help on them."
msgstr "Muestra comandos o ayuda sobre los mismos."

#: ../../TShockAPI/Commands.cs:2110
msgid "listusers - Lists all REST users and their current active tokens."
msgstr "listusers - Muestra todos los usuarios REST y sus tókens activos."

#: ../../TShockAPI/TShock.cs:798
#, csharp-format
msgid "Loading dedicated config file: {0}"
msgstr "Cargando un archivo de configuración dedicado: {0}"

#: ../../TShockAPI/Commands.cs:3159
#, csharp-format
msgid "Location of {0} is ({1}, {2})."
msgstr "La ubicación de {0} es ({1}, {2})."

#: ../../TShockAPI/Commands.cs:1750
msgid "Log display disabled."
msgstr "Registro en pantalla desactivado."

#: ../../TShockAPI/Commands.cs:1746
msgid "Log display enabled."
msgstr "Registro en pantalla activado."

#: ../../TShockAPI/TShock.cs:785
#, csharp-format
msgid "Log path has been set to {0}"
msgstr "La ruta del registro se ha establecido en {0}"

#: ../../TShockAPI/Commands.cs:874
msgid "Login attempt failed - see the message above."
msgstr "Fallo en el intento de inicio de sesión - vea el mensaje anterior."

#: ../../TShockAPI/TShock.cs:980
msgid "Login before join enabled. Users may be prompted for an account specific password instead of a server password on connect."
msgstr "El inicio de sesión antes de entrar está activado. A los usuarios se les solicitará la contraseña de su cuenta en lugar de la contraseña del servidor cuando se conecten."

#: ../../TShockAPI/TShock.cs:985
msgid "Login using UUID enabled. Users automatically login via UUID."
msgstr "Inicio de sesión con UUID habilitado. Los usuarios iniciarán sesión automáticamente a través de su UUID."

#: ../../TShockAPI/Commands.cs:240
msgid "Logs you into an account."
msgstr "Inicias sesión en una cuenta."

#: ../../TShockAPI/Commands.cs:246
msgid "Logs you out of your current account."
msgstr "Cierras la sesión de tu cuenta actual."

#: ../../TShockAPI/Commands.cs:1227
#, csharp-format
msgid "Machine name: {0}"
msgstr "Nombre de la máquina: {0}"

#: ../../TShockPluginManager/NugetCLI.cs:141
msgid "Make sure that you trust the plugins you're installing."
msgstr "Asegúrate de estar instalando plugins en los que confías."

#: ../../TShockAPI/Bouncer.cs:2471
msgid "Malicious portal attempt."
msgstr "Intento malicioso de uso de portal."

#: ../../TShockPluginManager/NugetCLI.cs:35
msgid "Manage plugins and their requirements"
msgstr "Administra plugins y sus requerimientos"

#: ../../TShockAPI/Commands.cs:280
msgid "Manages groups."
msgstr "Gestiona grupos."

#: ../../TShockAPI/Commands.cs:284
msgid "Manages item bans."
msgstr "Gestiona los objetos prohibidos."

#: ../../TShockAPI/Commands.cs:268
msgid "Manages player bans."
msgstr "Gestiona los bans de jugadores."

#: ../../TShockAPI/Commands.cs:288
msgid "Manages projectile bans."
msgstr "Gestiona los proyectiles prohibidos."

#: ../../TShockAPI/Commands.cs:296
msgid "Manages regions."
msgstr "Gestiona regiones."

#: ../../TShockAPI/Commands.cs:570
msgid "Manages the REST API."
msgstr "Gestiona el API REST."

#: ../../TShockAPI/Commands.cs:376
msgid "Manages the server whitelist."
msgstr "Gestiona la lista blanca del servidor."

#: ../../TShockAPI/Commands.cs:292
msgid "Manages tile bans."
msgstr "Gestiona los bloques prohibidos."

#: ../../TShockAPI/Commands.cs:232
msgid "Manages user accounts."
msgstr "Gestiona las cuentas de usuario."

#: ../../TShockAPI/Bouncer.cs:1775
msgid "Manipulating unknown liquid type"
msgstr "Manipulando un tipo de líquido desconocido"

#: ../../TShockAPI/Commands.cs:4721
#, csharp-format
msgid "Marked region {0} as protected."
msgstr "Región {0} marcada como protegida."

#: ../../TShockAPI/Commands.cs:4728
#, csharp-format
msgid "Marked region {0} as unprotected."
msgstr "Región {0} marcada como desprotegida."

#: ../../TShockAPI/Commands.cs:1222
#, csharp-format
msgid "Memory usage: {0}"
msgstr "Uso de memoria: {0}"

#: ../../TShockAPI/SqlLog.cs:39
#, csharp-format
msgid "Message: {0}: {1}: {2}"
msgstr "Mensaje: {0}: {1}: {2}"

#: ../../TShockAPI/Rest/RestManager.cs:874
msgid "Meteor has been spawned"
msgstr "Se ha generado un meteoro"

#: ../../TShockAPI/Commands.cs:1334
msgid "Misbehaviour."
msgstr "Mal comportamiento."

#: ../../TShockAPI/Commands.cs:6214
msgid "Missing item name/id."
msgstr "Falta el nombre/ID del objeto."

#: ../../TShockAPI/Rest/RestManager.cs:1274
#, csharp-format
msgid "Missing or empty {0} parameter"
msgstr "Parámetro {0} faltante o vacío"

#: ../../TShockAPI/Rest/RestManager.cs:1284
#, csharp-format
msgid "Missing or invalid {0} parameter"
msgstr "Parámetro {0} faltante o inválido"

#: ../../TShockAPI/Commands.cs:6219
msgid "Missing player name."
msgstr "Falta el nombre del jugador."

#: ../../TShockAPI/Commands.cs:1237
#, csharp-format
msgid "Mode: {0}"
msgstr "Modo: {0}"

#: ../../TShockAPI/TSPlayer.cs:1966
msgid "More than one match found -- unable to decide which is correct: "
msgstr "Hay más de una coincidencia -- no se puede decidir la correcta: "

#: ../../TShockAPI/Commands.cs:2767
msgid "Mourning Wood"
msgstr "Árbol de Luto"

#: ../../TShockAPI/Net/BaseMsg.cs:29
msgid "Msg ID not implemented"
msgstr "ID de Msg no implementado"

#: ../../TShockAPI/DB/UserManager.cs:294
#, csharp-format
msgid "Multiple user accounts found for {0} '{1}'"
msgstr "Se encontraron múltiples cuentas para {0} '{1}'"

#: ../../TShockAPI/Commands.cs:5461
msgid "Mute Syntax"
msgstr "Sintaxis de Mute"

#: ../../TShockAPI/Commands.cs:1293
msgid "N/A"
msgstr "N/D"

#: ../../TShockAPI/Commands.cs:5189
msgid "name [-u][-z][-p] - Shows the name of the region at the given point."
msgstr "name [-u][-z][-p] - Muestra el nombre de la región en el punto determinado."

#: ../../TShockAPI/Commands.cs:1233
#, csharp-format
msgid "Name: {0}"
msgstr "Nombre: {0}"

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:55
#, csharp-format
msgid "NetModuleHandler received attempt to unlock sacrifice while not in journey mode from {0}"
msgstr "NetModuleHandler recibida petición de {0} para desbloquear sacrificio sin estar en modo viaje"

#: ../../TShockAPI/Commands.cs:1474
msgid "Never."
msgstr "Nunca."

#: ../../TShockAPI/Commands.cs:6176
msgid "New name is too large!"
msgstr "¡El nuevo nombre es demasiado largo!"

#: ../../TShockAPI/TShock.cs:864
#, csharp-format
msgid "New worlds will be generated with the {0} world evil type!"
msgstr "¡Los mundos nuevos serán generados con el bioma maligno {0}!"

#: ../../TShockAPI/Permissions.cs:547
msgid "No associated commands."
msgstr "No hay comandos asociados."

#: ../../TShockAPI/Commands.cs:1694
msgid "No bans found matching the provided ticket number."
msgstr "No se encontraron baneos que coincidan con el número de ticket."

#: ../../TShockAPI/Commands.cs:5784
#, csharp-format
msgid "No command or command alias matching \"{0}\" found."
msgstr "No se encontró ningún comando o alias que coincida con \"{0}\"."

#: ../../TShockAPI/Permissions.cs:530
msgid "No description available."
msgstr "No hay descripción disponible."

#: ../../TShockAPI/Commands.cs:145
msgid "No help available."
msgstr "No hay ayuda disponible."

#: ../../TShockAPI/Rest/RestManager.cs:721
msgid "No matching bans found."
msgstr "No se encontraron baneos que coincidan."

#: ../../TShockAPI/Commands.cs:1829
#, csharp-format
msgid "No player was found matching '{0}'."
msgstr "No se encontró ningún jugador que coincida con '{0}'."

#: ../../TShockAPI/Commands.cs:1786
#, csharp-format
msgid "No players matched \"{0}\"."
msgstr "Ningún jugador coincide con \"{0}\"."

#: ../../TShockAPI/Commands.cs:6123
#, csharp-format
msgid "No prefix matched \"{0}\"."
msgstr "Ningún prefijo coincide con \"{0}\"."

#: ../../TShockAPI/Commands.cs:5492
msgid "No reason specified."
msgstr "No se ha especificado ninguna razón."

#: ../../TShockAPI/Rest/RestManager.cs:1224
msgid "No special permissions are required for this route."
msgstr "No se requieren permisos especiales para esta ruta."

#: ../../TShockAPI/Commands.cs:3474
#: ../../TShockAPI/Commands.cs:3483
#: ../../TShockAPI/Commands.cs:3524
#: ../../TShockAPI/Commands.cs:3569
#: ../../TShockAPI/Commands.cs:3614
#, csharp-format
msgid "No such group \"{0}\"."
msgstr "No existe el grupo \"{0}\"."

#: ../../TShockAPI/DB/IQueryBuilder.cs:345
msgid "No values supplied"
msgstr "No se proporcionó ningún valor"

#: ../../TShockAPI/Rest/SecureRest.cs:194
msgid "Not authorized. The provided token became invalid due to group changes, please create a new token."
msgstr "No autorizado. El tóken proporcionado fue invalidado debido a cambios en los grupos, por favor cree un nuevo tóken."

#: ../../TShockAPI/Rest/SecureRest.cs:186
msgid "Not authorized. The specified API endpoint requires a token, but the provided token was not valid."
msgstr "No autorizado. El punto final API especificado requiere un tóken, pero el que fue proporcionado no era válido."

#: ../../TShockAPI/Rest/RestCommand.cs:95
#: ../../TShockAPI/Rest/RestCommand.cs:101
#: ../../TShockAPI/Rest/SecureRest.cs:180
msgid "Not authorized. The specified API endpoint requires a token."
msgstr "No autorizado. El punto final API especificado requiere un tóken."

#: ../../TShockAPI/Rest/SecureRest.cs:200
#, csharp-format
msgid "Not authorized. User \"{0}\" has no access to use the specified API endpoint."
msgstr "No autorizado. El usuario \"{0}\" no tiene acceso para utilizar el punto final API especificado."

#: ../../TShockAPI/Commands.cs:991
#, csharp-format
msgid "Not logged in or Invalid syntax. Proper syntax: {0}password <oldpassword> <newpassword>."
msgstr "No conectado o sintaxis inválida. Sintaxis correcta: {0}password <contraseñaVieja> <contraseñaNueva>."

#: ../../TShockAPI/DB/UserManager.cs:468
msgid "Not upgrading work factor because bcrypt hash in an invalid format."
msgstr "No se está actualizando el factor de trabajo porque el hash de bcrypt está en un formato inválido."

#: ../../TShockAPI/Bouncer.cs:1383
#: ../../TShockAPI/Bouncer.cs:1387
#, csharp-format
msgid "NPC damage exceeded {0}."
msgstr "Daño a NPC excedió {0}."

#: ../../TShockPluginManager/NugetCLI.cs:103
msgid "One moment..."
msgstr "Un momento..."

#: ../../TShockAPI/DB/RegionManager.cs:102
#, csharp-format
msgid "One of your UserIDs is not a usable integer: {0}"
msgstr "Uno de tus UserIDs no es un entero utilizable: {0}"

#: ../../TShockAPI/Commands.cs:5344
#, csharp-format
msgid "Online Players ({0}/{1})"
msgstr "Jugadores en Línea ({0}/{1})"

#: ../../TShockAPI/Commands.cs:1225
#, csharp-format
msgid "Operating system: {0}"
msgstr "Sistema operativo: {0}"

#: ../../TShockAPI/Commands.cs:308
msgid "Overrides serverside characters for a player, temporarily."
msgstr "Ignora temporalmente los personajes exclusivos de servidor para un jugador."

#: ../../TShockAPI/PaginationTools.cs:105
msgid "Page {{0}} of {{1}}"
msgstr "Página {{0}} de {{1}}"

#: ../../TShockAPI/Commands.cs:3446
msgid "parent <group> <parent group> - Changes a group's parent group."
msgstr "parent <grupo> <grupo padre> - Cambia el grupo padre de un grupo."

#: ../../TShockAPI/Commands.cs:3504
#, csharp-format
msgid "Parent of \"{0}\" is \"{1}\"."
msgstr "El padre de \"{0}\" es \"{1}\"."

#: ../../TShockAPI/Commands.cs:3492
#, csharp-format
msgid "Parent of group \"{0}\" set to \"{1}\"."
msgstr "Padre del grupo \"{0}\" asignado a \"{1}\"."

#: ../../TShockAPI/DB/GroupManager.cs:356
#, csharp-format
msgid "Parenting group {0} to {1} would cause loops in the parent chain."
msgstr "Hacer al grupo {0} padre de {1} causaría bucles en la cadena de parentesco."

#: ../../TShockAPI/Commands.cs:1163
#, csharp-format
msgid "Password change attempt for {0} failed for an unknown reason. Check the server console for more details."
msgstr "El intento de cambio de contraseña de {0} falló por una razón desconocida. Comprueba la consola del servidor para más detalles."

#: ../../TShockAPI/Commands.cs:1155
#, csharp-format
msgid "Password change succeeded for {0}."
msgstr "La contraseña de {0} se cambió correctamente."

#: ../../TShockAPI/DB/UserManager.cs:492
#: ../../TShockAPI/DB/UserManager.cs:513
#, csharp-format
msgid "Password must be at least {0} characters."
msgstr "La contraseña debe tener al menos {0} caracteres."

#: ../../TShockAPI/Commands.cs:980
#: ../../TShockAPI/Commands.cs:1017
#: ../../TShockAPI/Commands.cs:1031
#: ../../TShockAPI/Commands.cs:1097
#: ../../TShockAPI/Commands.cs:1168
#, csharp-format
msgid "Password must be greater than or equal to {0} characters."
msgstr "La contraseña debe contener {0} o más caracteres."

#: ../../TShockAPI/Commands.cs:997
#, csharp-format
msgid "PasswordUser returned an error: {0}."
msgstr "PasswordUser devolvió un error: {0}."

#: ../../TShockAPI/Commands.cs:1238
#, csharp-format
msgid "Path: {0}"
msgstr "Ruta: {0}"

#: ../../TShockAPI/Commands.cs:6622
msgid "Pearlwood Tree"
msgstr "Árbol de Madera Perlada"

#: ../../TShockAPI/Commands.cs:3774
#, csharp-format
msgid "Permissions for {0} ({{0}}/{{1}}):"
msgstr "Permisos para {0} ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:2680
msgid "Plantera"
msgstr "Plantera"

#: ../../TShockAPI/Commands.cs:1803
#, csharp-format
msgid "Player \"{0}\" has to perform a /login attempt first."
msgstr "El jugador \"{0}\" debe realizar antes un intento de /login."

#: ../../TShockAPI/Commands.cs:1808
#, csharp-format
msgid "Player \"{0}\" has to reconnect first, because they need to delete their trash."
msgstr "El jugador \"{0}\" debe reconectarse antes, pues necesita eliminar su papelera."

#: ../../TShockAPI/Commands.cs:1798
#, csharp-format
msgid "Player \"{0}\" is already logged in."
msgstr "El jugador \"{0}\" ya está conectado."

#: ../../TShockAPI/TSPlayer.cs:1883
#: ../../TShockAPI/TSPlayer.cs:1887
#, csharp-format
msgid "Player {0} has been disabled for {1}."
msgstr "El jugador {0} ha sido deshabilitado por {1}."

#: ../../TShockAPI/Rest/RestManager.cs:1394
#, csharp-format
msgid "Player {0} has been muted"
msgstr "El jugador {0} fue silenciado"

#: ../../TShockAPI/Rest/RestManager.cs:1399
#, csharp-format
msgid "Player {0} has been unmuted"
msgstr "Al jugador {0} se le revocó su silencio"

#: ../../TShockAPI/Rest/RestManager.cs:1307
#, csharp-format
msgid "Player {0} matches {1} player"
msgid_plural "Player {0} matches {1} players"
msgstr[0] "El jugador {0} coincide con {1} jugador"
msgstr[1] "El jugador {0} coincide con {1} jugadores"

#: ../../TShockAPI/Commands.cs:4792
#: ../../TShockAPI/Commands.cs:4827
#, csharp-format
msgid "Player {0} not found."
msgstr "No se encontró al jugador {0}."

#: ../../TShockAPI/Bouncer.cs:1140
#, csharp-format
msgid "Player {0} tried to sneak {1} onto the server!"
msgstr "¡El jugador {0} intentó ingresar {1} de contrabando al servidor!"

#: ../../TShockAPI/Rest/RestManager.cs:1069
#, csharp-format
msgid "Player {0} was killed"
msgstr "El jugador {0} fue asesinado"

#: ../../TShockAPI/Rest/RestManager.cs:1305
#, csharp-format
msgid "Player {0} was not found"
msgstr "No se encontró al jugador {0}"

#: ../../TShockAPI/Bouncer.cs:2604
#: ../../TShockAPI/Bouncer.cs:2611
#, csharp-format
msgid "Player damage exceeded {0}."
msgstr "El daño al jugador excedió {0}."

#: ../../TShockAPI/Commands.cs:6289
msgid "Player does not have free slots!"
msgstr "¡El jugador no tiene espacios vacíos!"

#: ../../TShockAPI/Bouncer.cs:1182
#, csharp-format
msgid "Player does not have permission to create projectile {0}."
msgstr "El jugador no tiene permiso para crear el proyectil {0}."

#: ../../TShockAPI/Commands.cs:1324
msgid "Player not found. Unable to kick the player."
msgstr "Jugador no encontrado. Imposible expulsar al jugador."

#: ../../TShockAPI/TShock.cs:1696
#, csharp-format
msgid "Please {0}register or {0}login to play!"
msgstr "¡Por favor usa {0}register o {0}login para jugar!"

#: ../../TShockAPI/Commands.cs:951
msgid "Please close NPC windows before logging out."
msgstr "Por favor cierre las ventanas de PNJ antes de cerrar sesión."

#: ../../TShockAPI/Commands.cs:5761
msgid "Please enter a proper command name or alias."
msgstr "Por favor ingresa un nombre o alias de comando válido."

#: ../../TShockAPI/Commands.cs:1063
msgid "Please try a different username."
msgstr "Por favor prueba con un nombre de usuario distinto."

#: ../../TShockAPI/Commands.cs:5415
#, csharp-format
msgid "Please use {0}login <username> <password> after this process."
msgstr "Por favor usa {0}login <nombreUsuario> <contraseña> después de esto."

#: ../../TShockAPI/Commands.cs:5412
msgid "Please use the following to create a permanent account for you."
msgstr "Por favor utiliza lo siguiente para crearte una cuenta permanente."

#: ../../TShockAPI/TShock.cs:895
#, csharp-format
msgid "Port overridden by startup argument. Set to {0}"
msgstr "Puerto sobreescrito por argumento de inicio. Establecido en {0}"

#: ../../TShockAPI/DB/ResearchDatastore.cs:53
#: ../../TShockAPI/DB/BanManager.cs:81
msgid "Possible problem with your database - is Sqlite3.dll present?"
msgstr "Posible problema con su base de datos - ¿Está el archivo Sqlite3.dll presente?"

#: ../../TShockAPI/Commands.cs:3447
msgid "prefix <group> <prefix> - Changes a group's prefix."
msgstr "prefix <grupo> <prefijo> - Cambia el prefijo de un grupo."

#: ../../TShockAPI/Commands.cs:3594
#, csharp-format
msgid "Prefix of \"{0}\" is \"{1}\"."
msgstr "El prefijo de \"{0}\" es \"{1}\"."

#: ../../TShockAPI/Commands.cs:3582
#, csharp-format
msgid "Prefix of group \"{0}\" set to \"{1}\"."
msgstr "Prefijo del grupo \"{0}\" establecido como \"{1}\"."

#: ../../TShockAPI/Commands.cs:304
msgid "Prevents a player from talking."
msgstr "Evita que un jugador hable."

#: ../../TShockAPI/Commands.cs:1226
#, csharp-format
msgid "Proc count: {0}"
msgstr "Cantidad de Proc: {0}"

#: ../../TShockAPI/Commands.cs:4065
#: ../../TShockAPI/Commands.cs:4123
#, csharp-format
msgid "Projectile {0} is not banned."
msgstr "El proyectil {0} no está prohibido."

#: ../../TShockAPI/Commands.cs:4159
msgid "Projectile Ban Sub-Commands ({{0}}/{{1}}):"
msgstr "Sub-Comandos de Projectile Ban ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:4177
msgid "Projectile bans ({{0}}/{{1}}):"
msgstr "Prohibiciones de Proyectil ({{0}}/{{1}}):"

#: ../../TShockAPI/Bouncer.cs:1286
#, csharp-format
msgid "Projectile create threshold exceeded {0}."
msgstr "El umbral de creación de proyectiles excedió {0}."

#: ../../TShockAPI/Bouncer.cs:1192
#, csharp-format
msgid "Projectile damage is higher than {0}."
msgstr "El daño del proyectil es mayor que {0}."

#: ../../TShockAPI/Commands.cs:5198
msgid "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."
msgstr "protect <nombre> <true/false> - Establece si las casillas en el interior de la región están o no protegidas."

#: ../../TShockAPI/RegionHandler.cs:159
msgid "Protected regions at this point: "
msgstr "Regiones protegidas en este punto: "

#: ../../TShockAPI/Commands.cs:4950
#, csharp-format
msgid "Protected: {0}."
msgstr "Protegido: {0}."

#: ../../TShockAPI/Commands.cs:1373
#, csharp-format
msgid "Quick usage: {0} {1} \"Griefing\""
msgstr "Uso abreviado: {0} {1} \"Molestar\""

#: ../../TShockAPI/TSPlayer.cs:758
#, csharp-format
msgid "Rangecheck failed for {0} ({1}, {2}) (rg: {3}/{5}, {4}/{5})"
msgstr "Rangecheck falló para {0} ({1}, {2}) (rg: {3}/{5}, {4}/{5})"

#: ../../TShockAPI/TShock.cs:1196
msgid "Reached HealOtherPlayer threshold"
msgstr "Se alcanzó el umbral de HealOtherPlayer"

#: ../../TShockAPI/Bouncer.cs:2110
msgid "Reached HealOtherPlayer threshold."
msgstr "Se alcanzó el umbral de HealOtherPlayer."

#: ../../TShockAPI/TShock.cs:1187
msgid "Reached paint threshold"
msgstr "Se alcanzó el umbral de pintura"

#: ../../TShockAPI/Bouncer.cs:1290
msgid "Reached projectile create threshold."
msgstr "Se alcanzó el umbral de creación de proyectiles."

#: ../../TShockAPI/TShock.cs:1178
msgid "Reached projectile threshold"
msgstr "Se alcanzó el umbral de proyectiles"

#: ../../TShockAPI/Bouncer.cs:922
#: ../../TShockAPI/TShock.cs:1108
msgid "Reached TileKill threshold."
msgstr "Se alcanzó el umbral de TileKill."

#: ../../TShockAPI/TShock.cs:1169
msgid "Reached TileLiquid threshold"
msgstr "Se alcanzó el umbral de TileLiquid"

#: ../../TShockAPI/Bouncer.cs:1686
#, csharp-format
msgid "Reached TileLiquid threshold {0}."
msgstr "Se alcanzó el umbral de líquidos {0}."

#: ../../TShockAPI/Bouncer.cs:1690
msgid "Reached TileLiquid threshold."
msgstr "Se alcanzó el umbral de líquidos."

#: ../../TShockAPI/TShock.cs:1125
msgid "Reached TilePlace threshold"
msgstr "Se alcanzó el umbral de bloques puestos"

#: ../../TShockAPI/Bouncer.cs:940
#: ../../TShockAPI/Bouncer.cs:2376
msgid "Reached TilePlace threshold."
msgstr "Se alcanzó el umbral de bloques puestos."

#: ../../TShockPluginManager/NugetCLI.cs:128
msgid "Read the message below to find out more."
msgstr "Lea el siguiente mensaje para obtener más información."

#: ../../TShockAPI/Commands.cs:1495
#, csharp-format
msgid "Reason: {0}."
msgstr "Razón: {0}."

#: ../../TShockAPI/Extensions/DbExt.cs:254
#, csharp-format
msgid "Received type '{0}', however column '{1}' expects type '{2}'"
msgstr "Recibido tipo '{0}', sin embargo la columna '{1}' esperaba tipo '{2}'"

#: ../../TShockAPI/Commands.cs:5135
#, csharp-format
msgid "Region \"{0}\" already exists."
msgstr "La región \"{0}\" ya existe."

#: ../../TShockAPI/Commands.cs:5167
#, csharp-format
msgid "Region \"{0}\" does not exist."
msgstr "La región \"{0}\" no existe."

#: ../../TShockAPI/Commands.cs:4701
#, csharp-format
msgid "Region {0} already exists."
msgstr "La región {0} ya existe."

#: ../../TShockAPI/Commands.cs:4980
msgid "Region is not shared with any groups."
msgstr "La región no es compartida con ningún grupo."

#: ../../TShockAPI/Commands.cs:4969
msgid "Region is not shared with any users."
msgstr "La región no es compartida con ningún usuario."

#: ../../TShockAPI/Commands.cs:4949
#, csharp-format
msgid "Region owner: {0}."
msgstr "Dueño de la región: {0}."

#: ../../TShockAPI/Commands.cs:4706
msgid "Region points need to be defined first. Use /region set 1 and /region set 2."
msgstr "Primero hay que definir los puntos de la región. Usa /region set 1 y /region set 2."

#: ../../TShockAPI/Commands.cs:5141
msgid "Region renamed successfully!"
msgstr "¡La región se ha renombrado correctamente!"

#: ../../TShockAPI/Commands.cs:5095
msgid "Region Resized Successfully!"
msgstr "¡La región se ha redimensionado correctamente!"

#: ../../TShockAPI/Commands.cs:5042
#, csharp-format
msgid "Region's z is now {0}"
msgstr "El índice z de la región ahora es {0}"

#: ../../TShockAPI/Commands.cs:4915
msgid "Regions ({{0}}/{{1}}):"
msgstr "Regiones ({{0}}/{{1}}):"

#: ../../TShockAPI/RegionHandler.cs:159
msgid "Regions at this point: "
msgstr "Regiones en este punto: "

#: ../../TShockAPI/Commands.cs:258
msgid "Registers you an account."
msgstr "Te registra una cuenta."

#: ../../TShockAPI/Commands.cs:1070
#, csharp-format
msgid "RegisterUser returned an error: {0}."
msgstr "RegisterUser devolvió un error: {0}."

#: ../../TShockAPI/Bouncer.cs:2161
msgid "Released critter was not from its item."
msgstr "La criatura liberada no correspondía a su objeto."

#: ../../TShockAPI/Commands.cs:364
msgid "Reloads the server configuration file."
msgstr "Recarga el archivo de configuración del servidor."

#: ../../TShockAPI/Commands.cs:5194
msgid "remove <user> <region> - Removes a user from a region."
msgstr "remove <usuario> <región> - Retira a un usuario de una región."

#: ../../TShockAPI/Commands.cs:2521
#, csharp-format
msgid "Removed {0} players from the angler quest completion list for today."
msgstr "Eliminados {0} jugadores del listado de misiones completadas hoy del pescador."

#: ../../TShockAPI/Commands.cs:4890
#, csharp-format
msgid "Removed group {0} from {1}"
msgstr "El grupo {0} fue removido de {1}"

#: ../../TShockAPI/Commands.cs:3494
#, csharp-format
msgid "Removed parent of group \"{0}\"."
msgstr "Se eliminó el padre del grupo \"{0}\"."

#: ../../TShockAPI/Commands.cs:3584
#, csharp-format
msgid "Removed prefix of group \"{0}\"."
msgstr "Se quitó el prefijo del grupo \"{0}\"."

#: ../../TShockAPI/Commands.cs:3539
#, csharp-format
msgid "Removed suffix of group \"{0}\"."
msgstr "Se quitó el sufijo del grupo \"{0}\"."

#: ../../TShockAPI/Commands.cs:4820
#, csharp-format
msgid "Removed user {0} from {1}."
msgstr "Se quitó el usuario {0} de {1}."

#: ../../TShockAPI/Commands.cs:5196
msgid "removeg <group> <region> - Removes a user group from a region."
msgstr "removeg <grupo> <región> - Quita a un grupo de usuarios de la región."

#: ../../TShockAPI/Commands.cs:300
msgid "Removes a player from the server."
msgstr "Elimina a un jugador del servidor."

#: ../../TShockAPI/DB/UserManager.cs:112
msgid "RemoveUser SQL returned an error"
msgstr "SQL RemoveUser devolvió un error"

#: ../../TShockAPI/Commands.cs:3441
msgid "rename <group> <new name> - Changes a group's name."
msgstr "rename <grupo> <nombre nuevo> - Cambia el nombre de un grupo."

#: ../../TShockAPI/Commands.cs:5190
msgid "rename <region> <new name> - Renames the given region."
msgstr "rename <región> <nombre nuevo> - Renombra la región dada."

#: ../../TShockAPI/Commands.cs:397
msgid "Renames an NPC."
msgstr "Renombra a un PNJ."

#: ../../TShockAPI/Commands.cs:566
msgid "Replies to a PM sent to you."
msgstr "Contestas al mensaje privado que te fue enviado."

#: ../../TShockAPI/Rest/SecureRest.cs:93
msgid "Requested token was successfully destroyed."
msgstr "El tóken solicitado fue destruido exitosamente."

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:35
#, csharp-format
msgid "RequestTileEntityInteractionHandler: Rejected packet due to lack of building permissions! - From {0} | Position X:{1} Y:{2}, TileEntity type: {3}, Tile type: {4}"
msgstr "RequestTileEntityInteractionHandler: ¡Paquete rechazado por falta de permisos de construcción! - De {0} | Posición X:{1} Y:{2}, Tipo de TileEntity: {3}, Tipo de bloque: {4}"

#: ../../TShockAPI/Commands.cs:419
msgid "Resets the list of users who have completed an angler quest that day."
msgstr "Reinicia la lista de usuarios que han completado durante el día una misión del pescador."

#: ../../TShockAPI/SaveManager.cs:163
#, csharp-format
msgid "resetTime {0}, direct {1}"
msgstr "resetTime {0}, direct {1}"

#: ../../TShockAPI/Commands.cs:5192
msgid "resize <region> <u/d/l/r> <amount> - Resizes a region."
msgstr "resize <región> <u/d/l/r> <cantidad> - Redimensiona una región."

#: ../../TShockAPI/Commands.cs:603
msgid "Respawn yourself or another player."
msgstr "Te hace reaparecer a ti u otro jugador."

#: ../../TShockAPI/UpdateManager.cs:87
msgid "Retrying in 5 minutes."
msgstr "Reintentando en 5 minutos."

#: ../../TShockAPI/Commands.cs:456
msgid "Returns the user's or specified user's current position."
msgstr "Muestra la posición actual ya sea del usuario o de otro jugador."

#: ../../TShockAPI/Commands.cs:6600
msgid "Rich Mahogany"
msgstr "Madera de Caoba Rico"

#: ../../TShockAPI/Commands.cs:5627
msgid "Rocket Syntax"
msgstr "Sintaxis de Rocket"

#: ../../TShockAPI/Commands.cs:342
msgid "Rockets a player upwards. Requires SSC."
msgstr "Propulsa a un jugador hacia arriba. Requiere SSC."

#: ../../TShockAPI/Commands.cs:6662
msgid "Ruby Gemtree"
msgstr "Arbolgema de Rubí"

#: ../../TShockAPI/Commands.cs:6604
msgid "Sakura Tree"
msgstr "Árbol Sakura"

#: ../../TShockAPI/Commands.cs:2783
msgid "Santa-NK1"
msgstr "Papá-NK1"

#: ../../TShockAPI/Commands.cs:6654
msgid "Sapphire Gemtree"
msgstr "Arbolgema de Zafiro"

#: ../../TShockAPI/Commands.cs:312
msgid "Saves all serverside characters."
msgstr "Guarda todos los personajes exclusivos-de-servidor."

#: ../../TShockAPI/Commands.cs:500
msgid "Saves the world file."
msgstr "Guarda el archivo del mundo."

#: ../../TShockAPI/SaveManager.cs:58
msgid "Saving world..."
msgstr "Guardando mundo..."

#: ../../TShockAPI/Commands.cs:1236
#, csharp-format
msgid "Seed: {0}"
msgstr "Semilla: {0}"

#: ../../TShockAPI/Commands.cs:562
msgid "Sends a message to everyone on your team."
msgstr "Envía un mensaje a todos los miembros de tu equipo."

#: ../../TShockAPI/Commands.cs:586
msgid "Sends a PM to a player."
msgstr "Envía un mensaje privado a un jugador."

#: ../../TShockAPI/Commands.cs:599
msgid "Sends all tiles from the server to the player to resync the client with the actual world state."
msgstr "Envía todas las casillas desde el servidor al jugador para sincronizar el cliente con el estado actual del mundo."

#: ../../TShockAPI/Commands.cs:557
msgid "Sends an action message to everyone."
msgstr "Envía a todos un mensaje de acción."

#: ../../TShockAPI/Commands.cs:431
msgid "Sends you to the world's spawn point."
msgstr "Te envía al punto de aparición del mundo."

#: ../../TShockAPI/Commands.cs:426
msgid "Sends you to your spawn point."
msgstr "Te envía a tu punto de aparición."

#: ../../TShockAPI/TShock.cs:738
msgid "Server console interrupted!"
msgstr "¡Se ha interrumpido la consola del servidor!"

#: ../../TShockAPI/Configuration/TShockConfig.cs:337
msgid "Server is full"
msgstr "Servidor lleno"

#: ../../TShockAPI/Configuration/TShockConfig.cs:341
msgid "Server is full. No reserved slots open."
msgstr "Servidor lleno y sin cupos reservados."

#: ../../TShockAPI/TShock.cs:1300
msgid "Server is shutting down..."
msgstr "El servidor se está cerrando..."

#: ../../TShockAPI/BackupManager.cs:73
msgid "Server map saving..."
msgstr "Guardando mapa del servidor..."

#: ../../TShockAPI/Commands.cs:4407
#, csharp-format
msgid "Server password has been changed to: {0}."
msgstr "La contraseña de servidor se cambió a: {0}."

#: ../../TShockAPI/Commands.cs:2040
#: ../../TShockAPI/Commands.cs:2046
msgid "Server shutting down: "
msgstr "El servidor se está cerrando: "

#: ../../TShockAPI/Commands.cs:2040
msgid "Server shutting down!"
msgstr "¡El servidor se está cerrando!"

#: ../../TShockAPI/Commands.cs:2046
msgid "Server shutting down."
msgstr "El servidor se está cerrando."

#: ../../TShockAPI/Commands.cs:959
msgid "Server side characters are enabled. You need to be logged-in to play."
msgstr "Los personajes exclusivos-de-servidor están activados. Debes estar autenticado para jugar."

#: ../../TShockAPI/TShock.cs:1691
#, csharp-format
msgid "Server side characters is enabled! Please {0}register or {0}login to play!"
msgstr "¡Los personajes exclusivos-de-servidor están activados! ¡Por favor usa {0}register o {0}login para jugar!"

#: ../../TShockAPI/Commands.cs:1813
#, csharp-format
msgid "Server-side character data from \"{0}\" has been replaced by their current local data."
msgstr "Los datos exclusivos-de-servidor de \"{0}\" fueron reemplazados por sus datos locales actuales."

#: ../../TShockAPI/Commands.cs:1773
msgid "Server-side characters is disabled."
msgstr "Personajes exclusivos-de-servidor desactivados."

#: ../../TShockAPI/Commands.cs:5185
msgid "set <1/2> - Sets the temporary region points."
msgstr "set <1/2> - Establece los puntos temporales de región."

#: ../../TShockAPI/Commands.cs:4697
#, csharp-format
msgid "Set region {0}."
msgstr "Se creó la región {0}."

#: ../../TShockAPI/RegionHandler.cs:187
#, csharp-format
msgid "Set temp point {0}."
msgstr "Se estableció el punto temporal {0}."

#: ../../TShockAPI/Commands.cs:510
msgid "Sets the dungeon's position to your location."
msgstr "Establece la posición de la mazmorra en tu ubicación."

#: ../../TShockAPI/Commands.cs:401
msgid "Sets the maximum number of NPCs."
msgstr "Establece el número máximo de PNJ."

#: ../../TShockAPI/Commands.cs:415
msgid "Sets the spawn rate of NPCs."
msgstr "Establece la tasa de aparición de PNJ."

#: ../../TShockAPI/Commands.cs:518
msgid "Sets the world time."
msgstr "Establece la hora del mundo."

#: ../../TShockAPI/Commands.cs:505
msgid "Sets the world's spawn point to your location."
msgstr "Establece la posición del punto de reaparición del mundo en tu ubicación."

#: ../../TShockAPI/Commands.cs:4427
msgid "Settling liquids."
msgstr "Estabilizando líquidos."

#: ../../TShockAPI/DB/UserManager.cs:182
msgid "SetUserGroup SQL returned an error"
msgstr "SQL SetUserGroup devolvió un error"

#: ../../TShockAPI/DB/UserManager.cs:134
msgid "SetUserPassword SQL returned an error"
msgstr "SQL SetUserPassword devolvió un error"

#: ../../TShockAPI/DB/UserManager.cs:154
msgid "SetUserUUID SQL returned an error"
msgstr "SQL SetUserUUID devolvió un error"

#: ../../TShockAPI/Commands.cs:6612
msgid "Shadewood Tree"
msgstr "Árbol Sombrío"

#: ../../TShockAPI/Commands.cs:5386
msgid "Share your server, talk with admins, and chill on GitHub & Discord. -- https://tshock.co/"
msgstr "Comparte tu servidor, habla con otros admins, y relájate en GitHub & Discord. https://tshock.co/"

#: ../../TShockAPI/Commands.cs:4975
msgid "Shared with groups: "
msgstr "Compartiendo con los grupos: "

#: ../../TShockAPI/Commands.cs:4964
msgid "Shared with: "
msgstr "Compartiendo con: "

#: ../../TShockAPI/Commands.cs:609
msgid "Shows a command's aliases."
msgstr "Muestra los alias de un comando."

#: ../../TShockAPI/Commands.cs:332
msgid "Shows information about a player."
msgstr "Muestra información sobre un jugador."

#: ../../TShockAPI/Commands.cs:262
msgid "Shows information about a user."
msgstr "Muestra información sobre un usuario."

#: ../../TShockAPI/Commands.cs:526
msgid "Shows information about the current world."
msgstr "Muestra información sobre el mundo actual."

#: ../../TShockAPI/Commands.cs:621
msgid "Shows the currently connected players."
msgstr "Muestra los jugadores conectados actualmente."

#: ../../TShockAPI/Commands.cs:617
msgid "Shows the message of the day."
msgstr "Muestra el mensaje del día."

#: ../../TShockAPI/Commands.cs:578
msgid "Shows the server information."
msgstr "Muestra la información del servidor."

#: ../../TShockAPI/Commands.cs:625
msgid "Shows the server's rules."
msgstr "Muestra las reglas del servidor."

#: ../../TShockAPI/Commands.cs:372
msgid "Shows the TShock version."
msgstr "Muestra la versión de TShock."

#: ../../TShockAPI/Commands.cs:356
msgid "Shuts down the server while saving."
msgstr "Apaga el servidor guardándolo."

#: ../../TShockAPI/Commands.cs:360
msgid "Shuts down the server without saving."
msgstr "Apaga el servidor sin guardarlo."

#: ../../TShockAPI/TShock.cs:735
msgid "Shutting down safely. To force shutdown, send SIGINT (CTRL + C) again."
msgstr "Apagando de forma segura. Para forzar el apagado, envíe SIGINT (CTRL + C) de nuevo."

#: ../../TShockAPI/Commands.cs:1234
#, csharp-format
msgid "Size: {0}x{1}"
msgstr "Tamaño: {0}x{1}"

#: ../../TShockAPI/Commands.cs:2699
msgid "Skeletron"
msgstr "Esqueletrón"

#: ../../TShockAPI/Commands.cs:2687
msgid "Skeletron Prime"
msgstr "Esqueletrón Mayor"

#: ../../TShockAPI/TSPlayer.cs:1069
#, csharp-format
msgid "Skipping SSC save (due to tshock.ignore.ssc) for {0}"
msgstr "Omitiendo guardado SSC (debido a tshock.ignore.ssc) para {0}"

#: ../../TShockAPI/Commands.cs:574
msgid "Slaps a player, dealing damage."
msgstr "Abofetea a un jugador, infligiéndole daño."

#: ../../TShockAPI/Commands.cs:2446
msgid "Slime rain cannot be activated during normal rain. Stop the normal rainstorm and try again."
msgstr "No se puede activar la lluvia de slime durante una lluvia normal. Detén el aguacero actual y vuelve a intentarlo."

#: ../../TShockAPI/Commands.cs:1062
#, csharp-format
msgid "Sorry, {0} was already taken by another person."
msgstr "Lamentablemente {0} ya fue reservado por otra persona."

#: ../../TShockAPI/Commands.cs:996
#: ../../TShockAPI/Commands.cs:1069
#, csharp-format
msgid "Sorry, an error occurred: {0}."
msgstr "Lo sentimos, ha ocurrido un error: {0}."

#: ../../TShockAPI/Commands.cs:4378
msgid "Spawn has now been set at your location."
msgstr "Punto de aparición establecido en tu posición."

#: ../../TShockAPI/Commands.cs:5230
msgid "Spawn is now open."
msgstr "El punto de aparición ahora está abierto."

#: ../../TShockAPI/Commands.cs:5230
msgid "Spawn is now protected."
msgstr "El punto de aparición ahora está protegido."

#: ../../TShockAPI/Commands.cs:2874
#, csharp-format
msgid "Spawned {0} {1} time."
msgid_plural "Spawned {0} {1} times."
msgstr[0] "Se invocó {0} {1} vez."
msgstr[1] "Se invocó {0} {1} veces."

#: ../../TShockAPI/Commands.cs:2891
msgid "Spawned a Wall of Flesh."
msgstr "Se invocó un Muro Carnoso."

#: ../../TShockAPI/Commands.cs:406
msgid "Spawns a number of bosses around you."
msgstr "Invoca una cantidad de jefes a tu alrededor."

#: ../../TShockAPI/Commands.cs:411
msgid "Spawns a number of mobs around you."
msgstr "Invoca una cantidad de enemigos a tu alrededor."

#: ../../TShockAPI/Commands.cs:346
msgid "Spawns fireworks at a player."
msgstr "Genera fuegos artificiales en un jugador."

#: ../../TShockAPI/Rest/Rest.cs:433
msgid "Specified API endpoint doesn't exist. Refer to the documentation for a list of valid endpoints."
msgstr "El punto final API especificado no existe. Consulte la documentación para ver una lista de puntos finales válidos."

#: ../../TShockAPI/SqlLog.cs:346
#, csharp-format
msgid "SQL log failed at: {0}. {1}"
msgstr "El registro SQL falló en: {0}. {1}"

#: ../../TShockAPI/SqlLog.cs:317
#, csharp-format
msgid "SQL Log insert query failed: {0}"
msgstr "Consulta de inserción de registro SQL fallida: {0}"

#: ../../TShockAPI/Commands.cs:5667
msgid "SSC must be enabled to use this command."
msgstr "Para usar este comando SSC debe estar activado."

#: ../../TShockAPI/TSPlayer.cs:434
#, csharp-format
msgid "Stack cheat detected. Remove armor {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quítate la armadura {0} ({1}) y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:577
#, csharp-format
msgid "Stack cheat detected. Remove Defender's Forge item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quita el objeto {0} ({1}) de la Forja del Defensor y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:454
#, csharp-format
msgid "Stack cheat detected. Remove dye {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quítate el tinte {0} ({1}) y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:414
#: ../../TShockAPI/TSPlayer.cs:474
#, csharp-format
msgid "Stack cheat detected. Remove item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quítate el objeto {0} ({1}) y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:494
#, csharp-format
msgid "Stack cheat detected. Remove item dye {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quítate el objeto de tinte {0} ({1}) y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:618
#: ../../TShockAPI/TSPlayer.cs:638
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 1 item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quítate el objeto {0} ({1}) del Equipamiento 1 y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:658
#: ../../TShockAPI/TSPlayer.cs:678
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 2 item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quítate el objeto {0} ({1}) del Equipamiento 2 y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:698
#: ../../TShockAPI/TSPlayer.cs:718
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 3 item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quítate el objeto {0} ({1}) del Equipamiento 3 y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:515
#, csharp-format
msgid "Stack cheat detected. Remove piggy-bank item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quita el objeto {0} ({1}) de la Hucha y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:536
#, csharp-format
msgid "Stack cheat detected. Remove safe item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quita el objeto {0} ({1}) de la Caja Fuerte y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:556
#, csharp-format
msgid "Stack cheat detected. Remove trash item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quita el objeto {0} ({1}) de tu papelera y luego vuelve a entrar."

#: ../../TShockAPI/TSPlayer.cs:598
#, csharp-format
msgid "Stack cheat detected. Remove Void Vault item {0} ({1}) and then rejoin."
msgstr "Trampa de stack detectada. Quita el objeto {0} ({1}) de tu Cámara del Vacío y luego vuelve a entrar."

#: ../../TShockAPI/Commands.cs:2279
msgid "Started a blood moon event."
msgstr "Iniciada una luna sangrienta."

#: ../../TShockAPI/Commands.cs:2264
msgid "Started a full moon event."
msgstr "Iniciada una luna llena."

#: ../../TShockAPI/Commands.cs:2306
msgid "Started an eclipse."
msgstr "Iniciado un eclipse."

#: ../../TShockAPI/TShock.cs:927
msgid "Startup parameter overrode maximum player slot configuration value."
msgstr "El parámetro de inicio impuso su propio valor máximo de jugadores sobre los de la configuración."

#: ../../TShockAPI/TShock.cs:909
msgid "Startup parameter overrode REST enable."
msgstr "El parámetro de inicio anuló la activación de REST."

#: ../../TShockAPI/TShock.cs:918
msgid "Startup parameter overrode REST port."
msgstr "El parámetro de inicio anuló el puerto REST."

#: ../../TShockAPI/TShock.cs:901
msgid "Startup parameter overrode REST token."
msgstr "El parámetro de inicio anuló el tóken REST."

#: ../../TShockAPI/Commands.cs:2310
msgid "Stopped an eclipse."
msgstr "Se detuvo un eclipse."

#: ../../TShockAPI/Commands.cs:2283
msgid "Stopped the current blood moon event."
msgstr "Se detuvo la luna sangrienta en curso."

#: ../../TShockAPI/Rest/SecureRest.cs:167
msgid "Successful login"
msgstr "Inicio de sesión exitoso"

#: ../../TShockAPI/Commands.cs:3448
msgid "suffix <group> <suffix> - Changes a group's suffix."
msgstr "suffix <grupo> <sufijo> - Cambia el sufijo de un grupo."

#: ../../TShockAPI/Commands.cs:3549
#, csharp-format
msgid "Suffix of \"{0}\" is \"{1}\"."
msgstr "El sufijo de \"{0}\" es \"{1}\"."

#: ../../TShockAPI/Commands.cs:3537
#, csharp-format
msgid "Suffix of group \"{0}\" set to \"{1}\"."
msgstr "Sufijo del grupo \"{0}\" establecido como \"{1}\"."

#: ../../TShockAPI/Commands.cs:5798
msgid "Sync'd!"
msgstr "¡Sincronizado!"

#: ../../TShockAPI/Handlers/SyncTilePickingHandler.cs:23
#, csharp-format
msgid "SyncTilePickingHandler: X and Y position is out of world bounds! - From {0}"
msgstr "SyncTilePickingHandler: ¡Las posiciones X e Y están fuera de los límites del mundo! - De {0}"

#: ../../TShockAPI/Commands.cs:3029
#, csharp-format
msgid "Teleported {0} to {1}."
msgstr "Se teletransportó a {0} hacia {1}."

#: ../../TShockAPI/Commands.cs:3094
#, csharp-format
msgid "Teleported {0} to yourself."
msgstr "Se teletransportó a {0} hacia tu posición."

#: ../../TShockAPI/Commands.cs:3008
#, csharp-format
msgid "Teleported everyone to {0}."
msgstr "Se teletransportó a todos hacia {0}."

#: ../../TShockAPI/Commands.cs:3081
msgid "Teleported everyone to yourself."
msgstr "Se teletransportó a todos a tu posición."

#: ../../TShockAPI/Commands.cs:3183
#, csharp-format
msgid "Teleported to {0}, {1}."
msgstr "Teletransportado a {0}, {1}."

#: ../../TShockAPI/Commands.cs:2954
#, csharp-format
msgid "Teleported to {0}."
msgstr "Teletransportado a {0}."

#: ../../TShockAPI/Commands.cs:3137
#, csharp-format
msgid "Teleported to the '{0}'."
msgstr "Teletransportado hacia '{0}'."

#: ../../TShockAPI/Commands.cs:2923
msgid "Teleported to the map's spawn point."
msgstr "Teletransportado al punto de aparición del mapa."

#: ../../TShockAPI/Commands.cs:2917
msgid "Teleported to your spawn point (home)."
msgstr "Teletransportado a tu punto de aparición (casa)."

#: ../../TShockAPI/Commands.cs:436
msgid "Teleports a player to another player."
msgstr "Teletransporta a un jugador a la posición de otro."

#: ../../TShockAPI/Commands.cs:441
msgid "Teleports a player to yourself."
msgstr "Teletransporta a un jugador hacia tu posición."

#: ../../TShockAPI/Commands.cs:582
msgid "Teleports you to a warp point or manages warps."
msgstr "Te teletransporta a un punto de warp o permite administrarlos."

#: ../../TShockAPI/Commands.cs:446
msgid "Teleports you to an npc."
msgstr "Te teletransporta a un PNJ."

#: ../../TShockAPI/Commands.cs:451
msgid "Teleports you to tile coordinates."
msgstr "Te teletransporta a coordenadas de casilla."

#: ../../TShockAPI/Commands.cs:324
msgid "Temporarily elevates you to Super Admin."
msgstr "Te asciende temporalmente a Super Admin."

#: ../../TShockAPI/Commands.cs:320
msgid "Temporarily sets another player's group."
msgstr "Establece de forma temporal el grupo de otro usuario."

#: ../../TShockAPI/Commands.cs:4759
msgid "Temporary region set points have been removed."
msgstr "Los puntos temporales para demarcar región fueron quitados."

#: ../../TShockAPI/Commands.cs:5411
msgid "Temporary system access has been given to you, so you can run one command."
msgstr "Se te ha dado acceso temporal de sistema, así que puedes ejecutar un comando."

#: ../../TShockAPI/Commands.cs:5387
msgid "Thank you for using TShock for Terraria!"
msgstr "¡Gracias por usar TShock para Terraria!"

#: ../../TShockAPI/Commands.cs:1190
msgid "That group does not exist."
msgstr "No existe ese grupo."

#: ../../TShockAPI/DB/BanManager.cs:258
msgid "The ban is invalid because a current ban for this identifier already exists."
msgstr "El baneo es inválido porque ya existe un ban actual para este identificador."

#: ../../TShockAPI/DB/BanManager.cs:295
msgid "The ban was not valid for an unknown reason."
msgstr "El ban no es válido por razón desconocida."

#: ../../TShockAPI/Commands.cs:2634
msgid "the Brain of Cthulhu"
msgstr "el Cerebro de Cthulhu"

#: ../../TShockAPI/Commands.cs:4522
#, csharp-format
msgid "The current time is {0}:{1:D2}."
msgstr "La hora actual es {0}:{1:D2}."

#: ../../TShockAPI/DB/GroupManager.cs:218
msgid "The default usergroup could not be found."
msgstr "No se pudo encontrar el grupo predeterminado."

#: ../../TShockAPI/DB/GroupManager.cs:217
msgid "The default usergroup could not be found. This may indicate a typo in the configuration file, or that the group was renamed or deleted."
msgstr "No se pudo encontrar el grupo de usuarios predeterminado. Esto puede indicar un error tipográfico en el archivo de configuración, o que el grupo fue renombrado o eliminado."

#: ../../TShockAPI/Commands.cs:3174
msgid "The destination coordinates provided don't look like valid numbers."
msgstr "Las coordenadas de destino proporcionadas no parecen ser números válidos."

#: ../../TShockAPI/Commands.cs:3334
#: ../../TShockAPI/Commands.cs:3349
#, csharp-format
msgid "The destination warp, {0}, was not found."
msgstr "No se encontró el warp de destino, {0}."

#: ../../TShockAPI/Commands.cs:2641
msgid "the Destroyer"
msgstr "el Destructor"

#: ../../TShockAPI/GetDataHandlers.cs:3427
msgid "The Dungeon Guardian returned you to your spawn point."
msgstr "El Guardián de la Mazmorra te devolvió a tu punto de aparición."

#: ../../TShockAPI/Commands.cs:4386
msgid "The dungeon's position has now been set at your location."
msgstr "La posición de la mazmorra se ha establecido en tu ubicación."

#: ../../TShockAPI/Commands.cs:2655
msgid "the Eater of Worlds"
msgstr "el Devoramundos"

#: ../../TShockAPI/Commands.cs:2736
msgid "the Empress of Light"
msgstr "la Emperatriz de la Luz"

#: ../../TShockAPI/Commands.cs:2663
msgid "the Eye of Cthulhu"
msgstr "el Ojo de Cthulhu"

#: ../../TShockAPI/Commands.cs:2762
msgid "the Flying Dutchman"
msgstr "el Holandés Volador"

#: ../../TShockAPI/Commands.cs:2668
msgid "the Golem"
msgstr "el Gólem"

#: ../../TShockAPI/DB/GroupManager.cs:595
#, csharp-format
msgid "The group {0} appeared more than once. Keeping current group settings."
msgstr "El grupo {0} apareció más de una vez. Manteniendo la configuración actual de los grupos."

#: ../../TShockAPI/DB/GroupManager.cs:212
msgid "The guest group could not be found."
msgstr "No se pudo encontrar el grupo huésped."

#: ../../TShockAPI/DB/GroupManager.cs:211
msgid "The guest group could not be found. This may indicate a typo in the configuration file, or that the group was renamed or deleted."
msgstr "No se pudo encontrar el grupo huésped. Esto puede indicar un error tipográfico en el archivo de configuración, o que el grupo fue renombrado o eliminado."

#: ../../TShockAPI/Commands.cs:2788
msgid "the Ice Queen"
msgstr "la Reina del Hielo"

#: ../../TShockAPI/Commands.cs:5376
msgid "The initial setup system is disabled. This incident has been logged."
msgstr "El sistema de configuración inicial está deshabilitado. Este incidente ha sido registrado."

#: ../../TShockAPI/Commands.cs:6097
#, csharp-format
msgid "The item type {0} is invalid."
msgstr "El tipo de objeto {0} no es válido."

#: ../../TShockAPI/Commands.cs:2675
msgid "the King Slime"
msgstr "el Rey Slime"

#: ../../TShockAPI/Commands.cs:2750
msgid "the Lunatic Cultist"
msgstr "el Sectario Lunático"

#: ../../TShockAPI/PaginationTools.cs:185
msgid "The method referenced by LineFormatter has thrown an exception. See inner exception for details."
msgstr "El método al que hace referencia LineFormatter arrojó una excepción. Revise la excepción interna para más detalles."

#: ../../TShockAPI/PaginationTools.cs:247
msgid "The method represented by termFormatter has thrown an exception. See inner exception for details."
msgstr "El método al que representa termFormatter arrojó una excepción. Revise la excepción interna para más detalles."

#: ../../TShockAPI/Commands.cs:2729
msgid "the Moon Lord"
msgstr "el Señor de la Luna"

#: ../../TShockAPI/Commands.cs:3410
msgid "The permissions have been added to all of the groups in the system."
msgstr "Los permisos se agregaron a todos los grupos en el sistema."

#: ../../TShockAPI/Commands.cs:3715
msgid "The permissions have been removed from all of the groups in the system."
msgstr "Los permisos se quitaron de todos los grupos en el sistema."

#: ../../TShockAPI/Commands.cs:1860
msgid "The player's character data was successfully uploaded from their initial connection."
msgstr "Los datos de personaje del jugador fueron subidos exitosamente desde su conexión inicial."

#: ../../TShockAPI/Commands.cs:2772
msgid "the Pumpking"
msgstr "el Rey Calabaza"

#: ../../TShockAPI/Commands.cs:2693
msgid "the Queen Bee"
msgstr "la Abeja Reina"

#: ../../TShockAPI/Commands.cs:2742
msgid "the Queen Slime"
msgstr "la Reina Slime"

#: ../../TShockAPI/Rest/RestManager.cs:158
msgid "The REST authentication token."
msgstr "El tóken de autenticación REST."

#: ../../TShockAPI/UpdateManager.cs:150
msgid "The server is out of date. Latest version: "
msgstr "Servidor desactualizado. Última versión: "

#: ../../TShockAPI/Commands.cs:4495
msgid "The spawn rate you provided is out-of-range or not a number."
msgstr "La tasa de generación provista esta fuera del rango o no es un número."

#: ../../TShockAPI/Rest/SecureRest.cs:90
msgid "The specified token queued for destruction failed to be deleted."
msgstr "El tóken especificado marcado para ser destruido no pudo ser eliminado."

#: ../../TShockAPI/Commands.cs:1869
msgid "The target player has not logged in yet."
msgstr "El jugador objetivo aún no ha iniciado sesión."

#: ../../TShockAPI/Commands.cs:1849
msgid "The targeted user cannot have their data uploaded, because they are not a player."
msgstr "El usuario objetivo no puede subir sus datos, pues no es un jugador."

#: ../../TShockAPI/Commands.cs:2707
msgid "the Twins"
msgstr "los Gemelos"

#: ../../TShockAPI/Commands.cs:1136
#, csharp-format
msgid "The user {0} does not exist! Therefore, the account was not deleted."
msgstr "¡El usuario {0} no existe! Por ende, no se eliminó la cuenta."

#: ../../TShockAPI/PaginationTools.cs:95
msgid "The value has to be greater than or equal to zero."
msgstr "El valor debe ser mayor o igual a cero."

#: ../../TShockAPI/PaginationTools.cs:81
msgid "The value has to be greater than zero."
msgstr "El valor debe ser mayor que cero."

#: ../../TShockPluginManager/NugetCLI.cs:127
msgid "The versions of plugins you requested aren't compatible with eachother."
msgstr "Las versiones de plugins que has solicitado no son compatibles entre ellas."

#: ../../TShockAPI/Commands.cs:2722
msgid "the Wall of Flesh"
msgstr "el Muro Carnoso"

#: ../../TShockAPI/Bouncer.cs:805
msgid "The world's chest limit has been reached - unable to place more."
msgstr "El límite de cofres del mundo fue alcanzado - imposible colocar más."

#: ../../TShockAPI/Commands.cs:1672
msgid "There are currently no active bans."
msgstr "No hay bans activos en este momento."

#: ../../TShockAPI/Commands.cs:2093
msgid "There are currently no active REST users."
msgstr "No hay usuarios REST activos en este momento."

#: ../../TShockAPI/Commands.cs:1434
msgid "There are currently no available identifiers."
msgstr "No hay identificadores disponibles en este momento."

#: ../../TShockAPI/Commands.cs:4001
msgid "There are currently no banned items."
msgstr "No hay objetos prohibidos en este momento."

#: ../../TShockAPI/Commands.cs:4179
msgid "There are currently no banned projectiles."
msgstr "No hay proyectiles prohibidos en este momento."

#: ../../TShockAPI/Commands.cs:4355
msgid "There are currently no banned tiles."
msgstr "No hay bloques prohibidos en este momento."

#: ../../TShockAPI/Commands.cs:3776
#, csharp-format
msgid "There are currently no permissions for {0}."
msgstr "Ahora mismo {0} no posee permisos."

#: ../../TShockAPI/Commands.cs:5341
msgid "There are currently no players online."
msgstr "Actualmente no hay jugadores en línea."

#: ../../TShockAPI/Commands.cs:4917
msgid "There are currently no regions defined."
msgstr "Actualmente no hay regiones definidas."

#: ../../TShockAPI/Commands.cs:3230
msgid "There are currently no warps defined."
msgstr "Actualmente no hay warps definidos."

#: ../../TShockAPI/RegionHandler.cs:155
msgid "There are no regions at this point, or they are not protected."
msgstr "Este punto o no tiene regiones, o no están protegidas."

#: ../../TShockAPI/RegionHandler.cs:154
msgid "There are no regions at this point."
msgstr "No hay regiones en este punto."

#: ../../TShockAPI/Commands.cs:2713
msgid "There is already a Wall of Flesh."
msgstr "Ya hay un Muro Carnoso."

#: ../../TShockAPI/Commands.cs:936
msgid "There was an error processing your login or authentication related request."
msgstr "Hubo un error al procesar tu petición de inicio de sesión o relacionada con autenticación."

#: ../../TShockPluginManager/NugetCLI.cs:121
msgid "There was an issue figuring out what to download."
msgstr "Hubo un problema al determinar qué descargar."

#: ../../TShockPluginManager/NugetCLI.cs:90
msgid "There was an issue reading the packages.json."
msgstr "Hubo un problema leyendo el archivo packages.json."

#: ../../TShockPluginManager/NugetCLI.cs:99
#, csharp-format
msgid "This is the plugin you requested to install."
msgid_plural "These are the plugins you requested to install"
msgstr[0] "Este es el plugin que solicitaste instalar."
msgstr[1] "Estos son los plugins que solicitaste instalar."

#: ../../TShockAPI/TShock.cs:1013
#: ../../TShockAPI/TShock.cs:1023
#, csharp-format
msgid "This token will display until disabled by verification. ({0}setup)"
msgstr "Este tóken se mostrará hasta que se deshabilite por verificación. ({0}setup)"

#: ../../TShockAPI/Commands.cs:4241
#: ../../TShockAPI/Commands.cs:4299
#, csharp-format
msgid "Tile {0} is not banned."
msgstr "El bloque {0} no está prohibido."

#: ../../TShockAPI/Commands.cs:4335
msgid "Tile Ban Sub-Commands ({{0}}/{{1}}):"
msgstr "Sub-Comandos de Tile Ban ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:4353
msgid "Tile bans ({{0}}/{{1}}):"
msgstr "Objetos prohibidos ({{0}}/{{1}}):"

#: ../../TShockAPI/Bouncer.cs:918
#, csharp-format
msgid "Tile kill threshold exceeded {0}."
msgstr "El umbral de destrucción de bloques ha excedido {0}."

#: ../../TShockAPI/Bouncer.cs:936
#, csharp-format
msgid "Tile place threshold exceeded {0}."
msgstr "El umbral de colocación de bloques ha excedido {0}."

#: ../../TShockAPI/Commands.cs:6420
#, csharp-format
msgid "To buff a player without them knowing, use {0} instead of {1}"
msgstr "Para potenciar a un jugador sin que lo sepan, usa {0} en lugar de {1}"

#: ../../TShockAPI/Commands.cs:6015
#: ../../TShockAPI/Commands.cs:6311
#, csharp-format
msgid "To execute this command silently, use {0} instead of {1}"
msgstr "Para ejecutar este comando silenciosamente, usa {0} en lugar de {1}"

#: ../../TShockAPI/Commands.cs:6014
#, csharp-format
msgid "To get rid of NPCs without making them drop items, use the {0} command instead."
msgstr "Para deshacerte de los PNJ sin hacerlos soltar objetos, usa el comando {0} en su lugar."

#: ../../TShockAPI/Commands.cs:5464
#, csharp-format
msgid "To mute a player without broadcasting to chat, use the command with {0} instead of {1}"
msgstr "Para silenciar a un jugador sin mostrarlo en el chat, usa el comando con {0} en lugar de {1}"

#: ../../TShockAPI/TShock.cs:1012
#: ../../TShockAPI/TShock.cs:1022
#, csharp-format
msgid "To setup the server, join the game and type {0}setup {1}"
msgstr "Para configurar el servidor, únete al juego y escribe {0}setup {1}"

#: ../../TShockAPI/Commands.cs:471
msgid "Toggles build protection."
msgstr "Activa o desactiva la protección de construcción."

#: ../../TShockAPI/Commands.cs:484
msgid "Toggles christmas mode (present spawning, santa, etc)."
msgstr "Activa o desactiva el modo navideño (generación de regalos, santa, etc)."

#: ../../TShockAPI/Commands.cs:545
msgid "Toggles godmode on a player."
msgstr "Activa o desactiva el modo dios en un jugador."

#: ../../TShockAPI/Commands.cs:480
msgid "Toggles halloween mode (goodie bags, pumpkins, etc)."
msgstr "Activa o desactiva el modo halloween (bolsitas sorpresa, calabazas, etc)."

#: ../../TShockAPI/Commands.cs:496
msgid "Toggles spawn protection."
msgstr "Activa o desactiva la protección del área de aparición."

#: ../../TShockAPI/Commands.cs:492
msgid "Toggles the world's hardmode status."
msgstr "Activa o desactiva el modo difícil del mundo."

#: ../../TShockAPI/Commands.cs:591
msgid "Toggles to either ignore or recieve whispers from other players."
msgstr "Cambia entre ignorar o recibir susurros de otros jugadores."

#: ../../TShockAPI/Commands.cs:461
msgid "Toggles whether other people can teleport you."
msgstr "Alterna entre si otras personas pueden o no teletransportarse a tu posición."

#: ../../TShockAPI/Commands.cs:276
msgid "Toggles whether you receive server logs."
msgstr "Alterna si recibes o no los registros del servidor."

#: ../../TShockAPI/Commands.cs:777
msgid "Too many invalid login attempts."
msgstr "Demasiados intentos de inicio de sesión inválidos."

#: ../../TShockAPI/Commands.cs:6646
msgid "Topaz Gemtree"
msgstr "Arbolgema de Topacio"

#: ../../TShockAPI/Commands.cs:1224
#, csharp-format
msgid "Total processor time: {0}"
msgstr "Tiempo total de procesador: {0}"

#: ../../TShockAPI/Commands.cs:5202
msgid "tp <region> - Teleports you to the given region's center."
msgstr "tp <región> - Te teletransporta al centro de la región determinada."

#: ../../TShockAPI/Commands.cs:6511
msgid "Trees types & misc available to use. ({{0}}/{{1}}):"
msgstr "Tipos de árboles & misc disponibles para su uso. ({{0}}/{{1}}):"

#: ../../TShockAPI/Commands.cs:6700
#, csharp-format
msgid "Tried to grow a {0}."
msgstr "Se intentó hacer crecer {0}."

#: ../../TShockAPI/TShock.cs:399
#, csharp-format
msgid "TShock {0} ({1}) now running."
msgstr "TShock {0} ({1}) ahora en ejecución."

#: ../../TShockAPI/Commands.cs:1367
msgid "TShock Ban Help"
msgstr "Ayuda de TShock Ban"

#: ../../TShockAPI/TShock.cs:449
msgid "TShock comes with no warranty & is free software."
msgstr "TShock es gratuito y viene sin garantía."

#: ../../TShockAPI/TShock.cs:461
msgid "TShock encountered a problem from which it cannot recover. The following message may help diagnose the problem."
msgstr "TShock encontró un problema del que no puede recuperarse. El siguiente mensaje puede ayudar a diagnosticar el problema."

#: ../../TShockAPI/TShock.cs:1021
msgid "TShock Notice: setup-code.txt is still present, and the code located in that file will be used."
msgstr "Aviso de TShock: setup-code.txt todavía está presente, y el código ubicado en ese archivo será utilizado."

#: ../../TShockAPI/TShock.cs:353
msgid "TShock was improperly shut down. Please use the exit command in the future to prevent this."
msgstr "TShock se cerró incorrectamente. Utilice el comando exit en el futuro para evitar esto."

#: ../../TShockAPI/TShock.cs:997
msgid "TShock will now disable the initial setup system and remove setup-code.txt as it is no longer needed."
msgstr "TShock desactivará ahora el sistema de configuración inicial y eliminará setup-code.txt pues ya no es necesario."

#: ../../TShockAPI/Commands.cs:5299
#, csharp-format
msgid "TShock: {0} {1}."
msgstr "TShock: {0} {1}."

#: ../../TShockAPI/Commands.cs:1433
#, csharp-format
msgid "Type {0}ban help identifiers {{0}} for more."
msgstr "Escribe {0}ban help identifiers {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:1671
#, csharp-format
msgid "Type {0}ban list {{0}} for more."
msgstr "Escribe {0}ban list {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:3455
#, csharp-format
msgid "Type {0}group help {{0}} for more sub-commands."
msgstr "Escribe {0}group help {{0}} para más sub-comandos."

#: ../../TShockAPI/Commands.cs:3746
#, csharp-format
msgid "Type {0}group list {{0}} for more."
msgstr "Escribe {0}group list {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:3775
#, csharp-format
msgid "Type {0}group listperm {1} {{0}} for more."
msgstr "Escribe {0}group listperm {1} {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:6512
#, csharp-format
msgid "Type {0}grow help {{0}} for more sub-commands."
msgstr "Escribe {0}grow help {{0}} para más sub-comandos."

#: ../../TShockAPI/Commands.cs:5261
#, csharp-format
msgid "Type {0}help {{0}} for more."
msgstr "Escribe {0}help {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:3982
#, csharp-format
msgid "Type {0}itemban help {{0}} for more sub-commands."
msgstr "Escribe {0}itemban help {{0}} para más sub-comandos."

#: ../../TShockAPI/Commands.cs:4000
#, csharp-format
msgid "Type {0}itemban list {{0}} for more."
msgstr "Escribe {0}itemban list {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:1053
#, csharp-format
msgid "Type {0}login \"{1}\" {2} to log-in to your account."
msgstr "Escribe {0}login \"{1}\" {2} para iniciar sesión en tu cuenta."

#: ../../TShockAPI/Commands.cs:1055
#, csharp-format
msgid "Type {0}login {1} to log-in to your account."
msgstr "Escribe {0}login {1} para iniciar sesión en tu cuenta."

#: ../../TShockAPI/Commands.cs:1050
#, csharp-format
msgid "Type {0}login to log-in to your account using your UUID."
msgstr "Escribe {0}login para iniciar sesión usando tu UUID."

#: ../../TShockAPI/Commands.cs:4160
#, csharp-format
msgid "Type {0}projban help {{0}} for more sub-commands."
msgstr "Escribe {0}projban help {{0}} para más sub-comandos."

#: ../../TShockAPI/Commands.cs:4178
#, csharp-format
msgid "Type {0}projban list {{0}} for more."
msgstr "Escribe {0}projban list {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:5209
#, csharp-format
msgid "Type {0}region {{0}} for more sub-commands."
msgstr "Escribe {0}region {{0}} para más sub-comandos."

#: ../../TShockAPI/Commands.cs:4987
#, csharp-format
msgid "Type {0}region info {1} {{0}} for more information."
msgstr "Escribe {0}region info {1} {{0}} para más información."

#: ../../TShockAPI/Commands.cs:4916
#, csharp-format
msgid "Type {0}region list {{0}} for more."
msgstr "Escribe {0}region list {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:2095
#, csharp-format
msgid "Type {0}rest listusers {{0}} for more."
msgstr "Escribe {0}rest listusers {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:4336
#, csharp-format
msgid "Type {0}tileban help {{0}} for more sub-commands."
msgstr "Escribe {0}tileban help {{0}} para más sub-comandos."

#: ../../TShockAPI/Commands.cs:4354
#, csharp-format
msgid "Type {0}tileban list {{0}} for more."
msgstr "Escribe {0}tileban list {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:3229
#, csharp-format
msgid "Type {0}warp list {{0}} for more."
msgstr "Escribe {0}warp list {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:5367
#, csharp-format
msgid "Type {0}who {1} for more."
msgstr "Escribe {0}who {1} para ver más."

#: ../../TShockAPI/PaginationTools.cs:108
msgid "Type /<command> {{0}} for more."
msgstr "Escribe /<comando> {{0}} para ver más."

#: ../../TShockAPI/Commands.cs:6444
#, csharp-format
msgid "Unable to find any buff named \"{0}\""
msgstr "No se encontró ningún buff de nombre \"{0}\""

#: ../../TShockAPI/Commands.cs:6385
#, csharp-format
msgid "Unable to find any buffs named \"{0}\""
msgstr "No se encontraron buffs de nombre \"{0}\""

#: ../../TShockAPI/Commands.cs:6429
#, csharp-format
msgid "Unable to find any player named \"{0}\""
msgstr "No se encontró ningún jugador de nombre \"{0}\""

#: ../../TShockAPI/Commands.cs:6323
#, csharp-format
msgid "Unable to find any players named \"{0}\""
msgstr "No se encontraron jugadores de nombre \"{0}\""

#: ../../TShockAPI/Commands.cs:5670
#, csharp-format
msgid "Unable to launch {0} because he is not logged in."
msgstr "No se puede hacer despegar a {0} porque no está conectado."

#: ../../TShockAPI/Commands.cs:5672
#, csharp-format
msgid "Unable to launch {0} because she is not logged in."
msgstr "No se puede hacer despegar a {0} porque no está conectada."

#: ../../TShockAPI/TShock.cs:1484
msgid "Unable to parse command '{0}' from player {1}."
msgstr "No se puede analizar el comando '{0}' del jugador {1}."

#: ../../TShockAPI/TShock.cs:1483
msgid "Unable to parse command. Please contact an administrator for assistance."
msgstr "No se puede analizar el comando. Por favor contacte a un administrador para obtener ayuda."

#: ../../TShockAPI/Commands.cs:2885
msgid "Unable to spawn a Wall of Flesh based on its current state or your current location."
msgstr "No se puede generar un Muro Carnoso basado en su estado o tu ubicación actual."

#: ../../TShockAPI/DB/UserManager.cs:450
#, csharp-format
msgid "Unable to verify the password hash for user {0} ({1})"
msgstr "No se puede verificar el hash de contraseña para el usuario {0} ({1})"

#: ../../TShockAPI/Commands.cs:3912
#, csharp-format
msgid "Unbanned {0}."
msgstr "Se revocó la prohibición de {0}."

#: ../../TShockAPI/Commands.cs:4094
#, csharp-format
msgid "Unbanned projectile {0}."
msgstr "Se revocó la prohibición del proyectil {0}."

#: ../../TShockAPI/Commands.cs:4270
#, csharp-format
msgid "Unbanned tile {0}."
msgstr "Se revocó la prohibición del bloque {0}."

#: ../../TShockAPI/Commands.cs:1455
#, csharp-format
msgid "Unknown ban command. Try {0} {1}, {2}, {3}, {4}, {5}, or {6}."
msgstr "Comando de ban desconocido. Prueba {0} {1}, {2}, {3}, {4}, {5}, o {6}."

#: ../../TShockAPI/Commands.cs:6694
msgid "Unknown plant!"
msgstr "¡Planta desconocida!"

#: ../../TShockAPI/Bouncer.cs:246
msgid "Unrecognized player direction"
msgstr "Dirección del jugador no reconocida"

#: ../../TShockAPI/TShock.cs:462
msgid "Until the problem is resolved, TShock will not be able to start (and will crash on startup)."
msgstr "Hasta que no se resuelva el problema, TShock no podrá iniciarse (y crasheará al cargar)."

#: ../../TShockAPI/UpdateManager.cs:120
#, csharp-format
msgid "Update server did not respond with an OK. Server message: [error {0}] {1}"
msgstr "El servidor de actualización no respondió con un OK. Mensaje del servidor: [error {0}] {1}"

#: ../../TShockAPI/DB/UserManager.cs:197
msgid "UpdateLogin SQL returned an error"
msgstr "SQL UpdateLogin devolvió un error"

#: ../../TShockAPI/UpdateManager.cs:83
#: ../../TShockAPI/UpdateManager.cs:86
#, csharp-format
msgid "UpdateManager warning: {0}"
msgstr "Advertencia de UpdateManager: {0}"

#: ../../TShockAPI/Commands.cs:316
msgid "Upload the account information when you joined the server as your Server Side Character data."
msgstr "Sube la información de la cuenta cuando te uniste al servidor como tus datos de Personaje Exclusivo-de-Servidor."

#: ../../TShockAPI/Commands.cs:1916
#, csharp-format
msgid "Usage: {0}tempgroup <username> <new group> [time]"
msgstr "Uso: {0}tempgroup <nombreUsuario> <grupo nuevo> [tiempo]"

#: ../../TShockAPI/Commands.cs:2001
msgid "Usage: /sudo [command]."
msgstr "Uso: /sudo [comando]."

#: ../../TShockAPI/Commands.cs:1844
#: ../../TShockAPI/Commands.cs:1850
msgid "Usage: /uploadssc [playername]."
msgstr "Uso: /uploadssc [nombreJugador]."

#: ../../TShockAPI/Commands.cs:2441
#, csharp-format
msgid "Use \"{0}worldevent rain slime\" to start slime rain!"
msgstr "¡Usa \"{0}worldevent rain slime\" para iniciar una lluvia de slimes!"

#: ../../TShockAPI/TSPlayer.cs:1971
msgid "Use \"my query\" for items with spaces."
msgstr "Usa comillas (Ej. \"tal objeto\") para objetos con espacios."

#: ../../TShockAPI/TSPlayer.cs:1972
msgid "Use tsi:[number] or tsn:[username] to distinguish between user IDs and usernames."
msgstr "Usa tsi:[number] o tsn:[username] para distinguir entre IDs y nombres de usuario."

#: ../../TShockAPI/Commands.cs:227
msgid "Used to authenticate as superadmin when first setting up TShock."
msgstr "Se usa para autenticarse como superadmin la primera vez que configuras TShock."

#: ../../TShockAPI/Rest/RestManager.cs:1341
#, csharp-format
msgid "User {0} '{1}' doesn't exist"
msgstr "El usuario {0} '{1}' no existe"

#: ../../TShockAPI/Commands.cs:1114
#, csharp-format
msgid "User {0} already exists."
msgstr "Ya existe el usuario {0}."

#: ../../TShockAPI/Commands.cs:1118
#, csharp-format
msgid "User {0} could not be added, check console for details."
msgstr "El usuario {0} no pudo ser añadido, comprueba la consola para más detalles."

#: ../../TShockAPI/Commands.cs:1198
#, csharp-format
msgid "User {0} could not be added. Check console for details."
msgstr "El usuario {0} no pudo ser añadido. Comprueba la consola para más detalles."

#: ../../TShockAPI/Commands.cs:1194
#: ../../TShockAPI/Commands.cs:1302
#, csharp-format
msgid "User {0} does not exist."
msgstr "El usuario {0} no existe."

#: ../../TShockAPI/DB/UserManager.cs:612
#, csharp-format
msgid "User account {0} already exists"
msgstr "La cuenta de usuario {0} ya existe"

#: ../../TShockAPI/DB/UserManager.cs:625
#, csharp-format
msgid "User account {0} does not exist"
msgstr "La cuenta de usuario {0} no existe"

#: ../../TShockAPI/Commands.cs:1204
msgid "User management command help:"
msgstr "Ayuda del comando de gestión de usuario:"

#: ../../TShockAPI/Rest/SecureRest.cs:138
#: ../../TShockAPI/Rest/SecureRest.cs:144
#: ../../TShockAPI/Rest/SecureRest.cs:152
msgid "Username or password may be incorrect or this account may not have sufficient privileges."
msgstr "El nombre de usuario o la contraseña pueden ser incorrectos o esta cuenta puede no tener suficientes privilegios."

#: ../../TShockAPI/TShock.cs:390
#: ../../TShockAPI/TShock.cs:394
#, csharp-format
msgid "Using {0} for tile implementation"
msgstr "Usando {0} para la implementación de casillas"

#: ../../TShockAPI/Bouncer.cs:1794
#, csharp-format
msgid "Using {0} on non-honey"
msgstr "Usando {0} en algo que no es miel"

#: ../../TShockAPI/Bouncer.cs:1803
#, csharp-format
msgid "Using {0} on non-lava"
msgstr "Usando {0} en algo que no es lava"

#: ../../TShockAPI/Bouncer.cs:1810
#, csharp-format
msgid "Using {0} on non-shimmer"
msgstr "Usando {0} en algo que no es fulgor"

#: ../../TShockAPI/Bouncer.cs:1785
#, csharp-format
msgid "Using {0} on non-water"
msgstr "Usando {0} en algo que no es agua"

#: ../../TShockAPI/Bouncer.cs:1817
#, csharp-format
msgid "Using {0} on non-water or shimmer"
msgstr "Usando {0} en algo que no es agua o fulgor"

#: ../../TShockAPI/Bouncer.cs:1825
#, csharp-format
msgid "Using {0} to manipulate unknown liquid {1}"
msgstr "Usando {0} para manipular el líquido desconocido {1}"

#: ../../TShockAPI/Bouncer.cs:1740
#, csharp-format
msgid "Using banned {0} to manipulate liquid"
msgstr "Usando el {0} prohibido para manipular líquido"

#: ../../TShockAPI/Bouncer.cs:1763
msgid "Using banned honey bucket without permissions"
msgstr "Usando el cubo de miel prohibido sin permisos"

#: ../../TShockAPI/Bouncer.cs:1756
msgid "Using banned lava bucket without permissions"
msgstr "Usando cubo de lava prohibido sin permisos"

#: ../../TShockAPI/Bouncer.cs:1770
msgid "Using banned shimmering water bucket without permissions"
msgstr "Usando cubo de fulgor prohibido sin permisos"

#: ../../TShockAPI/Bouncer.cs:1749
msgid "Using banned water bucket without permissions"
msgstr "Usando cubo de agua prohibido sin permisos"

#: ../../TShockAPI/Commands.cs:924
msgid "UUID does not match this character."
msgstr "El UUID no coincide con este personaje."

#: ../../TShockAPI/Commands.cs:2147
#, csharp-format
msgid "Valid event types: {0}."
msgstr "Tipos de eventos válidos: {0}."

#: ../../TShockAPI/Commands.cs:2148
#, csharp-format
msgid "Valid invasion types if spawning an invasion: {0}."
msgstr "Tipos de invasión válidos si se genera una invasión: {0}."

#: ../../TShockAPI/Commands.cs:2333
#, csharp-format
msgid "Valid invasion types: {0}."
msgstr "Tipos de invasión válidos: {0}."

#: ../../TShockAPI/Commands.cs:2549
#, csharp-format
msgid "Valid world modes: {0}"
msgstr "Modos de mundo válidos: {0}"

#: ../../TShockAPI/Commands.cs:3250
#, csharp-format
msgid "Warp {0} already exists."
msgstr "El warp {0} ya existe."

#: ../../TShockAPI/Commands.cs:3286
#, csharp-format
msgid "Warp {0} is now private."
msgstr "El warp {0} es ahora privado."

#: ../../TShockAPI/Commands.cs:3288
#, csharp-format
msgid "Warp {0} is now public."
msgstr "El warp {0} es ahora público."

#: ../../TShockAPI/Commands.cs:3246
#, csharp-format
msgid "Warp added: {0}."
msgstr "Warp añadido: {0}"

#: ../../TShockAPI/Commands.cs:3265
#, csharp-format
msgid "Warp deleted: {0}"
msgstr "Warp eliminado: {0}"

#: ../../TShockAPI/Commands.cs:3345
#, csharp-format
msgid "Warped to {0}."
msgstr "Te transportas a {0}."

#: ../../TShockAPI/Commands.cs:3228
msgid "Warps ({{0}}/{{1}}):"
msgstr "Warps ({{0}}/{{1}}):"

#: ../../TShockAPI/TShock.cs:448
msgid "Welcome to TShock for Terraria!"
msgstr "¡Bienvenido a TShock para Terraria!"

#: ../../TShockAPI/Commands.cs:5518
msgid "Whisper Syntax"
msgstr "Sintaxis de Whisper"

#: ../../TShockAPI/Commands.cs:6608
msgid "Willow Tree"
msgstr "Sauce"

#: ../../TShockPluginManager/NugetCLI.cs:85
msgid "Without a list of plugins to install, no plugins can be installed."
msgstr "No se pueden instalar plugins sin una lista de estos para su instalación."

#: ../../TShockAPI/BackupManager.cs:80
#, csharp-format
msgid "World backed up ({0})."
msgstr "Mundo respaldado ({0})."

#: ../../TShockAPI/BackupManager.cs:78
msgid "World backed up."
msgstr "Mundo respaldado."

#: ../../TShockAPI/Commands.cs:2574
#, csharp-format
msgid "World mode set to {0}."
msgstr "Tipo de mundo cambiado a {0}."

#: ../../TShockAPI/TShock.cs:818
#, csharp-format
msgid "World name will be overridden by: {0}"
msgstr "El nombre del mundo será reemplazado por: {0}"

#: ../../TShockAPI/TShock.cs:775
#, csharp-format
msgid "World path has been set to {0}"
msgstr "La ruta del mundo se ha establecido en {0}"

#: ../../TShockAPI/SaveManager.cs:137
#, csharp-format
msgid "World saved at ({0})"
msgstr "Mundo guardado en ({0})"

#: ../../TShockAPI/SaveManager.cs:135
msgid "World saved."
msgstr "Mundo guardado."

#: ../../TShockAPI/Commands.cs:4948
#, csharp-format
msgid "X: {0}; Y: {1}; W: {2}; H: {3}, Z: {4}"
msgstr "X: {0}; Y: {1}; W: {2}; H: {3}, Z: {4}"

#: ../../TShockAPI/Commands.cs:5938
msgid "You are already dead!"
msgstr "¡Ya estás muerto!"

#: ../../TShockAPI/Commands.cs:783
msgid "You are already logged in, and cannot login again."
msgstr "Tu sesión ya ha sido iniciada, por lo que no puedes volver a iniciarla."

#: ../../TShockAPI/Commands.cs:2913
msgid "You are dead. Dead players can't go home."
msgstr "Estás muerto(a). Los jugadores muertos no pueden ir a casa."

#: ../../TShockAPI/TShock.cs:1501
msgid "You are muted!"
msgstr "¡Estás silenciado!"

#: ../../TShockAPI/Commands.cs:5428
#: ../../TShockAPI/Commands.cs:5443
#: ../../TShockAPI/Commands.cs:5534
#: ../../TShockAPI/Commands.cs:5571
msgid "You are muted."
msgstr "Estás silenciado."

#: ../../TShockAPI/Commands.cs:6758
#, csharp-format
msgid "You are no longer in god mode."
msgstr "Ya no estás en modo dios."

#: ../../TShockAPI/Commands.cs:5988
msgid "You are not dead!"
msgstr "¡No estás muerto!"

#: ../../TShockAPI/Commands.cs:5454
msgid "You are not in a party!"
msgstr "¡No estás en un grupo!"

#: ../../TShockAPI/Commands.cs:945
msgid "You are not logged-in. Therefore, you cannot logout."
msgstr "No has iniciado sesión. Por ende, no puedes cerrarla."

#: ../../TShockAPI/Configuration/TShockConfig.cs:333
msgid "You are not on the whitelist."
msgstr "No estás en la lista blanca."

#: ../../TShockAPI/Commands.cs:5618
msgid "You are now being annoyed."
msgstr "Ahora estás siendo molestado."

#: ../../TShockAPI/Commands.cs:6757
#, csharp-format
msgid "You are now in god mode."
msgstr "Ahora estas en modo dios."

#: ../../TShockAPI/Commands.cs:6406
#: ../../TShockAPI/Commands.cs:6463
#, csharp-format
msgid "You buffed yourself with {0} ({1}) for {2} seconds."
msgstr "Te potencias con {0} ({1}) por {2} segundos."

#: ../../TShockAPI/Commands.cs:6049
#, csharp-format
msgid "You butchered {0} NPC."
msgid_plural "You butchered {0} NPCs."
msgstr[0] "Mataste {0} PNJ."
msgstr[1] "Mataste {0} PNJ."

#: ../../TShockAPI/TShock.cs:450
msgid "You can modify & distribute it under the terms of the GNU GPLv3."
msgstr "Puedes modificar y distribuirlo bajo los términos de la GNU GPLv3."

#: ../../TShockAPI/Commands.cs:694
#, csharp-format
msgid "You can use '{0}sudo {0}{1}' to override this check."
msgstr "Puedes utilizar '{0}sudo {0}{1}' para anular esta comprobación."

#: ../../TShockAPI/Commands.cs:5602
#, csharp-format
msgid "You can use {0} instead of {1} to annoy a player silently."
msgstr "Puedes usar {0} en lugar de {1} para molestar a un jugador silenciosamente."

#: ../../TShockAPI/Commands.cs:5818
#: ../../TShockAPI/Commands.cs:5920
#, csharp-format
msgid "You can use {0} instead of {1} to execute this command silently."
msgstr "Puede usar {0} en lugar de {1} para ejecutar este comando de forma silenciosa."

#: ../../TShockAPI/Commands.cs:5686
#, csharp-format
msgid "You can use {0} instead of {1} to launch a firework silently."
msgstr "Puedes usar {0} en lugar de {1} para lanzar un fuego artificial silenciosamente."

#: ../../TShockAPI/Commands.cs:5630
#, csharp-format
msgid "You can use {0} instead of {1} to rocket a player silently."
msgstr "Puedes usar {0} en lugar de {1} para hacer despegar a un jugador silenciosamente."

#: ../../TShockAPI/Commands.cs:5564
#, csharp-format
msgid "You can use {0}{1} to toggle this setting."
msgstr "Puedes usar {0}{1} para cambiar esta configuración."

#: ../../TShockAPI/Commands.cs:5591
#, csharp-format
msgid "You can use {0}{1} to whisper to other players."
msgstr "Puedes usar {0}{1} para susurrar a otros jugadores."

#: ../../TShockAPI/Commands.cs:6733
msgid "You can't god mode a non player!"
msgstr "¡No puedes poner en modo dios nada que no sea un jugador!"

#: ../../TShockAPI/Commands.cs:6333
msgid "You can't heal a dead player!"
msgstr "¡No puedes curar a un jugador muerto!"

#: ../../TShockAPI/Commands.cs:1337
msgid "You can't kick another admin."
msgstr "No puedes expulsar a otro admin."

#: ../../TShockAPI/DB/GroupManager.cs:501
#: ../../TShockAPI/DB/GroupManager.cs:502
msgid "You can't remove the default guest group."
msgstr "No puedes quitar el grupo huésped predeterminado."

#: ../../TShockAPI/Commands.cs:5957
msgid "You can't respawn the server console!"
msgstr "¡No puedes reaparecer a la consola del servidor!"

#: ../../TShockAPI/Commands.cs:814
msgid "You cannot login whilst crowd controlled."
msgstr "No puedes iniciar sesión mientras se te está conteniendo."

#: ../../TShockAPI/Commands.cs:800
msgid "You cannot login whilst dead."
msgstr "No puedes iniciar sesión mientras estas muerto(a)."

#: ../../TShockAPI/Commands.cs:808
msgid "You cannot login whilst using an item."
msgstr "No puedes iniciar sesión mientras usas un objeto."

#: ../../TShockAPI/Commands.cs:6144
#: ../../TShockAPI/Commands.cs:6283
msgid "You cannot spawn banned items."
msgstr "No puedes generar objetos prohibidos."

#: ../../TShockAPI/GetDataHandlers.cs:3445
msgid "You cannot use the Enchanted Sundial because time is stopped."
msgstr "No puedes usar el Reloj de Sol Encantado porque el tiempo está detenido."

#: ../../TShockAPI/Commands.cs:5541
msgid "You cannot whisper to yourself."
msgstr "No puedes susurrarte a ti mismo."

#: ../../TShockAPI/Commands.cs:5851
#, csharp-format
msgid "You deleted {0} item within a radius of {1}."
msgid_plural "You deleted {0} items within a radius of {1}."
msgstr[0] "Has eliminado {0} objeto en un radio de {1}."
msgstr[1] "Has eliminado {0} objetos en un radio de {1}."

#: ../../TShockAPI/Commands.cs:5875
#, csharp-format
msgid "You deleted {0} NPC within a radius of {1}."
msgid_plural "You deleted {0} NPCs within a radius of {1}."
msgstr[0] "Has eliminado {0} PNJ en un radio de {1}."
msgstr[1] "Has eliminado {0} PNJ en un radio de {1}."

#: ../../TShockAPI/Commands.cs:5900
#, csharp-format
msgid "You deleted {0} projectile within a radius of {1}."
msgid_plural "You deleted {0} projectiles within a radius of {1}."
msgstr[0] "Has eliminado {0} proyectil en un radio de {1}."
msgstr[1] "Has eliminado {0} proyectiles en un radio de {1}."

#: ../../TShockAPI/Commands.cs:6316
msgid "You didn't put a player name."
msgstr "No has puesto un nombre de jugador."

#: ../../TShockAPI/GetDataHandlers.cs:4211
msgid "You died! Normally, you'd be banned."
msgstr "¡Has muerto! Normalmente habrías sido baneado."

#: ../../TShockAPI/Commands.cs:691
#: ../../TShockAPI/Commands.cs:5280
msgid "You do not have access to this command."
msgstr "No tienes acceso a este comando."

#: ../../TShockAPI/TSPlayer.cs:828
msgid "You do not have permission to build in the spawn point."
msgstr "No tienes permiso de construir en el punto de aparición."

#: ../../TShockAPI/TSPlayer.cs:831
msgid "You do not have permission to build in this region."
msgstr "No tienes permiso para construir dentro de esta región."

#: ../../TShockAPI/TSPlayer.cs:825
msgid "You do not have permission to build on this server."
msgstr "No tienes permiso para construir en este servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:74
msgid "You do not have permission to contribute research."
msgstr "No tienes permiso de contribuir investigación."

#: ../../TShockAPI/Bouncer.cs:1184
msgid "You do not have permission to create that projectile."
msgstr "No tienes permiso de crear ese proyectil."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:113
msgid "You do not have permission to freeze the biome spread of the server."
msgstr "No tienes permiso de detener la expansión de biomas del servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:109
msgid "You do not have permission to freeze the rain strength of the server."
msgstr "No tienes permiso de congelar la fuerza de la lluvia del servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:103
msgid "You do not have permission to freeze the time of the server."
msgstr "No tienes permiso de detener el tiempo del servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:110
msgid "You do not have permission to freeze the wind strength of the server."
msgstr "No tienes permiso de congelar la fuerza del viento del servidor."

#: ../../TShockAPI/Commands.cs:6711
msgid "You do not have permission to god mode another player."
msgstr "No tienes permiso para poner en modo dios a otro jugador."

#: ../../TShockAPI/Commands.cs:6522
msgid "You do not have permission to grow this tree type"
msgstr "No tienes permiso para hacer crecer este tipo de árbol."

#: ../../TShockAPI/GetDataHandlers.cs:2960
msgid "You do not have permission to hurt Town NPCs."
msgstr "No tienes permiso para dañar a PNJ ciudadanos."

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:22
msgid "You do not have permission to modify a Hat Rack in a protected area!"
msgstr "¡No tienes permiso para modificar el Perchero para Sombreros en un área protegida!"

#: ../../TShockAPI/Handlers/DisplayDollItemSyncHandler.cs:21
#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:28
msgid "You do not have permission to modify a Mannequin in a protected area!"
msgstr "¡No tienes permiso para modificar un Maniquí en un área protegida!"

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:34
msgid "You do not have permission to modify a TileEntity in a protected area!"
msgstr "¡No tienes permiso para modificar una TileEntity en un área protegida!"

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:114
msgid "You do not have permission to modify the NPC spawn rate of the server."
msgstr "No tienes permiso para modificar la tasa de generación de PNJ del servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:107
msgid "You do not have permission to modify the rain strength of the server."
msgstr "No tienes permiso para modificar la intensidad de la lluvia del servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:111
msgid "You do not have permission to modify the tile placement range of your character."
msgstr "No tienes permiso para modificar el rango de colocación de bloques de tu personaje."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:104
msgid "You do not have permission to modify the time of the server."
msgstr "No tienes permiso para cambiar la hora del servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:108
msgid "You do not have permission to modify the time speed of the server."
msgstr "No tienes permiso para cambiar la velocidad del tiempo del servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:106
msgid "You do not have permission to modify the wind strength of the server."
msgstr "No tienes permiso para cambiar la fuerza del viento del servidor."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:112
msgid "You do not have permission to modify the world difficulty of the server."
msgstr "No tienes permiso para cambiar la dificultad de mundo del servidor."

#: ../../TShockAPI/Commands.cs:5479
#, csharp-format
msgid "You do not have permission to mute {0}"
msgstr "No tienes permiso para silenciar a {0}"

#: ../../TShockAPI/Bouncer.cs:1732
msgid "You do not have permission to perform this action."
msgstr "No tienes permiso para realizar esta acción."

#: ../../TShockAPI/ItemBans.cs:202
msgid "You do not have permission to place actuators."
msgstr "No tienes permiso para colocar actuadores."

#: ../../TShockAPI/GetDataHandlers.cs:3967
msgid "You do not have permission to place Logic Sensors."
msgstr "No tienes permiso para colocar Sensores Lógicos."

#: ../../TShockAPI/Bouncer.cs:655
#: ../../TShockAPI/Bouncer.cs:2263
msgid "You do not have permission to place this tile."
msgstr "No tienes permiso para colocar este bloque."

#: ../../TShockAPI/GetDataHandlers.cs:3493
msgid "You do not have permission to relocate Town NPCs."
msgstr "No tienes permiso para reubicar a los PNJ ciudadanos."

#: ../../TShockAPI/Commands.cs:5965
msgid "You do not have permission to respawn another player."
msgstr "No tienes permiso para reaparecer a otro jugador."

#: ../../TShockAPI/Commands.cs:5335
msgid "You do not have permission to see player IDs."
msgstr "No tienes permiso para ver las IDs de los jugadores."

#: ../../TShockAPI/Handlers/EmojiHandler.cs:19
msgid "You do not have permission to send emotes!"
msgstr "¡No tienes permiso para enviar emoticonos!"

#: ../../TShockAPI/GetDataHandlers.cs:3532
msgid "You do not have permission to spawn pets."
msgstr "No tienes permiso para invocar mascotas."

#: ../../TShockAPI/GetDataHandlers.cs:4127
msgid "You do not have permission to start a party."
msgstr "No tienes permiso para iniciar una fiesta."

#: ../../TShockAPI/GetDataHandlers.cs:3525
msgid "You do not have permission to start invasions."
msgstr "No tienes permiso para iniciar invasiones."

#: ../../TShockAPI/Commands.cs:2156
#, csharp-format
msgid "You do not have permission to start the {0} event."
msgstr "No tienes permiso para iniciar el evento {0}."

#: ../../TShockAPI/GetDataHandlers.cs:4145
msgid "You do not have permission to start the Old One's Army."
msgstr "No tienes permiso para invocar el Ejército del Antiguo."

#: ../../TShockAPI/GetDataHandlers.cs:3518
msgid "You do not have permission to summon bosses."
msgstr "No tienes permiso para invocar jefes."

#: ../../TShockAPI/GetDataHandlers.cs:2970
msgid "You do not have permission to summon the Empress of Light."
msgstr "No tienes permiso para invocar a la Emperatriz de la Luz."

#: ../../TShockAPI/GetDataHandlers.cs:2987
msgid "You do not have permission to summon the Lunatic Cultist!"
msgstr "¡No tienes permiso para invocar al Sectario Lunático!"

#: ../../TShockAPI/Commands.cs:3070
msgid "You do not have permission to teleport all other players."
msgstr "No tienes permiso de teletransportar a todos los demás jugadores."

#: ../../TShockAPI/Commands.cs:2981
msgid "You do not have permission to teleport all players."
msgstr "No tienes permiso de teletransportar a todos los jugadores."

#: ../../TShockAPI/Commands.cs:2964
msgid "You do not have permission to teleport other players."
msgstr "No tienes permiso de teletransportar a otros jugadores."

#: ../../TShockAPI/GetDataHandlers.cs:3833
#, csharp-format
msgid "You do not have permission to teleport using {0}."
msgstr "No tienes permiso para teletransportarte usando {0}."

#: ../../TShockAPI/GetDataHandlers.cs:3745
msgid "You do not have permission to teleport using items."
msgstr "No tienes permiso para teletransportarte usando objetos."

#: ../../TShockAPI/Handlers/NetModules/PylonHandler.cs:54
msgid "You do not have permission to teleport using pylons."
msgstr "No tienes permiso de teletransportarte usando pilones."

#: ../../TShockAPI/GetDataHandlers.cs:3769
msgid "You do not have permission to teleport using Wormhole Potions."
msgstr "No tienes permiso para teletransportarte usando Pociones de Agujero de Gusano."

#: ../../TShockAPI/Commands.cs:5154
msgid "You do not have permission to teleport."
msgstr "No tienes permiso para teletransportarte."

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:105
msgid "You do not have permission to toggle godmode."
msgstr "No tienes permiso de activar el modo dios."

#: ../../TShockAPI/Commands.cs:1839
msgid "You do not have permission to upload another player's character join-state server-side-character data."
msgstr "No tienes permiso para subir datos de join-state de personaje exclusivo-de-servidor para otro jugador."

#: ../../TShockAPI/GetDataHandlers.cs:3437
msgid "You do not have permission to use the Enchanted Sundial."
msgstr "No tienes permiso para usar el Reloj de Sol Encantado."

#: ../../TShockAPI/Commands.cs:652
#, csharp-format
msgid "You entered a space after {0} instead of a command. Type {0}help for a list of valid commands."
msgstr "Has introducido un espacio después de {0} en lugar de un comando. Escribe {0}help para ver la lista de comandos."

#: ../../TShockAPI/Commands.cs:985
msgid "You failed to change your password."
msgstr "No pudiste cambiar tu contraseña."

#: ../../TShockAPI/GetDataHandlers.cs:2458
msgid "You have been Bounced."
msgstr "Se te ha negado la entrada."

#: ../../TShockAPI/Rest/RestManager.cs:1393
msgid "You have been remotely muted"
msgstr "Has sido silenciado de forma remota"

#: ../../TShockAPI/Rest/RestManager.cs:1398
msgid "You have been remotely unmmuted"
msgstr "Se revocó tu silencio de forma remota"

#: ../../TShockAPI/Commands.cs:956
msgid "You have been successfully logged out of your account."
msgstr "Te desconectaste de tu cuenta exitosamente."

#: ../../TShockAPI/Commands.cs:6465
#, csharp-format
msgid "You have buffed {0} with {1} ({2}) for {3} seconds!"
msgstr "¡Has potenciado a {0} con {1} ({2}) durante {3} segundos!"

#: ../../TShockAPI/Commands.cs:1959
#, csharp-format
msgid "You have changed {0}'s group to {1}"
msgstr "Has cambiado el grupo de {0} a {1}"

#: ../../TShockAPI/Commands.cs:1964
#, csharp-format
msgid "You have changed {0}'s group to {1} for {2}"
msgstr "Has cambiado el grupo de {0} a {1} durante {2}"

#: ../../TShockAPI/GetDataHandlers.cs:4226
msgid "You have fallen in hardcore mode, and your items have been lost forever."
msgstr "Has muerto en modo extremo y todos tus objetos se han perdido para siempre."

#: ../../TShockAPI/Commands.cs:5662
#, csharp-format
msgid "You have launched {0} into space."
msgstr "Has lanzado a {0} a la estratosfera."

#: ../../TShockAPI/Commands.cs:5660
msgid "You have launched yourself into space."
msgstr "Te has lanzado a ti mismo a la estratosfera."

#: ../../TShockAPI/Commands.cs:5498
#, csharp-format
msgid "You have muted {0} for {1}"
msgstr "Has silenciado a {0} por {1}"

#: ../../TShockAPI/Commands.cs:5997
#, csharp-format
msgid "You have respawned {0}"
msgstr "Has reaparecido a {0}"

#: ../../TShockAPI/Commands.cs:6002
msgid "You have respawned yourself."
msgstr "Te has reaparecido a ti mismo."

#: ../../TShockAPI/Commands.cs:974
msgid "You have successfully changed your password."
msgstr "Cambiaste tu contraseña exitosamente."

#: ../../TShockAPI/Commands.cs:5486
#, csharp-format
msgid "You have unmuted {0}."
msgstr "Has desmuteado a {0}."

#: ../../TShockAPI/Commands.cs:5590
msgid "You haven't previously received any whispers."
msgstr "No has recibido ningún susurro recientemente."

#: ../../TShockAPI/Commands.cs:6347
#, csharp-format
msgid "You healed {0} for {1} HP."
msgstr "Curas {1} puntos de vida a {0}."

#: ../../TShockAPI/Commands.cs:6345
#, csharp-format
msgid "You healed yourself for {0} HP."
msgstr "Te curas por {0} puntos de vida."

#: ../../TShockAPI/Commands.cs:5947
#, csharp-format
msgid "You just killed {0}!"
msgstr "¡Has matado a {0}!"

#: ../../TShockAPI/Commands.cs:5945
msgid "You just killed yourself!"
msgstr "¡Te has matado a ti mismo!"

#: ../../TShockAPI/Commands.cs:5744
#, csharp-format
msgid "You launched fireworks on {0}."
msgstr "Has lanzado fuegos artificiales sobre {0}."

#: ../../TShockAPI/Commands.cs:5742
msgid "You launched fireworks on yourself."
msgstr "Has lanzado fuegos artificiales sobre ti mismo."

#: ../../TShockAPI/TShock.cs:608
msgid "You logged in from another location."
msgstr "Has iniciado sesión desde otra ubicación."

#: ../../TShockAPI/TShock.cs:599
msgid "You logged in from the same IP."
msgstr "Has iniciado sesión desde la misma IP."

#: ../../TShockAPI/Commands.cs:5561
msgid "You may now receive whispers from other players."
msgstr "Ahora podrás recibir susurros de otros jugadores."

#: ../../TShockAPI/GetDataHandlers.cs:2621
msgid "You may wish to consider removing the tshock.ignore.ssc permission or negating it for this player."
msgstr "Deberías considerar el quitar o denegar el permiso tshock.ignore.ssc para este jugador."

#: ../../TShockAPI/DB/RegionManager.cs:788
msgid "You must be logged in to take advantage of protected regions."
msgstr "Debes estar conectado para poder aprovechar las regiones protegidas."

#: ../../TShockAPI/Commands.cs:5396
msgid "You must provide a setup code!"
msgstr "¡Debes proporcionar el código de configuración!"

#: ../../TShockAPI/GetDataHandlers.cs:3448
msgid "You must set ForceTime to normal via config to use the Enchanted Sundial."
msgstr "Debes cambiar a normal la opción ForceTime en el archivo de configuración para usar el Reloj de Sol Encantado."

#: ../../TShockAPI/Commands.cs:2718
msgid "You must spawn the Wall of Flesh in hell."
msgstr "Debes invocar al Muro Carnoso en el inframundo."

#: ../../TShockAPI/Commands.cs:699
msgid "You must use this command in-game."
msgstr "Debes usar este comando dentro del juego."

#: ../../TShockAPI/GetDataHandlers.cs:2523
msgid "You need to join with a hardcore player."
msgstr "Necesitas unirte con un jugador en modo extremo."

#: ../../TShockAPI/GetDataHandlers.cs:2517
msgid "You need to join with a mediumcore player or higher."
msgstr "Necesitas unirte con un jugador en modo medio o superior."

#: ../../TShockAPI/GetDataHandlers.cs:2511
msgid "You need to join with a softcore player."
msgstr "Necesitas unirte con un jugador en modo clásico."

#: ../../TShockAPI/Bouncer.cs:551
msgid "You need to rejoin to ensure your trash can is cleared!"
msgstr "¡Tienes que volver a entrar para asegurarnos que tu casilla basurero está vacía!"

#: ../../TShockAPI/Commands.cs:2827
#, csharp-format
msgid "You spawned {0} {1} time."
msgid_plural "You spawned {0} {1} times."
msgstr[0] "Has invocado a {0} {1} vez."
msgstr[1] "Has invocado a {0} {1} veces."

#: ../../TShockAPI/Commands.cs:3329
#, csharp-format
msgid "You warped {0} to {1}."
msgstr "Transportas a {0} hacia {1}."

#: ../../TShockAPI/Commands.cs:2995
#: ../../TShockAPI/Commands.cs:3035
#: ../../TShockAPI/Commands.cs:3078
#: ../../TShockAPI/Commands.cs:3093
#, csharp-format
msgid "You were teleported to {0}."
msgstr "Te han teletransportado hacia {0}."

#: ../../TShockAPI/TShock.cs:1706
msgid "You will be teleported to your last known location..."
msgstr "Serás teletransportado a tu última ubicación conocida..."

#: ../../TShockAPI/Commands.cs:5563
msgid "You will no longer receive whispers from other players."
msgstr "Ya no recibirás más susurros de otros jugadores."

#: ../../TShockAPI/Commands.cs:6485
msgid "You're not allowed to change tiles here!"
msgstr "¡No tienes permiso para cambiar bloques aquí!"

#: ../../TShockPluginManager/NugetCLI.cs:84
msgid "You're trying to sync, but you don't have a packages.json file."
msgstr "Estás intentando sincronizar, pero no tienes un archivo packages.json."

#: ../../TShockAPI/Commands.cs:1987
msgid "Your account has been elevated to superadmin for 10 minutes."
msgstr "Tu cuenta fue ascendida a superadmin por 10 minutos."

#: ../../TShockAPI/Commands.cs:1046
#, csharp-format
msgid "Your account, \"{0}\", has been registered."
msgstr "Has registrado tu cuenta: \"{0}\"."

#: ../../TShockAPI/DB/GroupManager.cs:235
#: ../../TShockAPI/DB/GroupManager.cs:237
msgid "Your account's group could not be loaded. Please contact server administrators about this."
msgstr "El grupo de tu cuenta no pudo ser cargado. Por favor informa de esto a los administradores del servidor."

#: ../../TShockAPI/Bouncer.cs:454
msgid "Your client sent a blank character name."
msgstr "Tu cliente envió un nombre de personaje en blanco."

#: ../../TShockAPI/TShock.cs:1351
msgid "Your client sent a blank UUID. Configure it to send one or use a different client."
msgstr "Tu cliente envió un UUID en blanco. Configúralo para que envíe uno o usa un cliente distinto."

#: ../../TShockAPI/DB/RegionManager.cs:107
msgid "Your database contains invalid UserIDs (they should be integers)."
msgstr "Tu base de datos contiene UserIDs inválidas (deberían ser números enteros)."

#: ../../TShockAPI/Commands.cs:1966
#, csharp-format
msgid "Your group has been changed to {0} for {1}"
msgstr "Tu grupo fue cambiado a {0} por {1}"

#: ../../TShockAPI/Commands.cs:1960
#, csharp-format
msgid "Your group has temporarily been changed to {0}"
msgstr "Tu grupo fue cambiado temporalmente a {0}"

#: ../../TShockAPI/Commands.cs:6149
msgid "Your inventory seems full."
msgstr "Tu inventario parece estar lleno."

#: ../../TShockAPI/Commands.cs:1859
msgid "Your local character data, from your initial connection, has been uploaded to the server."
msgstr "Los datos locales de tu personaje, desde tu conexión inicial, se han subido al servidor."

#: ../../TShockAPI/Commands.cs:5385
#, csharp-format
msgid "Your new account has been verified, and the {0}setup system has been turned off."
msgstr "Tu nueva cuenta ha sido verificada y el sistema {0}setup ha sido desactivado."

#: ../../TShockAPI/GetDataHandlers.cs:3217
msgid "Your password did not match this character's password."
msgstr "Tu contraseña no coincide con la contraseña de este personaje."

#: ../../TShockAPI/Commands.cs:1047
#, csharp-format
msgid "Your password is {0}."
msgstr "Tu contraseña es: {0}."

#: ../../TShockAPI/Commands.cs:1978
msgid "Your previous permission set has been restored."
msgstr "Se ha restaurado tu conjunto de permisos previos."

#: ../../TShockAPI/Commands.cs:5791
msgid "Your reference dumps have been created in the server folder."
msgstr "Los volcados de referencia han sido creados en la carpeta del servidor."

#: ../../TShockAPI/Commands.cs:1758
msgid "Your server-side character data has been saved."
msgstr "Se han guardado los datos de SSC para tu personaje."

#: ../../TShockAPI/TSPlayer.cs:1325
msgid "Your temporary group access has expired."
msgstr "Expiró tu acceso temporal al grupo."

#: ../../TShockAPI/Commands.cs:5199
msgid "z <name> <#> - Sets the z-order of the region."
msgstr "z <name> <#> - Establece el orden Z de la región."

#: ../../TShockAPI/GetDataHandlers.cs:3235
msgctxt "Likely non-vanilla client send zero-length password"
msgid "You have been Bounced for invalid password."
msgstr "Se te ha negado la entrada por contraseña inválida."

#: ../../TShockAPI/TSServerPlayer.cs:34
msgctxt "The account name of server console."
msgid "ServerConsole"
msgstr "ServerConsole"


```
### Folder: `temp_TShock-5.2.4/i18n`
#### File: `temp_TShock-5.2.4/i18n/template.pot`
```
msgid ""
msgstr ""
"Project-Id-Version: TShock\n"
"POT-Creation-Date: 2023-08-15 09:53:07+0000\n"
"PO-Revision-Date: 2023-08-15 09:53:09+0000\n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: GetText.NET Extractor\n"

#: ../../TShockAPI/DB/CharacterManager.cs:197
#: ../../TShockAPI/DB/CharacterManager.cs:267
#, csharp-format
msgctxt "{0} is a player name"
msgid "Skipping SSC save (due to tshock.ignore.ssc) for {0}"
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:213
#, csharp-format
msgctxt "{0} is ban number, {1} is ban reason, {2} is a timestamp"
msgid "#{0} - You are banned: {1} ({2} remaining)"
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:208
#, csharp-format
msgctxt "{0} is ban number, {1} is ban reason"
msgid "#{0} - You are banned: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6499
msgid ""
"     'basic', 'sakura', 'willow', 'boreal', 'mahogany', 'ebonwood', "
"'shadewood', 'pearlwood'."
msgstr ""

#: ../../TShockAPI/Commands.cs:6505
msgid "     'cactus', 'herb', 'mushroom'."
msgstr ""

#: ../../TShockAPI/Commands.cs:6501
msgid "     'palm', 'corruptpalm', 'crimsonpalm', 'hallowpalm'."
msgstr ""

#: ../../TShockAPI/Commands.cs:6503
msgid ""
"     'topaz', 'amethyst', 'sapphire', 'emerald', 'ruby', 'diamond', 'amber'."
msgstr ""

#: ../../TShockAPI/Commands.cs:1446
#, csharp-format
msgid ""
"   {0}{1} \"{2}\" (Find the IP associated with the offline target's account)"
msgstr ""

#: ../../TShockAPI/Commands.cs:1444
#, csharp-format
msgid "   {0}{1} \"{2}{3}\" {4} {5} (Permanently bans this account name)"
msgstr ""

#: ../../TShockAPI/Commands.cs:1449
#, csharp-format
msgid "   {0}{1} {2} (Find the player index for the target)"
msgstr ""

#: ../../TShockAPI/Commands.cs:1450
#, csharp-format
msgid ""
"   {0}{1} {2}{3} {4} {5} (Permanently bans the online player by Account, "
"UUID, and IP)"
msgstr ""

#: ../../TShockAPI/Commands.cs:1447
#, csharp-format
msgid "   {0}{1} {2}{3} {4} {5} (Permanently bans this IP address)"
msgstr ""

#: ../../TShockAPI/Commands.cs:1386
#, csharp-format
msgid "   Eg a value of {0} would represent 10 days, 30 minutes, 0 seconds."
msgstr ""

#: ../../TShockAPI/Commands.cs:1390
#, csharp-format
msgid "   If no {0} are specified, the command uses {1} by default."
msgstr ""

#: ../../TShockAPI/Commands.cs:1387
msgid "   If no duration is provided, the ban will be permanent."
msgstr ""

#: ../../TShockAPI/Commands.cs:1389
#, csharp-format
msgid ""
"   Unless {0} is passed to the command, {1} is assumed to be a player or "
"player index"
msgstr ""

#: ../../TShockAPI/Commands.cs:1262
#, csharp-format
msgid " -> Logged-in as: {0}; in group {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1398
#, csharp-format
msgid ""
"- {0} are provided when you add a ban, and can also be viewed with the {1} "
"command."
msgstr ""

#: ../../TShockAPI/Commands.cs:1414
#, csharp-format
msgid ""
"- {0} are provided when you add a ban, and can be found with the {1} command."
msgstr ""

#: ../../TShockAPI/Commands.cs:1388
#, csharp-format
msgid ""
"- {0}: -a (account name), -u (UUID), -n (character name), -ip (IP address), "
"-e (exact, {1} will be treated as identifier)"
msgstr ""

#: ../../TShockAPI/Commands.cs:1385
#, csharp-format
msgid "- {0}: uses the format {1} to determine the length of the ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:1443
msgid "- Ban an offline player by account name"
msgstr ""

#: ../../TShockAPI/Commands.cs:1445
msgid "- Ban an offline player by IP address"
msgstr ""

#: ../../TShockAPI/Commands.cs:1448
msgid "- Ban an online player by index (Useful for hard to type names)"
msgstr ""

#: ../../TShockAPI/Commands.cs:6498
msgid "- Default trees :"
msgstr ""

#: ../../TShockAPI/Commands.cs:6502
msgid "- Gem trees :"
msgstr ""

#: ../../TShockAPI/Commands.cs:1406
msgid ""
"- Lists active bans. Color trends towards green as the ban approaches "
"expiration"
msgstr ""

#: ../../TShockAPI/Commands.cs:6504
msgid "- Misc :"
msgstr ""

#: ../../TShockAPI/Commands.cs:6500
msgid "- Palm trees :"
msgstr ""

#: ../../TShockAPI/TShock.cs:999
msgid ""
"!!! > Set DisableLoginBeforeJoin to true in the config file and /reload if "
"this is a problem."
msgstr ""

#: ../../TShockAPI/TShock.cs:993
msgid ""
"!!! > Set DisableUUIDLogin to true in the config file and /reload if this is "
"a problem."
msgstr ""

#: ../../TShockAPI/TShock.cs:998
msgid ""
"!!! Login before join is enabled. Existing accounts can login & the server "
"password will be bypassed."
msgstr ""

#: ../../TShockAPI/TShock.cs:987
msgid ""
"!!! The server password in config.json was overridden by the interactive "
"prompt and will be ignored."
msgstr ""

#: ../../TShockAPI/TShock.cs:992
msgid ""
"!!! UUID login is enabled. If a user's UUID matches an account, the server "
"password will be bypassed."
msgstr ""

#: ../../TShockAPI/Commands.cs:6409
#, csharp-format
msgid "\"{0}\" is not a valid buff ID!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5906
#, csharp-format
msgid "\"{0}\" is not a valid clear option."
msgstr ""

#: ../../TShockAPI/Commands.cs:6026
#, csharp-format
msgid "\"{0}\" is not a valid NPC."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:283
#, csharp-format
msgid "\"{0}\" is not a valid page number."
msgstr ""

#: ../../TShockAPI/Commands.cs:5826
#, csharp-format
msgid "\"{0}\" is not a valid radius."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:213
#, csharp-format
msgid "\"{0}\" requested REST endpoint: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2020
msgid "(Server Broadcast) "
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:496
msgid "(Super Admin) "
msgstr ""

#: ../../TShockAPI/Commands.cs:1461
#, csharp-format
msgid "{0} - Ticket Number: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2088
#, csharp-format
msgid "{0} ({1} tokens)"
msgstr ""

#: ../../TShockAPI/Commands.cs:976
#, csharp-format
msgid "{0} ({1}) changed the password for account {2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:986
#, csharp-format
msgid "{0} ({1}) failed to change the password for account {2}."
msgstr ""

#: ../../TShockAPI/TShock.cs:1695
#, csharp-format
msgid "{0} ({1}) from '{2}' group from '{3}' joined. ({4}/{5})"
msgstr ""

#: ../../TShockAPI/TShock.cs:1703
#, csharp-format
msgid "{0} ({1}) from '{2}' group joined. ({3}/{4})"
msgstr ""

#: ../../TShockAPI/Commands.cs:775
#, csharp-format
msgid ""
"{0} ({1}) had {2} or more invalid login attempts and was kicked "
"automatically."
msgstr ""

#: ../../TShockAPI/TShock.cs:1699
#, csharp-format
msgid "{0} ({1}) has joined."
msgstr ""

#: ../../TShockAPI/Commands.cs:5354
#, csharp-format
msgid "{0} (Index: {1}, Account ID: {2})"
msgstr ""

#: ../../TShockAPI/Commands.cs:5356
#, csharp-format
msgid "{0} (Index: {1})"
msgstr ""

#: ../../TShockAPI/Commands.cs:1405
#, csharp-format
msgid "{0} [{1}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:6011
#, csharp-format
msgid "{0} [{1}|{2}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1462
#: ../../TShockAPI/Commands.cs:1463
#, csharp-format
msgid "{0} {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1467
#, csharp-format
msgid "{0} {1} ({2} ago)"
msgstr ""

#: ../../TShockAPI/Commands.cs:1481
#, csharp-format
msgid "{0} {1} ({2})"
msgstr ""

#: ../../TShockAPI/Commands.cs:5328
#, csharp-format
msgid "{0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1464
#, csharp-format
msgid "{0} {1} on {2} ({3} ago)"
msgstr ""

#: ../../TShockAPI/Commands.cs:6368
#, csharp-format
msgid "{0} <\"{1}|{2}\"> [{3}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1397
#: ../../TShockAPI/Commands.cs:1413
#: ../../TShockAPI/Commands.cs:5628
#: ../../TShockAPI/Commands.cs:5918
#, csharp-format
msgid "{0} <{1}>"
msgstr ""

#: ../../TShockAPI/Commands.cs:5462
#: ../../TShockAPI/Commands.cs:6308
#, csharp-format
msgid "{0} <{1}> [{2}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1384
#, csharp-format
msgid "{0} <{1}> [{2}] [{3}] [{4}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:5684
#, csharp-format
msgid "{0} <{1}> [{2}|{3}|{4}|{5}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:5519
#: ../../TShockAPI/Commands.cs:5600
#, csharp-format
msgid "{0} <{1}> <{2}>"
msgstr ""

#: ../../TShockAPI/Commands.cs:6418
#, csharp-format
msgid "{0} <{1}> <{2}|{3}> [{4}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:5815
#, csharp-format
msgid "{0} <{1}|{2}|{3}> [{4}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1106
#, csharp-format
msgid "{0} added account {1} to group {2}."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3587
#, csharp-format
msgid "{0} applied advanced combat techniques volume 2!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3605
#, csharp-format
msgid "{0} applied advanced combat techniques!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3584
#, csharp-format
msgid "{0} applied traveling merchant's satchel!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1064
#, csharp-format
msgid "{0} attempted to register for the account {1} but it was already taken."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2672
#: ../../TShockAPI/GetDataHandlers.cs:3252
#, csharp-format
msgid "{0} authenticated successfully as user {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:905
#, csharp-format
msgid "{0} authenticated successfully as user: {1}."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2042
#, csharp-format
msgid "{0} banned {1} for '{2}'."
msgstr ""

#: ../../TShockAPI/Commands.cs:6051
#, csharp-format
msgid "{0} butchered {1} NPC."
msgid_plural "{0} butchered {1} NPCs."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2462
#, csharp-format
msgid "{0} caused it to rain slime."
msgstr ""

#: ../../TShockAPI/Commands.cs:2477
#, csharp-format
msgid "{0} caused it to rain."
msgstr ""

#: ../../TShockAPI/Commands.cs:1180
#, csharp-format
msgid "{0} changed account {1} to group {2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4466
#, csharp-format
msgid "{0} changed the maximum spawns to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4447
#, csharp-format
msgid "{0} changed the maximum spawns to 5."
msgstr ""

#: ../../TShockAPI/Commands.cs:1154
#, csharp-format
msgid "{0} changed the password for account {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:4505
#, csharp-format
msgid "{0} changed the spawn rate to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4487
#, csharp-format
msgid "{0} changed the spawn rate to 600."
msgstr ""

#: ../../TShockAPI/Commands.cs:4639
#, csharp-format
msgid "{0} changed the wind speed to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5853
#, csharp-format
msgid "{0} deleted {1} item within a radius of {2}."
msgid_plural "{0} deleted {1} items within a radius of {2}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:5877
#, csharp-format
msgid "{0} deleted {1} NPC within a radius of {2}."
msgid_plural "{0} deleted {1} NPCs within a radius of {2}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:5902
#, csharp-format
msgid "{0} deleted {1} projectile within a radius of {2}."
msgid_plural "{0} deleted {1} projectiles within a radius of {2}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:1887
#, csharp-format
msgid "{0} disabled halloween mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1907
#, csharp-format
msgid "{0} disabled xmas mode."
msgstr ""

#: ../../TShockAPI/TShock.cs:1434
#, csharp-format
msgid "{0} disconnected."
msgstr ""

#: ../../TShockAPI/Commands.cs:1885
#, csharp-format
msgid "{0} enabled halloween mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1905
#, csharp-format
msgid "{0} enabled xmas mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:2469
#, csharp-format
msgid "{0} ended the rain."
msgstr ""

#: ../../TShockAPI/Commands.cs:2454
#, csharp-format
msgid "{0} ended the slime rain."
msgstr ""

#: ../../TShockAPI/Commands.cs:706
#, csharp-format
msgid "{0} executed (args omitted): {1}{2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:704
#, csharp-format
msgid "{0} executed: {1}{2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:930
#, csharp-format
msgid "{0} failed to authenticate as user: {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6279
#, csharp-format
msgid "{0} gave you {1} {2}."
msgid_plural "{0} gave you {1} {2}s."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:4247
#, csharp-format
msgid "{0} has been allowed to place tile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3881
#, csharp-format
msgid "{0} has been allowed to use {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4071
#, csharp-format
msgid "{0} has been allowed to use projectile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4305
#, csharp-format
msgid "{0} has been disallowed from placing tile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4129
#, csharp-format
msgid "{0} has been disallowed from using projectile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3952
#, csharp-format
msgid "{0} has been disallowed to use {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6467
#, csharp-format
msgid "{0} has buffed you with {1} ({2}) for {3} seconds!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1186
#, csharp-format
msgid "{0} has changed your group to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2949
#: ../../TShockAPI/Commands.cs:3020
#: ../../TShockAPI/Commands.cs:3026
#, csharp-format
msgid "{0} has disabled incoming teleports."
msgstr ""

#: ../../TShockAPI/Commands.cs:2412
#, csharp-format
msgid "{0} has ended the current invasion event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2408
#, csharp-format
msgid "{0} has ended the Old One's Army event."
msgstr ""

#: ../../TShockAPI/TShock.cs:1706
#, csharp-format
msgid "{0} has joined."
msgstr ""

#: ../../TShockAPI/TShock.cs:1710
#, csharp-format
msgid "{0} has joined. IP: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5655
#, csharp-format
msgid "{0} has launched {1} into space."
msgstr ""

#: ../../TShockAPI/Commands.cs:5653
#, csharp-format
msgid "{0} has launched herself into space."
msgstr ""

#: ../../TShockAPI/Commands.cs:5651
#, csharp-format
msgid "{0} has launched himself into space."
msgstr ""

#: ../../TShockAPI/TShock.cs:1433
#, csharp-format
msgid "{0} has left."
msgstr ""

#: ../../TShockAPI/Commands.cs:5500
#, csharp-format
msgid "{0} has muted {1} for {2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5999
#, csharp-format
msgid "{0} has respawned you."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3596
#, csharp-format
msgid "{0} has sent a request to the bunny delivery service!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3602
#, csharp-format
msgid "{0} has sent a request to the cat delivery service!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3599
#, csharp-format
msgid "{0} has sent a request to the dog delivery service!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3593
#, csharp-format
msgid "{0} has sent a request to the slime delivery service!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2878
#, csharp-format
msgid "{0} has spawned {1} {2} time."
msgid_plural "{0} has spawned {1} {2} times."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2895
#, csharp-format
msgid "{0} has spawned a Wall of Flesh."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2655
#, csharp-format
msgid ""
"{0} has SSC data in the database, but has the tshock.ignore.ssc permission. "
"This means their SSC data is being ignored."
msgstr ""

#: ../../TShockAPI/Commands.cs:2342
#, csharp-format
msgid "{0} has started a goblin army invasion."
msgstr ""

#: ../../TShockAPI/Commands.cs:2396
#, csharp-format
msgid "{0} has started a martian invasion."
msgstr ""

#: ../../TShockAPI/Commands.cs:2354
#, csharp-format
msgid "{0} has started a pirate invasion."
msgstr ""

#: ../../TShockAPI/Commands.cs:2348
#, csharp-format
msgid "{0} has started a snow legion invasion."
msgstr ""

#: ../../TShockAPI/Commands.cs:5488
#, csharp-format
msgid "{0} has unmuted {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6356
#, csharp-format
msgid "{0} healed {1} for {2} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:6354
#, csharp-format
msgid "{0} healed herself for {1} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:6352
#, csharp-format
msgid "{0} healed himself for {1} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:4250
#, csharp-format
msgid "{0} is already allowed to place tile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3885
#, csharp-format
msgid "{0} is already allowed to use {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4074
#, csharp-format
msgid "{0} is already allowed to use projectile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5940
#, csharp-format
msgid "{0} is already dead!"
msgstr ""

#: ../../TShockAPI/Commands.cs:3956
#, csharp-format
msgid "{0} is already disallowed to use {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4309
#, csharp-format
msgid "{0} is already prevented from placing tile {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4133
#, csharp-format
msgid "{0} is already prevented from using projectile {1}."
msgstr ""

#: ../../TShockAPI/ItemBans.cs:234
#, csharp-format
msgid "{0} is banned! Remove it!"
msgstr ""

#: ../../TShockAPI/Commands.cs:6747
#, csharp-format
msgid "{0} is no longer in god mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:5546
#: ../../TShockAPI/Commands.cs:5577
#, csharp-format
msgid "{0} is not accepting whispers."
msgstr ""

#: ../../TShockAPI/Commands.cs:3875
#: ../../TShockAPI/Commands.cs:3946
#, csharp-format
msgid "{0} is not banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:5990
#, csharp-format
msgid "{0} is not dead!"
msgstr ""

#: ../../TShockAPI/Commands.cs:6746
#, csharp-format
msgid "{0} is now in god mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:5586
#, csharp-format
msgid "{0} is offline and cannot receive your reply."
msgstr ""

#: ../../TShockAPI/Commands.cs:5949
#: ../../TShockAPI/Rest/RestManager.cs:1068
#, csharp-format
msgid "{0} just killed you!"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2013
#, csharp-format
msgid "{0} kicked {1} for '{2}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:5746
#, csharp-format
msgid "{0} launched fireworks on you."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:847
#, csharp-format
msgid "{0} NPC has been killed."
msgid_plural "{0} NPCs have been killed."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:1058
#, csharp-format
msgid "{0} registered an account: \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:1478
#, csharp-format
msgid "{0} remaining."
msgstr ""

#: ../../TShockAPI/Commands.cs:6196
#, csharp-format
msgid "{0} renamed the {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4574
#, csharp-format
msgid "{0} set the time to {1}:{2:D2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4542
#, csharp-format
msgid "{0} set the time to 00:00."
msgstr ""

#: ../../TShockAPI/Commands.cs:4530
#, csharp-format
msgid "{0} set the time to 04:30."
msgstr ""

#: ../../TShockAPI/Commands.cs:4538
#, csharp-format
msgid "{0} set the time to 12:00."
msgstr ""

#: ../../TShockAPI/Commands.cs:4534
#, csharp-format
msgid "{0} set the time to 19:30."
msgstr ""

#: ../../TShockAPI/Commands.cs:4616
#: ../../TShockAPI/Commands.cs:4617
#, csharp-format
msgid "{0} slapped {1} for {2} damage."
msgstr ""

#: ../../TShockAPI/Commands.cs:2831
#, csharp-format
msgid "{0} spawned {1} {2} time."
msgid_plural "{0} spawned {1} {2} times."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2290
#, csharp-format
msgid "{0} started a blood moon event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2268
#, csharp-format
msgid "{0} started a full moon event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2500
#, csharp-format
msgid "{0} started a lantern night."
msgstr ""

#: ../../TShockAPI/Commands.cs:2427
#, csharp-format
msgid "{0} started a sandstorm event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2317
#, csharp-format
msgid "{0} started an eclipse."
msgstr ""

#: ../../TShockAPI/Commands.cs:2391
#, csharp-format
msgid "{0} started the frost moon at wave {1}!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4194
#: ../../TShockAPI/GetDataHandlers.cs:4196
#, csharp-format
msgid "{0} started the Old One's Army event!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2373
#, csharp-format
msgid "{0} started the pumpkin moon at wave {1}!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2321
#, csharp-format
msgid "{0} stopped an eclipse."
msgstr ""

#: ../../TShockAPI/Commands.cs:2294
#, csharp-format
msgid "{0} stopped the current blood moon."
msgstr ""

#: ../../TShockAPI/Commands.cs:2422
#, csharp-format
msgid "{0} stopped the current sandstorm event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2504
#, csharp-format
msgid "{0} stopped the lantern night."
msgstr ""

#: ../../TShockAPI/Commands.cs:1132
#, csharp-format
msgid "{0} successfully deleted account: {1}."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3608
#, csharp-format
msgid "{0} summoned a Blood Moon!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3620
#, csharp-format
msgid "{0} summoned a frost moon!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3632
#, csharp-format
msgid "{0} summoned a Goblin Invasion!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3614
#, csharp-format
msgid "{0} summoned a Martian invasion!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3590
#, csharp-format
msgid "{0} summoned a Mechdusa!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3611
#, csharp-format
msgid "{0} summoned a Moon Lord!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3623
#, csharp-format
msgid "{0} summoned a pumpkin moon!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3617
#, csharp-format
msgid "{0} summoned an eclipse!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3639
#, csharp-format
msgid "{0} summoned the {1}!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3016
#: ../../TShockAPI/GetDataHandlers.cs:3019
#, csharp-format
msgid "{0} summoned the Empress of Light!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3626
#, csharp-format
msgid "{0} summoned the Pirates!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3629
#, csharp-format
msgid "{0} summoned the Snow Legion!"
msgstr ""

#: ../../TShockAPI/Commands.cs:3004
#: ../../TShockAPI/Commands.cs:3044
#, csharp-format
msgid "{0} teleported {1} to you."
msgstr ""

#: ../../TShockAPI/Commands.cs:2956
#, csharp-format
msgid "{0} teleported to you."
msgstr ""

#: ../../TShockAPI/Commands.cs:2997
#: ../../TShockAPI/Commands.cs:3037
#, csharp-format
msgid "{0} teleported you to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:690
#, csharp-format
msgid "{0} tried to execute (args omitted) {1}{2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:688
#, csharp-format
msgid "{0} tried to execute {1}{2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2255
#, csharp-format
msgid "{0} triggered a meteor."
msgstr ""

#: ../../TShockAPI/Commands.cs:3328
#, csharp-format
msgid "{0} warped you to {1}."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2040
#, csharp-format
msgid "{0} was banned for '{1}'."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2011
#, csharp-format
msgid "{0} was kicked for '{1}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:3002
#: ../../TShockAPI/Commands.cs:3042
#, csharp-format
msgid "{0} was teleported to you."
msgstr ""

#: ../../TShockAPI/Commands.cs:1296
#, csharp-format
msgid "{0}'s group is {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1297
#, csharp-format
msgid "{0}'s last known IP is {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1286
#, csharp-format
msgid "{0}'s last login occurred {1} {2} UTC{3}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1298
#, csharp-format
msgid "{0}'s register date is {1} {2} UTC{3}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5778
#, csharp-format
msgid "{0}{1} defines no aliases."
msgstr ""

#: ../../TShockAPI/Commands.cs:5284
#, csharp-format
msgid "{0}{1} help: "
msgstr ""

#: ../../TShockAPI/Utils.cs:1152
#, csharp-format
msgid "{0}{1}/{2} on {3} @ {4}:{5} (TShock for Terraria v{6})"
msgstr ""

#: ../../TShockAPI/Commands.cs:850
#, csharp-format
msgid "{0}login - Authenticates you using your UUID and character name."
msgstr ""

#: ../../TShockAPI/Commands.cs:855
#, csharp-format
msgid ""
"{0}login <password> - Authenticates you using your password and character "
"name."
msgstr ""

#: ../../TShockAPI/Commands.cs:853
#, csharp-format
msgid ""
"{0}login <username> <password> - Authenticates you using your username and "
"password."
msgstr ""

#: ../../TShockAPI/Commands.cs:5413
#, csharp-format
msgid "{0}user add <username> <password> owner"
msgstr ""

#: ../../TShockAPI/Commands.cs:1205
#, csharp-format
msgid "{0}user add username password group   -- Adds a specified user"
msgstr ""

#: ../../TShockAPI/Commands.cs:1206
#, csharp-format
msgid "{0}user del username                  -- Removes a specified user"
msgstr ""

#: ../../TShockAPI/Commands.cs:1208
#, csharp-format
msgid "{0}user group username newgroup       -- Changes a user's group"
msgstr ""

#: ../../TShockAPI/Commands.cs:1207
#, csharp-format
msgid "{0}user password username newpassword -- Changes a user's password"
msgstr ""

#: ../../TShockAPI/Permissions.cs:547
#, csharp-format
msgid "* **Commands**: `{0}`"
msgstr ""

#: ../../TShockAPI/Configuration/ServerSideConfig.cs:123
#: ../../TShockAPI/Configuration/TShockConfig.cs:645
#, csharp-format
msgid "* **Default**: `{0}`"
msgstr ""

#: ../../TShockAPI/Configuration/ServerSideConfig.cs:122
#: ../../TShockAPI/Configuration/TShockConfig.cs:644
#, csharp-format
msgid "* **Field type**: `{0}`"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1220
#, csharp-format
msgid "* **Permissions**: `{0}`"
msgstr ""

#: ../../TShockAPI/Commands.cs:5430
#, csharp-format
msgid "*{0} {1}"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1253
#, csharp-format
msgid "**Example Usage**: `{0}?{1}`"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1243
msgid "**Nouns**:"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1230
msgid "**Verbs**:"
msgstr ""

#: ../../TShockAPI/Commands.cs:1613
#, csharp-format
msgid "#{0} - You have been banned: {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5446
#, csharp-format
msgid "<{0}> {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5550
#: ../../TShockAPI/Commands.cs:5581
#, csharp-format
msgid "<From {0}> {1}"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:187
#, csharp-format
msgid "<green>{0} <black>from <blue>{1} <black>[{2}]"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:178
#, csharp-format
msgid "<green>{0}<black> from <blue>{1} <black>[{2}]"
msgstr ""

#: ../../TShockAPI/Commands.cs:5551
#: ../../TShockAPI/Commands.cs:5582
#, csharp-format
msgid "<To {0}> {1}"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:136
#, csharp-format
msgid "=== Dependency ==="
msgid_plural "=== Dependencies ==="
msgstr[0] ""
msgstr[1] ""

#: ../../TShockPluginManager/NugetCLI.cs:133
#, csharp-format
msgid "=== Requested Plugin ==="
msgid_plural "=== Requested Plugins ==="
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2818
msgid "a Deerclops"
msgstr ""

#: ../../TShockAPI/Commands.cs:3384
msgid "A group with the same name already exists."
msgstr ""

#: ../../TShockAPI/DB/RegionManager.cs:108
msgid ""
"A lot of things will fail because of this. You must manually delete and "
"re-create the allowed field."
msgstr ""

#: ../../TShockAPI/TShock.cs:1022
msgid ""
"A malicious server can easily steal a user's UUID. You may consider turning "
"this option off if you run a public server."
msgstr ""

#: ../../TShockAPI/Commands.cs:2793
msgid "a Martian Saucer"
msgstr ""

#: ../../TShockAPI/Commands.cs:2251
msgid "A meteor has been triggered."
msgstr ""

#: ../../TShockAPI/Commands.cs:2803
msgid "a Nebula Pillar"
msgstr ""

#: ../../TShockAPI/TShock.cs:1010
msgid "A password for this server was set in config.json and is being used."
msgstr ""

#: ../../TShockAPI/Commands.cs:1316
msgid "A player name must be provided to kick a player. Please provide one."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2486
msgid "A plugin on this server stopped your login."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:120
#, csharp-format
msgid ""
"A REST login from {0} was blocked as it currently has {1} rate-limit tokens "
"and is at the RESTMaximumRequestsPerInterval threshold."
msgstr ""

#: ../../TShockAPI/Commands.cs:2798
msgid "a Solar Pillar"
msgstr ""

#: ../../TShockAPI/Commands.cs:2813
msgid "a Stardust Pillar"
msgstr ""

#: ../../TShockAPI/Commands.cs:864
msgid "A user account by that name does not exist."
msgstr ""

#: ../../TShockAPI/Commands.cs:2808
msgid "a Vortex Pillar"
msgstr ""

#: ../../TShockAPI/Commands.cs:1159
#, csharp-format
msgid "Account {0} does not exist! Therefore, the password cannot be changed."
msgstr ""

#: ../../TShockAPI/Commands.cs:1105
#, csharp-format
msgid "Account {0} has been added to group {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1181
#, csharp-format
msgid "Account {0} has been changed to group {1}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:547
#, csharp-format
msgid "Account needed! Please {0}register or {0}login to play!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1131
msgid "Account removed successfully."
msgstr ""

#: ../../TShockAPI/Commands.cs:2094
msgid "Active REST Users ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:3971
msgid "add <item> - Adds an item ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:3438
msgid "add <name> <permissions...> - Adds a new group."
msgstr ""

#: ../../TShockAPI/Commands.cs:4149
msgid "add <projectile ID> - Adds a projectile ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:4325
msgid "add <tile ID> - Adds a tile ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:1737
#, csharp-format
msgid "Added {0} to the whitelist."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2041
#, csharp-format
msgid "Added buff to {0} NPC abnormally."
msgstr ""

#: ../../TShockAPI/Commands.cs:4855
#, csharp-format
msgid "Added group {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4785
#, csharp-format
msgid "Added user {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3439
msgid "addperm <group> <permissions...> - Adds permissions to a group."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:81
#, csharp-format
msgid "AddUser SQL returned an error ({0})"
msgstr ""

#: ../../TShockAPI/Commands.cs:5776
#, csharp-format
msgid "Aliases of {0}{1}: {0}{2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6013
msgid ""
"All alive NPCs (excluding town NPCs) on the server will be killed if you do "
"not input a name or ID."
msgstr ""

#: ../../TShockAPI/Commands.cs:2626
msgid "all bosses"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:169
msgid "All done! :)"
msgstr ""

#: ../../TShockAPI/Commands.cs:2104
msgid "All REST tokens have been destroyed."
msgstr ""

#: ../../TShockAPI/Commands.cs:1223
#, csharp-format
msgid "Allocated memory: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3972
msgid "allow <item> <group> - Allows a group to use an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:4150
msgid "allow <projectile ID> <group> - Allows a group to use a projectile."
msgstr ""

#: ../../TShockAPI/Commands.cs:4326
msgid "allow <tile ID> <group> - Allows a group to place a tile."
msgstr ""

#: ../../TShockAPI/Commands.cs:5193
msgid "allow <user> <region> - Allows a user to a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:5195
msgid "allowg <group> <region> - Allows a user group to a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:6670
msgid "Amber Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:6650
msgid "Amethyst Gemtree"
msgstr ""

#: ../../TShockAPI/TShock.cs:1032
msgid ""
"An account has been detected in the user database, but setup-code.txt is "
"still present."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:474
#, csharp-format
msgid "An exception has occurred during database rollback: {0}"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:467
#, csharp-format
msgid "An exception has occurred during database transaction: {0}"
msgstr ""

#: ../../TShockAPI/TShock.cs:1525
msgid "An exception occurred executing a command."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:644
msgid "An identifier for a character name."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:648
msgid "An identifier for a TShock User Account name."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:640
msgid "An identifier for a UUID."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:636
#, csharp-format
msgid "An identifier for an IP Address in octet format. e.g., '{0}'."
msgstr ""

#: ../../TShockAPI/Commands.cs:2052
msgid ""
"An update check has been queued. If an update is available, you will be "
"notified shortly."
msgstr ""

#: ../../TShockAPI/Commands.cs:5599
msgid "Annoy Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:5616
#, csharp-format
msgid "Annoying {0} for {1} seconds."
msgstr ""

#: ../../TShockAPI/Commands.cs:338
msgid "Annoys a player for an amount of time."
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:452
#, csharp-format
msgid "Anonymous requested REST endpoint: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5224
msgid "Anti-build is now off."
msgstr ""

#: ../../TShockAPI/Commands.cs:5224
msgid "Anti-build is now on."
msgstr ""

#: ../../TShockAPI/Commands.cs:3204
msgid "Arguments: add [warp name], del [warp name], list [page]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3205
msgid ""
"Arguments: send [player] [warp name], hide [warp name] [Enable(true/false)]."
msgstr ""

#: ../../TShockAPI/Commands.cs:903
#: ../../TShockAPI/GetDataHandlers.cs:2671
#: ../../TShockAPI/GetDataHandlers.cs:3251
#, csharp-format
msgid "Authenticated as {0} successfully."
msgstr ""

#: ../../TShockAPI/TShock.cs:471
#: ../../TShockAPI/TShock.cs:1626
msgid "AutoSave Disabled"
msgstr ""

#: ../../TShockAPI/TShock.cs:469
#: ../../TShockAPI/TShock.cs:1624
msgid "AutoSave Enabled"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:811
msgid "AutoSave has been disabled"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:807
msgid "AutoSave has been enabled"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:800
msgid "Autosave is currently disabled"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:796
msgid "Autosave is currently enabled"
msgstr ""

#: ../../TShockAPI/Commands.cs:1368
msgid "Available Ban commands:"
msgstr ""

#: ../../TShockAPI/Commands.cs:1432
msgid "Available identifiers ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:5208
msgid "Available Region Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:2109
msgid "Available REST Sub-Commands:"
msgstr ""

#: ../../TShockAPI/BackupManager.cs:75
msgid "Backing up world..."
msgstr ""

#: ../../TShockAPI/BackupManager.cs:87
#: ../../TShockAPI/BackupManager.cs:89
msgid "Backup failed!"
msgstr ""

#: ../../TShockAPI/BackupManager.cs:51
msgid "Backup Thread"
msgstr ""

#: ../../TShockAPI/TShock.cs:475
msgid "Backups Disabled"
msgstr ""

#: ../../TShockAPI/TShock.cs:473
msgid "Backups Enabled"
msgstr ""

#: ../../TShockAPI/Commands.cs:837
msgid "Bad login attempt."
msgstr ""

#: ../../TShockAPI/Commands.cs:1371
#, csharp-format
msgid "ban {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1370
#: ../../TShockAPI/Commands.cs:1372
#, csharp-format
msgid "ban {0} <Ban ID>"
msgstr ""

#: ../../TShockAPI/Commands.cs:1369
#, csharp-format
msgid "ban {0} <Target> [Flags]"
msgstr ""

#: ../../TShockAPI/Commands.cs:1633
#, csharp-format
msgid "Ban {0} has been revoked by {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1634
#, csharp-format
msgid "Ban {0} has now been marked as expired."
msgstr ""

#: ../../TShockAPI/Commands.cs:1383
msgid "Ban Add Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1490
#, csharp-format
msgid "Ban added. Ticket Number {0} was created for identifier {1}."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:668
#, csharp-format
msgid "Ban added. Ticket number: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1396
msgid "Ban Del Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1412
msgid "Ban Details Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1404
msgid "Ban List Syntax"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:695
msgid "Ban removed."
msgstr ""

#: ../../TShockAPI/Commands.cs:1442
msgid "Ban Usage Examples"
msgstr ""

#: ../../TShockAPI/Commands.cs:3841
#, csharp-format
msgid "Banned {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4037
#, csharp-format
msgid "Banned projectile {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4213
#, csharp-format
msgid "Banned tile {0}."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2037
#, csharp-format
msgid "Banned: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1517
msgid "Banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:1670
msgid "Bans ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:6592
msgid "Basic Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:2755
msgid "Betsy"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:889
#, csharp-format
msgid "Blood Moon has been set to {0}"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:904
#, csharp-format
msgid "Bloodmoon state: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6596
msgid "Boreal Tree"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3304
#, csharp-format
msgid "Bouncer / HandleNpcTalk rejected from bouncer out of bounds from {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3297
#, csharp-format
msgid "Bouncer / HandleNpcTalk rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1465
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from chest mismatch from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1472
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from disable from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1487
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1480
#, csharp-format
msgid "Bouncer / OnChestItemChange rejected from region protection? from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1500
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1507
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1514
#, csharp-format
msgid "Bouncer / OnChestOpen rejected from region check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2738
#, csharp-format
msgid ""
"Bouncer / OnFishOutNPC rejected for not finding active bobber projectile! - "
"From {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2732
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected for not using a fishing rod! - From {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2744
#, csharp-format
msgid ""
"Bouncer / OnFishOutNPC rejected for the NPC not being on the fishable NPCs "
"list! - From {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2756
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2750
#, csharp-format
msgid "Bouncer / OnFishOutNPC rejected summon boss permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2784
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2777
#, csharp-format
msgid ""
"Bouncer / OnFoodPlatterTryPlacing rejected item not placed by hand from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2795
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2806
#, csharp-format
msgid "Bouncer / OnFoodPlatterTryPlacing rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2770
#, csharp-format
msgid ""
"Bouncer / OnFoodPlatterTryPlacing rejected tile placement valid from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2508
#, csharp-format
msgid "Bouncer / OnGemLockToggle invalid placement/deadmod from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2501
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected boundaries check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2515
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2524
#, csharp-format
msgid "Bouncer / OnGemLockToggle rejected permissions check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:453
msgid "Bouncer / OnGetSection rejected empty player name."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:445
#, csharp-format
msgid "Bouncer / OnGetSection rejected GetSection packet from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2096
#, csharp-format
msgid "Bouncer / OnHealOtherPlayer 0.2 check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2120
#, csharp-format
msgid "Bouncer / OnHealOtherPlayer rejected disabled/throttled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2112
#, csharp-format
msgid ""
"Bouncer / OnHealOtherPlayer rejected heal other threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2086
msgid "Bouncer / OnHealOtherPlayer rejected null checks"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1074
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from attempt crash from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1150
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1130
#, csharp-format
msgid ""
"Bouncer / OnItemDrop rejected from drop item ban check / max stack check / "
"min stack check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1099
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from dupe range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1120
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from item drop/pickup check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1084
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from prefix check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1110
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1141
#, csharp-format
msgid "Bouncer / OnItemDrop rejected from sneaky from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2706
#, csharp-format
msgid "Bouncer / OnKillMe rejected bad length death text from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2713
#, csharp-format
msgid "Bouncer / OnKillMe rejected custom death message from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2687
#, csharp-format
msgid "Bouncer / OnKillMe rejected high damage from {0} {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2696
#, csharp-format
msgid "Bouncer / OnKillMe rejected index check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1832
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected build permission from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1676
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1694
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected from liquid threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1669
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected invalid check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1731
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected liquid type {0} from {1} holding {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1840
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1848
#, csharp-format
msgid "Bouncer / OnLiquidSet rejected throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2573
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected build perms from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2566
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2559
#, csharp-format
msgid "Bouncer / OnMassWireOperation rejected valid placement from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1274
#, csharp-format
msgid ""
"Bouncer / OnNewProjectile please report to tshock about this! normally this "
"is a reject from {0} {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1230
#, csharp-format
msgid ""
"Bouncer / OnNewProjectile please report to tshock about this! normally this "
"is a reject from {0} {1} (golf)"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1174
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from above projectile limit from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1315
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from bouncer modified AI from {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1331
#, csharp-format
msgid ""
"Bouncer / OnNewProjectile rejected from bouncer modified Zenith projectile "
"from {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1302
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1201
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1238
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from hostile projectile from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1183
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from permission check from {0} {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1294
#, csharp-format
msgid ""
"Bouncer / OnNewProjectile rejected from projectile create threshold from {0} "
"{1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1193
#, csharp-format
msgid ""
"Bouncer / OnNewProjectile rejected from projectile damage limit from {0} "
"{1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1249
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from tombstones from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1269
#, csharp-format
msgid "Bouncer / OnNewProjectile rejected from weird check from {0} {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2040
#, csharp-format
msgid ""
"Bouncer / OnNPCAddBuff rejected abnormal buff ({0}, last for {4}) added to "
"{1} ({2}) from {3}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1994
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1987
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected null npc from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1978
#, csharp-format
msgid "Bouncer / OnNPCAddBuff rejected out of bounds NPC update from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1416
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1391
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from damage threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1399
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1408
#, csharp-format
msgid "Bouncer / OnNPCStrike rejected from range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1550
#, csharp-format
msgid "Bouncer / OnPlaceChest / rejected from invalid place style from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1542
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1535
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from invalid check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1583
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from invalid permission from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1591
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from range check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1562
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from weird check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1573
#, csharp-format
msgid "Bouncer / OnPlaceChest rejected from weird placement check from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2440
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2448
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2456
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2433
#, csharp-format
msgid "Bouncer / OnPlaceItemFrame rejected tile placement valid from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2313
#, csharp-format
msgid ""
"Bouncer / OnPlaceObject rejected awkward tile creation/selection from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2300
#, csharp-format
msgid ""
"Bouncer / OnPlaceObject rejected Axe of Regrowth only places saplings {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2261
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected banned tiles from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2270
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected dead people don't do things from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2278
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2252
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected fake containers from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2351
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected mad loop from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2336
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected null tile data from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2325
#, csharp-format
msgid ""
"Bouncer / OnPlaceObject rejected object placement with invalid style {1} "
"(expected {2}) from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2229
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2236
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile x from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2243
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected out of bounds tile y from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2367
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2289
#, csharp-format
msgid ""
"Bouncer / OnPlaceObject rejected rubblemaker I can't believe it's not rubble! "
"from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2375
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected tile place threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2222
#, csharp-format
msgid "Bouncer / OnPlaceObject rejected valid placements from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2406
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2413
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected permissions from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2420
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2399
#, csharp-format
msgid "Bouncer / OnPlaceTileEntity rejected tile placement valid from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1642
#, csharp-format
msgid "Bouncer / OnPlayerAnimation rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1650
#, csharp-format
msgid "Bouncer / OnPlayerAnimation rejected from throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1960
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: buff cannot be applied for that long"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1942
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: buff cannot be applied to non-senders"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1951
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: buff cannot be applied without pvp"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1933
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: buff is not whitelisted"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1893
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: invalid buff type"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1902
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: sender is being disabled"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1911
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: sender is being throttled"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1924
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: sender is not in range of target"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1875
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: target ID out of bounds"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1884
#, csharp-format
msgid ""
"Bouncer / OnPlayerBuff rejected {0} ({1}) applying buff {2} to {3} for {4} "
"ticks: target is null"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2670
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected custom death message from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2603
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected damage threshold from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2610
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected damage threshold2 from {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2630
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2621
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected hostile from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2594
msgid "Bouncer / OnPlayerDamage rejected null check"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2639
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2648
#, csharp-format
msgid "Bouncer / OnPlayerDamage rejected throttled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2488
#, csharp-format
msgid "Bouncer / OnPlayerPortalTeleport rejected disabled/throttled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2480
#, csharp-format
msgid ""
"Bouncer / OnPlayerPortalTeleport rejected teleport out of bounds from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2469
#, csharp-format
msgid ""
"Bouncer / OnPlayerPortalTeleport rejected untargetable teleport from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:517
#, csharp-format
msgid ""
"Bouncer / OnPlayerUpdate *would have rejected* from (last network position "
"zero) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:495
#, csharp-format
msgid ""
"Bouncer / OnPlayerUpdate force kicked (attempted to set velocity +/- 50000) "
"from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:479
#, csharp-format
msgid ""
"Bouncer / OnPlayerUpdate force kicked (attempted to set velocity to infinity) "
"from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:487
#, csharp-format
msgid ""
"Bouncer / OnPlayerUpdate force kicked (attempted to set velocity to NaN) from "
"{0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:561
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (??) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:565
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (below ??) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:573
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (corpses don't move) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:510
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (inventory length) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:503
#, csharp-format
msgid "Bouncer / OnPlayerUpdate rejected from (position check) {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1628
#, csharp-format
msgid "Bouncer / OnPlayerZone rejected from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1445
#, csharp-format
msgid "Bouncer / OnProjectileKill rejected from bouncer throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1437
#, csharp-format
msgid "Bouncer / OnProjectileKill rejected from disabled from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1430
#, csharp-format
msgid ""
"Bouncer / OnProjectileKill rejected from negative projectile index from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2153
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected npc release from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2145
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected out of bounds from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2204
#, csharp-format
msgid "Bouncer / OnReleaseNPC rejected throttle from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2160
#, csharp-format
msgid "Bouncer / OnReleaseNPC released different critter from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:700
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (axe) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:804
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (chestcap) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:708
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (hammer) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:737
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (hammer2) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:756
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from (inconceivable rope coil) {0} {1} {2} "
"selectedItem:{3} itemCreateTile:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:767
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (ms1) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:639
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (pdm) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:725
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (pick) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:675
#: ../../TShockAPI/Bouncer.cs:686
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from (placestyle) {0} {1} {2} placeStyle: {3} "
"expectedStyle: {4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:653
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (tb) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:603
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from (tile placement valid) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:848
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from actuator/presserator from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:612
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from build from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:869
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from disable from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:624
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from editData out of bounds {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:908
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from explosives/fuses from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:878
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from ice/build from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:823
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from place wire from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:858
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from sts allow cut from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:952
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from throttled from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:926
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from tile kill threshold from {0}, (value: {1})"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:944
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from tile place threshold from {0}, (value: "
"{1})"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:786
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from tile placement not matching selected item "
"createTile {0} {1} {2} selectedItemID:{3} createTile:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:776
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from using ice rod but not placing ice block "
"{0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:795
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from wall placement not matching selected item "
"createWall {0} {1} {2} selectedItemID:{3} createWall:{4}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:985
#, csharp-format
msgid ""
"Bouncer / OnTileEdit rejected from weird confusing flow control from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:837
#, csharp-format
msgid "Bouncer / OnTileEdit rejected from wire cutter from {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:632
#, csharp-format
msgid "Bouncer / OnTileEdit super accepted from (ice block) {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2060
#, csharp-format
msgid "Bouncer / OnUpdateNPCHome rejected npc home build permission from {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2070
#, csharp-format
msgid "Bouncer / OnUpdateNPCHome rejected range checks from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:413
#, csharp-format
msgid "Bouncer / SendTileRect accepted clientside world edit from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:468
#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:488
#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:500
#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:511
#, csharp-format
msgid "Bouncer / SendTileRect reimplemented from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:446
#, csharp-format
msgid "Bouncer / SendTileRect rejected from being disabled from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:518
#, csharp-format
msgid "Bouncer / SendTileRect rejected from matches from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:459
#, csharp-format
msgid ""
"Bouncer / SendTileRect rejected from out of bounds / build permission from "
"{0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:478
#, csharp-format
msgid "Bouncer / SendTileRect rejected from out of range from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:427
#, csharp-format
msgid "Bouncer / SendTileRect rejected from size from {0}"
msgstr ""

#: ../../TShockAPI/Handlers/SendTileRectHandler.cs:436
#, csharp-format
msgid "Bouncer / SendTileRect rejected from throttle from {0}"
msgstr ""

#: ../../TShockAPI/Utils.cs:136
#, csharp-format
msgid "Broadcast: {0}"
msgstr ""

#: ../../TShockAPI/Utils.cs:159
#, csharp-format
msgid "Broadcast: {0}: {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:272
msgid "Broadcasts a message to everyone on the server."
msgstr ""

#: ../../TShockAPI/Commands.cs:6367
msgid "Buff Syntax and Example"
msgstr ""

#: ../../TShockAPI/Commands.cs:6010
msgid "Butcher Syntax and Example"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2654
msgid ""
"Bypass SSC is enabled for your account. SSC data will not be loaded or saved."
msgstr ""

#: ../../TShockAPI/Commands.cs:6676
msgid "Cactus"
msgstr ""

#: ../../TShockAPI/DB/IQueryBuilder.cs:319
msgid ""
"Can't set to true SqlColumn.DefaultCurrentTimestamp when the MySqlDbType is "
"not DateTime"
msgstr ""

#: ../../TShockAPI/Modules/ModuleManager.cs:56
#, csharp-format
msgid "Cannot load module {0} as it does not derive from {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1270
msgid "Certain projectiles have been ignored for cheat detection."
msgstr ""

#: ../../TShockAPI/Commands.cs:4462
#, csharp-format
msgid "Changed the maximum spawns to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4443
msgid "Changed the maximum spawns to 5."
msgstr ""

#: ../../TShockAPI/Commands.cs:4501
#, csharp-format
msgid "Changed the spawn rate to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4483
msgid "Changed the spawn rate to 600."
msgstr ""

#: ../../TShockAPI/Commands.cs:368
msgid "Changes the server password."
msgstr ""

#: ../../TShockAPI/Commands.cs:522
msgid "Changes the wind speed."
msgstr ""

#: ../../TShockAPI/Commands.cs:467
msgid "Changes the world mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:252
msgid "Changes your account's password."
msgstr ""

#: ../../TShockAPI/Commands.cs:3646
#, csharp-format
msgid "Chat color for \"{0}\" is \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3632
#, csharp-format
msgid "Chat color for group \"{0}\" set to \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:352
msgid "Checks for TShock updates."
msgstr ""

#: ../../TShockAPI/Commands.cs:5186
msgid "clear - Clears the temporary region points."
msgstr ""

#: ../../TShockAPI/Commands.cs:5814
msgid "Clear Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:2531
msgid "Cleared all users from the angler quest completion list for today."
msgstr ""

#: ../../TShockAPI/Commands.cs:537
msgid "Clears item drops or projectiles."
msgstr ""

#: ../../TShockAPI/Commands.cs:3440
msgid "color <group> <rrr,ggg,bbb> - Changes a group's chat color."
msgstr ""

#: ../../TShockAPI/Commands.cs:5329
#, csharp-format
msgid "Command aliases: {0}, {1}, {2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:162
msgid "Command failed, check logs for more details."
msgstr ""

#: ../../TShockAPI/Commands.cs:5260
msgid "Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:3203
msgid "Commands: add, del, hide, list, send, [warpname]."
msgstr ""

#: ../../TShockAPI/TShock.cs:801
#, csharp-format
msgid "Config path has been set to {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:4395
msgid ""
"Configuration, permissions, and regions reload complete. Some changes may "
"require a server restart."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:100
msgid "Connect to the internet to figure out what to download?"
msgstr ""

#: ../../TShockAPI/TShock.cs:1365
msgid "Connecting via a proxy is not allowed."
msgstr ""

#: ../../TShockAPI/Commands.cs:1778
#, csharp-format
msgid "Correct usage: {0}overridessc|{0}ossc <player name>"
msgstr ""

#: ../../TShockAPI/Commands.cs:6641
msgid "Corruption Palm"
msgstr ""

#: ../../TShockAPI/TShock.cs:300
#, csharp-format
msgid ""
"Could not apply the given log path / log format, defaults will be used. "
"Exception details:\n"
"{0}"
msgstr ""

#: ../../TShockAPI/DB/ResearchDatastore.cs:54
#: ../../TShockAPI/DB/BanManager.cs:82
msgid "Could not find a database library (probably Sqlite3.dll)"
msgstr ""

#: ../../TShockAPI/Commands.cs:3268
#, csharp-format
msgid "Could not find a warp named {0} to remove."
msgstr ""

#: ../../TShockAPI/Commands.cs:5526
#: ../../TShockAPI/Commands.cs:5610
#: ../../TShockAPI/Commands.cs:5635
#: ../../TShockAPI/Commands.cs:5691
#: ../../TShockAPI/Commands.cs:5972
#, csharp-format
msgid "Could not find any player named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:5928
#, csharp-format
msgid "Could not find any player named \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:5471
#, csharp-format
msgid "Could not find any players named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:1934
#, csharp-format
msgid "Could not find group {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1923
#, csharp-format
msgid "Could not find player {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5044
msgid "Could not find specified region"
msgstr ""

#: ../../TShockAPI/Commands.cs:3291
msgid "Could not find specified warp."
msgstr ""

#: ../../TShockAPI/Commands.cs:4723
#: ../../TShockAPI/Commands.cs:4730
#: ../../TShockAPI/Commands.cs:4749
#: ../../TShockAPI/Commands.cs:4788
#: ../../TShockAPI/Commands.cs:4823
#: ../../TShockAPI/Commands.cs:4858
#: ../../TShockAPI/Commands.cs:4893
#: ../../TShockAPI/Commands.cs:4937
#, csharp-format
msgid "Could not find the region {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1581
msgid ""
"Could not find the target specified. Check that you have the correct "
"spelling."
msgstr ""

#: ../../TShockAPI/Commands.cs:6200
#, csharp-format
msgid "Could not rename {0}!"
msgstr ""

#: ../../TShockAPI/TShock.cs:1484
msgid "Crash attempt via long chat packet."
msgstr ""

#: ../../TShockAPI/Commands.cs:595
msgid ""
"Creates a reference tables for Terraria data types and the TShock permission "
"system in the server folder."
msgstr ""

#: ../../TShockAPI/Commands.cs:5414
msgid ""
"Creates: <username> with the password <password> as part of the owner group."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:53
msgid ""
"CreativePowerHandler received permission check request for unknown creative "
"power"
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:65
#, csharp-format
msgid ""
"CreativeUnlocksHandler received non-vanilla unlock request. Random field "
"value: {0} but should be 0 from {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6636
msgid "Crimson Palm"
msgstr ""

#: ../../TShockAPI/Commands.cs:4434
#, csharp-format
msgid "Current maximum spawns: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4474
#, csharp-format
msgid "Current spawn rate: {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2689
#, csharp-format
msgid "Death Exploit Attempt: Damage {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2707
msgid "Death reason outside of normal bounds."
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:321
#: ../../TShockAPI/Configuration/TShockConfig.cs:357
msgid "Death results in a ban"
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:349
msgid "Death results in a kick"
msgstr ""

#: ../../TShockAPI/Commands.cs:5187
msgid "define <name> - Defines the region with the given name."
msgstr ""

#: ../../TShockAPI/Commands.cs:3442
msgid "del <group> - Deletes a group."
msgstr ""

#: ../../TShockAPI/Commands.cs:3973
msgid "del <item> - Deletes an item ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:4151
msgid "del <projectile ID> - Deletes an projectile ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:4327
msgid "del <tile ID> - Deletes a tile ban."
msgstr ""

#: ../../TShockAPI/Commands.cs:5188
msgid "delete <name> - Deletes the given region."
msgstr ""

#: ../../TShockAPI/Commands.cs:4746
#, csharp-format
msgid "Deleted region \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3443
msgid "delperm <group> <permissions...> - Removes permissions from a group."
msgstr ""

#: ../../TShockAPI/Commands.cs:6627
msgid "Desert Palm"
msgstr ""

#: ../../TShockAPI/Commands.cs:2111
msgid "destroytokens - Destroys all current REST tokens."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:480
#: ../../TShockAPI/Bouncer.cs:488
#: ../../TShockAPI/Bouncer.cs:496
msgid "Detected DOOM set to ON position."
msgstr ""

#: ../../TShockAPI/Commands.cs:6666
msgid "Diamond Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:1881
msgid "Disabled halloween mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1900
msgid "Disabled xmas mode."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:543
#, csharp-format
msgid "Disabled. You need to {0}login to load your saved data."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:539
msgid "Disabled. You went too far with banned armor."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:535
msgid "Disabled. You went too far with hacked item stacks."
msgstr ""

#: ../../TShockAPI/Commands.cs:3974
msgid "disallow <item> <group> - Disallows a group from using an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:4152
msgid ""
"disallow <projectile ID> <group> - Disallows a group from using a projectile."
msgstr ""

#: ../../TShockAPI/Commands.cs:4328
msgid "disallow <tile ID> <group> - Disallows a group from place a tile."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:140
#: ../../TShockPluginManager/NugetCLI.cs:161
msgid "Download and install the given packages?"
msgstr ""

#: ../../TShockAPI/Commands.cs:2648
msgid "Duke Fishron"
msgstr ""

#: ../../TShockAPI/Commands.cs:6617
msgid "Ebonwood Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:6658
msgid "Emerald Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:1879
msgid "Enabled halloween mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1898
msgid "Enabled xmas mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:488
msgid "Enables starting and stopping various world events."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:665
#, csharp-format
msgid "Error on reloading groups: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5119
msgid "Error: both names are the same."
msgstr ""

#: ../../TShockAPI/Commands.cs:2777
msgid "Everscream"
msgstr ""

#: ../../TShockAPI/Commands.cs:1407
#, csharp-format
msgid "Example usage: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5463
#, csharp-format
msgid "Example usage: {0} \"{1}\" \"{2}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:6369
#, csharp-format
msgid "Example usage: {0} \"{1}\" {2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1399
#: ../../TShockAPI/Commands.cs:1415
#: ../../TShockAPI/Commands.cs:5330
#: ../../TShockAPI/Commands.cs:5629
#: ../../TShockAPI/Commands.cs:5919
#: ../../TShockAPI/Commands.cs:6012
#, csharp-format
msgid "Example usage: {0} {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5520
#: ../../TShockAPI/Commands.cs:5685
#: ../../TShockAPI/Commands.cs:5816
#: ../../TShockAPI/Commands.cs:6309
#, csharp-format
msgid "Example usage: {0} {1} {2}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6419
#, csharp-format
msgid "Example usage: {0} {1} {2} {3}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1391
#, csharp-format
msgid "Example usage: {0} {1} {2} {3} {4}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5601
#, csharp-format
msgid "Example usage: {0} <{1}> <{2}>"
msgstr ""

#: ../../TShockAPI/Commands.cs:2002
msgid "Example: /sudo /ban add particles 2d Hacking."
msgstr ""

#: ../../TShockAPI/Commands.cs:3206
#, csharp-format
msgid "Examples: {0}warp add foobar, {0}warp hide foobar true, {0}warp foobar."
msgstr ""

#: ../../TShockAPI/Commands.cs:328
msgid "Executes a command as the super admin."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4416
msgid "Exploit attempt detected!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1494
#, csharp-format
msgid "Failed to add ban for identifier: {0}."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:671
#, csharp-format
msgid "Failed to add ban. {0}"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:324
#, csharp-format
msgid "Failed to add group {0}."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:512
#: ../../TShockAPI/DB/GroupManager.cs:513
#, csharp-format
msgid "Failed to delete group {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2524
msgid "Failed to find any users by that name on the list."
msgstr ""

#: ../../TShockAPI/Commands.cs:1638
#: ../../TShockAPI/Rest/RestManager.cs:698
msgid "Failed to remove ban."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:480
#, csharp-format
msgid "Failed to rename group {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5145
msgid "Failed to rename the region."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2688
msgid "Failed to shade polygon normals."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:369
#, csharp-format
msgid "Failed to update group \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:1864
msgid ""
"Failed to upload your character data to the server. Are you logged-in to an "
"account?"
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:245
msgid "Fatal Startup Exception"
msgstr ""

#: ../../TShockAPI/Extensions/DbExt.cs:79
msgid ""
"Fatal TShock initialization exception: failed to connect to MySQL database. "
"See inner exception for details."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:218
#, csharp-format
msgid "FetchHashedPasswordAndGroup SQL returned an error: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5683
msgid "Firework Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1944
msgid ""
"For example, 1d and 10h-30m+2m are both valid time strings, but 2 is not."
msgstr ""

#: ../../TShockAPI/Commands.cs:1374
#, csharp-format
msgid "For more info, use {0} {1} or {2} {3}"
msgstr ""

#: ../../TShockAPI/Commands.cs:514
msgid "Forces all liquids to update immediately."
msgstr ""

#: ../../TShockAPI/Commands.cs:6278
#, csharp-format
msgid "Gave {0} {1} {2}."
msgid_plural "Gave {0} {1} {2}s."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:6140
#, csharp-format
msgid "Gave {0} {1}."
msgid_plural "Gave {0} {1}s."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/GetDataHandlers.cs:3839
#, csharp-format
msgid "GetDataHandlers / HandleCatchNpc catch zero {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3847
#, csharp-format
msgid "GetDataHandlers / HandleCatchNpc rejected catch npc {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3158
#, csharp-format
msgid ""
"GetDataHandlers / HandleChestActive rejected build permission and region "
"check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3133
#, csharp-format
msgid "GetDataHandlers / HandleChestItem rejected max stacks {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2881
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected door gap check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2866
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected out of range door {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2872
#, csharp-format
msgid "GetDataHandlers / HandleDoorUse rejected type 0 5 check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2704
msgid "GetDataHandlers / HandleGetSection rejected reserve slot"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4086
#, csharp-format
msgid "GetDataHandlers / HandleKillPortal rejected owner mismatch check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3028
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected Cultist summon from {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3011
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected EoL summon from {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3001
#, csharp-format
msgid "GetDataHandlers / HandleNpcStrike rejected npc strike {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3290
#, csharp-format
msgid "GetDataHandlers / HandleNpcTalk rejected npc talk {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4130
#, csharp-format
msgid ""
"GetDataHandlers / HandleNpcTeleportPortal rejected not thinking with portals "
"{0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4123
#, csharp-format
msgid "GetDataHandlers / HandleNpcTeleportPortal rejected null check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3963
#, csharp-format
msgid ""
"GetDataHandlers / HandleNumberOfAnglerQuestsCompleted surprise packet! "
"Someone tell the TShock team! {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4188
#, csharp-format
msgid "GetDataHandlers / HandleOldOnesArmy rejected permissions {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4182
#, csharp-format
msgid "GetDataHandlers / HandleOldOnesArmy rejected throttled {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3664
#, csharp-format
msgid "GetDataHandlers / HandlePaintTile rejected range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3682
#, csharp-format
msgid "GetDataHandlers / HandlePaintTile rejected select consistency {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3691
#, csharp-format
msgid ""
"GetDataHandlers / HandlePaintTile rejected throttle/permission/range check "
"{0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3712
#, csharp-format
msgid "GetDataHandlers / HandlePaintWall rejected range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3730
#, csharp-format
msgid "GetDataHandlers / HandlePaintWall rejected selector consistency {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3739
#, csharp-format
msgid ""
"GetDataHandlers / HandlePaintWall rejected throttle/permission/range {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3452
#, csharp-format
msgid "GetDataHandlers / HandlePlayerBuffList handled event and sent data {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3437
#, csharp-format
msgid ""
"GetDataHandlers / HandlePlayerBuffList zeroed player buff due to below state "
"2 {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2814
#, csharp-format
msgid "GetDataHandlers / HandlePlayerHp rejected over max hp {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2557
msgid "GetDataHandlers / HandlePlayerInfo rejected hardcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2551
msgid "GetDataHandlers / HandlePlayerInfo rejected mediumcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2492
msgid "GetDataHandlers / HandlePlayerInfo rejected name length 0"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2485
#, csharp-format
msgid "GetDataHandlers / HandlePlayerInfo rejected plugin phase {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2545
msgid "GetDataHandlers / HandlePlayerInfo rejected softcore required"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4255
#: ../../TShockAPI/GetDataHandlers.cs:4261
#, csharp-format
msgid "GetDataHandlers / HandlePlayerKillMeV2 kicked with difficulty {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4270
#, csharp-format
msgid "GetDataHandlers / HandlePlayerKillMeV2 ssc delete {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3329
#, csharp-format
msgid "GetDataHandlers / HandlePlayerMana rejected max mana {0} {1}/{2}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2589
msgid "GetDataHandlers / HandlePlayerSlot rejected ignore ssc packets"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3357
#, csharp-format
msgid "GetDataHandlers / HandlePlayerTeam rejected team fastswitch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2794
#, csharp-format
msgid "GetDataHandlers / HandlePlayerUpdate home position delta {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3183
msgid "GetDataHandlers / HandlePlayerZone rejected null check"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3064
#, csharp-format
msgid ""
"GetDataHandlers / HandleProjectileKill permitted skeletron prime exemption "
"{0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3068
#, csharp-format
msgid "GetDataHandlers / HandleProjectileKill rejected banned projectile {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3053
#, csharp-format
msgid "GetDataHandlers / HandleProjectileKill rejected tombstone {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3395
#, csharp-format
msgid "GetDataHandlers / HandleSign rejected sign on build permission {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3402
#, csharp-format
msgid "GetDataHandlers / HandleSign rejected sign range check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3375
#, csharp-format
msgid "GetDataHandlers / HandleSignRead rejected out of bounds {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2737
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport 'vanilla spawn' {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2748
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport phase 1 {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2757
#, csharp-format
msgid "GetDataHandlers / HandleSpawn force teleport phase 2 {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2717
#, csharp-format
msgid "GetDataHandlers / HandleSpawn rejected dead player spawn request {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3558
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected boss {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3548
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected bouner throttled {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3565
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected invasion {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3572
#, csharp-format
msgid "GetDataHandlers / HandleSpawnBoss rejected pet {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3483
#, csharp-format
msgid ""
"GetDataHandlers / HandleSpecial rejected enchanted sundial permission "
"(ForceTime) {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3477
#, csharp-format
msgid ""
"GetDataHandlers / HandleSpecial rejected enchanted sundial permission {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3467
#, csharp-format
msgid "GetDataHandlers / HandleSpecial rejected type 1 for {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4049
#, csharp-format
msgid ""
"GetDataHandlers / HandleSyncExtraValue rejected expert/master mode check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4043
#, csharp-format
msgid "GetDataHandlers / HandleSyncExtraValue rejected extents check {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4055
#, csharp-format
msgid ""
"GetDataHandlers / HandleSyncExtraValue rejected npc id out of bounds check - "
"NPC ID: {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4062
#, csharp-format
msgid ""
"GetDataHandlers / HandleSyncExtraValue rejected npc is null - NPC ID: {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4069
#, csharp-format
msgid ""
"GetDataHandlers / HandleSyncExtraValue rejected range check {0},{1} vs "
"{2},{3} which is {4}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4442
#, csharp-format
msgid "GetDataHandlers / HandleSyncLoadout rejected loadout index sync {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4433
#, csharp-format
msgid ""
"GetDataHandlers / HandleSyncLoadout rejected loadout index sync out of bounds "
"{0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3796
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected npc teleport {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3805
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected p2p extents {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3811
#, csharp-format
msgid ""
"GetDataHandlers / HandleTeleport rejected p2p wormhole permission {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3787
#, csharp-format
msgid "GetDataHandlers / HandleTeleport rejected rod type {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3885
#: ../../TShockAPI/GetDataHandlers.cs:3901
#: ../../TShockAPI/GetDataHandlers.cs:3924
#: ../../TShockAPI/GetDataHandlers.cs:3944
#, csharp-format
msgid ""
"GetDataHandlers / HandleTeleportationPotion rejected not holding the correct "
"item {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3875
#, csharp-format
msgid ""
"GetDataHandlers / HandleTeleportationPotion rejected permissions {0} {1}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4170
#, csharp-format
msgid "GetDataHandlers / HandleToggleParty rejected no party {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3098
#, csharp-format
msgid "GetDataHandlers / HandleTogglePvp rejected fastswitch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3091
#, csharp-format
msgid "GetDataHandlers / HandleTogglePvp rejected index mismatch {0}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2772
msgid "GetDataHandlers / OnPlayerUpdate rejected from null player."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2499
msgid ""
"GetDataHandlers / rejecting player for name prefix starting with tsi: or "
"tsn:."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3533
#, csharp-format
msgid "GetDataHandlers / UpdateNPCHome rejected no permission {0}"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:291
#, csharp-format
msgid "GetUser SQL returned an error {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6417
msgid "Give Buff Syntax and Example"
msgstr ""

#: ../../TShockAPI/Commands.cs:541
msgid ""
"Gives another player a buff or debuff for an amount of time. Putting -1 for "
"time will set it to 415 days."
msgstr ""

#: ../../TShockAPI/Commands.cs:382
msgid "Gives another player an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:533
msgid ""
"Gives yourself a buff or debuff for an amount of time. Putting -1 for time "
"will set it to 415 days."
msgstr ""

#: ../../TShockAPI/Commands.cs:387
msgid "Gives yourself an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:6690
msgid "Glowing Mushroom Tree"
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:123
#, csharp-format
msgid ""
"GolfPacketHandler: Player did not have create a golf club projectile the last "
"5 seconds! - From {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3506
#, csharp-format
msgid "Group \"{0}\" has no parent."
msgstr ""

#: ../../TShockAPI/Commands.cs:3596
#, csharp-format
msgid "Group \"{0}\" has no prefix."
msgstr ""

#: ../../TShockAPI/Commands.cs:3551
#, csharp-format
msgid "Group \"{0}\" has no suffix."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:646
#, csharp-format
msgid ""
"Group \"{0}\" is referencing parent group {1} which is already part of the "
"parent chain. Parent reference removed."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:578
msgid ""
"Group \"superadmin\" is defined in the database even though it's a reserved "
"group name."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:708
#, csharp-format
msgid "Group {0} already exists"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1158
#, csharp-format
msgid "Group {0} created successfully"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1133
#, csharp-format
msgid "Group {0} deleted successfully"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:638
#: ../../TShockAPI/DB/GroupManager.cs:725
#, csharp-format
msgid "Group {0} does not exist"
msgstr ""

#: ../../TShockAPI/Commands.cs:1110
#, csharp-format
msgid "Group {0} does not exist."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1354
#, csharp-format
msgid "Group {0} doesn't exist"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:495
#: ../../TShockAPI/DB/GroupManager.cs:525
#: ../../TShockAPI/DB/GroupManager.cs:548
#, csharp-format
msgid "Group {0} doesn't exist."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:508
#, csharp-format
msgid "Group {0} has been deleted successfully."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:463
#, csharp-format
msgid "Group {0} has been renamed to {1}."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:631
#, csharp-format
msgid ""
"Group {0} is referencing a non existent parent group {1}, parent reference "
"was removed."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:637
#, csharp-format
msgid ""
"Group {0} is referencing itself as parent group; parent reference was "
"removed."
msgstr ""

#: ../../TShockAPI/Commands.cs:4862
#: ../../TShockAPI/Commands.cs:4897
#, csharp-format
msgid "Group {0} not found."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1187
#, csharp-format
msgid "Group {0} updated successfully"
msgstr ""

#: ../../TShockAPI/Commands.cs:3380
#, csharp-format
msgid "Group {0} was added successfully."
msgstr ""

#: ../../TShockAPI/Commands.cs:3454
msgid "Group Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:3745
msgid "Groups ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:476
msgid "Grows plants at your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:6631
msgid "Hallow Palm"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4417
#, csharp-format
msgid ""
"HandleSyncCavernMonsterType: Player is trying to modify NPC "
"cavernMonsterType; this is a crafted packet! - From {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2593
msgid "Hardmode is disabled in the server configuration file."
msgstr ""

#: ../../TShockAPI/Commands.cs:2584
msgid "Hardmode is now off."
msgstr ""

#: ../../TShockAPI/Commands.cs:2589
msgid "Hardmode is now on."
msgstr ""

#: ../../TShockAPI/Commands.cs:6307
msgid "Heal Syntax and Example"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2097
msgid "HealOtherPlayer cheat attempt!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2106
#, csharp-format
msgid "HealOtherPlayer threshold exceeded {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:549
msgid "Heals a player in HP and MP."
msgstr ""

#: ../../TShockAPI/Commands.cs:6684
msgid "Herb"
msgstr ""

#: ../../TShockAPI/Commands.cs:4658
msgid "Hit a block to get the name of the region."
msgstr ""

#: ../../TShockAPI/Commands.cs:4671
#, csharp-format
msgid "Hit a block to set point {0}."
msgstr ""

#: ../../TShockAPI/ItemBans.cs:94
#: ../../TShockAPI/ItemBans.cs:163
#, csharp-format
msgid "holding banned item: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1235
#, csharp-format
msgid "ID: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6310
msgid ""
"If no amount is specified, it will default to healing the target player by "
"their max HP."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1392
msgid ""
"If this player wasn't hacking, please report the damage threshold they were "
"disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2113
msgid ""
"If this player wasn't hacking, please report the HealOtherPlayer threshold "
"they were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1295
msgid ""
"If this player wasn't hacking, please report the projectile create threshold "
"they were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:927
msgid ""
"If this player wasn't hacking, please report the tile kill threshold they "
"were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1695
msgid ""
"If this player wasn't hacking, please report the tile liquid threshold they "
"were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:945
msgid ""
"If this player wasn't hacking, please report the tile place threshold they "
"were disabled for to TShock so we can improve this!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3065
msgid ""
"If this was not skeletron prime related, please report to TShock what "
"happened."
msgstr ""

#: ../../TShockAPI/Commands.cs:5377
msgid ""
"If you are locked out of all admin accounts, ask for help on "
"https://tshock.co/"
msgstr ""

#: ../../TShockAPI/Commands.cs:5817
#, csharp-format
msgid ""
"If you do not specify a radius, it will use a default radius of {0} around "
"your character."
msgstr ""

#: ../../TShockAPI/Commands.cs:6370
#, csharp-format
msgid "If you don't specify the duration, it will default to {0} seconds."
msgstr ""

#: ../../TShockAPI/Commands.cs:857
msgid "If you forgot your password, contact the administrator for help."
msgstr ""

#: ../../TShockAPI/Commands.cs:6371
#, csharp-format
msgid ""
"If you put {0} as the duration, it will use the max possible time of 415 "
"days."
msgstr ""

#: ../../TShockAPI/Commands.cs:5416
#, csharp-format
msgid ""
"If you understand, please {0}login <username> <password> now, and then type "
"{0}setup."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:142
msgid "If you want to know which plugins need which dependencies, press E."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:162
msgid ""
"If you'd like to see which plugins need which dependencies again, press E."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:986
msgid ""
"If you're seeing this message and you know what that player did, please "
"report it to TShock for further investigation."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1341
msgid "Ignoring shrapnel per config.."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2500
msgid "Illegal name: prefixes tsi: and tsn: are forbidden."
msgstr ""

#: ../../TShockAPI/Handlers/IllegalPerSe/EmojiPlayerMismatch.cs:19
#, csharp-format
msgid ""
"IllegalPerSe: Emoji packet rejected for ID spoofing. Expected {0}, received "
"{1} from {2}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3189
msgid "Incoming teleports are now allowed."
msgstr ""

#: ../../TShockAPI/Commands.cs:3191
msgid "Incoming teleports are now disabled."
msgstr ""

#: ../../TShockAPI/Commands.cs:5403
msgid "Incorrect setup code. This incident has been logged."
msgstr ""

#: ../../TShockAPI/DB/TileManager.cs:223
#: ../../TShockAPI/DB/ProjectileManager.cs:223
#, csharp-format
msgid "Infinite group parenting ({0})"
msgstr ""

#: ../../TShockAPI/Commands.cs:5197
msgid ""
"info <region> [-d] - Displays several information about the given region."
msgstr ""

#: ../../TShockAPI/Commands.cs:4986
#, csharp-format
msgid "Information About Region \"{0}\" ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:1232
msgid "Information about the currently running world"
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:314
msgid "Inserting the ban into the database failed."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:39
msgid "Install the plugins as specified in the plugins.json"
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:426
msgid "Internal server error."
msgstr ""

#: ../../TShockAPI/Commands.cs:1505
#, csharp-format
msgid ""
"Invalid Ban Add syntax. Refer to {0} for details on how to use the {1} "
"command"
msgstr ""

#: ../../TShockAPI/Commands.cs:1621
#, csharp-format
msgid ""
"Invalid Ban Del syntax. Refer to {0} for details on how to use the {1} "
"command"
msgstr ""

#: ../../TShockAPI/Commands.cs:1680
#, csharp-format
msgid ""
"Invalid Ban Details syntax. Refer to {0} for details on how to use the {1} "
"command"
msgstr ""

#: ../../TShockAPI/Commands.cs:1658
#, csharp-format
msgid ""
"Invalid Ban List syntax. Refer to {0} for details on how to use the {1} "
"command"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:500
msgid ""
"Invalid BCrypt work factor in config file! Creating new hash using default "
"work factor."
msgstr ""

#: ../../TShockAPI/Commands.cs:2608
msgid "Invalid boss amount."
msgstr ""

#: ../../TShockAPI/Commands.cs:2821
msgid "Invalid boss type!"
msgstr ""

#: ../../TShockAPI/Commands.cs:6470
msgid "Invalid buff ID!"
msgstr ""

#: ../../TShockAPI/Commands.cs:680
#, csharp-format
msgid "Invalid command entered. Type {0}help for a list of valid commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:5275
msgid "Invalid command."
msgstr ""

#: ../../TShockAPI/Commands.cs:3131
msgid "Invalid destination NPC."
msgstr ""

#: ../../TShockAPI/Commands.cs:2941
#: ../../TShockAPI/Commands.cs:2972
#: ../../TShockAPI/Commands.cs:3011
#: ../../TShockAPI/Commands.cs:3084
msgid "Invalid destination player."
msgstr ""

#: ../../TShockAPI/Commands.cs:2240
#, csharp-format
msgid "Invalid event type. Valid event types: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2382
msgid "Invalid frost moon event wave."
msgstr ""

#: ../../TShockAPI/Commands.cs:3765
#: ../../TShockAPI/Commands.cs:3868
#: ../../TShockAPI/Commands.cs:3939
#: ../../TShockAPI/Commands.cs:4058
#: ../../TShockAPI/Commands.cs:4116
#: ../../TShockAPI/Commands.cs:4234
#: ../../TShockAPI/Commands.cs:4292
msgid "Invalid group."
msgstr ""

#: ../../TShockAPI/Commands.cs:2401
#, csharp-format
msgid "Invalid invasion type. Valid invasion types: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6083
#: ../../TShockAPI/Commands.cs:6232
#: ../../TShockAPI/Commands.cs:6295
msgid "Invalid item type!"
msgstr ""

#: ../../TShockAPI/Commands.cs:3807
#: ../../TShockAPI/Commands.cs:3858
#: ../../TShockAPI/Commands.cs:3903
#: ../../TShockAPI/Commands.cs:3929
msgid "Invalid item."
msgstr ""

#: ../../TShockAPI/Commands.cs:4455
#, csharp-format
msgid "Invalid maximum spawns.  Acceptable range is {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2860
#: ../../TShockAPI/Commands.cs:6166
msgid "Invalid mob type!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2844
#: ../../TShockAPI/Commands.cs:2900
msgid "Invalid mob type."
msgstr ""

#: ../../TShockAPI/Commands.cs:2569
#, csharp-format
msgid "Invalid mode world mode. Valid modes: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1421
msgid "Invalid page number. Page number must be numeric."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:309
#, csharp-format
msgid "Invalid parent group {0} for group {1}"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:347
#, csharp-format
msgid "Invalid parent group {0} for group {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:928
msgid "Invalid password."
msgstr ""

#: ../../TShockAPI/Commands.cs:6263
#: ../../TShockAPI/Commands.cs:6718
msgid "Invalid player!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1255
msgid "Invalid player."
msgstr ""

#: ../../TShockAPI/Commands.cs:4040
msgid "Invalid projectile ID!"
msgstr ""

#: ../../TShockAPI/Commands.cs:4077
#: ../../TShockAPI/Commands.cs:4098
#: ../../TShockAPI/Commands.cs:4136
msgid "Invalid projectile ID."
msgstr ""

#: ../../TShockAPI/Commands.cs:2364
msgid "Invalid pumpkin moon event wave."
msgstr ""

#: ../../TShockAPI/Commands.cs:5127
#, csharp-format
msgid "Invalid region \"{0}\"."
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:247
#, csharp-format
msgid ""
"Invalid REST configuration: \n"
"You may already have a REST service bound to port {0}. \n"
"Please adjust your configuration and restart the server. \n"
"Press any key to exit."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3271
msgid "Invalid server password."
msgstr ""

#: ../../TShockAPI/Commands.cs:3782
#, csharp-format
msgid ""
"Invalid subcommand! Type {0}group help for more information on valid "
"commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4009
#, csharp-format
msgid ""
"Invalid subcommand. Type {0}itemban help for more information on valid "
"subcommands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4187
#, csharp-format
msgid ""
"Invalid subcommand. Type {0}projban help for more information on valid "
"subcommands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4363
#, csharp-format
msgid ""
"Invalid subcommand. Type {0}tileban help for more information on valid "
"subcommands."
msgstr ""

#: ../../TShockAPI/Commands.cs:3641
msgid "Invalid syntax for color, expected \"rrr,ggg,bbb\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:1915
msgid "Invalid syntax."
msgstr ""

#: ../../TShockAPI/Commands.cs:2332
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax:  {0}worldevent invasion [invasion type] "
"[invasion wave]."
msgstr ""

#: ../../TShockAPI/Commands.cs:1270
#: ../../TShockAPI/Commands.cs:1304
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}accountinfo <username>."
msgstr ""

#: ../../TShockAPI/Commands.cs:5754
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}aliases <command or alias>"
msgstr ""

#: ../../TShockAPI/Commands.cs:3369
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group add <group name> [permissions]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3398
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}group addperm <group name> "
"<permissions...>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3606
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}group color <group name> [new "
"color(000,000,000)]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3679
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group del <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3703
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}group delperm <group name> "
"<permissions...>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3756
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group listperm <group name> [page]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3466
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}group parent <group name> [new parent group "
"name]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3561
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}group prefix <group name> [new prefix]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3656
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}group rename <group> <new name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3516
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}group suffix <group name> [new suffix]."
msgstr ""

#: ../../TShockAPI/Commands.cs:5241
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}help <command/page>"
msgstr ""

#: ../../TShockAPI/Commands.cs:6058
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}item <item name/id> [item amount] [prefix "
"id/name]"
msgstr ""

#: ../../TShockAPI/Commands.cs:3800
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban add <item name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3851
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}itemban allow <item name> <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3896
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}itemban del <item name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3922
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}itemban disallow <item name> <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:1311
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}kick <player> [reason]."
msgstr ""

#: ../../TShockAPI/Commands.cs:5424
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}me <text>"
msgstr ""

#: ../../TShockAPI/Commands.cs:5437
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}p <team chat text>"
msgstr ""

#: ../../TShockAPI/Commands.cs:4030
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban add <proj id>"
msgstr ""

#: ../../TShockAPI/Commands.cs:4049
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban allow <id> <group>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4086
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban del <id>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4107
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}projban disallow <id> <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4796
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region allow <name> <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4866
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region allowg <group> <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4710
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region define <name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4752
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region delete <name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4925
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region info <region> [-d] [page]."
msgstr ""

#: ../../TShockAPI/Commands.cs:4733
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region protect <name> <true/false>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4831
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region remove <name> <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4901
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region removeg <group> <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:5109
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region rename <region> <new name>"
msgstr ""

#: ../../TShockAPI/Commands.cs:5099
#: ../../TShockAPI/Commands.cs:5102
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"
msgstr ""

#: ../../TShockAPI/Commands.cs:5159
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region tp <region>."
msgstr ""

#: ../../TShockAPI/Commands.cs:5047
#: ../../TShockAPI/Commands.cs:5050
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}region z <name> <#>"
msgstr ""

#: ../../TShockAPI/Commands.cs:1037
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}register <password>."
msgstr ""

#: ../../TShockAPI/Commands.cs:6157
#, csharp-format
msgid ""
"Invalid syntax. Proper syntax: {0}renameNPC <guide, nurse, etc.> <newname>"
msgstr ""

#: ../../TShockAPI/Commands.cs:4402
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}serverpassword \"<new password>\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:4583
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}slap <player> [damage]."
msgstr ""

#: ../../TShockAPI/Commands.cs:2601
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}spawnboss <boss type> [amount]."
msgstr ""

#: ../../TShockAPI/Commands.cs:2839
#: ../../TShockAPI/Commands.cs:2851
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}spawnmob <mob type> [amount]."
msgstr ""

#: ../../TShockAPI/Commands.cs:4206
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban add <tile id>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4225
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban allow <id> <group>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4262
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban del <id>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4283
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tileban disallow <id> <group name>."
msgstr ""

#: ../../TShockAPI/Commands.cs:2931
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tp <player> [player 2]."
msgstr ""

#: ../../TShockAPI/Commands.cs:2933
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tp <player>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3058
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tphere <player>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3056
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tphere <player|*>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3103
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tpnpc <NPC>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3167
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}tppos <tile x> <tile y>."
msgstr ""

#: ../../TShockAPI/Commands.cs:1249
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}userinfo <player>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3202
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp [command] [arguments]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3211
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp [name] or {0}warp list <page>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3254
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp add [name]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3271
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp del [name]."
msgstr ""

#: ../../TShockAPI/Commands.cs:3294
#: ../../TShockAPI/Commands.cs:3297
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp hide [name] <true/false>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3305
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}warp send [player] [warpname]."
msgstr ""

#: ../../TShockAPI/Commands.cs:4625
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}wind <speed>."
msgstr ""

#: ../../TShockAPI/Commands.cs:2146
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}worldevent <event type>."
msgstr ""

#: ../../TShockAPI/Commands.cs:2548
#, csharp-format
msgid "Invalid syntax. Proper syntax: {0}worldmode <mode>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4736
#, csharp-format
msgid "Invalid syntax. Proper syntax: /region protect <name> <true/false>."
msgstr ""

#: ../../TShockAPI/Commands.cs:4676
msgid "Invalid syntax. Proper syntax: /region set <1/2>."
msgstr ""

#: ../../TShockAPI/Commands.cs:3151
#: ../../TShockAPI/Commands.cs:3312
#: ../../TShockAPI/Commands.cs:4589
#: ../../TShockAPI/Commands.cs:4597
msgid "Invalid target player."
msgstr ""

#: ../../TShockAPI/Commands.cs:1627
#: ../../TShockAPI/Commands.cs:1686
#, csharp-format
msgid ""
"Invalid Ticket Number. Refer to {0} for details on how to use the {1} command"
msgstr ""

#: ../../TShockAPI/Commands.cs:4216
#: ../../TShockAPI/Commands.cs:4253
#: ../../TShockAPI/Commands.cs:4274
#: ../../TShockAPI/Commands.cs:4312
msgid "Invalid tile ID."
msgstr ""

#: ../../TShockAPI/Commands.cs:1943
msgid ""
"Invalid time string! Proper format: _d_h_m_s, with at least one time "
"specifier."
msgstr ""

#: ../../TShockAPI/Commands.cs:4548
#: ../../TShockAPI/Commands.cs:4557
msgid "Invalid time string. Proper format: hh:mm, in 24-hour time."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1332
#, csharp-format
msgid "Invalid Type: '{0}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:1079
#: ../../TShockAPI/Commands.cs:1212
#, csharp-format
msgid "Invalid user syntax. Try {0}user help."
msgstr ""

#: ../../TShockAPI/Commands.cs:3242
msgid ""
"Invalid warp name. The names 'list', 'hide', 'del' and 'add' are reserved for "
"commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4632
msgid "Invalid wind speed."
msgstr ""

#: ../../TShockAPI/Commands.cs:2559
#, csharp-format
msgid "Invalid world mode. Valid world modes: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1260
#, csharp-format
msgid "IP Address: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3981
msgid "Item Ban Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:3999
msgid "Item bans ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2007
#, csharp-format
msgid "Kicked {0} for : '{1}'"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1049
msgid "Kicked via web"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2006
#, csharp-format
msgid "Kicked: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5917
msgid "Kill syntax and example"
msgstr ""

#: ../../TShockAPI/Commands.cs:553
msgid "Kills another player."
msgstr ""

#: ../../TShockAPI/Commands.cs:393
msgid "Kills hostile NPCs or NPCs of a certain type."
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:114
#, csharp-format
msgid ""
"LandGolfBallInCupHandler: Invalid golf ball projectile ID {0}! - From {1}"
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:130
#, csharp-format
msgid "LandGolfBallInCupHandler: Item selected is not a golf club! - From {0}"
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:92
#, csharp-format
msgid ""
"LandGolfBallInCupHandler: Packet rejected for ID spoofing. Expected {0}, "
"received {1} from {2}."
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:107
#, csharp-format
msgid ""
"LandGolfBallInCupHandler: Tile at packet position X:{0} Y:{1} is not a golf "
"hole! - From {2}"
msgstr ""

#: ../../TShockAPI/Handlers/LandGolfBallInCupHandler.cs:100
#, csharp-format
msgid ""
"LandGolfBallInCupHandler: X and Y position is out of world bounds! - From {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2493
msgid "Lanterns are now down."
msgstr ""

#: ../../TShockAPI/Commands.cs:2489
msgid "Lanterns are now up."
msgstr ""

#: ../../TShockAPI/Commands.cs:4423
msgid "Liquids are already settling."
msgstr ""

#: ../../TShockAPI/Commands.cs:5191
msgid "list - Lists all regions."
msgstr ""

#: ../../TShockAPI/Commands.cs:3975
msgid "list [page] - Lists all item bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:4153
msgid "list [page] - Lists all projectile bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:4329
msgid "list [page] - Lists all tile bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:3444
msgid "list [page] - Lists groups."
msgstr ""

#: ../../TShockAPI/Commands.cs:5327
msgid "List Online Players Syntax"
msgstr ""

#: ../../TShockAPI/TShock.cs:864
#, csharp-format
msgid "Listening on IP {0}."
msgstr ""

#: ../../TShockAPI/TShock.cs:845
#, csharp-format
msgid "Listening on port {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3445
msgid "listperm <group> [page] - Lists a group's permissions."
msgstr ""

#: ../../TShockAPI/Commands.cs:613
msgid "Lists commands or gives help on them."
msgstr ""

#: ../../TShockAPI/Commands.cs:2110
msgid "listusers - Lists all REST users and their current active tokens."
msgstr ""

#: ../../TShockAPI/TShock.cs:834
#, csharp-format
msgid "Loading dedicated config file: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3159
#, csharp-format
msgid "Location of {0} is ({1}, {2})."
msgstr ""

#: ../../TShockAPI/Commands.cs:1750
msgid "Log display disabled."
msgstr ""

#: ../../TShockAPI/Commands.cs:1746
msgid "Log display enabled."
msgstr ""

#: ../../TShockAPI/TShock.cs:821
#, csharp-format
msgid "Log path has been set to {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:874
msgid "Login attempt failed - see the message above."
msgstr ""

#: ../../TShockAPI/TShock.cs:1016
msgid ""
"Login before join enabled. Users may be prompted for an account specific "
"password instead of a server password on connect."
msgstr ""

#: ../../TShockAPI/TShock.cs:1021
msgid "Login using UUID enabled. Users automatically login via UUID."
msgstr ""

#: ../../TShockAPI/Commands.cs:240
msgid "Logs you into an account."
msgstr ""

#: ../../TShockAPI/Commands.cs:246
msgid "Logs you out of your current account."
msgstr ""

#: ../../TShockAPI/Commands.cs:1227
#, csharp-format
msgid "Machine name: {0}"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:141
msgid "Make sure that you trust the plugins you're installing."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2471
msgid "Malicious portal attempt."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:35
msgid "Manage plugins and their requirements"
msgstr ""

#: ../../TShockAPI/Commands.cs:280
msgid "Manages groups."
msgstr ""

#: ../../TShockAPI/Commands.cs:284
msgid "Manages item bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:268
msgid "Manages player bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:288
msgid "Manages projectile bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:296
msgid "Manages regions."
msgstr ""

#: ../../TShockAPI/Commands.cs:570
msgid "Manages the REST API."
msgstr ""

#: ../../TShockAPI/Commands.cs:376
msgid "Manages the server whitelist."
msgstr ""

#: ../../TShockAPI/Commands.cs:292
msgid "Manages tile bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:232
msgid "Manages user accounts."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1775
msgid "Manipulating unknown liquid type"
msgstr ""

#: ../../TShockAPI/Commands.cs:4721
#, csharp-format
msgid "Marked region {0} as protected."
msgstr ""

#: ../../TShockAPI/Commands.cs:4728
#, csharp-format
msgid "Marked region {0} as unprotected."
msgstr ""

#: ../../TShockAPI/Commands.cs:1222
#, csharp-format
msgid "Memory usage: {0}"
msgstr ""

#: ../../TShockAPI/SqlLog.cs:39
#, csharp-format
msgid "Message: {0}: {1}: {2}"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:874
msgid "Meteor has been spawned"
msgstr ""

#: ../../TShockAPI/Commands.cs:1334
msgid "Misbehaviour."
msgstr ""

#: ../../TShockAPI/Commands.cs:6214
msgid "Missing item name/id."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1274
#, csharp-format
msgid "Missing or empty {0} parameter"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1284
#, csharp-format
msgid "Missing or invalid {0} parameter"
msgstr ""

#: ../../TShockAPI/Commands.cs:6219
msgid "Missing player name."
msgstr ""

#: ../../TShockAPI/Commands.cs:1237
#, csharp-format
msgid "Mode: {0}"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2053
msgid "More than one match found -- unable to decide which is correct: "
msgstr ""

#: ../../TShockAPI/Commands.cs:2767
msgid "Mourning Wood"
msgstr ""

#: ../../TShockAPI/Net/BaseMsg.cs:29
msgid "Msg ID not implemented"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:294
#, csharp-format
msgid "Multiple user accounts found for {0} '{1}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:5461
msgid "Mute Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:1293
msgid "N/A"
msgstr ""

#: ../../TShockAPI/Commands.cs:5189
msgid "name [-u][-z][-p] - Shows the name of the region at the given point."
msgstr ""

#: ../../TShockAPI/Commands.cs:1233
#, csharp-format
msgid "Name: {0}"
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:55
#, csharp-format
msgid ""
"NetModuleHandler received attempt to unlock sacrifice while not in journey "
"mode from {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1474
msgid "Never."
msgstr ""

#: ../../TShockAPI/Commands.cs:6176
msgid "New name is too large!"
msgstr ""

#: ../../TShockAPI/TShock.cs:900
#, csharp-format
msgid "New worlds will be generated with the {0} world evil type!"
msgstr ""

#: ../../TShockAPI/Permissions.cs:547
msgid "No associated commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:1694
msgid "No bans found matching the provided ticket number."
msgstr ""

#: ../../TShockAPI/Commands.cs:5784
#, csharp-format
msgid "No command or command alias matching \"{0}\" found."
msgstr ""

#: ../../TShockAPI/Permissions.cs:530
msgid "No description available."
msgstr ""

#: ../../TShockAPI/Commands.cs:145
msgid "No help available."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:721
msgid "No matching bans found."
msgstr ""

#: ../../TShockAPI/Commands.cs:1829
#, csharp-format
msgid "No player was found matching '{0}'."
msgstr ""

#: ../../TShockAPI/Commands.cs:1786
#, csharp-format
msgid "No players matched \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:6123
#, csharp-format
msgid "No prefix matched \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:5492
msgid "No reason specified."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1224
msgid "No special permissions are required for this route."
msgstr ""

#: ../../TShockAPI/Commands.cs:3474
#: ../../TShockAPI/Commands.cs:3483
#: ../../TShockAPI/Commands.cs:3524
#: ../../TShockAPI/Commands.cs:3569
#: ../../TShockAPI/Commands.cs:3614
#, csharp-format
msgid "No such group \"{0}\"."
msgstr ""

#: ../../TShockAPI/DB/IQueryBuilder.cs:345
msgid "No values supplied"
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:194
msgid ""
"Not authorized. The provided token became invalid due to group changes, "
"please create a new token."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:186
msgid ""
"Not authorized. The specified API endpoint requires a token, but the provided "
"token was not valid."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:180
#: ../../TShockAPI/Rest/RestCommand.cs:95
#: ../../TShockAPI/Rest/RestCommand.cs:101
msgid "Not authorized. The specified API endpoint requires a token."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:200
#, csharp-format
msgid ""
"Not authorized. User \"{0}\" has no access to use the specified API endpoint."
msgstr ""

#: ../../TShockAPI/Commands.cs:991
#, csharp-format
msgid ""
"Not logged in or Invalid syntax. Proper syntax: {0}password <oldpassword> "
"<newpassword>."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:468
msgid "Not upgrading work factor because bcrypt hash in an invalid format."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1383
#: ../../TShockAPI/Bouncer.cs:1387
#, csharp-format
msgid "NPC damage exceeded {0}."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:103
msgid "One moment..."
msgstr ""

#: ../../TShockAPI/DB/RegionManager.cs:102
#, csharp-format
msgid "One of your UserIDs is not a usable integer: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5344
#, csharp-format
msgid "Online Players ({0}/{1})"
msgstr ""

#: ../../TShockAPI/Commands.cs:1225
#, csharp-format
msgid "Operating system: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:308
msgid "Overrides serverside characters for a player, temporarily."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:105
msgid "Page {{0}} of {{1}}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3446
msgid "parent <group> <parent group> - Changes a group's parent group."
msgstr ""

#: ../../TShockAPI/Commands.cs:3504
#, csharp-format
msgid "Parent of \"{0}\" is \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3492
#, csharp-format
msgid "Parent of group \"{0}\" set to \"{1}\"."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:356
#, csharp-format
msgid "Parenting group {0} to {1} would cause loops in the parent chain."
msgstr ""

#: ../../TShockAPI/Commands.cs:1163
#, csharp-format
msgid ""
"Password change attempt for {0} failed for an unknown reason. Check the "
"server console for more details."
msgstr ""

#: ../../TShockAPI/Commands.cs:1155
#, csharp-format
msgid "Password change succeeded for {0}."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:492
#: ../../TShockAPI/DB/UserManager.cs:513
#, csharp-format
msgid "Password must be at least {0} characters."
msgstr ""

#: ../../TShockAPI/Commands.cs:980
#: ../../TShockAPI/Commands.cs:1017
#: ../../TShockAPI/Commands.cs:1031
#: ../../TShockAPI/Commands.cs:1097
#: ../../TShockAPI/Commands.cs:1168
#, csharp-format
msgid "Password must be greater than or equal to {0} characters."
msgstr ""

#: ../../TShockAPI/Commands.cs:997
#, csharp-format
msgid "PasswordUser returned an error: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1238
#, csharp-format
msgid "Path: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6622
msgid "Pearlwood Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:3774
#, csharp-format
msgid "Permissions for {0} ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:2680
msgid "Plantera"
msgstr ""

#: ../../TShockAPI/Commands.cs:1803
#, csharp-format
msgid "Player \"{0}\" has to perform a /login attempt first."
msgstr ""

#: ../../TShockAPI/Commands.cs:1808
#, csharp-format
msgid ""
"Player \"{0}\" has to reconnect first, because they need to delete their "
"trash."
msgstr ""

#: ../../TShockAPI/Commands.cs:1798
#, csharp-format
msgid "Player \"{0}\" is already logged in."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1970
#: ../../TShockAPI/TSPlayer.cs:1974
#, csharp-format
msgid "Player {0} has been disabled for {1}."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1394
#, csharp-format
msgid "Player {0} has been muted"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1399
#, csharp-format
msgid "Player {0} has been unmuted"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1307
#, csharp-format
msgid "Player {0} matches {1} player"
msgid_plural "Player {0} matches {1} players"
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:4792
#: ../../TShockAPI/Commands.cs:4827
#, csharp-format
msgid "Player {0} not found."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1140
#, csharp-format
msgid "Player {0} tried to sneak {1} onto the server!"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1069
#, csharp-format
msgid "Player {0} was killed"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1305
#, csharp-format
msgid "Player {0} was not found"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2604
#: ../../TShockAPI/Bouncer.cs:2611
#, csharp-format
msgid "Player damage exceeded {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6289
msgid "Player does not have free slots!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1182
#, csharp-format
msgid "Player does not have permission to create projectile {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1324
msgid "Player not found. Unable to kick the player."
msgstr ""

#: ../../TShockAPI/TShock.cs:1732
#, csharp-format
msgid "Please {0}register or {0}login to play!"
msgstr ""

#: ../../TShockAPI/Commands.cs:951
msgid "Please close NPC windows before logging out."
msgstr ""

#: ../../TShockAPI/Commands.cs:5761
msgid "Please enter a proper command name or alias."
msgstr ""

#: ../../TShockAPI/Commands.cs:1063
msgid "Please try a different username."
msgstr ""

#: ../../TShockAPI/Commands.cs:5415
#, csharp-format
msgid "Please use {0}login <username> <password> after this process."
msgstr ""

#: ../../TShockAPI/Commands.cs:5412
msgid "Please use the following to create a permanent account for you."
msgstr ""

#: ../../TShockAPI/TShock.cs:931
#, csharp-format
msgid "Port overridden by startup argument. Set to {0}"
msgstr ""

#: ../../TShockAPI/DB/ResearchDatastore.cs:53
#: ../../TShockAPI/DB/BanManager.cs:81
msgid "Possible problem with your database - is Sqlite3.dll present?"
msgstr ""

#: ../../TShockAPI/Commands.cs:3447
msgid "prefix <group> <prefix> - Changes a group's prefix."
msgstr ""

#: ../../TShockAPI/Commands.cs:3594
#, csharp-format
msgid "Prefix of \"{0}\" is \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3582
#, csharp-format
msgid "Prefix of group \"{0}\" set to \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:304
msgid "Prevents a player from talking."
msgstr ""

#: ../../TShockAPI/Commands.cs:1226
#, csharp-format
msgid "Proc count: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:4065
#: ../../TShockAPI/Commands.cs:4123
#, csharp-format
msgid "Projectile {0} is not banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:4159
msgid "Projectile Ban Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:4177
msgid "Projectile bans ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1286
#, csharp-format
msgid "Projectile create threshold exceeded {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1192
#, csharp-format
msgid "Projectile damage is higher than {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5198
msgid ""
"protect <name> <true/false> - Sets whether the tiles inside the region are "
"protected or not."
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:159
msgid "Protected regions at this point: "
msgstr ""

#: ../../TShockAPI/Commands.cs:4950
#, csharp-format
msgid "Protected: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1373
#, csharp-format
msgid "Quick usage: {0} {1} \"Griefing\""
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:759
#, csharp-format
msgid "Rangecheck failed for {0} ({1}, {2}) (rg: {3}/{5}, {4}/{5})"
msgstr ""

#: ../../TShockAPI/TShock.cs:1232
msgid "Reached HealOtherPlayer threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2110
msgid "Reached HealOtherPlayer threshold."
msgstr ""

#: ../../TShockAPI/TShock.cs:1223
msgid "Reached paint threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1290
msgid "Reached projectile create threshold."
msgstr ""

#: ../../TShockAPI/TShock.cs:1214
msgid "Reached projectile threshold"
msgstr ""

#: ../../TShockAPI/TShock.cs:1144
#: ../../TShockAPI/Bouncer.cs:922
msgid "Reached TileKill threshold."
msgstr ""

#: ../../TShockAPI/TShock.cs:1205
msgid "Reached TileLiquid threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1686
#, csharp-format
msgid "Reached TileLiquid threshold {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1690
msgid "Reached TileLiquid threshold."
msgstr ""

#: ../../TShockAPI/TShock.cs:1161
msgid "Reached TilePlace threshold"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:940
#: ../../TShockAPI/Bouncer.cs:2376
msgid "Reached TilePlace threshold."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:128
msgid "Read the message below to find out more."
msgstr ""

#: ../../TShockAPI/Commands.cs:1495
#, csharp-format
msgid "Reason: {0}."
msgstr ""

#: ../../TShockAPI/Extensions/DbExt.cs:254
#, csharp-format
msgid "Received type '{0}', however column '{1}' expects type '{2}'"
msgstr ""

#: ../../TShockAPI/Commands.cs:5135
#, csharp-format
msgid "Region \"{0}\" already exists."
msgstr ""

#: ../../TShockAPI/Commands.cs:5167
#, csharp-format
msgid "Region \"{0}\" does not exist."
msgstr ""

#: ../../TShockAPI/Commands.cs:4701
#, csharp-format
msgid "Region {0} already exists."
msgstr ""

#: ../../TShockAPI/Commands.cs:4980
msgid "Region is not shared with any groups."
msgstr ""

#: ../../TShockAPI/Commands.cs:4969
msgid "Region is not shared with any users."
msgstr ""

#: ../../TShockAPI/Commands.cs:4949
#, csharp-format
msgid "Region owner: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4706
msgid ""
"Region points need to be defined first. Use /region set 1 and /region set 2."
msgstr ""

#: ../../TShockAPI/Commands.cs:5141
msgid "Region renamed successfully!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5095
msgid "Region Resized Successfully!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5042
#, csharp-format
msgid "Region's z is now {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:4915
msgid "Regions ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:159
msgid "Regions at this point: "
msgstr ""

#: ../../TShockAPI/Commands.cs:258
msgid "Registers you an account."
msgstr ""

#: ../../TShockAPI/Commands.cs:1070
#, csharp-format
msgid "RegisterUser returned an error: {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:2161
msgid "Released critter was not from its item."
msgstr ""

#: ../../TShockAPI/Commands.cs:364
msgid "Reloads the server configuration file."
msgstr ""

#: ../../TShockAPI/Commands.cs:5194
msgid "remove <user> <region> - Removes a user from a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:2521
#, csharp-format
msgid "Removed {0} players from the angler quest completion list for today."
msgstr ""

#: ../../TShockAPI/Commands.cs:4890
#, csharp-format
msgid "Removed group {0} from {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3494
#, csharp-format
msgid "Removed parent of group \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3584
#, csharp-format
msgid "Removed prefix of group \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3539
#, csharp-format
msgid "Removed suffix of group \"{0}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:4820
#, csharp-format
msgid "Removed user {0} from {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5196
msgid "removeg <group> <region> - Removes a user group from a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:300
msgid "Removes a player from the server."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:112
msgid "RemoveUser SQL returned an error"
msgstr ""

#: ../../TShockAPI/Commands.cs:3441
msgid "rename <group> <new name> - Changes a group's name."
msgstr ""

#: ../../TShockAPI/Commands.cs:5190
msgid "rename <region> <new name> - Renames the given region."
msgstr ""

#: ../../TShockAPI/Commands.cs:397
msgid "Renames an NPC."
msgstr ""

#: ../../TShockAPI/Commands.cs:566
msgid "Replies to a PM sent to you."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:93
msgid "Requested token was successfully destroyed."
msgstr ""

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:35
#, csharp-format
msgid ""
"RequestTileEntityInteractionHandler: Rejected packet due to lack of building "
"permissions! - From {0} | Position X:{1} Y:{2}, TileEntity type: {3}, Tile "
"type: {4}"
msgstr ""

#: ../../TShockAPI/Commands.cs:419
msgid "Resets the list of users who have completed an angler quest that day."
msgstr ""

#: ../../TShockAPI/SaveManager.cs:163
#, csharp-format
msgid "resetTime {0}, direct {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5192
msgid "resize <region> <u/d/l/r> <amount> - Resizes a region."
msgstr ""

#: ../../TShockAPI/Commands.cs:603
msgid "Respawn yourself or another player."
msgstr ""

#: ../../TShockAPI/UpdateManager.cs:87
msgid "Retrying in 5 minutes."
msgstr ""

#: ../../TShockAPI/Commands.cs:456
msgid "Returns the user's or specified user's current position."
msgstr ""

#: ../../TShockAPI/Commands.cs:6600
msgid "Rich Mahogany"
msgstr ""

#: ../../TShockAPI/Commands.cs:5627
msgid "Rocket Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:342
msgid "Rockets a player upwards. Requires SSC."
msgstr ""

#: ../../TShockAPI/Commands.cs:6662
msgid "Ruby Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:6604
msgid "Sakura Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:2783
msgid "Santa-NK1"
msgstr ""

#: ../../TShockAPI/Commands.cs:6654
msgid "Sapphire Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:312
msgid "Saves all serverside characters."
msgstr ""

#: ../../TShockAPI/Commands.cs:500
msgid "Saves the world file."
msgstr ""

#: ../../TShockAPI/SaveManager.cs:58
msgid "Saving world..."
msgstr ""

#: ../../TShockAPI/Commands.cs:1236
#, csharp-format
msgid "Seed: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:562
msgid "Sends a message to everyone on your team."
msgstr ""

#: ../../TShockAPI/Commands.cs:586
msgid "Sends a PM to a player."
msgstr ""

#: ../../TShockAPI/Commands.cs:599
msgid ""
"Sends all tiles from the server to the player to resync the client with the "
"actual world state."
msgstr ""

#: ../../TShockAPI/Commands.cs:557
msgid "Sends an action message to everyone."
msgstr ""

#: ../../TShockAPI/Commands.cs:431
msgid "Sends you to the world's spawn point."
msgstr ""

#: ../../TShockAPI/Commands.cs:426
msgid "Sends you to your spawn point."
msgstr ""

#: ../../TShockAPI/TShock.cs:774
msgid "Server console interrupted!"
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:337
msgid "Server is full"
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:341
msgid "Server is full. No reserved slots open."
msgstr ""

#: ../../TShockAPI/TShock.cs:1336
msgid "Server is shutting down..."
msgstr ""

#: ../../TShockAPI/BackupManager.cs:73
msgid "Server map saving..."
msgstr ""

#: ../../TShockAPI/Commands.cs:4407
#, csharp-format
msgid "Server password has been changed to: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2040
#: ../../TShockAPI/Commands.cs:2046
msgid "Server shutting down: "
msgstr ""

#: ../../TShockAPI/Commands.cs:2040
msgid "Server shutting down!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2046
msgid "Server shutting down."
msgstr ""

#: ../../TShockAPI/Commands.cs:959
msgid "Server side characters are enabled. You need to be logged-in to play."
msgstr ""

#: ../../TShockAPI/TShock.cs:1727
#, csharp-format
msgid ""
"Server side characters is enabled! Please {0}register or {0}login to play!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1813
#, csharp-format
msgid ""
"Server-side character data from \"{0}\" has been replaced by their current "
"local data."
msgstr ""

#: ../../TShockAPI/Commands.cs:1773
msgid "Server-side characters is disabled."
msgstr ""

#: ../../TShockAPI/Commands.cs:5185
msgid "set <1/2> - Sets the temporary region points."
msgstr ""

#: ../../TShockAPI/Commands.cs:4697
#, csharp-format
msgid "Set region {0}."
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:187
#, csharp-format
msgid "Set temp point {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:510
msgid "Sets the dungeon's position to your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:401
msgid "Sets the maximum number of NPCs."
msgstr ""

#: ../../TShockAPI/Commands.cs:415
msgid "Sets the spawn rate of NPCs."
msgstr ""

#: ../../TShockAPI/Commands.cs:518
msgid "Sets the world time."
msgstr ""

#: ../../TShockAPI/Commands.cs:505
msgid "Sets the world's spawn point to your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:4427
msgid "Settling liquids."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:182
msgid "SetUserGroup SQL returned an error"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:134
msgid "SetUserPassword SQL returned an error"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:154
msgid "SetUserUUID SQL returned an error"
msgstr ""

#: ../../TShockAPI/Commands.cs:6612
msgid "Shadewood Tree"
msgstr ""

#: ../../TShockAPI/Commands.cs:5386
msgid ""
"Share your server, talk with admins, and chill on GitHub & Discord. -- "
"https://tshock.co/"
msgstr ""

#: ../../TShockAPI/Commands.cs:4975
msgid "Shared with groups: "
msgstr ""

#: ../../TShockAPI/Commands.cs:4964
msgid "Shared with: "
msgstr ""

#: ../../TShockAPI/Commands.cs:609
msgid "Shows a command's aliases."
msgstr ""

#: ../../TShockAPI/Commands.cs:332
msgid "Shows information about a player."
msgstr ""

#: ../../TShockAPI/Commands.cs:262
msgid "Shows information about a user."
msgstr ""

#: ../../TShockAPI/Commands.cs:526
msgid "Shows information about the current world."
msgstr ""

#: ../../TShockAPI/Commands.cs:621
msgid "Shows the currently connected players."
msgstr ""

#: ../../TShockAPI/Commands.cs:617
msgid "Shows the message of the day."
msgstr ""

#: ../../TShockAPI/Commands.cs:578
msgid "Shows the server information."
msgstr ""

#: ../../TShockAPI/Commands.cs:625
msgid "Shows the server's rules."
msgstr ""

#: ../../TShockAPI/Commands.cs:372
msgid "Shows the TShock version."
msgstr ""

#: ../../TShockAPI/Commands.cs:356
msgid "Shuts down the server while saving."
msgstr ""

#: ../../TShockAPI/Commands.cs:360
msgid "Shuts down the server without saving."
msgstr ""

#: ../../TShockAPI/TShock.cs:771
msgid "Shutting down safely. To force shutdown, send SIGINT (CTRL + C) again."
msgstr ""

#: ../../TShockAPI/Commands.cs:1234
#, csharp-format
msgid "Size: {0}x{1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:2699
msgid "Skeletron"
msgstr ""

#: ../../TShockAPI/Commands.cs:2687
msgid "Skeletron Prime"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1076
#, csharp-format
msgid "Skipping SSC save (due to tshock.ignore.ssc) for {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:574
msgid "Slaps a player, dealing damage."
msgstr ""

#: ../../TShockAPI/Commands.cs:2446
msgid ""
"Slime rain cannot be activated during normal rain. Stop the normal rainstorm "
"and try again."
msgstr ""

#: ../../TShockAPI/Commands.cs:1062
#, csharp-format
msgid "Sorry, {0} was already taken by another person."
msgstr ""

#: ../../TShockAPI/Commands.cs:996
#: ../../TShockAPI/Commands.cs:1069
#, csharp-format
msgid "Sorry, an error occurred: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4378
msgid "Spawn has now been set at your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:5230
msgid "Spawn is now open."
msgstr ""

#: ../../TShockAPI/Commands.cs:5230
msgid "Spawn is now protected."
msgstr ""

#: ../../TShockAPI/Commands.cs:2874
#, csharp-format
msgid "Spawned {0} {1} time."
msgid_plural "Spawned {0} {1} times."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:2891
msgid "Spawned a Wall of Flesh."
msgstr ""

#: ../../TShockAPI/Commands.cs:406
msgid "Spawns a number of bosses around you."
msgstr ""

#: ../../TShockAPI/Commands.cs:411
msgid "Spawns a number of mobs around you."
msgstr ""

#: ../../TShockAPI/Commands.cs:346
msgid "Spawns fireworks at a player."
msgstr ""

#: ../../TShockAPI/Rest/Rest.cs:433
msgid ""
"Specified API endpoint doesn't exist. Refer to the documentation for a list "
"of valid endpoints."
msgstr ""

#: ../../TShockAPI/SqlLog.cs:346
#, csharp-format
msgid "SQL log failed at: {0}. {1}"
msgstr ""

#: ../../TShockAPI/SqlLog.cs:317
#, csharp-format
msgid "SQL Log insert query failed: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5667
msgid "SSC must be enabled to use this command."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:435
#, csharp-format
msgid "Stack cheat detected. Remove armor {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:578
#, csharp-format
msgid ""
"Stack cheat detected. Remove Defender's Forge item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:455
#, csharp-format
msgid "Stack cheat detected. Remove dye {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:415
#: ../../TShockAPI/TSPlayer.cs:475
#, csharp-format
msgid "Stack cheat detected. Remove item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:495
#, csharp-format
msgid "Stack cheat detected. Remove item dye {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:619
#: ../../TShockAPI/TSPlayer.cs:639
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 1 item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:659
#: ../../TShockAPI/TSPlayer.cs:679
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 2 item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:699
#: ../../TShockAPI/TSPlayer.cs:719
#, csharp-format
msgid "Stack cheat detected. Remove Loadout 3 item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:516
#, csharp-format
msgid "Stack cheat detected. Remove piggy-bank item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:537
#, csharp-format
msgid "Stack cheat detected. Remove safe item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:557
#, csharp-format
msgid "Stack cheat detected. Remove trash item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:599
#, csharp-format
msgid "Stack cheat detected. Remove Void Vault item {0} ({1}) and then rejoin."
msgstr ""

#: ../../TShockAPI/Commands.cs:2279
msgid "Started a blood moon event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2264
msgid "Started a full moon event."
msgstr ""

#: ../../TShockAPI/Commands.cs:2306
msgid "Started an eclipse."
msgstr ""

#: ../../TShockAPI/TShock.cs:963
msgid "Startup parameter overrode maximum player slot configuration value."
msgstr ""

#: ../../TShockAPI/TShock.cs:945
msgid "Startup parameter overrode REST enable."
msgstr ""

#: ../../TShockAPI/TShock.cs:954
msgid "Startup parameter overrode REST port."
msgstr ""

#: ../../TShockAPI/TShock.cs:937
msgid "Startup parameter overrode REST token."
msgstr ""

#: ../../TShockAPI/Commands.cs:2310
msgid "Stopped an eclipse."
msgstr ""

#: ../../TShockAPI/Commands.cs:2283
msgid "Stopped the current blood moon event."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:167
msgid "Successful login"
msgstr ""

#: ../../TShockAPI/Commands.cs:3448
msgid "suffix <group> <suffix> - Changes a group's suffix."
msgstr ""

#: ../../TShockAPI/Commands.cs:3549
#, csharp-format
msgid "Suffix of \"{0}\" is \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:3537
#, csharp-format
msgid "Suffix of group \"{0}\" set to \"{1}\"."
msgstr ""

#: ../../TShockAPI/Commands.cs:5798
msgid "Sync'd!"
msgstr ""

#: ../../TShockAPI/Handlers/SyncTilePickingHandler.cs:23
#, csharp-format
msgid ""
"SyncTilePickingHandler: X and Y position is out of world bounds! - From {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3029
#, csharp-format
msgid "Teleported {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3094
#, csharp-format
msgid "Teleported {0} to yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:3008
#, csharp-format
msgid "Teleported everyone to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3081
msgid "Teleported everyone to yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:3183
#, csharp-format
msgid "Teleported to {0}, {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2954
#, csharp-format
msgid "Teleported to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3137
#, csharp-format
msgid "Teleported to the '{0}'."
msgstr ""

#: ../../TShockAPI/Commands.cs:2923
msgid "Teleported to the map's spawn point."
msgstr ""

#: ../../TShockAPI/Commands.cs:2917
msgid "Teleported to your spawn point (home)."
msgstr ""

#: ../../TShockAPI/Commands.cs:436
msgid "Teleports a player to another player."
msgstr ""

#: ../../TShockAPI/Commands.cs:441
msgid "Teleports a player to yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:582
msgid "Teleports you to a warp point or manages warps."
msgstr ""

#: ../../TShockAPI/Commands.cs:446
msgid "Teleports you to an npc."
msgstr ""

#: ../../TShockAPI/Commands.cs:451
msgid "Teleports you to tile coordinates."
msgstr ""

#: ../../TShockAPI/Commands.cs:324
msgid "Temporarily elevates you to Super Admin."
msgstr ""

#: ../../TShockAPI/Commands.cs:320
msgid "Temporarily sets another player's group."
msgstr ""

#: ../../TShockAPI/Commands.cs:4759
msgid "Temporary region set points have been removed."
msgstr ""

#: ../../TShockAPI/Commands.cs:5411
msgid ""
"Temporary system access has been given to you, so you can run one command."
msgstr ""

#: ../../TShockAPI/Commands.cs:5387
msgid "Thank you for using TShock for Terraria!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1190
msgid "That group does not exist."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:258
msgid ""
"The ban is invalid because a current ban for this identifier already exists."
msgstr ""

#: ../../TShockAPI/DB/BanManager.cs:295
msgid "The ban was not valid for an unknown reason."
msgstr ""

#: ../../TShockAPI/Commands.cs:2634
msgid "the Brain of Cthulhu"
msgstr ""

#: ../../TShockAPI/Commands.cs:4522
#, csharp-format
msgid "The current time is {0}:{1:D2}."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:218
msgid "The default usergroup could not be found."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:217
msgid ""
"The default usergroup could not be found. This may indicate a typo in the "
"configuration file, or that the group was renamed or deleted."
msgstr ""

#: ../../TShockAPI/Commands.cs:3174
msgid "The destination coordinates provided don't look like valid numbers."
msgstr ""

#: ../../TShockAPI/Commands.cs:3334
#: ../../TShockAPI/Commands.cs:3349
#, csharp-format
msgid "The destination warp, {0}, was not found."
msgstr ""

#: ../../TShockAPI/Commands.cs:2641
msgid "the Destroyer"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3468
msgid "The Dungeon Guardian returned you to your spawn point."
msgstr ""

#: ../../TShockAPI/Commands.cs:4386
msgid "The dungeon's position has now been set at your location."
msgstr ""

#: ../../TShockAPI/Commands.cs:2655
msgid "the Eater of Worlds"
msgstr ""

#: ../../TShockAPI/Commands.cs:2736
msgid "the Empress of Light"
msgstr ""

#: ../../TShockAPI/Commands.cs:2663
msgid "the Eye of Cthulhu"
msgstr ""

#: ../../TShockAPI/Commands.cs:2762
msgid "the Flying Dutchman"
msgstr ""

#: ../../TShockAPI/Commands.cs:2668
msgid "the Golem"
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:595
#, csharp-format
msgid "The group {0} appeared more than once. Keeping current group settings."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:212
msgid "The guest group could not be found."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:211
msgid ""
"The guest group could not be found. This may indicate a typo in the "
"configuration file, or that the group was renamed or deleted."
msgstr ""

#: ../../TShockAPI/Commands.cs:2788
msgid "the Ice Queen"
msgstr ""

#: ../../TShockAPI/Commands.cs:5376
msgid "The initial setup system is disabled. This incident has been logged."
msgstr ""

#: ../../TShockAPI/Commands.cs:6097
#, csharp-format
msgid "The item type {0} is invalid."
msgstr ""

#: ../../TShockAPI/Commands.cs:2675
msgid "the King Slime"
msgstr ""

#: ../../TShockAPI/Commands.cs:2750
msgid "the Lunatic Cultist"
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:185
msgid ""
"The method referenced by LineFormatter has thrown an exception. See inner "
"exception for details."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:247
msgid ""
"The method represented by termFormatter has thrown an exception. See inner "
"exception for details."
msgstr ""

#: ../../TShockAPI/Commands.cs:2729
msgid "the Moon Lord"
msgstr ""

#: ../../TShockAPI/Commands.cs:3410
msgid "The permissions have been added to all of the groups in the system."
msgstr ""

#: ../../TShockAPI/Commands.cs:3715
msgid "The permissions have been removed from all of the groups in the system."
msgstr ""

#: ../../TShockAPI/Commands.cs:1860
msgid ""
"The player's character data was successfully uploaded from their initial "
"connection."
msgstr ""

#: ../../TShockAPI/Commands.cs:2772
msgid "the Pumpking"
msgstr ""

#: ../../TShockAPI/Commands.cs:2693
msgid "the Queen Bee"
msgstr ""

#: ../../TShockAPI/Commands.cs:2742
msgid "the Queen Slime"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:158
msgid "The REST authentication token."
msgstr ""

#: ../../TShockAPI/UpdateManager.cs:150
msgid "The server is out of date. Latest version: "
msgstr ""

#: ../../TShockAPI/Commands.cs:4495
msgid "The spawn rate you provided is out-of-range or not a number."
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:90
msgid "The specified token queued for destruction failed to be deleted."
msgstr ""

#: ../../TShockAPI/Commands.cs:1869
msgid "The target player has not logged in yet."
msgstr ""

#: ../../TShockAPI/Commands.cs:1849
msgid ""
"The targeted user cannot have their data uploaded, because they are not a "
"player."
msgstr ""

#: ../../TShockAPI/Commands.cs:2707
msgid "the Twins"
msgstr ""

#: ../../TShockAPI/Commands.cs:1136
#, csharp-format
msgid "The user {0} does not exist! Therefore, the account was not deleted."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:95
msgid "The value has to be greater than or equal to zero."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:81
msgid "The value has to be greater than zero."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:127
msgid "The versions of plugins you requested aren't compatible with eachother."
msgstr ""

#: ../../TShockAPI/Commands.cs:2722
msgid "the Wall of Flesh"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:805
msgid "The world's chest limit has been reached - unable to place more."
msgstr ""

#: ../../TShockAPI/Commands.cs:1672
msgid "There are currently no active bans."
msgstr ""

#: ../../TShockAPI/Commands.cs:2093
msgid "There are currently no active REST users."
msgstr ""

#: ../../TShockAPI/Commands.cs:1434
msgid "There are currently no available identifiers."
msgstr ""

#: ../../TShockAPI/Commands.cs:4001
msgid "There are currently no banned items."
msgstr ""

#: ../../TShockAPI/Commands.cs:4179
msgid "There are currently no banned projectiles."
msgstr ""

#: ../../TShockAPI/Commands.cs:4355
msgid "There are currently no banned tiles."
msgstr ""

#: ../../TShockAPI/Commands.cs:3776
#, csharp-format
msgid "There are currently no permissions for {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5341
msgid "There are currently no players online."
msgstr ""

#: ../../TShockAPI/Commands.cs:4917
msgid "There are currently no regions defined."
msgstr ""

#: ../../TShockAPI/Commands.cs:3230
msgid "There are currently no warps defined."
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:155
msgid "There are no regions at this point, or they are not protected."
msgstr ""

#: ../../TShockAPI/RegionHandler.cs:154
msgid "There are no regions at this point."
msgstr ""

#: ../../TShockAPI/Commands.cs:2713
msgid "There is already a Wall of Flesh."
msgstr ""

#: ../../TShockAPI/Commands.cs:936
msgid ""
"There was an error processing your login or authentication related request."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:121
msgid "There was an issue figuring out what to download."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:90
msgid "There was an issue reading the packages.json."
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:99
#, csharp-format
msgid "This is the plugin you requested to install."
msgid_plural "These are the plugins you requested to install"
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/TShock.cs:1049
#: ../../TShockAPI/TShock.cs:1059
#, csharp-format
msgid "This token will display until disabled by verification. ({0}setup)"
msgstr ""

#: ../../TShockAPI/Commands.cs:4241
#: ../../TShockAPI/Commands.cs:4299
#, csharp-format
msgid "Tile {0} is not banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:4335
msgid "Tile Ban Sub-Commands ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:4353
msgid "Tile bans ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:918
#, csharp-format
msgid "Tile kill threshold exceeded {0}."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:936
#, csharp-format
msgid "Tile place threshold exceeded {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6420
#, csharp-format
msgid "To buff a player without them knowing, use {0} instead of {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6015
#: ../../TShockAPI/Commands.cs:6311
#, csharp-format
msgid "To execute this command silently, use {0} instead of {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6014
#, csharp-format
msgid ""
"To get rid of NPCs without making them drop items, use the {0} command "
"instead."
msgstr ""

#: ../../TShockAPI/Commands.cs:5464
#, csharp-format
msgid ""
"To mute a player without broadcasting to chat, use the command with {0} "
"instead of {1}"
msgstr ""

#: ../../TShockAPI/TShock.cs:1048
#: ../../TShockAPI/TShock.cs:1058
#, csharp-format
msgid "To setup the server, join the game and type {0}setup {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:471
msgid "Toggles build protection."
msgstr ""

#: ../../TShockAPI/Commands.cs:484
msgid "Toggles christmas mode (present spawning, santa, etc)."
msgstr ""

#: ../../TShockAPI/Commands.cs:545
msgid "Toggles godmode on a player."
msgstr ""

#: ../../TShockAPI/Commands.cs:480
msgid "Toggles halloween mode (goodie bags, pumpkins, etc)."
msgstr ""

#: ../../TShockAPI/Commands.cs:496
msgid "Toggles spawn protection."
msgstr ""

#: ../../TShockAPI/Commands.cs:492
msgid "Toggles the world's hardmode status."
msgstr ""

#: ../../TShockAPI/Commands.cs:591
msgid "Toggles to either ignore or recieve whispers from other players."
msgstr ""

#: ../../TShockAPI/Commands.cs:461
msgid "Toggles whether other people can teleport you."
msgstr ""

#: ../../TShockAPI/Commands.cs:276
msgid "Toggles whether you receive server logs."
msgstr ""

#: ../../TShockAPI/Commands.cs:777
msgid "Too many invalid login attempts."
msgstr ""

#: ../../TShockAPI/Commands.cs:6646
msgid "Topaz Gemtree"
msgstr ""

#: ../../TShockAPI/Commands.cs:1224
#, csharp-format
msgid "Total processor time: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5202
msgid "tp <region> - Teleports you to the given region's center."
msgstr ""

#: ../../TShockAPI/Commands.cs:6511
msgid "Trees types & misc available to use. ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/Commands.cs:6700
#, csharp-format
msgid "Tried to grow a {0}."
msgstr ""

#: ../../TShockAPI/TShock.cs:403
#, csharp-format
msgid "TShock {0} ({1}) now running."
msgstr ""

#: ../../TShockAPI/Commands.cs:1367
msgid "TShock Ban Help"
msgstr ""

#: ../../TShockAPI/TShock.cs:480
msgid "TShock comes with no warranty & is free software."
msgstr ""

#: ../../TShockAPI/TShock.cs:492
msgid ""
"TShock encountered a problem from which it cannot recover. The following "
"message may help diagnose the problem."
msgstr ""

#: ../../TShockAPI/TShock.cs:1057
msgid ""
"TShock Notice: setup-code.txt is still present, and the code located in that "
"file will be used."
msgstr ""

#: ../../TShockAPI/TShock.cs:357
msgid ""
"TShock was improperly shut down. Please use the exit command in the future to "
"prevent this."
msgstr ""

#: ../../TShockAPI/TShock.cs:1033
msgid ""
"TShock will now disable the initial setup system and remove setup-code.txt as "
"it is no longer needed."
msgstr ""

#: ../../TShockAPI/Commands.cs:5299
#, csharp-format
msgid "TShock: {0} {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1433
#, csharp-format
msgid "Type {0}ban help identifiers {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:1671
#, csharp-format
msgid "Type {0}ban list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:3455
#, csharp-format
msgid "Type {0}group help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:3746
#, csharp-format
msgid "Type {0}group list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:3775
#, csharp-format
msgid "Type {0}group listperm {1} {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:6512
#, csharp-format
msgid "Type {0}grow help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:5261
#, csharp-format
msgid "Type {0}help {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:3982
#, csharp-format
msgid "Type {0}itemban help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4000
#, csharp-format
msgid "Type {0}itemban list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:1053
#, csharp-format
msgid "Type {0}login \"{1}\" {2} to log-in to your account."
msgstr ""

#: ../../TShockAPI/Commands.cs:1055
#, csharp-format
msgid "Type {0}login {1} to log-in to your account."
msgstr ""

#: ../../TShockAPI/Commands.cs:1050
#, csharp-format
msgid "Type {0}login to log-in to your account using your UUID."
msgstr ""

#: ../../TShockAPI/Commands.cs:4160
#, csharp-format
msgid "Type {0}projban help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4178
#, csharp-format
msgid "Type {0}projban list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:5209
#, csharp-format
msgid "Type {0}region {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4987
#, csharp-format
msgid "Type {0}region info {1} {{0}} for more information."
msgstr ""

#: ../../TShockAPI/Commands.cs:4916
#, csharp-format
msgid "Type {0}region list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:2095
#, csharp-format
msgid "Type {0}rest listusers {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:4336
#, csharp-format
msgid "Type {0}tileban help {{0}} for more sub-commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:4354
#, csharp-format
msgid "Type {0}tileban list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:3229
#, csharp-format
msgid "Type {0}warp list {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:5367
#, csharp-format
msgid "Type {0}who {1} for more."
msgstr ""

#: ../../TShockAPI/PaginationTools.cs:108
msgid "Type /<command> {{0}} for more."
msgstr ""

#: ../../TShockAPI/Commands.cs:6444
#, csharp-format
msgid "Unable to find any buff named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:6385
#, csharp-format
msgid "Unable to find any buffs named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:6429
#, csharp-format
msgid "Unable to find any player named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:6323
#, csharp-format
msgid "Unable to find any players named \"{0}\""
msgstr ""

#: ../../TShockAPI/Commands.cs:5670
#, csharp-format
msgid "Unable to launch {0} because he is not logged in."
msgstr ""

#: ../../TShockAPI/Commands.cs:5672
#, csharp-format
msgid "Unable to launch {0} because she is not logged in."
msgstr ""

#: ../../TShockAPI/TShock.cs:1520
msgid "Unable to parse command '{0}' from player {1}."
msgstr ""

#: ../../TShockAPI/TShock.cs:1519
msgid ""
"Unable to parse command. Please contact an administrator for assistance."
msgstr ""

#: ../../TShockAPI/Commands.cs:2885
msgid ""
"Unable to spawn a Wall of Flesh based on its current state or your current "
"location."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:450
#, csharp-format
msgid "Unable to verify the password hash for user {0} ({1})"
msgstr ""

#: ../../TShockAPI/Commands.cs:3912
#, csharp-format
msgid "Unbanned {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4094
#, csharp-format
msgid "Unbanned projectile {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:4270
#, csharp-format
msgid "Unbanned tile {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1455
#, csharp-format
msgid "Unknown ban command. Try {0} {1}, {2}, {3}, {4}, {5}, or {6}."
msgstr ""

#: ../../TShockAPI/Commands.cs:6694
msgid "Unknown plant!"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:246
msgid "Unrecognized player direction"
msgstr ""

#: ../../TShockAPI/TShock.cs:493
msgid ""
"Until the problem is resolved, TShock will not be able to start (and will "
"crash on startup)."
msgstr ""

#: ../../TShockAPI/UpdateManager.cs:120
#, csharp-format
msgid ""
"Update server did not respond with an OK. Server message: [error {0}] {1}"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:197
msgid "UpdateLogin SQL returned an error"
msgstr ""

#: ../../TShockAPI/UpdateManager.cs:83
#: ../../TShockAPI/UpdateManager.cs:86
#, csharp-format
msgid "UpdateManager warning: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:316
msgid ""
"Upload the account information when you joined the server as your Server Side "
"Character data."
msgstr ""

#: ../../TShockAPI/Commands.cs:1916
#, csharp-format
msgid "Usage: {0}tempgroup <username> <new group> [time]"
msgstr ""

#: ../../TShockAPI/Commands.cs:2001
msgid "Usage: /sudo [command]."
msgstr ""

#: ../../TShockAPI/Commands.cs:1844
#: ../../TShockAPI/Commands.cs:1850
msgid "Usage: /uploadssc [playername]."
msgstr ""

#: ../../TShockAPI/Commands.cs:2441
#, csharp-format
msgid "Use \"{0}worldevent rain slime\" to start slime rain!"
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2058
msgid "Use \"my query\" for items with spaces."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:2059
msgid ""
"Use tsi:[number] or tsn:[username] to distinguish between user IDs and "
"usernames."
msgstr ""

#: ../../TShockAPI/Commands.cs:227
msgid "Used to authenticate as superadmin when first setting up TShock."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1341
#, csharp-format
msgid "User {0} '{1}' doesn't exist"
msgstr ""

#: ../../TShockAPI/Commands.cs:1114
#, csharp-format
msgid "User {0} already exists."
msgstr ""

#: ../../TShockAPI/Commands.cs:1118
#, csharp-format
msgid "User {0} could not be added, check console for details."
msgstr ""

#: ../../TShockAPI/Commands.cs:1198
#, csharp-format
msgid "User {0} could not be added. Check console for details."
msgstr ""

#: ../../TShockAPI/Commands.cs:1194
#: ../../TShockAPI/Commands.cs:1302
#, csharp-format
msgid "User {0} does not exist."
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:612
#, csharp-format
msgid "User account {0} already exists"
msgstr ""

#: ../../TShockAPI/DB/UserManager.cs:625
#, csharp-format
msgid "User account {0} does not exist"
msgstr ""

#: ../../TShockAPI/Commands.cs:1204
msgid "User management command help:"
msgstr ""

#: ../../TShockAPI/Rest/SecureRest.cs:138
#: ../../TShockAPI/Rest/SecureRest.cs:144
#: ../../TShockAPI/Rest/SecureRest.cs:152
msgid ""
"Username or password may be incorrect or this account may not have sufficient "
"privileges."
msgstr ""

#: ../../TShockAPI/TShock.cs:394
#: ../../TShockAPI/TShock.cs:398
#, csharp-format
msgid "Using {0} for tile implementation"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1794
#, csharp-format
msgid "Using {0} on non-honey"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1803
#, csharp-format
msgid "Using {0} on non-lava"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1810
#, csharp-format
msgid "Using {0} on non-shimmer"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1785
#, csharp-format
msgid "Using {0} on non-water"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1817
#, csharp-format
msgid "Using {0} on non-water or shimmer"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1825
#, csharp-format
msgid "Using {0} to manipulate unknown liquid {1}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1740
#, csharp-format
msgid "Using banned {0} to manipulate liquid"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1763
msgid "Using banned honey bucket without permissions"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1756
msgid "Using banned lava bucket without permissions"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1770
msgid "Using banned shimmering water bucket without permissions"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1749
msgid "Using banned water bucket without permissions"
msgstr ""

#: ../../TShockAPI/Commands.cs:924
msgid "UUID does not match this character."
msgstr ""

#: ../../TShockAPI/Commands.cs:2147
#, csharp-format
msgid "Valid event types: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2148
#, csharp-format
msgid "Valid invasion types if spawning an invasion: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2333
#, csharp-format
msgid "Valid invasion types: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2549
#, csharp-format
msgid "Valid world modes: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3250
#, csharp-format
msgid "Warp {0} already exists."
msgstr ""

#: ../../TShockAPI/Commands.cs:3286
#, csharp-format
msgid "Warp {0} is now private."
msgstr ""

#: ../../TShockAPI/Commands.cs:3288
#, csharp-format
msgid "Warp {0} is now public."
msgstr ""

#: ../../TShockAPI/Commands.cs:3246
#, csharp-format
msgid "Warp added: {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3265
#, csharp-format
msgid "Warp deleted: {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:3345
#, csharp-format
msgid "Warped to {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:3228
msgid "Warps ({{0}}/{{1}}):"
msgstr ""

#: ../../TShockAPI/TShock.cs:479
msgid "Welcome to TShock for Terraria!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5518
msgid "Whisper Syntax"
msgstr ""

#: ../../TShockAPI/Commands.cs:6608
msgid "Willow Tree"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:85
msgid "Without a list of plugins to install, no plugins can be installed."
msgstr ""

#: ../../TShockAPI/BackupManager.cs:80
#, csharp-format
msgid "World backed up ({0})."
msgstr ""

#: ../../TShockAPI/BackupManager.cs:78
msgid "World backed up."
msgstr ""

#: ../../TShockAPI/Commands.cs:2574
#, csharp-format
msgid "World mode set to {0}."
msgstr ""

#: ../../TShockAPI/TShock.cs:854
#, csharp-format
msgid "World name will be overridden by: {0}"
msgstr ""

#: ../../TShockAPI/TShock.cs:811
#, csharp-format
msgid "World path has been set to {0}"
msgstr ""

#: ../../TShockAPI/SaveManager.cs:137
#, csharp-format
msgid "World saved at ({0})"
msgstr ""

#: ../../TShockAPI/SaveManager.cs:135
msgid "World saved."
msgstr ""

#: ../../TShockAPI/Commands.cs:4948
#, csharp-format
msgid "X: {0}; Y: {1}; W: {2}; H: {3}, Z: {4}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5938
msgid "You are already dead!"
msgstr ""

#: ../../TShockAPI/Commands.cs:783
msgid "You are already logged in, and cannot login again."
msgstr ""

#: ../../TShockAPI/Commands.cs:2913
msgid "You are dead. Dead players can't go home."
msgstr ""

#: ../../TShockAPI/TShock.cs:1537
msgid "You are muted!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5428
#: ../../TShockAPI/Commands.cs:5443
#: ../../TShockAPI/Commands.cs:5534
#: ../../TShockAPI/Commands.cs:5571
msgid "You are muted."
msgstr ""

#: ../../TShockAPI/Commands.cs:6754
#, csharp-format
msgid "You are no longer in god mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:5988
msgid "You are not dead!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5454
msgid "You are not in a party!"
msgstr ""

#: ../../TShockAPI/Commands.cs:945
msgid "You are not logged-in. Therefore, you cannot logout."
msgstr ""

#: ../../TShockAPI/Configuration/TShockConfig.cs:333
msgid "You are not on the whitelist."
msgstr ""

#: ../../TShockAPI/Commands.cs:5618
msgid "You are now being annoyed."
msgstr ""

#: ../../TShockAPI/Commands.cs:6753
#, csharp-format
msgid "You are now in god mode."
msgstr ""

#: ../../TShockAPI/Commands.cs:6406
#: ../../TShockAPI/Commands.cs:6463
#, csharp-format
msgid "You buffed yourself with {0} ({1}) for {2} seconds."
msgstr ""

#: ../../TShockAPI/Commands.cs:6049
#, csharp-format
msgid "You butchered {0} NPC."
msgid_plural "You butchered {0} NPCs."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/TShock.cs:481
msgid "You can modify & distribute it under the terms of the GNU GPLv3."
msgstr ""

#: ../../TShockAPI/Commands.cs:694
#, csharp-format
msgid "You can use '{0}sudo {0}{1}' to override this check."
msgstr ""

#: ../../TShockAPI/Commands.cs:5602
#, csharp-format
msgid "You can use {0} instead of {1} to annoy a player silently."
msgstr ""

#: ../../TShockAPI/Commands.cs:5818
#: ../../TShockAPI/Commands.cs:5920
#, csharp-format
msgid "You can use {0} instead of {1} to execute this command silently."
msgstr ""

#: ../../TShockAPI/Commands.cs:5686
#, csharp-format
msgid "You can use {0} instead of {1} to launch a firework silently."
msgstr ""

#: ../../TShockAPI/Commands.cs:5630
#, csharp-format
msgid "You can use {0} instead of {1} to rocket a player silently."
msgstr ""

#: ../../TShockAPI/Commands.cs:5564
#, csharp-format
msgid "You can use {0}{1} to toggle this setting."
msgstr ""

#: ../../TShockAPI/Commands.cs:5591
#, csharp-format
msgid "You can use {0}{1} to whisper to other players."
msgstr ""

#: ../../TShockAPI/Commands.cs:6733
msgid "You can't god mode a non player!"
msgstr ""

#: ../../TShockAPI/Commands.cs:6333
msgid "You can't heal a dead player!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1337
msgid "You can't kick another admin."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:501
#: ../../TShockAPI/DB/GroupManager.cs:502
msgid "You can't remove the default guest group."
msgstr ""

#: ../../TShockAPI/Commands.cs:5957
msgid "You can't respawn the server console!"
msgstr ""

#: ../../TShockAPI/Commands.cs:814
msgid "You cannot login whilst crowd controlled."
msgstr ""

#: ../../TShockAPI/Commands.cs:800
msgid "You cannot login whilst dead."
msgstr ""

#: ../../TShockAPI/Commands.cs:808
msgid "You cannot login whilst using an item."
msgstr ""

#: ../../TShockAPI/Commands.cs:6144
#: ../../TShockAPI/Commands.cs:6283
msgid "You cannot spawn banned items."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3486
msgid "You cannot use the Enchanted Sundial because time is stopped."
msgstr ""

#: ../../TShockAPI/Commands.cs:5541
msgid "You cannot whisper to yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:5851
#, csharp-format
msgid "You deleted {0} item within a radius of {1}."
msgid_plural "You deleted {0} items within a radius of {1}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:5875
#, csharp-format
msgid "You deleted {0} NPC within a radius of {1}."
msgid_plural "You deleted {0} NPCs within a radius of {1}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:5900
#, csharp-format
msgid "You deleted {0} projectile within a radius of {1}."
msgid_plural "You deleted {0} projectiles within a radius of {1}."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:6316
msgid "You didn't put a player name."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4256
msgid "You died! Normally, you'd be banned."
msgstr ""

#: ../../TShockAPI/Commands.cs:691
#: ../../TShockAPI/Commands.cs:5280
msgid "You do not have access to this command."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:829
msgid "You do not have permission to build in the spawn point."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:832
msgid "You do not have permission to build in this region."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:826
msgid "You do not have permission to build on this server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativeUnlocksHandler.cs:74
msgid "You do not have permission to contribute research."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1184
msgid "You do not have permission to create that projectile."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:113
msgid "You do not have permission to freeze the biome spread of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:109
msgid "You do not have permission to freeze the rain strength of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:103
msgid "You do not have permission to freeze the time of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:110
msgid "You do not have permission to freeze the wind strength of the server."
msgstr ""

#: ../../TShockAPI/Commands.cs:6711
msgid "You do not have permission to god mode another player."
msgstr ""

#: ../../TShockAPI/Commands.cs:6522
msgid "You do not have permission to grow this tree type"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2999
msgid "You do not have permission to hurt Town NPCs."
msgstr ""

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:22
msgid "You do not have permission to modify a Hat Rack in a protected area!"
msgstr ""

#: ../../TShockAPI/Handlers/DisplayDollItemSyncHandler.cs:21
#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:28
msgid "You do not have permission to modify a Mannequin in a protected area!"
msgstr ""

#: ../../TShockAPI/Handlers/RequestTileEntityInteractionHandler.cs:34
msgid "You do not have permission to modify a TileEntity in a protected area!"
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:114
msgid "You do not have permission to modify the NPC spawn rate of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:107
msgid "You do not have permission to modify the rain strength of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:111
msgid ""
"You do not have permission to modify the tile placement range of your "
"character."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:104
msgid "You do not have permission to modify the time of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:108
msgid "You do not have permission to modify the time speed of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:106
msgid "You do not have permission to modify the wind strength of the server."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:112
msgid ""
"You do not have permission to modify the world difficulty of the server."
msgstr ""

#: ../../TShockAPI/Commands.cs:5479
#, csharp-format
msgid "You do not have permission to mute {0}"
msgstr ""

#: ../../TShockAPI/Bouncer.cs:1732
msgid "You do not have permission to perform this action."
msgstr ""

#: ../../TShockAPI/ItemBans.cs:202
msgid "You do not have permission to place actuators."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4011
msgid "You do not have permission to place Logic Sensors."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:655
#: ../../TShockAPI/Bouncer.cs:2263
msgid "You do not have permission to place this tile."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3534
msgid "You do not have permission to relocate Town NPCs."
msgstr ""

#: ../../TShockAPI/Commands.cs:5965
msgid "You do not have permission to respawn another player."
msgstr ""

#: ../../TShockAPI/Commands.cs:5335
msgid "You do not have permission to see player IDs."
msgstr ""

#: ../../TShockAPI/Handlers/EmojiHandler.cs:19
msgid "You do not have permission to send emotes!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3573
msgid "You do not have permission to spawn pets."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4171
msgid "You do not have permission to start a party."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3566
msgid "You do not have permission to start invasions."
msgstr ""

#: ../../TShockAPI/Commands.cs:2156
#, csharp-format
msgid "You do not have permission to start the {0} event."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4189
msgid "You do not have permission to start the Old One's Army."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3559
msgid "You do not have permission to summon bosses."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3009
msgid "You do not have permission to summon the Empress of Light."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3026
msgid "You do not have permission to summon the Lunatic Cultist!"
msgstr ""

#: ../../TShockAPI/Commands.cs:3070
msgid "You do not have permission to teleport all other players."
msgstr ""

#: ../../TShockAPI/Commands.cs:2981
msgid "You do not have permission to teleport all players."
msgstr ""

#: ../../TShockAPI/Commands.cs:2964
msgid "You do not have permission to teleport other players."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3876
#, csharp-format
msgid "You do not have permission to teleport using {0}."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3788
msgid "You do not have permission to teleport using items."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/PylonHandler.cs:54
msgid "You do not have permission to teleport using pylons."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3812
msgid "You do not have permission to teleport using Wormhole Potions."
msgstr ""

#: ../../TShockAPI/Commands.cs:5154
msgid "You do not have permission to teleport."
msgstr ""

#: ../../TShockAPI/Handlers/NetModules/CreativePowerHandler.cs:105
msgid "You do not have permission to toggle godmode."
msgstr ""

#: ../../TShockAPI/Commands.cs:1839
msgid ""
"You do not have permission to upload another player's character join-state "
"server-side-character data."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3478
msgid "You do not have permission to use the Enchanted Sundial."
msgstr ""

#: ../../TShockAPI/Commands.cs:652
#, csharp-format
msgid ""
"You entered a space after {0} instead of a command. Type {0}help for a list "
"of valid commands."
msgstr ""

#: ../../TShockAPI/Commands.cs:985
msgid "You failed to change your password."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2493
msgid "You have been Bounced."
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1393
msgid "You have been remotely muted"
msgstr ""

#: ../../TShockAPI/Rest/RestManager.cs:1398
msgid "You have been remotely unmmuted"
msgstr ""

#: ../../TShockAPI/Commands.cs:956
msgid "You have been successfully logged out of your account."
msgstr ""

#: ../../TShockAPI/Commands.cs:6465
#, csharp-format
msgid "You have buffed {0} with {1} ({2}) for {3} seconds!"
msgstr ""

#: ../../TShockAPI/Commands.cs:1959
#, csharp-format
msgid "You have changed {0}'s group to {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1964
#, csharp-format
msgid "You have changed {0}'s group to {1} for {2}"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:4271
msgid ""
"You have fallen in hardcore mode, and your items have been lost forever."
msgstr ""

#: ../../TShockAPI/Commands.cs:5662
#, csharp-format
msgid "You have launched {0} into space."
msgstr ""

#: ../../TShockAPI/Commands.cs:5660
msgid "You have launched yourself into space."
msgstr ""

#: ../../TShockAPI/Commands.cs:5498
#, csharp-format
msgid "You have muted {0} for {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:5997
#, csharp-format
msgid "You have respawned {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6002
msgid "You have respawned yourself."
msgstr ""

#: ../../TShockAPI/Commands.cs:974
msgid "You have successfully changed your password."
msgstr ""

#: ../../TShockAPI/Commands.cs:5486
#, csharp-format
msgid "You have unmuted {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5590
msgid "You haven't previously received any whispers."
msgstr ""

#: ../../TShockAPI/Commands.cs:6347
#, csharp-format
msgid "You healed {0} for {1} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:6345
#, csharp-format
msgid "You healed yourself for {0} HP."
msgstr ""

#: ../../TShockAPI/Commands.cs:5947
#, csharp-format
msgid "You just killed {0}!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5945
msgid "You just killed yourself!"
msgstr ""

#: ../../TShockAPI/Commands.cs:5744
#, csharp-format
msgid "You launched fireworks on {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:5742
msgid "You launched fireworks on yourself."
msgstr ""

#: ../../TShockAPI/TShock.cs:648
msgid "You logged in from another location."
msgstr ""

#: ../../TShockAPI/TShock.cs:639
msgid "You logged in from the same IP."
msgstr ""

#: ../../TShockAPI/Commands.cs:5561
msgid "You may now receive whispers from other players."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2656
msgid ""
"You may wish to consider removing the tshock.ignore.ssc permission or "
"negating it for this player."
msgstr ""

#: ../../TShockAPI/DB/RegionManager.cs:788
msgid "You must be logged in to take advantage of protected regions."
msgstr ""

#: ../../TShockAPI/Commands.cs:5396
msgid "You must provide a setup code!"
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3489
msgid ""
"You must set ForceTime to normal via config to use the Enchanted Sundial."
msgstr ""

#: ../../TShockAPI/Commands.cs:2718
msgid "You must spawn the Wall of Flesh in hell."
msgstr ""

#: ../../TShockAPI/Commands.cs:699
msgid "You must use this command in-game."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2558
msgid "You need to join with a hardcore player."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2552
msgid "You need to join with a mediumcore player or higher."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:2546
msgid "You need to join with a softcore player."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:551
msgid "You need to rejoin to ensure your trash can is cleared!"
msgstr ""

#: ../../TShockAPI/Commands.cs:2827
#, csharp-format
msgid "You spawned {0} {1} time."
msgid_plural "You spawned {0} {1} times."
msgstr[0] ""
msgstr[1] ""

#: ../../TShockAPI/Commands.cs:3329
#, csharp-format
msgid "You warped {0} to {1}."
msgstr ""

#: ../../TShockAPI/Commands.cs:2995
#: ../../TShockAPI/Commands.cs:3035
#: ../../TShockAPI/Commands.cs:3078
#: ../../TShockAPI/Commands.cs:3093
#, csharp-format
msgid "You were teleported to {0}."
msgstr ""

#: ../../TShockAPI/TShock.cs:1742
msgid "You will be teleported to your last known location..."
msgstr ""

#: ../../TShockAPI/Commands.cs:5563
msgid "You will no longer receive whispers from other players."
msgstr ""

#: ../../TShockAPI/Commands.cs:6485
msgid "You're not allowed to change tiles here!"
msgstr ""

#: ../../TShockPluginManager/NugetCLI.cs:84
msgid "You're trying to sync, but you don't have a packages.json file."
msgstr ""

#: ../../TShockAPI/Commands.cs:1987
msgid "Your account has been elevated to superadmin for 10 minutes."
msgstr ""

#: ../../TShockAPI/Commands.cs:1046
#, csharp-format
msgid "Your account, \"{0}\", has been registered."
msgstr ""

#: ../../TShockAPI/DB/GroupManager.cs:235
#: ../../TShockAPI/DB/GroupManager.cs:237
msgid ""
"Your account's group could not be loaded. Please contact server "
"administrators about this."
msgstr ""

#: ../../TShockAPI/Bouncer.cs:454
msgid "Your client sent a blank character name."
msgstr ""

#: ../../TShockAPI/TShock.cs:1387
msgid ""
"Your client sent a blank UUID. Configure it to send one or use a different "
"client."
msgstr ""

#: ../../TShockAPI/DB/RegionManager.cs:107
msgid "Your database contains invalid UserIDs (they should be integers)."
msgstr ""

#: ../../TShockAPI/Commands.cs:1966
#, csharp-format
msgid "Your group has been changed to {0} for {1}"
msgstr ""

#: ../../TShockAPI/Commands.cs:1960
#, csharp-format
msgid "Your group has temporarily been changed to {0}"
msgstr ""

#: ../../TShockAPI/Commands.cs:6149
msgid "Your inventory seems full."
msgstr ""

#: ../../TShockAPI/Commands.cs:1859
msgid ""
"Your local character data, from your initial connection, has been uploaded to "
"the server."
msgstr ""

#: ../../TShockAPI/Commands.cs:5385
#, csharp-format
msgid ""
"Your new account has been verified, and the {0}setup system has been turned "
"off."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3257
msgid "Your password did not match this character's password."
msgstr ""

#: ../../TShockAPI/Commands.cs:1047
#, csharp-format
msgid "Your password is {0}."
msgstr ""

#: ../../TShockAPI/Commands.cs:1978
msgid "Your previous permission set has been restored."
msgstr ""

#: ../../TShockAPI/Commands.cs:5791
msgid "Your reference dumps have been created in the server folder."
msgstr ""

#: ../../TShockAPI/Commands.cs:1758
msgid "Your server-side character data has been saved."
msgstr ""

#: ../../TShockAPI/TSPlayer.cs:1342
msgid "Your temporary group access has expired."
msgstr ""

#: ../../TShockAPI/Commands.cs:5199
msgid "z <name> <#> - Sets the z-order of the region."
msgstr ""

#: ../../TShockAPI/GetDataHandlers.cs:3275
msgctxt "Likely non-vanilla client send zero-length password"
msgid "You have been Bounced for invalid password."
msgstr ""

#: ../../TShockAPI/TSServerPlayer.cs:34
msgctxt "The account name of server console."
msgid "ServerConsole"
msgstr ""


```
### Folder: `temp_TShock-5.2.4/prebuilts`
#### File: `temp_TShock-5.2.4/prebuilts/HttpServer.xml`
```
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HttpServer</name>
    </assembly>
    <members>
        <member name="T:HttpServer.SocketFilterEventArgs">
            <summary>
            Used by <see cref="E:HttpServer.HttpListener.SocketAccepted"/> to filter out unwanted connections.
            </summary>
        </member>
        <member name="M:HttpServer.SocketFilterEventArgs.#ctor(System.Net.Sockets.Socket)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.SocketFilterEventArgs"/> class.
            </summary>
            <param name="socket">The socket.</param>
        </member>
        <member name="P:HttpServer.SocketFilterEventArgs.IsSocketOk">
            <summary>
            Gets or sets if socket can be accepted.
            </summary>
        </member>
        <member name="P:HttpServer.SocketFilterEventArgs.Socket">
            <summary>
            Gets socket.
            </summary>
        </member>
        <member name="T:HttpServer.RequestEventArgs">
            <summary>
            A request have been received.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:HttpServer.RequestEventArgs.#ctor(HttpServer.IHttpContext,HttpServer.IRequest,HttpServer.IResponse)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.RequestEventArgs"/> class.
            </summary>
            <param name="context">context that received the request.</param>
            <param name="request">Received request.</param>
            <param name="response">Response to send.</param>
        </member>
        <member name="P:HttpServer.RequestEventArgs.Context">
            <summary>
            Gets context that received the request.
            </summary>
            <remarks>
            Do not forget to set <see cref="P:HttpServer.RequestEventArgs.IsHandled"/> to <c>true</c> if you are sending
            back a response manually through <see cref="P:HttpServer.IHttpContext.Stream"/>.
            </remarks>
        </member>
        <member name="P:HttpServer.RequestEventArgs.IsHandled">
            <summary>
            Gets or sets if the request have been handled.
            </summary>
            <remarks>
            The library will not attempt to send the response object
            back to the client if this property is set to <c>true</c>.
            </remarks>
        </member>
        <member name="P:HttpServer.RequestEventArgs.Request">
            <summary>
            Gets request object.
            </summary>
        </member>
        <member name="P:HttpServer.RequestEventArgs.Response">
            <summary>
            Gets response object.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.ResponseCookieCollection">
            <summary>
            Cookies that should be set.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookieCollection.Add(HttpServer.Messages.ResponseCookie)">
            <summary>
            Adds a cookie in the collection.
            </summary>
            <param name="cookie">cookie to add</param>
            <exception cref="T:System.ArgumentNullException">cookie is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">Name and Content must be specified.</exception>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookieCollection.Add(HttpServer.Messages.RequestCookie,System.DateTime)">
            <summary>
            Copy a request cookie
            </summary>
            <param name="cookie"></param>
            <param name="expires">When the cookie should expire</param>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookieCollection.Clear">
            <summary>
            Remove all cookies
            </summary>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookieCollection.GetEnumerator">
            <summary>
            Gets a collection enumerator on the cookie list.
            </summary>
            <returns>collection enumerator</returns>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookieCollection.System#Collections#Generic#IEnumerable{HttpServer#Messages#ResponseCookie}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:HttpServer.Messages.ResponseCookieCollection.Count">
            <summary>
            Gets the count of cookies in the collection.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.ResponseCookieCollection.Item(System.String)">
            <summary>
            Gets the cookie of a given identifier.
            </summary>
            <value>Cookie if found; otherwise <c>null</c>.</value>
        </member>
        <member name="T:HttpServer.ExceptionEventArgs">
            <summary>
            An exception that can't be handled by the library have been thrown.
            </summary>
        </member>
        <member name="M:HttpServer.ExceptionEventArgs.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ExceptionEventArgs"/> class.
            </summary>
            <param name="exception">The exception.</param>
        </member>
        <member name="P:HttpServer.ExceptionEventArgs.Exception">
            <summary>
            Gets caught exception.
            </summary>
        </member>
        <member name="T:HttpServer.BodyDecoders.DecodedData">
            <summary>
            Data decoded from a POST body.
            </summary>
        </member>
        <member name="M:HttpServer.BodyDecoders.DecodedData.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.BodyDecoders.DecodedData"/> class.
            </summary>
        </member>
        <member name="P:HttpServer.BodyDecoders.DecodedData.Files">
            <summary>
            Gets or sets decoded files.
            </summary>
        </member>
        <member name="P:HttpServer.BodyDecoders.DecodedData.Parameters">
            <summary>
            Gets or sets decoded parameters.
            </summary>
        </member>
        <member name="T:HttpServer.Sessions.SessionFileStore">
            <summary>
             Stores sessions in files.
            </summary>
             <remarks>
             All session parameters must be serializable.
             </remarks>
        </member>
        <member name="T:HttpServer.Sessions.ISessionStore">
            <summary>
            Stores sessions in your favorite store
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="M:HttpServer.Sessions.ISessionStore.Save(HttpServer.Sessions.Session)">
            <summary>
            Saves the specified session.
            </summary>
            <param name="session">The session.</param>
        </member>
        <member name="M:HttpServer.Sessions.ISessionStore.Touch(System.String)">
            <summary>
            Touches the specified session
            </summary>
            <param name="id">Session id.</param>
            <remarks>
            Used to prevent sessions from expiring.
            </remarks>
        </member>
        <member name="M:HttpServer.Sessions.ISessionStore.Load(System.String)">
            <summary>
            Loads a session 
            </summary>
            <param name="id">Session id.</param>
            <returns>Session if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Sessions.ISessionStore.Delete(System.String)">
            <summary>
            Delete a session
            </summary>
            <param name="id">Id of session</param>
        </member>
        <member name="M:HttpServer.Sessions.SessionFileStore.Save(HttpServer.Sessions.Session)">
            <summary>
            Saves the specified session.
            </summary>
            <param name="session">The session.</param>
        </member>
        <member name="M:HttpServer.Sessions.SessionFileStore.Touch(System.String)">
            <summary>
            Touches the specified session
            </summary>
            <param name="id">Session id.</param>
            <remarks>
            Used to prevent sessions from expiring.
            </remarks>
        </member>
        <member name="M:HttpServer.Sessions.SessionFileStore.Load(System.String)">
            <summary>
            Loads a session
            </summary>
            <param name="id">Session id.</param>
            <returns>Session if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:HttpServer.Method">
            <summary>
            HTTP methods.
            </summary>
        </member>
        <member name="F:HttpServer.Method.Unknown">
            <summary>
            Unknown method
            </summary>
        </member>
        <member name="F:HttpServer.Method.Post">
            <summary>
            Posting data
            </summary>
        </member>
        <member name="F:HttpServer.Method.Get">
            <summary>
            Get data
            </summary>
        </member>
        <member name="F:HttpServer.Method.Put">
            <summary>
            Update data
            </summary>
        </member>
        <member name="F:HttpServer.Method.Delete">
            <summary>
            Remove data
            </summary>
        </member>
        <member name="F:HttpServer.Method.Head">
            <summary>
            Get only HTTP headers.
            </summary>
        </member>
        <member name="F:HttpServer.Method.Options">
            <summary>
            Options HTTP 1.1 header.
            </summary>
        </member>
        <member name="T:HttpServer.HttpListener">
            <summary>
            Http listener.
            </summary>
        </member>
        <member name="T:HttpServer.IHttpListener">
            <summary>
            Http listener
            </summary>
        </member>
        <member name="M:HttpServer.IHttpListener.Start(System.Int32)">
            <summary>
            Start listener.
            </summary>
            <param name="backLog">Number of pending accepts.</param>
            <remarks>
            Make sure that you are subscribing on <see cref="E:HttpServer.IHttpListener.RequestReceived"/> first.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Listener have already been started.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Failed to start socket.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid port number.</exception>
        </member>
        <member name="M:HttpServer.IHttpListener.Stop">
            <summary>
            Stop listener.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpListener.Address">
            <summary>
            Gets listener address.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpListener.IsSecure">
            <summary>
            Gets if listener is secure.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpListener.IsStarted">
            <summary>
            Gets if listener have been started.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpListener.Logger">
            <summary>
            Gets or sets logger.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpListener.Port">
            <summary>
            Gets listening port.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpListener.ContentLengthLimit">
            <summary>
            Gets the maximum content size.
            </summary>
            <value>The content length limit.</value>
            <remarks>
            Used when responding to 100-continue.
            </remarks>
        </member>
        <member name="E:HttpServer.IHttpListener.RequestReceived">
            <summary>
            A new request have been received.
            </summary>
        </member>
        <member name="E:HttpServer.IHttpListener.SocketAccepted">
            <summary>
            Can be used to reject certain clients.
            </summary>
        </member>
        <member name="E:HttpServer.IHttpListener.ErrorPageRequested">
            <summary>
            A HTTP exception have been thrown.
            </summary>
            <remarks>
            Fill the body with a user friendly error page, or redirect to somewhere else.
            </remarks>
        </member>
        <member name="M:HttpServer.HttpListener.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpListener"/> class.
            </summary>
            <param name="address">The address.</param>
            <param name="port">The port.</param>
        </member>
        <member name="M:HttpServer.HttpListener.#ctor(System.Net.IPAddress,System.Int32,HttpServer.HttpFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpListener"/> class.
            </summary>
            <param name="address">The address.</param>
            <param name="port">The port.</param>
            <param name="httpFactory">The HTTP factory.</param>
        </member>
        <member name="M:HttpServer.HttpListener.Create(System.Net.IPAddress,System.Int32)">
            <summary>
            Creates a new <see cref="T:HttpServer.HttpListener"/> instance with default factories.
            </summary>
            <param name="address">Address that the listener should accept connections on.</param>
            <param name="port">Port that listener should accept connections on.</param>
            <returns>Created HTTP listener.</returns>
        </member>
        <member name="M:HttpServer.HttpListener.Create(System.Net.IPAddress,System.Int32,HttpServer.HttpFactory)">
            <summary>
            Creates a new <see cref="T:HttpServer.HttpListener"/> instance with default factories.
            </summary>
            <param name="address">Address that the listener should accept connections on.</param>
            <param name="port">Port that listener should accept connections on.</param>
            <param name="factory">Factory used to create different types in the framework.</param>
            <returns>Created HTTP listener.</returns>
        </member>
        <member name="M:HttpServer.HttpListener.Create(System.Net.IPAddress,System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Creates a new <see cref="T:HttpServer.HttpListener"/> instance with default factories.
            </summary>
            <param name="address">Address that the listener should accept connections on.</param>
            <param name="port">Port that listener should accept connections on.</param>
            <param name="certificate">Certificate to use</param>
            <returns>Created HTTP listener.</returns>
        </member>
        <member name="M:HttpServer.HttpListener.CreateContext(System.Net.Sockets.Socket)">
            <summary>
            Create a new context 
            </summary>
            <param name="socket">Accepted socket</param>
            <returns>A new context.</returns>
        </member>
        <member name="M:HttpServer.HttpListener.OnRequest(System.Object,HttpServer.RequestEventArgs)">
            <exception cref="T:System.Exception">Throwing exception if in debug mode and not exception handler have been specified.</exception>
        </member>
        <member name="M:HttpServer.HttpListener.Start(System.Int32)">
            <summary>
            Start listener.
            </summary>
            <param name="backLog">Number of pending accepts.</param>
            <remarks>
            Make sure that you are subscribing on <see cref="E:HttpServer.HttpListener.RequestReceived"/> first.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Listener have already been started.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">Failed to start socket.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid port number.</exception>
        </member>
        <member name="M:HttpServer.HttpListener.Stop">
            <summary>
            Stop listener.
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.Factory">
            <summary>
            Gets HTTP factory used to create types used by this HTTP library.
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.ContentLengthLimit">
            <summary>
            Gets or sets the maximum number of bytes that the request body can contain.
            </summary>
            <value>The content length limit.</value>
            <remarks>
            <para>
            Used when responding to 100-continue.
            </para>
            <para>
            0 = turned off.
            </para>
            </remarks>
        </member>
        <member name="P:HttpServer.HttpListener.Address">
            <summary>
            Gets listener address.
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.IsSecure">
            <summary>
            Gets if listener is secure.
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.IsStarted">
            <summary>
            Gets if listener have been started.
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.Logger">
            <summary>
            Gets or sets logger.
            </summary>
        </member>
        <member name="P:HttpServer.HttpListener.Port">
            <summary>
            Gets listening port.
            </summary>
        </member>
        <member name="E:HttpServer.HttpListener.RequestReceived">
            <summary>
            A new request have been received.
            </summary>
        </member>
        <member name="E:HttpServer.HttpListener.SocketAccepted">
            <summary>
            Can be used to reject certain clients.
            </summary>
        </member>
        <member name="E:HttpServer.HttpListener.ErrorPageRequested">
            <summary>
            A HTTP exception have been thrown.
            </summary>
            <remarks>
            Fill the body with a user friendly error page, or redirect to somewhere else.
            </remarks>
        </member>
        <member name="E:HttpServer.HttpListener.ContinueResponseRequested">
            <summary>
            Client asks if he may continue.
            </summary>
            <remarks>
            If the body is too large or anything like that you should respond <see cref="F:System.Net.HttpStatusCode.ExpectationFailed"/>.
            </remarks>
        </member>
        <member name="T:HttpServer.Headers.CookieHeader">
            <summary>
            Contents of a cookie header.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.IHeader">
            <summary>
            Header in a message
            </summary>
            <remarks>
            Important! Each header should override ToString() 
            and return it's data correctly formatted as a HTTP header value.
            </remarks>
        </member>
        <member name="P:HttpServer.Headers.IHeader.Name">
            <summary>
            Gets header name
            </summary>
        </member>
        <member name="P:HttpServer.Headers.IHeader.HeaderValue">
            <summary>
            Gets value as it would be sent back to client.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.CookieHeader.#ctor(HttpServer.Messages.RequestCookieCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.CookieHeader"/> class.
            </summary>
            <param name="collection">The collection.</param>
            <exception cref="T:System.ArgumentNullException"><c>collection</c> is <c>null</c>.</exception>
        </member>
        <member name="P:HttpServer.Headers.CookieHeader.Cookies">
            <summary>
            Gets cookie collection
            </summary>
        </member>
        <member name="P:HttpServer.Headers.CookieHeader.Name">
            <summary>
            Gets header name
            </summary>
        </member>
        <member name="P:HttpServer.Headers.CookieHeader.HeaderValue">
            <summary>
            Gets value as it would be sent back to client.
            </summary>
            <value></value>
        </member>
        <member name="T:HttpServer.BadRequestException">
            <summary>
            Request couldn't be parsed successfully.
            </summary>
        </member>
        <member name="T:HttpServer.HttpException">
            <summary>
            Exception thrown from HTTP server.
            </summary>
        </member>
        <member name="M:HttpServer.HttpException.#ctor(System.Net.HttpStatusCode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpException"/> class.
            </summary>
            <param name="code">HTTP status code.</param>
            <param name="errMsg">Exception description.</param>
        </member>
        <member name="M:HttpServer.HttpException.#ctor(System.Net.HttpStatusCode,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpException"/> class.
            </summary>
            <param name="code">HTTP status code.</param>
            <param name="errMsg">Exception description.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="P:HttpServer.HttpException.Code">
            <summary>
            Gets HTTP status code.
            </summary>
        </member>
        <member name="M:HttpServer.BadRequestException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.BadRequestException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
        </member>
        <member name="M:HttpServer.BadRequestException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.BadRequestException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
            <param name="inner">Exception description.</param>
        </member>
        <member name="T:HttpServer.Messages.Parser.ParserException">
            <summary>
            Something failed during parsing.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.ParserException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.ParserException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
        </member>
        <member name="M:HttpServer.Messages.Parser.ParserException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.ParserException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="T:HttpServer.Headers.Parsers.IHeaderParser">
            <summary>
            Used to parse header values
            </summary>
        </member>
        <member name="M:HttpServer.Headers.Parsers.IHeaderParser.Parse(System.String,HttpServer.Tools.ITextReader)">
            <summary>
            Parse a header
            </summary>
            <param name="name">Name of header.</param>
            <param name="reader">Reader containing value.</param>
            <returns>HTTP Header</returns>
            <exception cref="T:System.FormatException">Header value is not of the expected format.</exception>
        </member>
        <member name="T:HttpServer.BodyDecoders.BodyDecoderCollection">
            <summary>
            Collection of body decoders.
            </summary>
            <remarks>
            Body decoders are used to parse request body and convert it
            into a <see cref="T:HttpServer.HttpFileCollection"/> and a <see cref="T:HttpServer.ParameterCollection"/>.
            </remarks>
        </member>
        <member name="M:HttpServer.BodyDecoders.BodyDecoderCollection.Add(HttpServer.BodyDecoders.IBodyDecoder)">
            <summary>
            Add another body decoder.
            </summary>
            <param name="decoder"></param>
        </member>
        <member name="M:HttpServer.BodyDecoders.BodyDecoderCollection.Decode(System.IO.Stream,HttpServer.Headers.ContentTypeHeader,System.Text.Encoding)">
            <summary>
            Decode body stream
            </summary>
            <param name="stream">Stream containing the content</param>
            <param name="contentType">Content type header</param>
            <param name="encoding">Stream encoding</param>
            <returns>Decoded data.</returns>
            <exception cref="T:System.FormatException">Body format is invalid for the specified content type.</exception>
            <exception cref="T:HttpServer.InternalServerException">Something unexpected failed.</exception>
        </member>
        <member name="M:HttpServer.BodyDecoders.BodyDecoderCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.BodyDecoders.BodyDecoderCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:HttpServer.BodyDecoders.BodyDecoderCollection.Count">
            <summary>
            Gets number of decoders.
            </summary>
        </member>
        <member name="T:HttpServer.Transports.ReusableSocketNetworkStream">
            <summary>
            Custom network stream to mark sockets as reusable when disposing the stream.
            </summary>
        </member>
        <member name="M:HttpServer.Transports.ReusableSocketNetworkStream.#ctor(System.Net.Sockets.Socket)">
            <summary>
                                Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
            <param name="socket">
                                The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data. 
                            </param>
            <exception cref="T:System.ArgumentNullException">
                                The <paramref name="socket" /> parameter is <c>null</c>. 
                            </exception>
            <exception cref="T:System.IO.IOException">
                                The <paramref name="socket" /> parameter is not connected.
                                -or- 
                                The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.
                                -or- 
                                The <paramref name="socket" /> parameter is in a nonblocking state. 
                            </exception>
        </member>
        <member name="M:HttpServer.Transports.ReusableSocketNetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)">
            <summary>
                                Initializes a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.
            </summary>
            <param name="socket">
                                The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data. 
                            </param>
            <param name="ownsSocket">
                                Set to <c>true</c> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, <c>false</c>. 
                            </param>
            <exception cref="T:System.ArgumentNullException">
                                The <paramref name="socket" /> parameter is <c>null</c>. 
                            </exception>
            <exception cref="T:System.IO.IOException">
                                The <paramref name="socket" /> parameter is not connected.
                                -or- 
                                the value of the <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.
                                -or- 
                                the <paramref name="socket" /> parameter is in a nonblocking state. 
                            </exception>
        </member>
        <member name="M:HttpServer.Transports.ReusableSocketNetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)">
            <summary>
                                Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights.
            </summary>
            <param name="socket">
                                The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data. 
                            </param>
            <param name="access">
                                A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specify the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />. 
                            </param>
            <exception cref="T:System.ArgumentNullException">
                                The <paramref name="socket" /> parameter is <c>null</c>. 
                            </exception>
            <exception cref="T:System.IO.IOException">
                                The <paramref name="socket" /> parameter is not connected.
                                -or- 
                                the <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.
                                -or- 
                                the <paramref name="socket" /> parameter is in a nonblocking state. 
                            </exception>
        </member>
        <member name="M:HttpServer.Transports.ReusableSocketNetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)">
            <summary>
                                Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights and the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.
            </summary>
            <param name="socket">
                                The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data. 
                            </param>
            <param name="access">
                                A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specifies the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />. 
                            </param>
            <param name="ownsSocket">
                                Set to <c>true</c> to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, <c>false</c>. 
                            </param>
            <exception cref="T:System.ArgumentNullException">
                                The <paramref name="socket" /> parameter is <c>null</c>. 
                            </exception>
            <exception cref="T:System.IO.IOException">
                                The <paramref name="socket" /> parameter is not connected.
                                -or- 
                                The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of the <paramref name="socket" /> parameter is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.
                                -or- 
                                The <paramref name="socket" /> parameter is in a nonblocking state. 
                            </exception>
        </member>
        <member name="M:HttpServer.Transports.ReusableSocketNetworkStream.Close">
            <summary>
            Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.
            </summary>
        </member>
        <member name="M:HttpServer.Transports.ReusableSocketNetworkStream.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.NetworkStream"/> and optionally releases the managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="T:HttpServer.Tools.UrlParser">
            <summary>
            Parses query string
            </summary>
        </member>
        <member name="M:HttpServer.Tools.UrlParser.Parse(HttpServer.Tools.ITextReader)">
            <summary>
            Parse a query string
            </summary>
            <param name="reader">string to parse</param>
            <returns>A collection</returns>
            <exception cref="T:System.ArgumentNullException"><c>reader</c> is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.UrlParser.Parse(System.String)">
            <summary>
            Parse a query string
            </summary>
            <param name="queryString">string to parse</param>
            <returns>A collection</returns>
            <exception cref="T:System.ArgumentNullException"><c>queryString</c> is <c>null</c>.</exception>
        </member>
        <member name="T:HttpServer.SimpleServer">
            <summary>
            Convention over configuration server.
            </summary>
            <remarks>
            Used to make it easy to create and use a web server.
            <para>
            All resources must exist in the "YourProject.Content" namespace (or a subdirectory called "Content" relative to yourapp.exe).
            </para>
            </remarks>
        </member>
        <member name="T:HttpServer.Server">
            <summary>
            Http server.
            </summary>
        </member>
        <member name="M:HttpServer.Server.#ctor(HttpServer.HttpFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Server"/> class.
            </summary>
            <param name="factory">Factory used to create objects used in this library.</param>
        </member>
        <member name="M:HttpServer.Server.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Server"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Server.Add(HttpServer.BodyDecoders.IBodyDecoder)">
            <summary>
            Add a decoder.
            </summary>
            <param name="decoder">decoder to add</param>
            <remarks>
            Adding zero decoders will make the server add the 
            default ones which is <see cref="T:HttpServer.BodyDecoders.MultiPartDecoder"/> and <see cref="T:HttpServer.BodyDecoders.UrlDecoder"/>.
            </remarks>
        </member>
        <member name="M:HttpServer.Server.Add(HttpServer.Routing.IRouter)">
            <summary>
            Add a new router.
            </summary>
            <param name="router">Router to add</param>
            <exception cref="T:System.InvalidOperationException">Server have been started.</exception>
        </member>
        <member name="M:HttpServer.Server.Add(HttpServer.Modules.IModule)">
            <summary>
            Add a file module
            </summary>
            <param name="module">Module to add</param>
            <exception cref="T:System.ArgumentNullException"><c>module</c> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add modules when server have been started.</exception>
        </member>
        <member name="M:HttpServer.Server.Add(HttpServer.IHttpListener)">
            <summary>
            Add a HTTP listener.
            </summary>
            <param name="listener"></param>
            <exception cref="T:System.InvalidOperationException">Listener have been started.</exception>
        </member>
        <member name="M:HttpServer.Server.DisplayErrorPage(HttpServer.IHttpContext,System.Exception)">
            <summary>
            An error have occurred and we need to send a result pack to the client
            </summary>
            <param name="context">The context.</param>
            <param name="exception">The exception.</param>
            <remarks>
            Invoke base class (<see cref="T:HttpServer.Server"/>) to send the contents
            of <see cref="P:HttpServer.IHttpContext.Response"/>.
            </remarks>
        </member>
        <member name="M:HttpServer.Server.OnAuthentication(HttpServer.RequestContext)">
            <summary>
            Called before anything else.
            </summary>
            <param name="context">The context.</param>
            <remarks>
            Looks after a <see cref="T:HttpServer.Headers.AuthorizationHeader"/> in the request and will
            use the <see cref="P:HttpServer.Server.AuthenticationProvider"/> if found.
            </remarks>
        </member>
        <member name="M:HttpServer.Server.OnBeforeModules(HttpServer.RequestContext)">
            <summary>
            All server modules are about to be invoked.
            </summary>
            <param name="context">The context.</param>
            <remarks>
            Called when routers have been invoked but no modules yet.
            </remarks>
        </member>
        <member name="M:HttpServer.Server.OnBeforeRequest(HttpServer.RequestContext)">
            <summary>
            A request have arrived but not yet been processed yet.
            </summary>
            <param name="context">The context.</param>
            <remarks>
            Default implementation adds a <c>Date</c> header and <c>Server</c> header.
            </remarks>
        </member>
        <member name="M:HttpServer.Server.ProcessModules(HttpServer.RequestContext)">
            <summary>
            Go through all modules and check if any of them can handle the current request.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Server.ProcessResult(HttpServer.ProcessingResult,HttpServer.RequestEventArgs)">
            <summary>
            Process result (check if it should be sent back or not)
            </summary>
            <param name="result"></param>
            <param name="e"></param>
            <returns><c>true</c> if request was processed properly.; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:HttpServer.Server.ProcessRouters(HttpServer.RequestContext)">
            <summary>
            Processes all routers.
            </summary>
            <param name="context">Request context.</param>
            <returns>Processing result.</returns>
        </member>
        <member name="M:HttpServer.Server.RequestAuthentication(System.String)">
            <summary>
            Requests authentication from the user.
            </summary>
            <param name="realm">Host/domain name that the server hosts.</param>
            <remarks>
            Used when calculating hashes in Digest authentication. 
            </remarks>
            <seealso cref="T:HttpServer.Authentication.DigestAuthentication"/>
            <seealso cref="M:HttpServer.Authentication.DigestAuthentication.GetHA1(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HttpServer.Server.SendResponse(HttpServer.IHttpContext,HttpServer.IRequest,HttpServer.IResponse)">
            <summary>
            Send a response.
            </summary>
            <param name="context"></param>
            <param name="request"></param>
            <param name="response"></param>
        </member>
        <member name="M:HttpServer.Server.Start(System.Int32)">
            <summary>
            Start http server.
            </summary>
            <param name="backLog">Number of pending connections.</param>
        </member>
        <member name="M:HttpServer.Server.Stop(System.Boolean)">
            <summary>
            Stops the server 
            </summary>
            <param name="removeModules">true if all modules should be removed.</param>
        </member>
        <member name="P:HttpServer.Server.AuthenticationProvider">
            <summary>
            Gets the authentication provider.
            </summary>
            <remarks>
            A authentication provider is used to keep track of all authentication types
            that can be used.
            </remarks>
        </member>
        <member name="P:HttpServer.Server.ContentLengthLimit">
            <summary>
            Gets or sets number of bytes that a body can be.
            </summary>
            <remarks>
            <para>
            Used to determine the answer to a 100-continue request.
            </para>
            <para>
             0 = turned off.
            </para>
            </remarks>
        </member>
        <member name="P:HttpServer.Server.Current">
            <summary>
            Gets current server.
            </summary>
            <remarks>
            Only valid when a request have been received and is being processed.
            </remarks>
        </member>
        <member name="P:HttpServer.Server.MaxContentSize">
            <summary>
            Gets or sets the maximum size of request body (in bytes)
            </summary>
        </member>
        <member name="P:HttpServer.Server.ServerName">
            <summary>
            Gets or sets server name.
            </summary>
            <remarks>
            Used in the "Server" header when serving requests.
            </remarks>
        </member>
        <member name="E:HttpServer.Server.SendingResponse">
            <summary>
            Invoked just before a response is sent back to the client.
            </summary>
        </member>
        <member name="E:HttpServer.Server.RequestReceived">
            <summary>
            Invoked *after* the web server has tried to handled the request.
            </summary>
            <remarks>
            The event can be used to handle the request after all routes and modules
            have tried to process the request.
            </remarks>
        </member>
        <member name="E:HttpServer.Server.PrepareRequest">
            <summary>
            Invoked *before* the web server has tried to handled the request.
            </summary>
            <remarks>
            Event can be used to load a session from a cookie or to force
            authentication or anything other you might need t do before a request
            is handled.
            </remarks>
        </member>
        <member name="E:HttpServer.Server.ErrorPageRequested">
            <summary>
            An error page have been requested.
            </summary>
        </member>
        <member name="M:HttpServer.SimpleServer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.SimpleServer"/> class.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.HeaderFactory">
            <summary>
            Used to build headers.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.HeaderFactory.Add(System.String,HttpServer.Headers.Parsers.IHeaderParser)">
            <summary>
            Add a parser
            </summary>
            <param name="name">Header that the parser is for.</param>
            <param name="parser">Parser implementation</param>
            <remarks>
            Will replace any existing parser for the specified header.
            </remarks>
        </member>
        <member name="M:HttpServer.Headers.HeaderFactory.AddDefaultParsers">
            <summary>
            Add all default (built-in) parsers.
            </summary>
            <remarks>
            Will not replace previously added parsers.
            </remarks>
        </member>
        <member name="M:HttpServer.Headers.HeaderFactory.CreateParser(System.Type)">
            <summary>
            Create a header parser
            </summary>
            <param name="type"><see cref="T:HttpServer.Headers.Parsers.IHeaderParser"/> implementation.</param>
            <remarks>
            <para>
            Uses <see cref="T:HttpServer.Headers.Parsers.ParserForAttribute"/> attribute to find which headers
            the parser is for.
            </para>
            <para>Will not replace previously added parsers.</para>
            </remarks>
        </member>
        <member name="M:HttpServer.Headers.HeaderFactory.Parse(System.String,System.String)">
            <summary>
            Parse a header.
            </summary>
            <param name="name">Name of header</param>
            <param name="value">Header value</param>
            <returns>Header.</returns>
            <exception cref="T:System.FormatException">Value is not a well formatted header value.</exception>
        </member>
        <member name="T:HttpServer.IRequest">
            <summary>
            Request sent to a HTTP server.
            </summary>
            <seealso cref="T:HttpServer.Messages.Request"/>
        </member>
        <member name="T:HttpServer.IMessage">
            <summary>
            Base interface for request and response.
            </summary>
        </member>
        <member name="M:HttpServer.IMessage.Add(System.String,HttpServer.Headers.IHeader)">
            <summary>
            Add a new header.
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:HttpServer.IMessage.Add(HttpServer.Headers.IHeader)">
            <summary>
            Add a new header.
            </summary>
            <param name="header">Header to add.</param>
        </member>
        <member name="P:HttpServer.IMessage.Body">
            <summary>
            Gets body stream.
            </summary>
        </member>
        <member name="P:HttpServer.IMessage.ContentLength">
            <summary>
            Size of the body. MUST be specified before sending the header,
            unless property Chunked is set to <c>true</c>.
            </summary>
        </member>
        <member name="P:HttpServer.IMessage.ContentType">
            <summary>
            Kind of content in the body
            </summary>
            <remarks>Default is <c>text/html</c></remarks>
        </member>
        <member name="P:HttpServer.IMessage.Encoding">
            <summary>
            Gets or sets encoding
            </summary>
        </member>
        <member name="P:HttpServer.IMessage.Headers">
            <summary>
            Gets headers.
            </summary>
        </member>
        <member name="M:HttpServer.IRequest.Get``1(System.String)">
            <summary>
            Get a header 
            </summary>
            <typeparam name="T">Type that it should be cast to</typeparam>
            <param name="headerName">Name of header</param>
            <returns>Header if found and casted properly; otherwise <c>null</c>.</returns>
        </member>
        <member name="P:HttpServer.IRequest.Connection">
            <summary>
            Gets or sets connection header.
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.Cookies">
            <summary>
            Gets cookies.
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.Files">
            <summary>
            Gets all uploaded files.
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.Form">
            <summary>
            Gets form parameters.
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.HttpVersion">
            <summary>
            Gets or sets HTTP version.
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.IsAjax">
            <summary>
            Gets if request is an Ajax request.
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.Method">
            <summary>
            Gets or sets HTTP method.
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.Parameters">
            <summary>
            Gets query string and form parameters
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.QueryString">
            <summary>
            Gets query string.
            </summary>
        </member>
        <member name="P:HttpServer.IRequest.Uri">
            <summary>
            Gets requested URI.
            </summary>
        </member>
        <member name="T:HttpServer.Resources.FileResources">
            <summary>
            Load resources from disk.
            </summary>
        </member>
        <member name="T:HttpServer.Resources.IResourceLoader">
            <summary>
            Loads resources from a specific location (such as assembly, hard drive etc).
            </summary>
        </member>
        <member name="M:HttpServer.Resources.IResourceLoader.Exists(System.String)">
            <summary>
            Checks if a resource exists in the specified directory
            </summary>
            <param name="uriPath">Uri path to resource</param>
            <returns><c>true</c> if resource was found; otherwise <c>false</c>.</returns>
            <example>
            <code>
            if (resources.Exists("/files/user/user.png"))
              Debug.WriteLine("Resource exists.");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.IResourceLoader.Find(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Find all views in a folder/path.
            </summary>
            <param name="path">Absolute Uri path to files that should be found, can end with wild card.</param>
            <param name="viewNames">Collection to add all view names to.</param>
        </member>
        <member name="M:HttpServer.Resources.IResourceLoader.Get(System.String)">
            <summary>
            Gets a resource.
            </summary>
            <param name="uriPath">Uri path to resource.</param>
            <returns>Resource</returns>
            <exception cref="T:HttpServer.ForbiddenException">Uri contains forbidden characters.</exception>
            <example>
            <code>
            Resource resource = resources.Get("/files/user/user.png");
            </code>
            </example>
        </member>
        <member name="F:HttpServer.Resources.FileResources.DefaultForbiddenChars">
            <summary>
            Default forbidden characters.
            </summary>
        </member>
        <member name="F:HttpServer.Resources.FileResources._paths">
            <summary>
            relative to absolute path mappings.
            </summary>
        </member>
        <member name="M:HttpServer.Resources.FileResources.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Resources.FileResources"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Resources.FileResources.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Resources.FileResources"/> class.
            </summary>
            <param name="uri">Request URI path</param>
            <param name="absolutePath">Disk path</param>
            <remarks>
            File names should not be included in URI or path.
            </remarks>
            <example>
            <code>
            new FileResources("/files/user/", "C:\\intetpub\\files\users\\");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.FileResources.Add(System.String,System.String)">
            <summary>
            Add a new resource mapping.
            </summary>
            <param name="uri">Request URI path</param>
            <param name="absolutePath">Disk path</param>
            <remarks>
            File names should not be included in URI or path.
            </remarks>
            <example>
            <code>
            resources.Add("/files/", "C:\\intetpub\\files\\");
            </code>
            </example>
            <exception cref="T:System.IO.DirectoryNotFoundException"><c>absolutePath</c> is not found.</exception>
        </member>
        <member name="M:HttpServer.Resources.FileResources.Contains(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            check if source contains any of the chars.
            </summary>
            <param name="source">string to check</param>
            <param name="chars">Characters to fined</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Resources.FileResources.GetFullFilePath(System.String)">
            <summary>
            Go through all mappings and find requested Uri.
            </summary>
            <param name="uriPath">Uri to get local path for.</param>
            <returns>Path if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Resources.FileResources.Exists(System.String)">
            <summary>
            Checks if a resource exists in the specified directory
            </summary>
            <param name="uriPath">Uri path to resource</param>
            <returns><c>true</c> if resource was found; otherwise <c>false</c>.</returns>
            <example>
            <code>
            if (resources.Exists("/files/user/user.png"))
              Debug.WriteLine("Resource exists.");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.FileResources.Get(System.String)">
            <summary>
            Gets a resource.
            </summary>
            <param name="uriPath">Uri path to resource.</param>
            <returns>Resource</returns>
            <exception cref="T:HttpServer.ForbiddenException">Uri contains forbidden characters.</exception>
            <example>
            <code>
            Resource resource = resources.Get("/files/user/user.png");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.FileResources.Find(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Find all views in a folder/path.
            </summary>
            <param name="path">Absolute Uri path to files that should be found, can end with wild card.</param>
            <param name="viewNames">Collection to add all view names to.</param>
            <exception cref="T:HttpServer.ForbiddenException">Uri contains forbidden characters.</exception>
            <example>
            Find("
            </example>
        </member>
        <member name="P:HttpServer.Resources.FileResources.ForbiddenCharacters">
            <summary>
            Gets or sets forbidden characters.
            </summary>
            <remarks>
            Used to revoke access to any system files.
            </remarks>
        </member>
        <member name="P:HttpServer.Resources.FileResources.Mapping.AbsolutePath">
            <summary>
            Gets or sets absolute path on disk, including file name.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.FileResources.Mapping.RelativePath">
            <summary>
            Gets or sets relative file path.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.FileResources.Mapping.UriPath">
            <summary>
            Gets or sets Uri path, excluding file name
            </summary>
        </member>
        <member name="T:HttpServer.Messages.ResponseWriter">
            <summary>
            Used to send a response back to the client.
            </summary>
            <remarks>
            <para>
            Writes a <see cref="T:HttpServer.IResponse"/> object into a stream.
            </para>
            <para>
            Important! ResponseWriter do not throw any exceptions. Instead it just logs them and
            let them die peacefully. This is since the response writer is used from
            catch blocks here and there.
            </para>
            </remarks>
        </member>
        <member name="M:HttpServer.Messages.ResponseWriter.Send(HttpServer.IHttpContext,HttpServer.IResponse)">
            <summary>
            Sends response using the specified context.
            </summary>
            <param name="context">The context.</param>
            <param name="response">The response.</param>
        </member>
        <member name="M:HttpServer.Messages.ResponseWriter.Send(HttpServer.IHttpContext,System.String,System.Text.Encoding)">
            <summary>
            Converts and sends a string.
            </summary>
            <param name="context"></param>
            <param name="data"></param>
            <param name="encoding">Encoding used to transfer string</param>
        </member>
        <member name="M:HttpServer.Messages.ResponseWriter.SendBody(HttpServer.IHttpContext,System.IO.Stream)">
            <summary>
            Send a body to the client
            </summary>
            <param name="context">Context containing the stream to use.</param>
            <param name="body">Body to send</param>
        </member>
        <member name="M:HttpServer.Messages.ResponseWriter.SendHeaders(HttpServer.IHttpContext,HttpServer.IResponse)">
            <summary>
            Send all headers to the client
            </summary>
            <param name="response">Response containing call headers.</param>
            <param name="context">Content used to send headers.</param>
        </member>
        <member name="T:HttpServer.BodyDecoders.IBodyDecoder">
            <summary>
            Decodes body stream.
            </summary>
        </member>
        <member name="M:HttpServer.BodyDecoders.IBodyDecoder.Decode(System.IO.Stream,HttpServer.Headers.ContentTypeHeader,System.Text.Encoding)">
            <summary>
            Decode body stream
            </summary>
            <param name="stream">Stream containing the content</param>
            <param name="contentType">Content type header</param>
            <param name="encoding">Stream encoding</param>
            <returns>Decoded data.</returns>
            <exception cref="T:System.FormatException">Body format is invalid for the specified content type.</exception>
            <exception cref="T:HttpServer.InternalServerException">Something unexpected failed.</exception>
        </member>
        <member name="P:HttpServer.BodyDecoders.IBodyDecoder.ContentTypes">
            <summary>
            All content types that the decoder can parse.
            </summary>
            <returns>A collection of all content types that the decoder can handle.</returns>
        </member>
        <member name="T:HttpServer.BodyDecoders.MultiPartDecoder">
            <summary>
            Decodes forms that have multiple sections.
            </summary>
            <remarks>
            http://www.faqs.org/rfcs/rfc1867.html
            </remarks>
        </member>
        <member name="F:HttpServer.BodyDecoders.MultiPartDecoder.FormData">
            <summary>
            form-data
            </summary>
        </member>
        <member name="F:HttpServer.BodyDecoders.MultiPartDecoder.MimeType">
            <summary>
            multipart/form-data
            </summary>
        </member>
        <member name="M:HttpServer.BodyDecoders.MultiPartDecoder.Decode(System.IO.Stream,HttpServer.Headers.ContentTypeHeader,System.Text.Encoding)">
            <summary>
            Decode body stream
            </summary>
            <param name="stream">Stream containing the content</param>
            <param name="contentType">Content type header</param>
            <param name="encoding">Stream encoding</param>
            <returns>Decoded data.</returns>
            <exception cref="T:System.FormatException">Body format is invalid for the specified content type.</exception>
            <exception cref="T:HttpServer.InternalServerException">Something unexpected failed.</exception>
            <exception cref="T:System.ArgumentNullException"><c>stream</c> is <c>null</c>.</exception>
        </member>
        <member name="P:HttpServer.BodyDecoders.MultiPartDecoder.ContentTypes">
            <summary>
            All content types that the decoder can parse.
            </summary>
            <returns>A collection of all content types that the decoder can handle.</returns>
        </member>
        <member name="T:HttpServer.Tools.SessionProvider`1">
            <summary>
            Provides sessions.
            </summary>
            <typeparam name="T">Type of session object</typeparam>
            <remarks>
            <para>Will always use files for sessions (utilizing the binary formatter), but can
            also cache them in memory.</para>
            <para>
            If caching is enabled, it will only write sessions to disk every 20 seconds if they have
            been accessed the last minute (to not keep writing dead sessions to disk).
            </para>
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.SessionProvider`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Tools.SessionProvider`1"/> class.
            </summary>
            <exception cref="T:System.InvalidOperationException">Session type must use [Serializable] attribute.</exception>
        </member>
        <member name="M:HttpServer.Tools.SessionProvider`1.Create">
            <summary>
            Create a new session.
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Tools.SessionProvider`1.Load(System.String)">
            <summary>
            Load session
            </summary>
            <param name="sessionId">Id of session.</param>
            <returns>Session if found; otherwise <c>null</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><c>sessionId</c> is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.SessionProvider`1.OnLoadSession(System.Object,HttpServer.RequestEventArgs)">
            <summary>
            Load session when a new request comes in.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:HttpServer.Tools.SessionProvider`1.Save(`0)">
            <summary>
            Save a session to disk.
            </summary>
            <param name="session">Session to write to disk.</param>
            <remarks>
            You are responsible for writing sessions to disk if you are not using caching.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.SessionProvider`1.Start(HttpServer.Server)">
            <summary>
            Start the session system and hook
            </summary>
            <param name="webServer"></param>
        </member>
        <member name="M:HttpServer.Tools.SessionProvider`1.Stop">
            <summary>
            Stop session handling
            </summary>
        </member>
        <member name="P:HttpServer.Tools.SessionProvider`1.CookieName">
            <summary>
            Gets or sets session cookie name
            </summary>
        </member>
        <member name="P:HttpServer.Tools.SessionProvider`1.Cache">
            <summary>
            Gets or sets cache
            </summary>
        </member>
        <member name="P:HttpServer.Tools.SessionProvider`1.Current">
            <summary>
            Gets current session.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.SessionProvider`1.SessionExpireSeconds">
            <summary>
            Gets or sets number of seconds before a session expired.
            </summary>
            <remarks>
            A session have expired if nothing have accessed it for X seconds. This
            class modifies the write time each time it's accessed.
            </remarks>
        </member>
        <member name="P:HttpServer.Tools.SessionProvider`1.SetCookie">
            <summary>
            Determines if cookie should be set in the response.
            </summary>
        </member>
        <member name="T:HttpServer.Tools.SessionChangedHandler">
            <summary>
            Invoked when a session have been changed and should be written to disc.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.Parser.ResponseLineEventArgs">
            <summary>
            First line in a response have been received
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.ResponseLineEventArgs.ReasonPhrase">
            <summary>
            Gets or sets motivation to why the status code was used.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.ResponseLineEventArgs.StatusCode">
            <summary>
            Gets or sets message status code
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.ResponseLineEventArgs.Version">
            <summary>
            Gets or sets sip protocol version used.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.FactoryRequestEventArgs">
            <summary>
            A request have been parsed successfully by the server.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.FactoryRequestEventArgs.#ctor(HttpServer.IRequest)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.FactoryRequestEventArgs"/> class.
            </summary>
            <param name="request">Received request.</param>
        </member>
        <member name="P:HttpServer.Messages.FactoryRequestEventArgs.Request">
            <summary>
            Gets received request.
            </summary>
        </member>
        <member name="T:HttpServer.Authentication.IUserProvider">
            <summary>
            Provider returning user to be authenticated.
            </summary>
        </member>
        <member name="M:HttpServer.Authentication.IUserProvider.Lookup(System.String,System.String)">
            <summary>
            Lookups the specified user
            </summary>
            <param name="userName">User name.</param>
            <param name="host">Typically web server domain name.</param>
            <returns>User if found; otherwise <c>null</c>.</returns>
            <remarks>
            User name can basically be anything. For instance name entered by user when using
            basic or digest authentication, or SID when using Windows authentication.
            </remarks>
        </member>
        <member name="M:HttpServer.Authentication.IUserProvider.GetPrincipal(HttpServer.Authentication.IAuthenticationUser)">
            <summary>
            Gets the principal to use.
            </summary>
            <param name="user">Successfully authenticated user.</param>
            <returns></returns>
            <remarks>
            Invoked when a user have successfully been authenticated.
            </remarks>
            <seealso cref="T:System.Security.Principal.GenericPrincipal"/>
            <seealso cref="T:System.Security.Principal.WindowsPrincipal"/>
        </member>
        <member name="T:HttpServer.Authentication.IAuthenticationUser">
            <summary>
            User information used during authentication process.
            </summary>
        </member>
        <member name="P:HttpServer.Authentication.IAuthenticationUser.Username">
            <summary>
            Gets or sets user name used during authentication.
            </summary>
        </member>
        <member name="P:HttpServer.Authentication.IAuthenticationUser.Password">
            <summary>
            Gets or sets unencrypted password.
            </summary>
            <remarks>
            Password as clear text. You could use <see cref="P:HttpServer.Authentication.IAuthenticationUser.HA1"/> instead if your passwords
            are encrypted in the database.
            </remarks>
        </member>
        <member name="P:HttpServer.Authentication.IAuthenticationUser.HA1">
            <summary>
            Gets or sets HA1 hash.
            </summary>
            <remarks>
            <para>
            Digest authentication requires clear text passwords to work. If you
            do not have that, you can store a HA1 hash in your database (which is part of
            the Digest authentication process).
            </para>
            <para>
            A HA1 hash is simply a Md5 encoded string: "UserName:Realm:Password". The quotes should
            not be included. Realm is the currently requested Host (as in <c>Request.Headers["host"]</c>).
            </para>
            <para>
            Leave the string as <c>null</c> if you are not using HA1 hashes.
            </para>
            </remarks>
        </member>
        <member name="T:HttpServer.Tools.Properties.PropertyProvider">
            <summary>
            Used to get or set properties on objects.
            </summary>
            <remarks>
            This class should be a bit faster than the standard reflection.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.Properties.PropertyProvider.Get(System.Type)">
            <summary>
            Get cached type.
            </summary>
            <param name="type">Type to get/set properties in</param>
            <returns>Type to use</returns>
        </member>
        <member name="T:HttpServer.Sessions.SessionProvider`1">
            <summary>
            Used to load/store sessions in the server.
            </summary>
        </member>
        <member name="M:HttpServer.Sessions.SessionProvider`1.#ctor(HttpServer.Server,HttpServer.Sessions.ISessionStore)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Sessions.SessionProvider`1"/> class.
            </summary>
            <param name="server">Web server that the provider is for..</param>
            <param name="store">Store to use.</param>
        </member>
        <member name="M:HttpServer.Sessions.SessionProvider`1.#ctor(HttpServer.Server)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Sessions.SessionProvider`1"/> class.
            </summary>
            <param name="server">The server.</param>
            <remarks>
            Uses a file store.
            </remarks>
        </member>
        <member name="M:HttpServer.Sessions.SessionProvider`1.OnRequest(System.Object,HttpServer.RequestEventArgs)">
            <summary>
            Loads a session for all requests that got the session cookie.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:HttpServer.RequestEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="P:HttpServer.Sessions.SessionProvider`1.CurrentSession">
            <summary>
            Gets current session
            </summary>
            <value>Session if set, otherwise <c>null</c>.</value>
        </member>
        <member name="P:HttpServer.Sessions.SessionProvider`1.SessionLifeTime">
            <summary>
            Gets or sets the session life time in minutes.
            </summary>
            <value>The session life time.</value>
        </member>
        <member name="E:HttpServer.Sessions.SessionProvider`1.SessionLoaded">
            <summary>
            A session have been loaded. Use <see cref="P:HttpServer.Sessions.SessionProvider`1.CurrentSession"/> to access it.
            </summary>
        </member>
        <member name="T:HttpServer.SecureHttpListener">
            <summary>
            Secure version of the HTTP listener.
            </summary>
        </member>
        <member name="M:HttpServer.SecureHttpListener.#ctor(System.Net.IPAddress,System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.SecureHttpListener"/> class.
            </summary>
            <param name="address">Address to accept new connections on.</param>
            <param name="port">Port to accept connections on.</param>
            <param name="certificate">Certificate securing the connection.</param>
        </member>
        <member name="M:HttpServer.SecureHttpListener.CreateContext(System.Net.Sockets.Socket)">
            <summary>
            Create a new context
            </summary>
            <param name="socket">Accepted socket</param>
            <returns>A new context.</returns>
            <remarks>
            Factory is assigned by the <see cref="T:HttpServer.HttpListener"/> on each incoming request.
            </remarks>
        </member>
        <member name="P:HttpServer.SecureHttpListener.IsSecure">
            <summary>
            Gets if listener is secure.
            </summary>
            <value></value>
        </member>
        <member name="P:HttpServer.SecureHttpListener.Protocol">
            <summary>
            Gets or sets SSL protocol.
            </summary>
        </member>
        <member name="P:HttpServer.SecureHttpListener.UseClientCertificate">
            <summary>
            Gets or sets if client certificate should be used.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.Parser.BodyEventArgs">
            <summary>
            Arguments used when more body bytes have come.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.BodyEventArgs.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.BodyEventArgs"/> class.
            </summary>
            <param name="buffer">buffer that contains the received bytes.</param>
            <param name="offset">offset in buffer where to start processing.</param>
            <param name="count">number of bytes from <paramref name="offset"/> that should be parsed.</param>
            <exception cref="T:System.ArgumentNullException"><c>buffer</c> is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Messages.Parser.BodyEventArgs.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.BodyEventArgs"/> class.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.BodyEventArgs.Buffer">
            <summary>
            Gets or sets buffer that contains the received bytes.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.BodyEventArgs.Count">
            <summary>
            Gets or sets number of bytes from <see cref="P:HttpServer.Messages.Parser.BodyEventArgs.Offset"/> that should be parsed.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.BodyEventArgs.Offset">
            <summary>
            Gets or sets offset in buffer where to start processing.
            </summary>
        </member>
        <member name="T:HttpServer.Modules.IModule">
            <summary>
            HTTP Module
            </summary>
        </member>
        <member name="M:HttpServer.Modules.IModule.Process(HttpServer.RequestContext)">
            <summary>
            Process a request.
            </summary>
            <param name="context">Request information</param>
            <returns>What to do next.</returns>
        </member>
        <member name="T:HttpServer.InternalServerException">
            <summary>
            Something unexpected went wrong.
            </summary>
        </member>
        <member name="M:HttpServer.InternalServerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.InternalServerException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
        </member>
        <member name="M:HttpServer.InternalServerException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.InternalServerException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="T:HttpServer.HttpFile">
            <summary>
            File sent from remote end.
            </summary>
        </member>
        <member name="P:HttpServer.HttpFile.ContentType">
            <summary>
            Gets or sets content type.
            </summary>
        </member>
        <member name="P:HttpServer.HttpFile.Name">
            <summary>
            Gets or sets name in form.
            </summary>
        </member>
        <member name="P:HttpServer.HttpFile.OriginalFileName">
            <summary>
            Gets or sets name original file name
            </summary>
        </member>
        <member name="P:HttpServer.HttpFile.TempFileName">
            <summary>
            Gets or sets filename for locally stored file.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.Parsers.CookieParser">
            <summary>
            Parses Cookie header.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.Parsers.CookieParser.Parse(System.String,HttpServer.Tools.ITextReader)">
            <summary>
            Parse a header
            </summary>
            <param name="name">Name of header.</param>
            <param name="reader">Reader containing value.</param>
            <returns>HTTP Header</returns>
            <exception cref="T:System.FormatException">Header value is not of the expected format.</exception>
        </member>
        <member name="T:HttpServer.BodyDecoders.UrlDecoder">
            <summary>
            Decodes URL encoded values.
            </summary>
        </member>
        <member name="M:HttpServer.BodyDecoders.UrlDecoder.Decode(System.IO.Stream,HttpServer.Headers.ContentTypeHeader,System.Text.Encoding)">
            <summary>
            
            </summary>
            <param name="stream">Stream containing the content</param>
            <param name="contentType">Content type header</param>
            <param name="encoding">Stream encoding</param>
            <returns>Collection with all parameters.</returns>
            <exception cref="T:System.FormatException">Body format is invalid for the specified content type.</exception>
            <exception cref="T:HttpServer.InternalServerException">Failed to read all bytes from body stream.</exception>
        </member>
        <member name="P:HttpServer.BodyDecoders.UrlDecoder.ContentTypes">
            <summary>
            All content types that the decoder can parse.
            </summary>
            <returns>A collection of all content types that the decoder can handle.</returns>
        </member>
        <member name="T:HttpServer.Tools.Session">
            <summary>
            Base class for sessions.
            </summary>
            <remarks>
            Your class must be tagged with <see cref="T:System.Runtime.Serialization.ISerializable"/> attribute to be able to use sessions.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.Session.TriggerChanged">
            <summary>
            The session have been changed and should be written to disk.
            </summary>
        </member>
        <member name="F:HttpServer.Tools.Session.Changed">
            <summary>
            Session have been changed.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.Session.AccessedAt">
            <summary>
            Gets or sets when session was accessed last
            </summary>
        </member>
        <member name="P:HttpServer.Tools.Session.CurrentSession">
            <summary>
            Gets current session.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.Session.SessionId">
            <summary>
            Gets or sets session id.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.Session.WrittenAt">
            <summary>
            Gets or sets when the session was last written to disk.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.MessageFactory">
            <summary>
            Parses and builds messages
            </summary>
            <remarks>
            <para>The message factory takes care of building messages
            from all end points.</para>
            <para>
            Since both message and packet protocols are used, the factory 
            hands out contexts to all end points. The context keeps a state
            to be able to parse partial messages properly.
            </para>
            <para>
            Each end point need to hand the context back to the message factory
            when the client disconnects (or a message have been parsed).
            </para>
            </remarks>
        </member>
        <member name="M:HttpServer.Messages.MessageFactory.#ctor(HttpServer.Headers.HeaderFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.MessageFactory"/> class.
            </summary>
            <param name="factory">Factory used to create headers.</param>
        </member>
        <member name="M:HttpServer.Messages.MessageFactory.CreateNewContext">
            <summary>
            Create a new message factory context.
            </summary>
            <returns>A new context.</returns>
            <remarks>
            A context is used to parse messages from a specific endpoint.
            </remarks>
        </member>
        <member name="M:HttpServer.Messages.MessageFactory.Release(HttpServer.Messages.MessageFactoryContext)">
            <summary>
            Release a used factory context.
            </summary>
            <param name="factoryContext"></param>
        </member>
        <member name="E:HttpServer.Messages.MessageFactory.RequestReceived">
            <summary>
            A request have been received from one of the end points.
            </summary>
        </member>
        <member name="E:HttpServer.Messages.MessageFactory.ResponseReceived">
            <summary>
            A response have been received from one of the end points.
            </summary>
        </member>
        <member name="T:HttpServer.Logging.ILogger">
            <summary>
            Interface used to write to log files.
            </summary>
            <remarks>
            If you want to use the built in filtering mechanism, create a constructor
            which takes one parameter, a <see cref="T:HttpServer.Logging.ILogFilter"/>.
            </remarks>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Debug(System.String)">
            <summary>
            Write an entry that helps when debugging code.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Debug(System.String,System.Exception)">
            <summary>
            Write an entry that helps when debugging code.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Error(System.String)">
            <summary>
            Something went wrong, but the application do not need to die. The current thread/request
            cannot continue as expected.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Error(System.String,System.Exception)">
            <summary>
            Something went wrong, but the application do not need to die. The current thread/request
            cannot continue as expected.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Fatal(System.String)">
            <summary>
            Something went very wrong, application might not recover.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Fatal(System.String,System.Exception)">
            <summary>
            Something went very wrong, application might not recover.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Info(System.String)">
            <summary>
            Informational message, needed when helping customer to find a problem.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Info(System.String,System.Exception)">
            <summary>
            Informational message, needed when helping customer to find a problem.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Trace(System.String)">
            <summary>
            Write a entry that helps when trying to find hard to find bugs.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Trace(System.String,System.Exception)">
            <summary>
            Write a entry that helps when trying to find hard to find bugs.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Warning(System.String)">
            <summary>
            Something is not as we expect, but the code can continue to run without any changes.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ILogger.Warning(System.String,System.Exception)">
            <summary>
            Something is not as we expect, but the code can continue to run without any changes.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="T:HttpServer.Messages.RequestCookie">
            <summary>
            cookie sent by the client/browser
            </summary>
            <seealso cref="T:HttpServer.Messages.ResponseCookie"/>
        </member>
        <member name="M:HttpServer.Messages.RequestCookie.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="id">cookie identifier</param>
            <param name="content">cookie content</param>
            <exception cref="T:System.ArgumentNullException">id or content is null</exception>
            <exception cref="T:System.ArgumentException">id is empty</exception>
        </member>
        <member name="M:HttpServer.Messages.RequestCookie.ToString">
            <summary>
            Gets the cookie HTML representation.
            </summary>
            <returns>cookie string</returns>
        </member>
        <member name="P:HttpServer.Messages.RequestCookie.Name">
            <summary>
            Gets the cookie identifier.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.RequestCookie.Value">
            <summary>
            Gets value. 
            </summary>
            <remarks>
            Set to <c>null</c> to remove cookie.
            </remarks>
        </member>
        <member name="T:HttpServer.ErrorPageEventArgs">
            <summary>
            Arguments for <see cref="E:HttpServer.Server.ErrorPageRequested"/>.
            </summary>
        </member>
        <member name="M:HttpServer.ErrorPageEventArgs.#ctor(HttpServer.IHttpContext)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ErrorPageEventArgs"/> class.
            </summary>
            <param name="context">The context.</param>
        </member>
        <member name="P:HttpServer.ErrorPageEventArgs.Exception">
            <summary>
            Gets or sets thrown exception
            </summary>
        </member>
        <member name="P:HttpServer.ErrorPageEventArgs.IsHandled">
            <summary>
            Gets or sets if error page was provided.
            </summary>
        </member>
        <member name="P:HttpServer.ErrorPageEventArgs.Request">
            <summary>
            Gets requested resource.
            </summary>
        </member>
        <member name="P:HttpServer.ErrorPageEventArgs.Response">
            <summary>
            Gets response to send
            </summary>
        </member>
        <member name="T:HttpServer.Authentication.DigestAuthentication">
            <summary>
            Implements HTTP Digest authentication. It's more secure than Basic auth since password is 
            encrypted with a "key" from the server. 
            </summary>
            <remarks>
            Keep in mind that the password is encrypted with MD5. Use a combination of SSL and digest auth to be secure.
            </remarks>
        </member>
        <member name="T:HttpServer.Authentication.IAuthenticator">
            <summary>
            Authenticates requests
            </summary>
        </member>
        <member name="M:HttpServer.Authentication.IAuthenticator.Authenticate(HttpServer.Headers.AuthorizationHeader,System.String,System.String)">
            <summary>
            Authenticate request
            </summary>
            <param name="header">Authorization header send by web client</param>
            <param name="realm">Realm to authenticate in, typically a domain name.</param>
            <param name="httpVerb">HTTP Verb used in the request.</param>
            <returns><c>User</c> if authentication was successful; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Authentication.IAuthenticator.CreateChallenge(System.String)">
            <summary>
            Create a authentication challenge.
            </summary>
            <param name="realm">Realm that the user should authenticate in</param>
            <returns>A WWW-Authenticate header.</returns>
            <exception cref="T:System.ArgumentNullException">If realm is empty or <c>null</c>.</exception>
        </member>
        <member name="P:HttpServer.Authentication.IAuthenticator.Scheme">
            <summary>
            Gets authenticator scheme
            </summary>
            <example>
            digest
            </example>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.#ctor(HttpServer.Authentication.IUserProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Authentication.DigestAuthentication"/> class.
            </summary>
            <param name="userProvider">Supplies users during authentication process.</param>
        </member>
        <member name="F:HttpServer.Authentication.DigestAuthentication.DisableNonceCheck">
            <summary>
            Used by test classes to be able to use hardcoded values
            </summary>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.Authenticate(HttpServer.Headers.AuthorizationHeader,System.String,System.String)">
            <summary>
            An authentication response have been received from the web browser.
            Check if it's correct
            </summary>
            <param name="header">Contents from the Authorization header</param>
            <param name="realm">Realm that should be authenticated</param>
            <param name="httpVerb">GET/POST/PUT/DELETE etc.</param>
            <returns>
            Authentication object that is stored for the request. A user class or something like that.
            </returns>
            <exception cref="T:System.ArgumentException">if authenticationHeader is invalid</exception>
            <exception cref="T:System.ArgumentNullException">If any of the parameters is empty or null.</exception>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.Encrypt(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Encrypts parameters into a Digest string
            </summary>
            <param name="realm">Realm that the user want to log into.</param>
            <param name="userName">User logging in</param>
            <param name="password">Users password.</param>
            <param name="method">HTTP method.</param>
            <param name="uri">Uri/domain that generated the login prompt.</param>
            <param name="qop">Quality of Protection.</param>
            <param name="nonce">"Number used ONCE"</param>
            <param name="nc">Hexadecimal request counter.</param>
            <param name="cnonce">"Client Number used ONCE"</param>
            <returns>Digest encrypted string</returns>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.Encrypt(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="ha1">Md5 hex encoded "userName:realm:password", without the quotes.</param>
            <param name="ha2">Md5 hex encoded "method:uri", without the quotes</param>
            <param name="qop">Quality of Protection</param>
            <param name="nonce">"Number used ONCE"</param>
            <param name="nc">Hexadecimal request counter.</param>
            <param name="cnonce">Client number used once</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.CreateChallenge(System.String)">
            <summary>
            Create a authentication challenge.
            </summary>
            <param name="realm">Realm that the user should authenticate in</param>
            <returns>A correct auth request.</returns>
            <exception cref="T:System.ArgumentNullException">If realm is empty or null.</exception>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.GetCurrentNonce">
            <summary>
            Gets the current nonce.
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.GetMD5HashBinHex2(System.String)">
            <summary>
            Gets the Md5 hash bin hex2.
            </summary>
            <param name="toBeHashed">To be hashed.</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Authentication.DigestAuthentication.IsValidNonce(System.String)">
            <summary>
            determines if the nonce is valid or has expired.
            </summary>
            <param name="nonce">nonce value (check wikipedia for info)</param>
            <returns><c>true</c> if the nonce has not expired.</returns>
        </member>
        <member name="P:HttpServer.Authentication.DigestAuthentication.Name">
            <summary>
            Gets authentication scheme name
            </summary>
        </member>
        <member name="P:HttpServer.Authentication.DigestAuthentication.Scheme">
            <summary>
            Gets authenticator scheme
            </summary>
            <value></value>
            <example>
            digest
            </example>
        </member>
        <member name="T:HttpServer.Authentication.AuthenticationProvider">
            <summary>
            Provides authentication in the web server.
            </summary>
            <remarks>
            To initiate authentication you just need to throw a Una
            </remarks>
        </member>
        <member name="M:HttpServer.Authentication.AuthenticationProvider.Add(HttpServer.Authentication.IAuthenticator)">
            <summary>
            Add a authenticator.
            </summary>
            <param name="authenticator"></param>
        </member>
        <member name="M:HttpServer.Authentication.AuthenticationProvider.Authenticate(HttpServer.IRequest)">
            <summary>
            Authenticate request.
            </summary>
            <param name="request"></param>
            <returns></returns>
            <remarks>
            Requires that a <c>AuthorizationHeader</c> have been sent by the client. If not,
            request one by sending a WWW-Authentication header (can be generated by the Challenge method).
            </remarks>
            <exception cref="T:System.InvalidOperationException">Authorization header was not found in the request.</exception>
            <exception cref="T:System.NotSupportedException">Requested authentication scheme is not supported.</exception>
        </member>
        <member name="M:HttpServer.Authentication.AuthenticationProvider.CreateChallenge(HttpServer.IResponse,System.String)">
            <summary>
            Create a challenge header (WWW-authenticate)
            </summary>
            <param name="response">Response that the authentication header should be added to</param>
            <param name="realm">Realm that the user should authenticate in</param>
            <returns>WWW-Authenticate header.</returns>
            <remarks>
            <para>
            Scheme can currently be <c>basic</c> or <c>digest</c>. Basic is not very safe, but easier to use.
            Digest is quite safe.
            </para><para>
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Requested scheme is not supported.</exception>
        </member>
        <member name="T:HttpServer.Logging.ConsoleLogFactory">
            <summary>
            Creates a console logger.
            </summary>
        </member>
        <member name="T:HttpServer.Logging.ILogFactory">
            <summary>
            Factory implementation used to create logs.
            </summary>
        </member>
        <member name="M:HttpServer.Logging.ILogFactory.CreateLogger(System.Type)">
            <summary>
            Create a new logger.
            </summary>
            <param name="type">Type that requested a logger.</param>
            <returns>Logger for the specified type;</returns>
            <remarks>
            MUST ALWAYS return a logger. Return <see cref="T:HttpServer.Logging.NullLogWriter"/> if no logging
            should be used.
            </remarks>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogFactory.#ctor(HttpServer.Logging.ILogFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Logging.ConsoleLogFactory"/> class.
            </summary>
            <param name="filter">The filter.</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogFactory.CreateLogger(System.Type)">
            <summary>
            Create a new logger.
            </summary>
            <param name="type">Type that requested a logger.</param>
            <returns>Logger for the specified type;</returns>
            <remarks>
            MUST ALWAYS return a logger. Return <see cref="T:HttpServer.Logging.NullLogWriter"/> if no logging
            should be used.
            </remarks>
        </member>
        <member name="T:HttpServer.Routing.SimpleRouter">
            <summary>
            redirects from one URL to another.
            </summary>
        </member>
        <member name="T:HttpServer.Routing.IRouter">
            <summary>
            Rules are used to perform operations before a request is being handled.
            Rules can be used to create routing etc.
            </summary>
        </member>
        <member name="M:HttpServer.Routing.IRouter.Process(HttpServer.RequestContext)">
            <summary>
            Process the incoming request.
            </summary>
            <param name="context">Request context information.</param>
            <returns>Processing result.</returns>
            <exception cref="T:System.ArgumentNullException">If any parameter is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Routing.SimpleRouter.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Routing.SimpleRouter"/> class.
            </summary>
            <param name="fromUrl">Absolute path (no server name)</param>
            <param name="toUrl">Absolute path (no server name)</param>
            <example>
            server.Add(new RedirectRule("/", "/user/index"));
            </example>
        </member>
        <member name="M:HttpServer.Routing.SimpleRouter.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Routing.SimpleRouter"/> class.
            </summary>
            <param name="fromUrl">Absolute path (no server name)</param>
            <param name="toUrl">Absolute path (no server name)</param>
            <param name="shouldRedirect"><c>true</c> if request should be redirected, <c>false</c> if the request URI should be replaced.</param>
            <example>
            server.Add(new RedirectRule("/", "/user/index"));
            </example>
        </member>
        <member name="M:HttpServer.Routing.SimpleRouter.Process(HttpServer.RequestContext)">
            <summary>
            Process the incoming request.
            </summary>
            <param name="context">Request context.</param>
            <returns>Processing result.</returns>
            <exception cref="T:System.ArgumentNullException">If any parameter is <c>null</c>.</exception>
        </member>
        <member name="P:HttpServer.Routing.SimpleRouter.FromUrl">
            <summary>
            Gets string to match request URI with.
            </summary>
            <remarks>Is compared to request.Uri.AbsolutePath</remarks>
        </member>
        <member name="P:HttpServer.Routing.SimpleRouter.ShouldRedirect">
            <summary>
            Gets whether the server should redirect the client instead of simply modifying the URI.
            </summary>
            <remarks>
            <c>false</c> means that the rule will replace
            the current request URI with the new one from this class.
            <c>true</c> means that a redirect response is sent to the client.
            </remarks>
        </member>
        <member name="P:HttpServer.Routing.SimpleRouter.ToUrl">
            <summary>
            Gets where to redirect.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.ConnectionHeader">
             <summary>
             The Connection general-header field allows the sender to specify options
             that are desired for that particular connection and MUST NOT be
             communicated by proxies over further connections.
             </summary>
             <remarks>
             <para>
               HTTP/1.1 proxies MUST parse the Connection header field before a
               message is forwarded and, for each connection-token in this field,
               remove any header field(s) from the message with the same name as the
               connection-token. Connection options are signaled by the presence of
               a connection-token in the Connection header field, not by any
               corresponding additional header field(s), since the additional header
               field may not be sent if there are no parameters associated with that
               connection option.
            </para><para>
               Message headers listed in the Connection header MUST NOT include
               end-to-end headers, such as Cache-Control.
            </para><para>
               HTTP/1.1 defines the "close" connection option for the sender to
               signal that the connection will be closed after completion of the
               response. For example,
            <example>
                   Connection: close
            </example>
               in either the request or the response header fields indicates that
               the connection SHOULD NOT be considered `persistent' (section 8.1)
               after the current request/response is complete.
            </para><para>
               HTTP/1.1 applications that do not support persistent connections MUST
               include the "close" connection option in every message.
            </para><para>
               A system receiving an HTTP/1.0 (or lower-version) message that
               includes a Connection header MUST, for each connection-token in this
               field, remove and ignore any header field(s) from the message with
               the same name as the connection-token. This protects against mistaken
               forwarding of such header fields by pre-HTTP/1.1 proxies. See section
               19.6.2 in RFC2616.
             </para>
             </remarks>
        </member>
        <member name="F:HttpServer.Headers.ConnectionHeader.NAME">
            <summary>
            Header name
            </summary>
        </member>
        <member name="F:HttpServer.Headers.ConnectionHeader.Default10">
            <summary>
            Default connection header for HTTP/1.0
            </summary>
        </member>
        <member name="F:HttpServer.Headers.ConnectionHeader.Default11">
            <summary>
            Default connection header for HTTP/1.1
            </summary>
        </member>
        <member name="M:HttpServer.Headers.ConnectionHeader.#ctor(HttpServer.Headers.ConnectionType,HttpServer.Headers.HeaderParameterCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.ConnectionHeader"/> class.
            </summary>
            <param name="type">Connection type.</param>
            <param name="parameters">The parameters.</param>
        </member>
        <member name="M:HttpServer.Headers.ConnectionHeader.#ctor(HttpServer.Headers.ConnectionType)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.ConnectionHeader"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:HttpServer.Headers.ConnectionHeader.ToString">
            <summary>
            Returns data formatted as a HTTP header value.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:HttpServer.Headers.ConnectionHeader.Parameters">
            <summary>
            Gets connection parameters.
            </summary>
        </member>
        <member name="P:HttpServer.Headers.ConnectionHeader.Type">
            <summary>
            Gets or sets connection type
            </summary>
        </member>
        <member name="P:HttpServer.Headers.ConnectionHeader.Name">
            <summary>
            Gets header name
            </summary>
        </member>
        <member name="T:HttpServer.Headers.ConnectionType">
            <summary>
            Type of HTTP connection
            </summary>
        </member>
        <member name="F:HttpServer.Headers.ConnectionType.Close">
            <summary>
            Connection is closed after each request-response
            </summary>
        </member>
        <member name="F:HttpServer.Headers.ConnectionType.KeepAlive">
            <summary>
            Connection is kept alive for X seconds (unless another request have been made)
            </summary>
        </member>
        <member name="F:HttpServer.Headers.ConnectionType.TransferEncoding">
            <summary>
            Requests message-body be sent with an encoding to be specified in the "Transfer-Encoding" header.
            </summary>
        </member>
        <member name="T:HttpServer.ContentTypeHelper">
            <summary>
            Helper for content types.
            </summary>
        </member>
        <member name="T:HttpServer.Tools.ObjectPool`1">
            <summary>
            Flyweight design pattern implementation.
            </summary>
            <typeparam name="T">Type of object.</typeparam>
        </member>
        <member name="M:HttpServer.Tools.ObjectPool`1.#ctor(HttpServer.Tools.CreateHandler{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Tools.ObjectPool`1"/> class.
            </summary>
            <param name="createHandler">How large buffers to allocate.</param>
        </member>
        <member name="M:HttpServer.Tools.ObjectPool`1.Dequeue">
            <summary>
            Get an object.
            </summary>
            <returns>Created object.</returns>
            <remarks>Will create one if queue is empty.</remarks>
        </member>
        <member name="M:HttpServer.Tools.ObjectPool`1.Enqueue(`0)">
            <summary>
            Enqueues the specified buffer.
            </summary>
            <param name="value">Object to enqueue.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Buffer is is less than the minimum requirement.</exception>
        </member>
        <member name="T:HttpServer.Tools.CreateHandler`1">
            <summary>
            Used to create new objects.
            </summary>
            <typeparam name="T">Type of objects to create.</typeparam>
            <returns>Newly created object.</returns>
            <seealso cref="T:HttpServer.Tools.ObjectPool`1"/>.
        </member>
        <member name="T:HttpServer.Messages.Parser.HttpParser">
            <summary>
            A HTTP parser using delegates to which parsing methods.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.HttpParser"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.GetBody">
            <summary>
            Parser method to copy all body bytes.
            </summary>
            <returns></returns>
            <remarks>Needed since a TCP packet can contain multiple messages
            after each other, or partial messages.</remarks>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.GetHeaderName">
            <summary>
            Try to find a header name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.GetHeaderValue">
            <summary>
            Get header values.
            </summary>
            <returns></returns>
            <remarks>Will also look for multi header values and automatically merge them to one line.</remarks>
            <exception cref="T:HttpServer.Messages.Parser.ParserException">Content length is not a number.</exception>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.OnBodyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Toggle body bytes event.
            </summary>
            <param name="bytes"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.OnComplete">
            <summary>
            Raise the <see cref="E:HttpServer.Messages.Parser.HttpParser.MessageComplete"/> event, since we have successfully parsed a message and it's body.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.OnFirstLine(System.String[])">
            <summary>
            First message line.
            </summary>
            <param name="words">Will always contain three elements.</param>
            <remarks>Used to raise the <see cref="E:HttpServer.Messages.Parser.HttpParser.RequestLineParsed"/> or <see cref="E:HttpServer.Messages.Parser.HttpParser.ResponseLineParsed"/> event 
            depending on the words in the array.</remarks>
            <exception cref="T:HttpServer.BadRequestException"><c>BadRequestException</c>.</exception>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.Parse(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Continue parsing a message
            </summary>
            <param name="buffer">Byte buffer containing bytes</param>
            <param name="offset">Where to start the parsing</param>
            <param name="count">Number of bytes to parse</param>
            <returns>index where the parsing stopped.</returns>
            <exception cref="T:HttpServer.Messages.Parser.ParserException">Parsing failed.</exception>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.ParseFirstLine">
            <summary>
            Parses the first line in a request/response.
            </summary>
            <returns><c>true</c> if first line is well formatted; otherwise <c>false</c>.</returns>
            <exception cref="T:HttpServer.BadRequestException">Invalid request/response line.</exception>
        </member>
        <member name="M:HttpServer.Messages.Parser.HttpParser.Reset">
            <summary>
            Reset parser to initial state.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.HttpParser.LineNumber">
            <summary>
            Gets or sets current line number.
            </summary>
        </member>
        <member name="E:HttpServer.Messages.Parser.HttpParser.RequestLineParsed">
            <summary>
            The request line has been parsed.
            </summary>
        </member>
        <member name="E:HttpServer.Messages.Parser.HttpParser.ResponseLineParsed">
            <summary>
            Response line has been parsed.
            </summary>
        </member>
        <member name="E:HttpServer.Messages.Parser.HttpParser.HeaderParsed">
            <summary>
            Parsed a header.
            </summary>
        </member>
        <member name="E:HttpServer.Messages.Parser.HttpParser.BodyBytesReceived">
            <summary>
            Received body bytes.
            </summary>
        </member>
        <member name="E:HttpServer.Messages.Parser.HttpParser.MessageComplete">
            <summary>
            A message have been successfully parsed.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.Parser.HttpParser.ParserMethod">
            <summary>
            Used to be able to quickly swap parser method.
            </summary>
            <returns></returns>
        </member>
        <member name="T:HttpServer.IHttpFactory">
            <summary>
            Get or create components used in the web server framework
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="M:HttpServer.IHttpFactory.Get``1(System.Object[])">
            <summary>
            Get or create a type.
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns>Created type.</returns>
            <remarks>
            Gets or creates types in the framework. 
            Check <see cref="T:HttpServer.HttpFactory"/> for more information on which
            types the factory should contain.
            </remarks>
        </member>
        <member name="T:HttpServer.HttpFactory">
            <summary>
            Used to create all key types in the HTTP server.
            </summary>
            <remarks>
            <para>Should have factory methods at least for the following types:
            <see cref="T:HttpServer.IRequest"/>, <see cref="T:HttpServer.IResponse"/>, 
            <see cref="T:HttpServer.Headers.HeaderFactory"/>, <see cref="T:HttpServer.Messages.MessageFactory"/>,
            <see cref="T:HttpServer.HttpContext"/>, <see cref="T:HttpServer.SecureHttpContext"/>,
            <see cref="T:HttpServer.IResponse"/>, <see cref="T:HttpServer.IRequest"/>,
            <see cref="T:HttpServer.Messages.ResponseWriter"/>.
            </para>
            <para>Check the default implementations to see which constructor 
            parameters you will get.</para>
            </remarks>
            <example>
            HttpFactory.Add(typeof(IRequest), (type, args) =&gt; new MyRequest((string)args[0]));
            </example>
            
        </member>
        <member name="M:HttpServer.HttpFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpFactory"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.HttpFactory.Add(System.Type,HttpServer.FactoryMethod)">
            <summary>
            Add a factory method for a type.
            </summary>
            <param name="type">Type to create</param>
            <param name="handler">Method creating the type.</param>
        </member>
        <member name="M:HttpServer.HttpFactory.FindFactoryMethod(System.Type)">
            <summary>
            Used to 
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpFactory.OnSetupHeaderFactory(System.Type,System.Object[])">
            <summary>
            Setup our singleton.
            </summary>
            <param name="type"></param>
            <param name="arguments"></param>
            <returns></returns>
            <remarks>
            We want to use a singleton, but we also want to be able
            to let the developer to setup his own header factory.
            Therefore we use this method to create our own factory only if the user
            have not specified one.
            </remarks>
        </member>
        <member name="M:HttpServer.HttpFactory.OnSetupMessageFactory(System.Type,System.Object[])">
            <summary>
            Small method to create a message factory singleton and replace then default delegate method.
            </summary>
            <param name="type"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpFactory.Get``1(System.Object[])">
            <summary>
            Create a type.
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns>Created type.</returns>
        </member>
        <member name="P:HttpServer.HttpFactory.Current">
            <summary>
            Gets http factory for the current listener.
            </summary>
        </member>
        <member name="T:HttpServer.FactoryMethod">
            <summary>
            Delegate used to create a certain type
            </summary>
            <returns>Created type.</returns>
            <remarks>
            Method must never fail.
            </remarks>
        </member>
        <member name="T:HttpServer.Headers.Parsers.ParserForAttribute">
            <summary>
            Used to define which headers a parse is for.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.Parsers.ParserForAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.Parsers.ParserForAttribute"/> class.
            </summary>
            <param name="headerName">Name of the header.</param>
        </member>
        <member name="P:HttpServer.Headers.Parsers.ParserForAttribute.HeaderName">
            <summary>
            Gets name of header that this parser is for.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.Parsers.DateParser">
            <summary>
            Parses "Date" header.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.Parsers.DateParser.Parse(System.String,HttpServer.Tools.ITextReader)">
            <summary>
            Parse a header
            </summary>
            <param name="name">Name of header.</param>
            <param name="reader">Reader containing value.</param>
            <returns>HTTP Header</returns>
            <exception cref="T:System.FormatException">Header value is not of the expected format.</exception>
        </member>
        <member name="T:HttpServer.Headers.AuthorizationHeader">
            <summary>
            Authorization response
            </summary>
            <remarks>
            <para>
            A user agent that wishes to authenticate itself with a server--
            usually, but not necessarily, after receiving a 401 response--does
            so by including an Authorization request-header field with the
            request.  The Authorization field value consists of credentials
            containing the authentication information of the user agent for
            the realm of the resource being requested.
            </para>
            <example>
                Authorization  = "Authorization" ":" credentials
            </example>
            <para>
            HTTP access authentication is described in "HTTP Authentication:
            Basic and Digest Access Authentication" [43]. If a request is
            authenticated and a realm specified, the same credentials SHOULD
            be valid for all other requests within this realm (assuming that
            the authentication scheme itself does not require otherwise, such
            as credentials that vary according to a challenge value or using
            synchronized clocks).
            When a shared cache (see section 13.7) receives a request
            containing an Authorization field, it MUST NOT return the
            corresponding response as a reply to any other request, unless one
            of the following specific exceptions holds:
            </para>
            <list type="number">
            <item>
             If the response includes the "s-maxage" cache-control
               directive, the cache MAY use that response in replying to a
               subsequent request. But (if the specified maximum age has
               passed) a proxy cache MUST first revalidate it with the origin
               server, using the request-headers from the new request to allow
               the origin server to authenticate the new request. (This is the
               defined behavior for s-maxage.) If the response includes "s-
               maxage=0", the proxy MUST always revalidate it before re-using
               it.
            </item><item>
             If the response includes the "must-revalidate" cache-control
               directive, the cache MAY use that response in replying to a
               subsequent request. But if the response is stale, all caches
               MUST first revalidate it with the origin server, using the
               request-headers from the new request to allow the origin server
               to authenticate the new request.
            </item><item>
             If the response includes the "public" cache-control directive,
               it MAY be returned in reply to any subsequent request.
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:HttpServer.Headers.AuthorizationHeader.NAME">
            <summary>
            Name constant
            </summary>
        </member>
        <member name="P:HttpServer.Headers.AuthorizationHeader.Data">
            <summary>
            Gets or sets authentication data.
            </summary>
        </member>
        <member name="P:HttpServer.Headers.AuthorizationHeader.Scheme">
            <summary>
            Gets or sets authentication protocol.
            </summary>
        </member>
        <member name="P:HttpServer.Headers.AuthorizationHeader.Name">
            <summary>
            Gets name of header.
            </summary>
        </member>
        <member name="T:HttpServer.AuthenticationRequiredException">
            <summary>
            User needs to authenticate.
            </summary>
            <seealso cref="T:HttpServer.ForbiddenException"/>
            <seealso cref="T:HttpServer.Authentication.AuthenticationProvider"/>
        </member>
        <member name="M:HttpServer.AuthenticationRequiredException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
        </member>
        <member name="M:HttpServer.AuthenticationRequiredException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="T:HttpServer.Messages.Parser.FactoryResponseEventArgs">
            <summary>
            A response have been received.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.FactoryResponseEventArgs.#ctor(HttpServer.IResponse)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.FactoryResponseEventArgs"/> class.
            </summary>
            <param name="response">The response.</param>
        </member>
        <member name="P:HttpServer.Messages.Parser.FactoryResponseEventArgs.Response">
            <summary>
            Gets or sets response.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.MessageFactoryContext">
            <summary>
            Creates a single message for one of the end points.
            </summary>
            <remarks>
            The factory is 
            </remarks>
        </member>
        <member name="M:HttpServer.Messages.MessageFactoryContext.#ctor(HttpServer.Messages.MessageFactory,HttpServer.Headers.HeaderFactory,HttpServer.Messages.Parser.HttpParser)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.MessageFactoryContext"/> class.
            </summary>
            <param name="msgFactory">The MSG factory.</param>
            <param name="factory">The factory.</param>
            <param name="parser">The parser.</param>
        </member>
        <member name="M:HttpServer.Messages.MessageFactoryContext.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:HttpServer.Messages.MessageFactoryContext.OnHeader(System.Object,HttpServer.Messages.Parser.HeaderEventArgs)">
            <summary>
            Received a header from parser
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:HttpServer.Messages.MessageFactoryContext.Parse(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Will continue the parsing until nothing more can be parsed.
            </summary>
            <param name="buffer">buffer to parse</param>
            <param name="offset">where to start in the buffer</param>
            <param name="length">number of bytes to process.</param>
            <returns>Position where parser stopped parsing.</returns>
            <exception cref="T:HttpServer.Messages.Parser.ParserException">Parsing failed.</exception>
        </member>
        <member name="M:HttpServer.Messages.MessageFactoryContext.Reset">
            <summary>
            Reset parser.
            </summary>
            <remarks>
            Something failed, reset parser so it can start on a new request.
            </remarks>
        </member>
        <member name="E:HttpServer.Messages.MessageFactoryContext.RequestCompleted">
            <summary>
            A request have been successfully parsed.
            </summary>
        </member>
        <member name="E:HttpServer.Messages.MessageFactoryContext.ResponseCompleted">
            <summary>
            A response have been successfully parsed.
            </summary>
        </member>
        <member name="E:HttpServer.Messages.MessageFactoryContext.ContinueResponseRequested">
            <summary>
            Client asks if he may continue.
            </summary>
            <remarks>
            If the body is too large or anything like that you should respond <see cref="F:System.Net.HttpStatusCode.ExpectationFailed"/>.
            </remarks>
        </member>
        <member name="T:HttpServer.Messages.ContinueEventArgs">
            <summary>
            Used to notify about 100-continue header.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.ContinueEventArgs.#ctor(HttpServer.IRequest)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.ContinueEventArgs"/> class.
            </summary>
            <param name="request">request that want to continue.</param>
        </member>
        <member name="P:HttpServer.Messages.ContinueEventArgs.Request">
            <summary>
            Gets request that want to continue
            </summary>
        </member>
        <member name="T:HttpServer.Logging.LogFilter">
            <summary>
            Default log filter implementation.
            </summary>
        </member>
        <member name="T:HttpServer.Logging.ILogFilter">
            <summary>
            Determines which classes can log
            </summary>
        </member>
        <member name="M:HttpServer.Logging.ILogFilter.CanLog(HttpServer.Logging.LogLevel,System.Type)">
            <summary>
            Checks if the specified type can send
            log entries at the specified level.
            </summary>
            <param name="level">Log level</param>
            <param name="type">Type that want to write a log entry.</param>
            <returns><c>true</c> if logging is allowed; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:HttpServer.Logging.LogFilter.AddNameSpace(System.String,HttpServer.Logging.LogLevel)">
            <summary>
            Add a name space filter.
            </summary>
            <param name="ns">Name space to add filter for.</param>
            <param name="level">Minimum log level required.</param>
            <example>
            <code>
            // Parsing can only add error and fatal messages
            AddNamespace("SipSharp.Messages.Headers.Parsers", LogLevel.Error);
            AddType(typeof(SipParser), LogLevel.Error);
            
            // Transport layer can only log warnings, errors and fatal messages
            AddNamespace("SipSharp.Transports.*", LogLevel.Warning);
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Logging.LogFilter.AddStandardRules">
            <summary>
            Used to specify standard filter rules
            </summary>
            <remarks>
            Parser can only display errors. Transports only warnings.
            </remarks>
        </member>
        <member name="M:HttpServer.Logging.LogFilter.AddType(System.Type,HttpServer.Logging.LogLevel)">
            <summary>
            Add filter for a type
            </summary>
            <param name="type">Type to add filter for.</param>
            <param name="level">Minimum log level required.</param>
            <example>
            <code>
            // Parsing can only add error and fatal messages
            AddNamespace("SipSharp.Messages.Headers.Parsers", LogLevel.Error);
            AddType(typeof(SipParser), LogLevel.Error);
            
            // Transport layer can only log warnings, errors and fatal messages
            AddNamespace("SipSharp.Transports.*", LogLevel.Warning);
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Logging.LogFilter.AddType(System.String,HttpServer.Logging.LogLevel)">
            <summary>
            Add filter for a type
            </summary>
            <param name="typeStr">Type to add filter for.</param>
            <param name="level">Minimum log level required.</param>
            <example>
            <code>
            // Parsing can only add error and fatal messages
            AddNamespace("SipSharp.Messages.Headers.Parsers", LogLevel.Error);
            AddType("SipSharp.Messages.MessageFactory", LogLevel.Error);
            
            // Transport layer can only log warnings, errors and fatal messages
            AddNamespace("SipSharp.Transports.*", LogLevel.Warning);
            </code>
            </example>
            <exception cref="T:System.ArgumentException">Type could not be identified.</exception>
        </member>
        <member name="M:HttpServer.Logging.LogFilter.HttpServer#Logging#ILogFilter#CanLog(HttpServer.Logging.LogLevel,System.Type)">
            <summary>
            Checks if the specified type can send
            log entries at the specified level.
            </summary>
            <param name="level">Log level</param>
            <param name="type">Type that want to write a log entry.</param>
            <returns><c>true</c> if logging is allowed; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:HttpServer.Logging.LogFilter.NamespaceFilter.#ctor(System.String,HttpServer.Logging.LogLevel)">
            <exception cref="T:System.ArgumentException">No filters = everything logged. <see cref="T:HttpServer.Logging.NullLogFactory"/> = no logs. Don't use a rule with '*' or '.*'</exception>
        </member>
        <member name="P:HttpServer.Logging.LogFilter.NamespaceFilter.IsWildcard">
            <summary>
            User have specified a wild card filter.
            </summary>
            <remarks>
            Wild card filters are used to log a name space and
            all it's children name spaces.
            </remarks>
        </member>
        <member name="T:HttpServer.ProcessingResult">
            <summary>
            Result of processing.
            </summary>
        </member>
        <member name="F:HttpServer.ProcessingResult.Continue">
            <summary>
            Continue with the next handler
            </summary>
        </member>
        <member name="F:HttpServer.ProcessingResult.SendResponse">
            <summary>
            No more handlers can process the request.
            </summary>
            <remarks>
            The server will process the response object and
            generate a HTTP response from it.
            </remarks>
        </member>
        <member name="F:HttpServer.ProcessingResult.Abort">
            <summary>
            Response have been sent back by the handler.
            </summary>
            <remarks>
            This option should only be used if you are streaming
            something or sending back a custom result. The server will
            not process the response object or send anything back
            to the client.
            </remarks>
        </member>
        <member name="T:HttpServer.Headers.StringHeader">
            <summary>
            Used to store all headers that that aren't recognized.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.StringHeader.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.StringHeader"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:HttpServer.Headers.StringHeader.Value">
            <summary>
            Gets or sets value
            </summary>
        </member>
        <member name="P:HttpServer.Headers.StringHeader.Name">
            <summary>
            Gets header name
            </summary>
        </member>
        <member name="T:HttpServer.Headers.Parsers.ConnectionParser">
            <summary>
            Parses <see cref="T:HttpServer.Headers.ConnectionHeader"/>.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.Parsers.ConnectionParser.Parse(System.String,HttpServer.Tools.ITextReader)">
            <summary>
            Parse a header
            </summary>
            <param name="name">Name of header.</param>
            <param name="reader">Reader containing value.</param>
            <returns>HTTP Header</returns>
            <exception cref="T:System.FormatException">Header value is not of the expected format.</exception>
        </member>
        <member name="T:HttpServer.IParameterCollection">
            <summary>
            Collection of parameters
            </summary>
        </member>
        <member name="M:HttpServer.IParameterCollection.Get(System.String)">
            <summary>
            Get a parameter.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.IParameterCollection.Add(System.String,System.String)">
            <summary>
            Add a query string parameter.
            </summary>
            <param name="name">Parameter name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:HttpServer.IParameterCollection.Exists(System.String)">
            <summary>
            Checks if the specified parameter exists
            </summary>
            <param name="name">Parameter name.</param>
            <returns><c>true</c> if found; otherwise <c>false</c>;</returns>
        </member>
        <member name="P:HttpServer.IParameterCollection.Count">
            <summary>
            Gets number of parameters.
            </summary>
        </member>
        <member name="P:HttpServer.IParameterCollection.Item(System.String)">
            <summary>
            Gets last value of an parameter.
            </summary>
            <param name="name">Parameter name</param>
            <returns>String if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:HttpServer.IParameter">
            <summary>
            Parameter in <see cref="T:HttpServer.IParameterCollection"/>
            </summary>
        </member>
        <member name="P:HttpServer.IParameter.Value">
            <summary>
            Gets *last* value.
            </summary>
            <remarks>
            Parameters can have multiple values. This property will always get the last value in the list.
            </remarks>
            <value>String if any value exist; otherwise <c>null</c>.</value>
        </member>
        <member name="P:HttpServer.IParameter.Name">
            <summary>
            Gets or sets name.
            </summary>
        </member>
        <member name="P:HttpServer.IParameter.Values">
            <summary>
            Gets a list of all values.
            </summary>
        </member>
        <member name="T:HttpServer.Parameter">
            <summary>
            A parameter in <see cref="T:HttpServer.IParameterCollection"/>.
            </summary>
        </member>
        <member name="M:HttpServer.Parameter.System#Collections#Generic#IEnumerable{System#String}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.Parameter.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:HttpServer.Parameter.Value">
            <summary>
            Gets last value.
            </summary>
            <remarks>
            Parameters can have multiple values. This property will always get the last value in the list.
            </remarks>
            <value>String if any value exist; otherwise <c>null</c>.</value>
        </member>
        <member name="P:HttpServer.Parameter.Name">
            <summary>
            Gets or sets name.
            </summary>
        </member>
        <member name="P:HttpServer.Parameter.Values">
            <summary>
            Gets a list of all values.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.Parser.RequestLineEventArgs">
            <summary>
            Used when the request line have been successfully parsed.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.RequestLineEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.RequestLineEventArgs"/> class.
            </summary>
            <param name="method">The HTTP method.</param>
            <param name="uriPath">The URI path.</param>
            <param name="version">The HTTP version.</param>
        </member>
        <member name="M:HttpServer.Messages.Parser.RequestLineEventArgs.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.RequestLineEventArgs"/> class.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.RequestLineEventArgs.Method">
            <summary>
            Gets or sets HTTP method.
            </summary>
            <remarks>
            Should be one of the methods declared in <see cref="P:HttpServer.Messages.Parser.RequestLineEventArgs.Method"/>.
            </remarks>
        </member>
        <member name="P:HttpServer.Messages.Parser.RequestLineEventArgs.UriPath">
            <summary>
            Gets or sets requested URI path.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.RequestLineEventArgs.Version">
            <summary>
            Gets or sets the version of the SIP protocol that the client want to use.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.ContentTypeHeader">
            <summary>
            Content-type
            </summary>
        </member>
        <member name="F:HttpServer.Headers.ContentTypeHeader.NAME">
            <summary>
            Header name.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.ContentTypeHeader.#ctor(System.String,HttpServer.Headers.HeaderParameterCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.ContentTypeHeader"/> class.
            </summary>
            <param name="contentType">Type of the content.</param>
            <param name="parameterCollection">Value parameters.</param>
        </member>
        <member name="M:HttpServer.Headers.ContentTypeHeader.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.ContentTypeHeader"/> class.
            </summary>
            <param name="contentType">Type of the content.</param>
        </member>
        <member name="M:HttpServer.Headers.ContentTypeHeader.ToString">
            <summary>
            Returns data formatted as a HTTP header value.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:HttpServer.Headers.ContentTypeHeader.Parameters">
            <summary>
            Gets all parameters.
            </summary>
        </member>
        <member name="P:HttpServer.Headers.ContentTypeHeader.Value">
            <summary>
            Gets content type.
            </summary>
        </member>
        <member name="P:HttpServer.Headers.ContentTypeHeader.Name">
            <summary>
            Gets header name
            </summary>
        </member>
        <member name="T:HttpServer.ForbiddenException">
            <summary>
            Requested resource may not be accessed.
            </summary>
            <remarks>
            Normally thrown after an authentication attempt have failed too many times.
            </remarks>
            <seealso cref="T:HttpServer.AuthenticationRequiredException"/>
        </member>
        <member name="M:HttpServer.ForbiddenException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ForbiddenException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
        </member>
        <member name="M:HttpServer.ForbiddenException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ForbiddenException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="T:HttpServer.BodyDecoders.Mono.HttpMultipart">
             <summary>
             Stream-based multipart handling.
            
             In this incarnation deals with an HttpInputStream as we are now using
             IntPtr-based streams instead of byte [].   In the future, we will also
             send uploads above a certain threshold into the disk (to implement
             limit-less HttpInputFiles). 
             </summary>
             <remarks>
             Taken from HttpRequest in mono (http://www.mono-project.com)
             </remarks>
        </member>
        <member name="T:HttpServer.Transports.ClientCertificate">
            <summary>
            Client X.509 certificate, X.509 chain, and any SSL policy errors encountered
            during the SSL stream creation
            </summary>
        </member>
        <member name="M:HttpServer.Transports.ClientCertificate.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Transports.ClientCertificate"/> class.
            </summary>
            <param name="certificate">The certificate.</param>
            <param name="chain">Client security certificate chain.</param>
            <param name="sslPolicyErrors">Any SSL policy errors encountered during the SSL stream creation.</param>
        </member>
        <member name="P:HttpServer.Transports.ClientCertificate.Certificate">
            <summary>
            Client security certificate
            </summary>
        </member>
        <member name="P:HttpServer.Transports.ClientCertificate.Chain">
            <summary>
            Client security certificate chain
            </summary>
        </member>
        <member name="P:HttpServer.Transports.ClientCertificate.SslPolicyErrors">
            <summary>
            Any SSL policy errors encountered during the SSL stream creation
            </summary>
        </member>
        <member name="T:HttpServer.Tools.Properties.EmitHelper">
            <summary>
            Credits and description: http://theinstructionlimit.com/?p=76
            </summary>
            <remarks>
            Converted to .Net 2.0
            </remarks>
        </member>
        <member name="T:HttpServer.Sessions.Session">
            <summary>
            Session in the system
            </summary>
        </member>
        <member name="P:HttpServer.Sessions.Session.SessionId">
            <summary>
            Gets or sets session id.
            </summary>
        </member>
        <member name="T:HttpServer.Logging.NullLogFactory">
            <summary>
            Factory creating null logger.
            </summary>
        </member>
        <member name="M:HttpServer.Logging.NullLogFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Logging.NullLogFactory"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Logging.NullLogFactory.CreateLogger(System.Type)">
            <summary>
            Create a new logger.
            </summary>
            <param name="type">Type that requested a logger.</param>
            <returns>Logger for the specified type;</returns>
            <remarks>
            MUST ALWAYS return a logger. Return <see cref="T:HttpServer.Logging.NullLogWriter"/> if no logging
            should be used.
            </remarks>
        </member>
        <member name="P:HttpServer.Logging.NullLogFactory.Instance">
            <summary>
            Logger instance.
            </summary>
        </member>
        <member name="T:HttpServer.Resources.ResourceProvider">
            <summary>
            Provides resources.
            </summary>
        </member>
        <member name="T:HttpServer.Resources.IResourceProvider">
            <summary>
            Used to access resources.
            </summary>
        </member>
        <member name="M:HttpServer.Resources.IResourceProvider.Add(HttpServer.Resources.IResourceLoader)">
            <summary>
            Add a new resource loader.
            </summary>
            <param name="loader">Provider to add.</param>
            <exception cref="T:System.InvalidOperationException">Manager have been started.</exception>
        </member>
        <member name="M:HttpServer.Resources.IResourceProvider.Exists(System.String)">
            <summary>
            Check if a resource exists.
            </summary>
            <param name="uriPath">Uri to check</param>
            <returns><c>true</c> if found; otherwise <c>false</c>.</returns>
            <example>
            <code>
            if (manager.Exists("/views/user/view.haml"))
              return true
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.IResourceProvider.Get(System.String)">
            <summary>
            Get a resource.
            </summary>
            <param name="uri">Uri path to resource.</param>
            <returns>Resource if found; otherwise <c>null</c>.</returns>
            <example>
            <code>
            Resource resource = manager.Get("/views/user/view.haml");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.IResourceProvider.Start">
            <summary>
            Start manager.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.IResourceProvider.Count">
            <summary>
            Gets number of resource providers
            </summary>
        </member>
        <member name="M:HttpServer.Resources.ResourceProvider.Find(System.String)">
            <summary>
            Get all view names from a folder.
            </summary>
            <param name="path">Path to find views in.</param>
            <returns>A collection of view names (without path).</returns>
        </member>
        <member name="M:HttpServer.Resources.ResourceProvider.Add(HttpServer.Resources.IResourceLoader)">
            <summary>
            Add a new resource loader.
            </summary>
            <param name="loader">Provider to add.</param>
            <exception cref="T:System.InvalidOperationException">Manager have been started.</exception>
        </member>
        <member name="M:HttpServer.Resources.ResourceProvider.Start">
            <summary>
            Start manager.
            </summary>
        </member>
        <member name="M:HttpServer.Resources.ResourceProvider.Exists(System.String)">
            <summary>
            Check if a resource exists.
            </summary>
            <param name="uriPath">Uri to check</param>
            <returns><c>true</c> if found; otherwise <c>false</c>.</returns>
            <example>
            <code>
            if (manager.Exists("/views/user/view.haml"))
              return true
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.ResourceProvider.Get(System.String)">
            <summary>
            Get a resource.
            </summary>
            <param name="uri">Uri path to resource.</param>
            <returns>Resource if found; otherwise <c>null</c>.</returns>
            <example>
            <code>
            Resource resource = manager.Get("/views/user/view.haml");
            </code>
            </example>
        </member>
        <member name="P:HttpServer.Resources.ResourceProvider.Count">
            <summary>
            Gets number of resource providers
            </summary>
        </member>
        <member name="T:HttpServer.Resources.EmbeddedResourceLoader">
            <summary>
            Loads resources that are embedded in assemblies.
            </summary>
            <remarks>
            No locks used internally since all mappings are loaded during start up.
            </remarks>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Resources.EmbeddedResourceLoader"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.#ctor(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Resources.EmbeddedResourceLoader"/> class.
            </summary>
            <param name="path">Path (Uri) requested by clients</param>
            <param name="assembly">Assembly that the resources exist in</param>
            <param name="nameSpace">Name space that the resources exist in</param>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.Add(System.String,System.Reflection.Assembly,System.String,System.String)">
            <summary>
            Add a specific resource.
            </summary>
            <param name="path">Path (Uri) requested by clients</param>
            <param name="assembly">Assembly that the resources exist in</param>
            <param name="rootNameSpace">Name space to root folder under (all name spaces below the specified one are considered as folders)</param>
            <param name="fullResourceName">Name space and name of resource.</param>
            <example>
            <code>
            Add("/", Assembly.GetExecutingAssembly(), "MyApplication.Files", "Myapplication.Files.Images.MyImage.png");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.AddFile(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Add resources.
            </summary>
            <param name="path">Path (Uri) requested by clients</param>
            <param name="assembly">Assembly that the resources exist in</param>
            <param name="resourceName">Name of resource, including name space.</param>
            <returns><c>true</c> if file was found (and has not previously been added); otherwise <c>false</c>.</returns>
            <remarks>
            </remarks>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.AddFilesInFolder(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Add resources in a specific path (will not work with sub folders)
            </summary>
            <param name="path">Path (Uri) requested by clients</param>
            <param name="assembly">Assembly that the resources exist in</param>
            <param name="rootNameSpace">Name space to root folder under which all name spaces exists in,</param>
            <returns><c>true</c> if any files was found; otherwise <c>false</c>.</returns>
            <remarks>
            <para>
            Adds all views in the specified folder. Sub folders are not supported since it's hard to determine
            with parts are the path and witch parts are the filename. Use <see cref="M:HttpServer.Resources.EmbeddedResourceLoader.AddPath(System.String,System.Reflection.Assembly,System.String)"/> to get support
            for sub folders.
            </para>
            </remarks>
            <example>
            <code>
            Add("/user/", typeof(MyController).Assembly, "YourProject.Users.Views");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.AddPath(System.String,System.Reflection.Assembly,System.String)">
            <summary>
            Add resources in a folder and it's sub folder
            </summary>
            <param name="path"></param>
            <param name="assembly"></param>
            <param name="rootNameSpace"></param>
            <remarks>
            <para>This method is not going to map files but keep the mapping and 
            try to look up views every time they are requested. This is the method
            to use to add a resource folder that has sub folders.
            </para>
            </remarks>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.LoadMappingFromPath(System.String)">
            <summary>
            Tries to load file by using previously added paths.
            </summary>
            <param name="uriPath">Uri path including file name</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.Exists(System.String)">
            <summary>
            Checks if a resource exists in the specified directory
            </summary>
            <param name="uriPath">Uri path to resource</param>
            <returns><c>true</c> if resource was found; otherwise <c>false</c>.</returns>
            <example>
            <code>
            if (resources.Exists("/files/user/user.png"))
              Debug.WriteLine("Resource exists.");
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.Get(System.String)">
            <summary>
            Load a resource.
            </summary>
            <param name="uri">Uri of resource.</param>
            <returns>Resource if found and loaded; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.Find(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Find all views in a folder/path.
            </summary>
            <param name="path">Uri path</param>
            <param name="viewNames">Collection to add all view names to.</param>
        </member>
        <member name="M:HttpServer.Resources.EmbeddedResourceLoader.LoadFromPathMappings(System.String)">
            <summary>
            Loads all files in a resource directory
            </summary>
            <param name="path"></param>
        </member>
        <member name="P:HttpServer.Resources.EmbeddedResourceLoader.Mapping.Assembly">
            <summary>
            Gets or sets assembly that the resource exists in.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.EmbeddedResourceLoader.Mapping.FileName">
            <summary>
            Gets or sets resource name.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.EmbeddedResourceLoader.Mapping.FullResourceName">
            <summary>
            Gets or sets full name space path to resource.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.EmbeddedResourceLoader.Mapping.TypeExtension">
            <summary>
            Gets or sets if this file is for a certain content type.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.EmbeddedResourceLoader.Mapping.UriPath">
            <summary>
            Gets or sets full "virtual" Uri path, excluding file name.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.EmbeddedResourceLoader.PathMapping.Assembly">
            <summary>
            Gets or sets assembly
            </summary>
        </member>
        <member name="P:HttpServer.Resources.EmbeddedResourceLoader.PathMapping.RootNameSpace">
            <summary>
            Gets or sets name space root.
            </summary>
        </member>
        <member name="P:HttpServer.Resources.EmbeddedResourceLoader.PathMapping.UriPath">
            <summary>
            Gets or sets uri path.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.RequestCookieCollection">
            <summary>
            A list of request cookies.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.RequestCookieCollection.#ctor(System.String)">
            <summary>
            Let's copy all the cookies.
            </summary>
            <param name="cookies">value from cookie header.</param>
        </member>
        <member name="M:HttpServer.Messages.RequestCookieCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.RequestCookieCollection"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.RequestCookieCollection.Add(HttpServer.Messages.RequestCookie)">
            <summary>
            Adds a cookie in the collection.
            </summary>
            <param name="cookie">cookie to add</param>
            <exception cref="T:System.ArgumentNullException">cookie is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">Name must be specified.</exception>
        </member>
        <member name="M:HttpServer.Messages.RequestCookieCollection.Clear">
            <summary>
            Remove all cookies.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.RequestCookieCollection.Remove(System.String)">
            <summary>
            Remove a cookie from the collection.
            </summary>
            <param name="cookieName">Name of cookie.</param>
        </member>
        <member name="M:HttpServer.Messages.RequestCookieCollection.GetEnumerator">
            <summary>
            Gets a collection enumerator on the cookie list.
            </summary>
            <returns>collection enumerator</returns>
        </member>
        <member name="M:HttpServer.Messages.RequestCookieCollection.System#Collections#Generic#IEnumerable{HttpServer#Messages#RequestCookie}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:HttpServer.Messages.RequestCookieCollection.Count">
            <summary>
            Gets the count of cookies in the collection.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.RequestCookieCollection.Item(System.String)">
            <summary>
            Gets the cookie of a given identifier (<c>null</c> if not existing).
            </summary>
        </member>
        <member name="T:HttpServer.Headers.HeaderCollection">
            <summary>
            Collection of headers.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.IHeaderCollection">
            <summary>
            Collection of headers.
            </summary>
        </member>
        <member name="P:HttpServer.Headers.IHeaderCollection.Item(System.String)">
            <summary>
            Gets a header
            </summary>
            <param name="name">header name.</param>
            <returns>header if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Headers.HeaderCollection.#ctor(HttpServer.Headers.HeaderFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.HeaderCollection"/> class.
            </summary>
            <param name="factory">Factory used to created headers.</param>
        </member>
        <member name="M:HttpServer.Headers.HeaderCollection.Add(HttpServer.Headers.IHeader)">
            <summary>
            Adds a header
            </summary>
            <remarks>
            Will replace any existing header with the same name.
            </remarks>
            <param name="header">header to add</param>
            <exception cref="T:System.ArgumentNullException"><c>header</c> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Header name cannot be <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Headers.HeaderCollection.Add(System.String,System.String)">
            <summary>
            Add a header.
            </summary>
            <param name="name">Header name</param>
            <param name="value">Header value</param>
            <remarks>
            Will try to parse the header and create a <see cref="T:HttpServer.Headers.IHeader"/> object.
            </remarks>
            <exception cref="T:System.FormatException">Header value is not correctly formatted.</exception>
            <exception cref="T:System.ArgumentNullException"><c>name</c> or <c>value</c> is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Headers.HeaderCollection.Add(System.String,HttpServer.Headers.IHeader)">
            <summary>
            Add a header.
            </summary>
            <param name="name">Header name</param>
            <param name="value">Header value</param>
            <remarks>
            Will try to parse the header and create a <see cref="T:HttpServer.Headers.IHeader"/> object.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><c>name</c> or <c>value</c> is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Headers.HeaderCollection.Get``1(System.String)">
            <summary>
            Get a header 
            </summary>
            <typeparam name="T">Type that it should be cast to</typeparam>
            <param name="headerName">Name of header</param>
            <returns>Header if found and casted properly; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Headers.HeaderCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.Headers.HeaderCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:HttpServer.Headers.HeaderCollection.Item(System.String)">
            <summary>
            Gets a header
            </summary>
            <param name="name">header name.</param>
            <returns>header if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:HttpServer.Headers.DateHeader">
             <summary>
             Header for "Date" and "If-Modified-Since"
             </summary>
             <remarks>
             <para>
             The field value is an HTTP-date, as described in section 3.3.1 in RFC2616;
             it MUST be sent in RFC 1123 [8]-date format. An example is
            <example>
             Date: Tue, 15 Nov 1994 08:12:31 GMT
             </example>
            </para><para>Origin servers MUST include a Date header field in all
            responses, except in these cases:
            <list type="number">
             <item>If the response status code is 100 (Continue) or 101 (Switching
             Protocols), the response MAY include a Date header field, at the server's
             option.
            </item><item>If the response status code conveys a server error, e.g. 500
            (Internal Server Error) or 503 (Service Unavailable), and it is inconvenient
            or impossible to generate a valid Date.
            </item><item>If the server does not have a clock that can provide a
            reasonable approximation of the current time, its responses MUST NOT include
            a Date header field. In this case, the rules in section 14.18.1 in RFC2616
            MUST be followed.
             </item>
             </list>
            </para><para>A received message that does not have a Date header field MUST
            be assigned one by the recipient if the message will be cached by that
            recipient or gatewayed via a protocol which requires a Date. An HTTP
            implementation without a clock MUST NOT cache responses without revalidating
            them on every use. An HTTP cache, especially a shared cache, SHOULD use a
            mechanism, such as NTP [28], to synchronize its clock with a reliable
            external standard.
            </para><para>Clients SHOULD only send a Date header field in messages that
            include an entity-body, as in the case of the PUT and POST requests, and
            even then it is optional. A client without a clock MUST NOT send a Date
            header field in a request.
            </para><para>The HTTP-date sent in a Date header SHOULD NOT represent a date
            and time subsequent to the generation of the message. It SHOULD represent
            the best available approximation of the date and time of message generation,
            unless the implementation has no means of generating a reasonably accurate
            date and time. In theory, the date ought to represent the moment just before
            the entity is generated. In practice, the date can be generated at any time
            during the message origination without affecting its semantic value.
             </para>
             </remarks>
        </member>
        <member name="F:HttpServer.Headers.DateHeader.NAME">
            <summary>
            Header name
            </summary>
        </member>
        <member name="M:HttpServer.Headers.DateHeader.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.DateHeader"/> class.
            </summary>
            <param name="name">Header name.</param>
            <exception cref="T:System.ArgumentException">Name must not be empty.</exception>
        </member>
        <member name="M:HttpServer.Headers.DateHeader.#ctor(System.String,System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.DateHeader"/> class.
            </summary>
            <param name="name">Header name.</param>
            <param name="value">Universal time.</param>
        </member>
        <member name="M:HttpServer.Headers.DateHeader.ToString">
            <summary>
            Returns data formatted as a HTTP header value.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:HttpServer.Headers.DateHeader.Value">
            <summary>
            Gets or sets date time.
            </summary>
            <value>Should be in UTC.</value>
        </member>
        <member name="P:HttpServer.Headers.DateHeader.Name">
            <summary>
            Gets header name
            </summary>
        </member>
        <member name="T:HttpServer.Tools.Properties.ICachedType">
            <summary>
            Type cached for fast property value modifications.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.Properties.ICachedType.GetValue(System.Object,System.String)">
            <summary>
            Get a property value.
            </summary>
            <param name="instance">Instance to get value from.</param>
            <param name="propertyName">Name of property.</param>
            <returns>Property value.</returns>
        </member>
        <member name="M:HttpServer.Tools.Properties.ICachedType.SetConvertedValue(System.Object,System.String,System.Object)">
            <summary>
            Assign a value, try to convert it if it's not the same type as the property type.
            </summary>
            <param name="instance">Object containing the property</param>
            <param name="propertyName">Name of property</param>
            <param name="value">Value to convert and assign</param>
            <exception cref="T:System.InvalidOperationException">Failed to find property.</exception>
            <exception cref="T:System.InvalidCastException">Could not convert value type to property type.</exception>
        </member>
        <member name="M:HttpServer.Tools.Properties.ICachedType.SetValue(System.Object,System.String,System.Object)">
            <summary>
            Assign value to a property
            </summary>
            <param name="instance">Object containing the property</param>
            <param name="propertyName">Name of property</param>
            <param name="value">Value to assign, must be of the same type as the property.</param>
            <exception cref="T:System.InvalidOperationException">Failed to find property.</exception>
        </member>
        <member name="T:HttpServer.Tools.Properties.CachedType">
            <summary>
            Used to cache property information
            </summary>
        </member>
        <member name="M:HttpServer.Tools.Properties.CachedType.GetProperty(System.String)">
            <summary>
            Gets the property.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Failed to find property.</exception>
        </member>
        <member name="M:HttpServer.Tools.Properties.CachedType.ToDate(System.Type,System.Object)">
            <exception cref="T:System.InvalidCastException"><c>InvalidCastException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.Properties.CachedType.GetValue(System.Object,System.String)">
            <summary>
            Get a property value.
            </summary>
            <param name="instance">Instance to get value from.</param>
            <param name="propertyName">Name of property.</param>
            <returns>Property value.</returns>
        </member>
        <member name="M:HttpServer.Tools.Properties.CachedType.SetConvertedValue(System.Object,System.String,System.Object)">
            <summary>
            Assign a value, try to convert it if it's not the same type as the property type.
            </summary>
            <param name="instance">Object containing the property</param>
            <param name="propertyName">Name of property</param>
            <param name="value">Value to convert and assign</param>
            <exception cref="T:System.InvalidOperationException">Failed to find property.</exception>
            <exception cref="T:System.InvalidCastException">Could not convert value type to property type.</exception>
        </member>
        <member name="M:HttpServer.Tools.Properties.CachedType.SetValue(System.Object,System.String,System.Object)">
            <summary>
            Assign value to a property
            </summary>
            <param name="instance">Object containing the property</param>
            <param name="propertyName">Name of property</param>
            <param name="value">Value to assign, must be of the same type as the property.</param>
            <exception cref="T:System.InvalidOperationException">Failed to find property.</exception>
        </member>
        <member name="P:HttpServer.Tools.Properties.CachedType.CachedProperty.MemberInfo">
            <summary>
            Gets or sets member info
            </summary>
        </member>
        <member name="P:HttpServer.Tools.Properties.CachedType.CachedProperty.MemberType">
            <summary>
            Gets or sets member type
            </summary>
        </member>
        <member name="T:HttpServer.Tools.ITextReader">
            <summary>
            Base interface to read string tokens from different sources.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.Assign(System.Object,System.Int32,System.Int32)">
            <summary>
            Assign a new buffer
            </summary>
            <param name="buffer">Buffer to process.</param>
            <param name="offset">Where to start process buffer</param>
            <param name="count">Buffer length</param>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.Assign(System.Object)">
            <summary>
            Assign a new buffer
            </summary>
            <param name="buffer">Buffer to process</param>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.Consume">
            <summary>
            Consume current character.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.Consume(System.Char[])">
            <summary>
            Consume specified characters
            </summary>
            <param name="chars">One or more characters.</param>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ConsumeWhiteSpaces">
            <summary>
            Consumes horizontal white spaces (space and tab).
            </summary>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ConsumeWhiteSpaces(System.Char)">
            <summary>
            Consume horizontal white spaces and the specified character.
            </summary>
            <param name="extraCharacter">Extra character to consume</param>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.Contains(System.Char)">
            <summary>
            Checks if one of the remaining bytes are a specified character.
            </summary>
            <param name="ch">Character to find.</param>
            <returns><c>true</c> if found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.Read">
            <summary>
            Read a character.
            </summary>
            <returns>Character if not EOF; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ReadLine">
            <summary>
            Get a text line. 
            </summary>
            <returns></returns>
            <remarks>Will merge multiline headers.</remarks> 
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ReadQuotedString">
            <summary>
            Read quoted string
            </summary>
            <returns>string if current character (in buffer) is a quote; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ReadToEnd(System.String)">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ReadToEnd">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ReadToEnd(System.Char)">
            <summary>
            Read to end of buffer, or until specified delimiter is found.
            </summary>
            <param name="delimiter">Delimiter to find.</param>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ReadUntil(System.Char)">
            <summary>
            Will read until specified delimiter is found.
            </summary>
            <param name="delimiter">Character to stop at.</param>
            <returns>A string if the delimiter was found; otherwise <c>null</c>.</returns>
            <remarks>
            Will trim away spaces and tabs from the end.
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ReadUntil(System.String)">
            <summary>
            Read until one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>A string if one of the delimiters was found; otherwise <c>null</c>.</returns>
            <remarks>
            Will trim away spaces and tabs from the end.
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.ITextReader.ReadWord">
            <summary>
            Read until a horizontal white space occurs.
            </summary>
            <returns>A string if a white space was found; otherwise <c>null</c>.</returns>
        </member>
        <member name="P:HttpServer.Tools.ITextReader.Current">
            <summary>
            Gets current character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:HttpServer.Tools.ITextReader.EOF">
            <summary>
            Gets if end of buffer have been reached
            </summary>
        </member>
        <member name="P:HttpServer.Tools.ITextReader.HasMore">
            <summary>
            Gets if more bytes can be processed.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.ITextReader.Index">
            <summary>
            Gets or sets current position in buffer.
            </summary>
            <remarks>
            THINK before you manually change the position since it can blow up
            the whole parsing in your face.
            </remarks>
        </member>
        <member name="P:HttpServer.Tools.ITextReader.Length">
            <summary>
            Gets total length of buffer.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.ITextReader.LineNumber">
            <summary>
            Gets or sets line number.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.ITextReader.Peek">
            <summary>
            Gets next character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:HttpServer.Tools.ITextReader.RemainingLength">
            <summary>
            Gets number of bytes left.
            </summary>
        </member>
        <member name="T:HttpServer.Logging.LogFactory">
            <summary>
            Factory is used to create new logs in the system.
            </summary>
        </member>
        <member name="M:HttpServer.Logging.LogFactory.Assign(HttpServer.Logging.ILogFactory)">
            <summary>
            Assigns log factory being used.
            </summary>
            <param name="logFactory">The log factory.</param>
            <exception cref="T:System.InvalidOperationException">A factory have already been assigned.</exception>
        </member>
        <member name="M:HttpServer.Logging.LogFactory.CreateLogger(System.Type)">
            <summary>
            Create a new logger.
            </summary>
            <param name="type">Type that requested a logger.</param>
            <returns>Logger for the specified type;</returns>
        </member>
        <member name="T:HttpServer.ComponentAttribute">
            <summary>
            Component that should be registered in the container.
            </summary>
            <remarks>
            Register using all interfaces that is specified in this assembly.
            </remarks>
        </member>
        <member name="T:HttpServer.Authentication.IAuthenticationProvider">
            <summary>
            Used to authenticate users 
            </summary>
            <remarks>
            Authentication is requested by throwing 
            </remarks>
        </member>
        <member name="T:HttpServer.Messages.Request">
            <summary>
            Request implementation.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Request.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Request"/> class.
            </summary>
            <param name="method">The method.</param>
            <param name="path">The path.</param>
            <param name="version">The version.</param>
        </member>
        <member name="M:HttpServer.Messages.Request.Get``1(System.String)">
            <summary>
            Get a header 
            </summary>
            <typeparam name="T">Type that it should be cast to</typeparam>
            <param name="headerName">Name of header</param>
            <returns>Header if found and casted properly; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Messages.Request.Add(System.String,HttpServer.Headers.IHeader)">
            <summary>
            Add a new header.
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:HttpServer.Messages.Request.Add(HttpServer.Headers.IHeader)">
            <summary>
            Add a new header.
            </summary>
            <param name="header">Header to add.</param>
        </member>
        <member name="M:HttpServer.Messages.Request.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.Messages.Request.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:HttpServer.Messages.Request.Item(System.String)">
            <summary>
            Gets a header.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:HttpServer.Messages.Request.Uri">
            <summary>
            Gets request URI.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.Cookies">
            <summary>
            Gets cookies.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.Files">
            <summary>
            Gets all uploaded files.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.Parameters">
            <summary>
            Gets query string and form parameters
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.Form">
            <summary>
            Gets form parameters.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.QueryString">
            <summary>
            Gets query string.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.IsAjax">
            <summary>
            Gets if request is an Ajax request.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.Connection">
            <summary>
            Gets or sets connection header.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.HttpVersion">
            <summary>
            Gets or sets HTTP version.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.Method">
            <summary>
            Gets or sets HTTP method.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.HttpServer#IRequest#Uri">
            <summary>
            Gets requested URI.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.ContentType">
            <summary>
            Kind of content in the body
            </summary>
            <remarks>Default is <c>text/html</c></remarks>
        </member>
        <member name="P:HttpServer.Messages.Request.Encoding">
            <summary>
            Gets or sets encoding
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.Headers">
            <summary>
            Gets headers.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.Body">
            <summary>
            Gets body stream.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Request.ContentLength">
            <summary>
            Size of the body. MUST be specified before sending the header,
            unless property Chunked is set to <c>true</c>.
            </summary>
            <value>
            Any specifically assigned value or Body stream length.
            </value>
        </member>
        <member name="T:HttpServer.Messages.Parser.HeaderEventArgs">
            <summary>
            Event arguments used when a new header have been parsed.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.HeaderEventArgs.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.HeaderEventArgs"/> class.
            </summary>
            <param name="name">Name of header.</param>
            <param name="value">Header value.</param>
            <exception cref="T:System.ArgumentException">Name cannot be empty</exception>
            <exception cref="T:System.ArgumentNullException"><c>value</c> is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Messages.Parser.HeaderEventArgs.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.HeaderEventArgs"/> class.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.HeaderEventArgs.Name">
            <summary>
            Gets or sets header name.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.HeaderEventArgs.Value">
            <summary>
            Gets or sets header value.
            </summary>
        </member>
        <member name="T:HttpServer.ParameterCollection">
            <summary>
            Collection of parameters.
            </summary>
            <remarks>
            <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Specialized.NameValueCollection"/> is not used since each parameter can
            have multiple values.
            </remarks>
        </member>
        <member name="M:HttpServer.ParameterCollection.#ctor(HttpServer.IParameterCollection[])">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ParameterCollection"/> class.
            </summary>
            <param name="collections">Collections to merge.</param>
            <remarks>
            Later collections will overwrite parameters from earlier collections.
            </remarks>
        </member>
        <member name="M:HttpServer.ParameterCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ParameterCollection"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.ParameterCollection.GetArrayNames">
            <summary>
            Get a list of string arrays.
            </summary>
            <returns></returns>
        </member>
        <member name="M:HttpServer.ParameterCollection.GetParameters(System.String)">
            <summary>
            Get parameters 
            </summary>
            <param name="arrayName">Sub array (text array)</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.ParameterCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.ParameterCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:HttpServer.ParameterCollection.Get(System.String)">
            <summary>
            Get a parameter.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.ParameterCollection.Add(System.String,System.String)">
            <summary>
            Add a query string parameter.
            </summary>
            <param name="name">Parameter name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:HttpServer.ParameterCollection.Exists(System.String)">
            <summary>
            Checks if the specified parameter exists
            </summary>
            <param name="name">Parameter name.</param>
            <returns><c>true</c> if found; otherwise <c>false</c>;</returns>
        </member>
        <member name="P:HttpServer.ParameterCollection.Count">
            <summary>
            Gets number of parameters.
            </summary>
        </member>
        <member name="P:HttpServer.ParameterCollection.Item(System.String)">
            <summary>
            Gets last value of an parameter.
            </summary>
            <param name="name">Parameter name</param>
            <returns>String if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:HttpServer.Headers.Parsers.StringParser">
            <summary>
            Parses <see cref="T:HttpServer.Headers.StringHeader"/>.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.Parsers.StringParser.Parse(System.String,HttpServer.Tools.ITextReader)">
            <summary>
            Parse a header
            </summary>
            <param name="name">Name of header.</param>
            <param name="reader">Reader containing value.</param>
            <returns>HTTP Header</returns>
            <exception cref="T:System.FormatException">Header value is not of the expected format.</exception>
        </member>
        <member name="T:HttpServer.Headers.Parsers.NumericHeaderParser">
            <summary>
            Parses numerical values
            </summary>
        </member>
        <member name="M:HttpServer.Headers.Parsers.NumericHeaderParser.Parse(System.String,HttpServer.Tools.ITextReader)">
            <summary>
            Parse a header
            </summary>
            <param name="name">Name of header.</param>
            <param name="reader">Reader containing value.</param>
            <returns>HTTP Header</returns>
            <exception cref="T:System.FormatException">Header value is not of the expected format.</exception>
        </member>
        <member name="T:HttpServer.Headers.Parsers.ContentTypeParser">
            <summary>
            Parses <see cref="T:HttpServer.Headers.ContentTypeHeader"/>.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.Parsers.ContentTypeParser.Parse(System.String,HttpServer.Tools.ITextReader)">
            <summary>
            Parse a header
            </summary>
            <param name="name">Name of header.</param>
            <param name="reader">Reader containing value.</param>
            <returns>HTTP Header</returns>
            <exception cref="T:System.FormatException">Header value is not of the expected format.</exception>
        </member>
        <member name="T:HttpServer.NotFoundException">
            <summary>
            Request couldn't be parsed successfully.
            </summary>
        </member>
        <member name="M:HttpServer.NotFoundException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.BadRequestException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
        </member>
        <member name="M:HttpServer.NotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.BadRequestException"/> class.
            </summary>
            <param name="errMsg">Exception description.</param>
            <param name="inner">Exception description.</param>
        </member>
        <member name="T:HttpServer.Authentication.BasicAuthentication">
            <summary>
            Implements basic authentication scheme.
            </summary>
        </member>
        <member name="M:HttpServer.Authentication.BasicAuthentication.CreateChallenge(System.String)">
            <summary>
            Create a response that can be sent in the WWW-Authenticate header.
            </summary>
            <param name="realm">Realm that the user should authenticate in</param>
            <param name="options">Not used by basic authentication</param>
            <returns>A WWW-Authenticate header.</returns>
            <exception cref="T:System.ArgumentNullException">Argument is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Authentication.BasicAuthentication.Authenticate(HttpServer.Headers.AuthorizationHeader,System.String,System.String)">
            <summary>
            An authentication response have been received from the web browser.
            Check if it's correct
            </summary>
            <param name="header">Authorization header</param>
            <param name="realm">Realm that should be authenticated</param>
            <param name="httpVerb">GET/POST/PUT/DELETE etc.</param>
            <returns>Authentication object that is stored for the request. A user class or something like that.</returns>
            <exception cref="T:System.ArgumentException">if authenticationHeader is invalid</exception>
            <exception cref="T:System.ArgumentNullException">If any of the paramters is empty or null.</exception>
        </member>
        <member name="P:HttpServer.Authentication.BasicAuthentication.Scheme">
            <summary>
            Gets authenticator scheme
            </summary>
            <value></value>
            <example>
            digest
            </example>
        </member>
        <member name="T:HttpServer.Tools.BufferReader">
            <summary>
            Reads strings from a byte array.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Tools.BufferReader"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.#ctor(System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Tools.BufferReader"/> class.
            </summary>
            <param name="encoding">Encoding to use when converting byte array to strings.</param>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.#ctor(System.Byte[],System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Tools.BufferReader"/> class.
            </summary>
            <param name="buffer">Buffer to read from.</param>
            <param name="encoding">Encoding to use when converting byte array to strings.</param>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.Assign(System.Object,System.Int32,System.Int32)">
            <summary>
            Assign a new buffer
            </summary>
            <param name="buffer">Buffer to process.</param>
            <param name="offset">Where to start process buffer</param>
            <param name="count">Buffer length</param>
            <exception cref="T:System.ArgumentException">Buffer needs to be a byte array</exception>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.Assign(System.Object)">
            <summary>
            Assign a new buffer
            </summary>
            <param name="buffer">Buffer to process</param>
            <exception cref="T:System.ArgumentException">Buffer needs to be a byte array</exception>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.Consume">
            <summary>
            Consume current character.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ReadLine">
            <summary>
            Get a text line. 
            </summary>
            <returns></returns>
            <remarks>Will merge multi line headers.</remarks> 
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ReadQuotedString">
            <summary>
            Read quoted string
            </summary>
            <returns>string if current character (in buffer) is a quote; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ReadToEnd(System.String)">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>
            A string (can be <see cref="F:System.String.Empty"/>).
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ReadToEnd">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ReadToEnd(System.Char)">
            <summary>
            Read to end of buffer, or until specified delimiter is found.
            </summary>
            <param name="delimiter">Delimiter to find.</param>
            <returns>
            A string (can be <see cref="F:System.String.Empty"/>).
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.Consume(System.Char[])">
            <summary>
            Consume specified characters
            </summary>
            <param name="chars">One or more characters.</param>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ConsumeWhiteSpaces">
            <summary>
            Consumes horizontal white spaces (space and tab).
            </summary>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ConsumeWhiteSpaces(System.Char)">
            <summary>
            Consume horizontal white spaces and the specified character.
            </summary>
            <param name="extraCharacter">Extra character to consume</param>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.Read">
            <summary>
            Read a character.
            </summary>
            <returns>
            Character if not EOF; otherwise <c>null</c>.
            </returns>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ReadUntil(System.Char)">
            <summary>
            Will read until specified delimiter is found.
            </summary>
            <param name="delimiter">Character to stop at.</param>
            <returns>
            A string if the delimiter was found; otherwise <c>null</c>.
            </returns>
            <remarks>
            Will trim away spaces and tabs from the end.</remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ReadUntil(System.String)">
            <summary>
            Read until one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>
            A string if one of the delimiters was found; otherwise <c>null</c>.
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.ReadWord">
            <summary>
            Read until a horizontal white space occurs.
            </summary>
            <returns>A string if a white space was found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Tools.BufferReader.Contains(System.Char)">
            <summary>
            Checks if one of the remaining bytes are a specified character.
            </summary>
            <param name="ch">Character to find.</param>
            <returns>
            	<c>true</c> if found; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="P:HttpServer.Tools.BufferReader.LineNumber">
            <summary>
            Gets or sets line number.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.BufferReader.EOF">
            <summary>
            Gets if end of buffer have been reached
            </summary>
            <value></value>
        </member>
        <member name="P:HttpServer.Tools.BufferReader.HasMore">
            <summary>
            Gets if more bytes can be processed.
            </summary>
            <value></value>
        </member>
        <member name="P:HttpServer.Tools.BufferReader.Peek">
            <summary>
            Gets next character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:HttpServer.Tools.BufferReader.Current">
            <summary>
            Gets current character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:HttpServer.Tools.BufferReader.Index">
            <summary>
            Gets or sets current position in buffer.
            </summary>
            <remarks>
            THINK before you manually change the position since it can blow up
            the whole parsing in your face.
            </remarks>
        </member>
        <member name="P:HttpServer.Tools.BufferReader.Length">
            <summary>
            Gets total length of buffer.
            </summary>
            <value></value>
        </member>
        <member name="P:HttpServer.Tools.BufferReader.RemainingLength">
            <summary>
            Gets number of bytes left.
            </summary>
        </member>
        <member name="T:HttpServer.IResponse">
            <summary>
            Response to a request.
            </summary>
        </member>
        <member name="M:HttpServer.IResponse.Redirect(System.String)">
            <summary>
            Redirect user.
            </summary>
            <param name="uri">Where to redirect to.</param>
            <remarks>
            Any modifications after a redirect will be ignored.
            </remarks>
        </member>
        <member name="P:HttpServer.IResponse.Connection">
            <summary>
            Gets connection type.
            </summary>
        </member>
        <member name="P:HttpServer.IResponse.Cookies">
            <summary>
            Gets cookies.
            </summary>
        </member>
        <member name="P:HttpServer.IResponse.HttpVersion">
            <summary>
            Gets HTTP version.
            </summary>
            <remarks>
            Default is HTTP/1.1
            </remarks>
        </member>
        <member name="P:HttpServer.IResponse.Reason">
            <summary>
            Information about why a specific status code was used.
            </summary>
        </member>
        <member name="P:HttpServer.IResponse.Status">
            <summary>
            Status code that is sent to the client.
            </summary>
            <remarks>Default is <see cref="F:System.Net.HttpStatusCode.OK"/></remarks>
        </member>
        <member name="P:HttpServer.IResponse.ContentType">
            <summary>
             Gets or sets content type
            </summary>
        </member>
        <member name="T:HttpServer.RequestContext">
            <summary>
            Request context
            </summary>
            <remarks>
            Contains information about a HTTP request and where it came from.
            </remarks>
        </member>
        <member name="P:HttpServer.RequestContext.HttpContext">
            <summary>
            Gets or sets http context.
            </summary>
        </member>
        <member name="P:HttpServer.RequestContext.Request">
            <summary>
            Gets or sets http request.
            </summary>
        </member>
        <member name="P:HttpServer.RequestContext.Response">
            <summary>
            Gets or sets http response.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.NumericHeader">
            <summary>
            Contains numerical value.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.NumericHeader.#ctor(System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Headers.NumericHeader"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:HttpServer.Headers.NumericHeader.ToString">
            <summary>
            Returns data formatted as a HTTP header value.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:HttpServer.Headers.NumericHeader.Value">
            <summary>
            Gets value
            </summary>
        </member>
        <member name="P:HttpServer.Headers.NumericHeader.Name">
            <summary>
            Gets header name
            </summary>
        </member>
        <member name="T:HttpServer.ArrayParameterCollection">
            <summary>
            Form parameters where form string arrays have been converted to real arrays.
            </summary>
        </member>
        <member name="M:HttpServer.ArrayParameterCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ArrayParameterCollection"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.ArrayParameterCollection.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ArrayParameterCollection"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:HttpServer.ArrayParameterCollection.#ctor(System.Collections.Generic.IEnumerable{HttpServer.IParameter})">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.ArrayParameterCollection"/> class.
            </summary>
            <param name="collection">Parse parameters from the this collection.</param>
        </member>
        <member name="M:HttpServer.ArrayParameterCollection.Get(System.String)">
            <summary>
            Get a parameter.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.ArrayParameterCollection.Add(System.String,System.String)">
            <summary>
            Add a parameter
            </summary>
            <param name="name">Name of parameter, can contain a string array.</param>
            <param name="value">Value</param>
            <example>
            <code>
            ArrayParameterCollection array = new ArrayParameterCollection();
            array.Add("user[FirstName]", "Jonas");
            array.Add("user[FirstName]", "Arne");
            string firstName = array["user"]["FirstName"].Value; // "Arne" is returned
            foreach (string value in array["user"]["FirstName"])
              Console.WriteLine(value);  // each name is displayed.
            </code>
            </example>
        </member>
        <member name="M:HttpServer.ArrayParameterCollection.Exists(System.String)">
            <summary>
            Checks if the specified parameter exists
            </summary>
            <param name="name">Parameter name.</param>
            <returns><c>true</c> if found; otherwise <c>false</c>;</returns>
        </member>
        <member name="M:HttpServer.ArrayParameterCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:HttpServer.ArrayParameterCollection.Item(System.String)">
            <summary>
            Gets first value of an item.
            </summary>
            <value></value>
            <returns>String if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="P:HttpServer.ArrayParameterCollection.Count">
            <summary>
            Gets number of parameters.
            </summary>
        </member>
        <member name="P:HttpServer.ArrayParameterCollection.HttpServer#IParameterCollection#Item(System.String)">
            <summary>
            Gets last value of an parameter.
            </summary>
            <param name="name">Parameter name</param>
            <returns>String if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:HttpServer.Helpers.PropertyAssigner">
            <summary>
            Assign properties from HTTP parameters.
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.PropertyAssigner.SetFilterHandler(HttpServer.Helpers.FilterHandler)">
            <summary>
            Used to filter out properties.
            </summary>
            <param name="handler">Filter handler.</param>
            <exception cref="T:System.InvalidOperationException">Handler have already been set.</exception>
        </member>
        <member name="M:HttpServer.Helpers.PropertyAssigner.Assign(System.Object,HttpServer.IParameterCollection)">
            <summary>
            Assign properties in the specified object.
            </summary>
            <param name="instance">Object to fill.</param>
            <param name="parameters">Contains all parameters that should be assigned to the properties.</param>
            <exception cref="T:HttpServer.Helpers.PropertyException">Properties was not found or value could not be converted.</exception>
            <exception cref="T:System.ArgumentNullException">Any parameter is <c>null</c>.</exception>
        </member>
        <member name="T:HttpServer.Helpers.FilterHandler">
            <summary>
            Used to be able to filter properties
            </summary>
            <param name="instance">Model having it's properties assigned</param>
            <param name="propertyName">Property about to be assigned</param>
            <param name="propertyValue">Value to assign</param>
            <returns><c>true</c> if value can be set; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:HttpServer.Helpers.PropertyException">
            <summary>
            Failed to assign properties.
            </summary>
        </member>
        <member name="M:HttpServer.Helpers.PropertyException.#ctor(System.Collections.Generic.Dictionary{System.String,System.Exception})">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Helpers.PropertyException"/> class.
            </summary>
            <param name="propertyErrors">The property errors.</param>
        </member>
        <member name="P:HttpServer.Helpers.PropertyException.PropertyErrors">
            <summary>
            Gets all errors during assignment.
            </summary>
            <remarks>
            Dictionary key is property name.
            </remarks>
        </member>
        <member name="T:HttpServer.Tools.StringReader">
            <summary>
            Used to read from a string object.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.StringReader.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Tools.StringReader"/> class.
            </summary>
            <param name="buffer">Buffer to process.</param>
        </member>
        <member name="M:HttpServer.Tools.StringReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Tools.StringReader"/> class.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.StringReader.Assign(System.Object,System.Int32,System.Int32)">
            <summary>
            Assign a new buffer
            </summary>
            <param name="buffer">Buffer to process.</param>
            <param name="offset">Where to start process buffer</param>
            <param name="count">Buffer length</param>
            <remarks><paramref name="buffer"/> MUST be of type <see cref="T:System.String"/>.</remarks>
            <exception cref="T:System.ArgumentException">buffer needs to be of type string</exception>
        </member>
        <member name="M:HttpServer.Tools.StringReader.Assign(System.Object)">
            <summary>
            Assign a new buffer
            </summary>
            <param name="buffer">Buffer to process</param>
            <remarks><paramref name="buffer"/> MUST be of type <see cref="T:System.String"/>.</remarks>
            <exception cref="T:System.ArgumentException">buffer needs to be of type string</exception>
        </member>
        <member name="M:HttpServer.Tools.StringReader.Consume">
            <summary>
            Consume current character.
            </summary>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ReadLine">
            <summary>
            Get a text line. 
            </summary>
            <returns></returns>
            <remarks>Will merge multiline headers.</remarks> 
        </member>
        <member name="M:HttpServer.Tools.StringReader.ReadQuotedString">
            <summary>
            Read quoted string
            </summary>
            <returns>string if current character (in buffer) is a quote; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ReadToEnd(System.String)">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ReadToEnd">
            <summary>
            Read until end of string, or to one of the delimiters are found.
            </summary>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ReadToEnd(System.Char)">
            <summary>
            Read to end of buffer, or until specified delimiter is found.
            </summary>
            <param name="delimiter">Delimiter to find.</param>
            <returns>A string (can be <see cref="F:System.String.Empty"/>).</returns>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.StringReader.Consume(System.Char[])">
            <summary>
            Consume specified characters
            </summary>
            <param name="chars">One or more characters.</param>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ConsumeWhiteSpaces">
            <summary>
            Consumes horizontal white spaces (space and tab).
            </summary>
        </member>
        <member name="M:HttpServer.Tools.StringReader.Read">
            <summary>
            Read a character.
            </summary>
            <returns>
            Character if not EOF; otherwise <c>null</c>.
            </returns>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ReadUntil(System.Char)">
            <summary>
            Will read until specified delimiter is found.
            </summary>
            <param name="delimiter">Character to stop at.</param>
            <returns>
            A string if the delimiter was found; otherwise <c>null</c>.
            </returns>
            <remarks>
            Will trim away spaces and tabs from the end.
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ReadUntil(System.String)">
            <summary>
            Read until one of the delimiters are found.
            </summary>
            <param name="delimiters">characters to stop at</param>
            <returns>
            A string if one of the delimiters was found; otherwise <c>null</c>.
            </returns>
            <remarks>
            Will not consume the delimiter.
            </remarks>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ReadWord">
            <summary>
            Read until a horizontal white space occurs (or end, or end of line).
            </summary>
            <returns>
            A string if a white space was found; otherwise <c>null</c>.
            </returns>
        </member>
        <member name="M:HttpServer.Tools.StringReader.ConsumeWhiteSpaces(System.Char)">
            <summary>
            Consume horizontal white spaces and the specified character.
            </summary>
            <param name="extraCharacter">Extra character to consume</param>
        </member>
        <member name="M:HttpServer.Tools.StringReader.Contains(System.Char)">
            <summary>
            Checks if one of the remaining bytes are a specified character.
            </summary>
            <param name="ch">Character to find.</param>
            <returns>
            	<c>true</c> if found; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="P:HttpServer.Tools.StringReader.LineNumber">
            <summary>
            Gets or sets line number.
            </summary>
        </member>
        <member name="P:HttpServer.Tools.StringReader.EOF">
            <summary>
            Gets if end of buffer have been reached
            </summary>
            <value></value>
        </member>
        <member name="P:HttpServer.Tools.StringReader.HasMore">
            <summary>
            Gets if more bytes can be processed.
            </summary>
            <value></value>
        </member>
        <member name="P:HttpServer.Tools.StringReader.Peek">
            <summary>
            Gets next character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:HttpServer.Tools.StringReader.Current">
            <summary>
            Gets current character
            </summary>
            <value><see cref="F:System.Char.MinValue"/> if end of buffer.</value>
        </member>
        <member name="P:HttpServer.Tools.StringReader.Index">
            <summary>
            Gets or sets current position in buffer.
            </summary>
            <remarks>
            THINK before you manually change the position since it can blow up
            the whole parsing in your face.
            </remarks>
        </member>
        <member name="P:HttpServer.Tools.StringReader.Length">
            <summary>
            Gets total length of buffer.
            </summary>
            <value></value>
        </member>
        <member name="P:HttpServer.Tools.StringReader.RemainingLength">
            <summary>
            Gets number of bytes left.
            </summary>
        </member>
        <member name="T:HttpServer.Logging.NullLogWriter">
            <summary>
            Default log writer, writes everything to void (nowhere).
            </summary>
            <seealso cref="T:HttpServer.Logging.ILogger"/>
        </member>
        <member name="F:HttpServer.Logging.NullLogWriter.Instance">
            <summary>
            The logging instance.
            </summary>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Debug(System.String)">
            <summary>
            Write an entry that helps when debugging code.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Debug(System.String,System.Exception)">
            <summary>
            Write an entry that helps when debugging code.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Trace(System.String)">
            <summary>
            Write a entry needed when following through code during hard to find bugs.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Trace(System.String,System.Exception)">
            <summary>
            Write a entry that helps when trying to find hard to find bugs.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Info(System.String)">
            <summary>
            Informational message, needed when helping customer to find a problem.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Info(System.String,System.Exception)">
            <summary>
            Informational message, needed when helping customer to find a problem.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Warning(System.String)">
            <summary>
            Something is not as we expect, but the code can continue to run without any changes.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Warning(System.String,System.Exception)">
            <summary>
            Something is not as we expect, but the code can continue to run without any changes.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Error(System.String)">
            <summary>
            Something went wrong, but the application do not need to die. The current thread/request
            cannot continue as expected.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Error(System.String,System.Exception)">
            <summary>
            Something went wrong, but the application do not need to die. The current thread/request
            cannot continue as expected.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Fatal(System.String)">
            <summary>
            Something went very wrong, application might not recover.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.NullLogWriter.Fatal(System.String,System.Exception)">
            <summary>
            Something went very wrong, application might not recover.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="T:HttpServer.Logging.LogLevel">
            <summary>
            Priority for log entries
            </summary>
            <seealso cref="T:HttpServer.Logging.ILogger"/>
        </member>
        <member name="F:HttpServer.Logging.LogLevel.Trace">
            <summary>
            Very detailed logs to be able to follow the flow of the program.
            </summary>
        </member>
        <member name="F:HttpServer.Logging.LogLevel.Debug">
            <summary>
            Logs to help debug errors in the application
            </summary>
        </member>
        <member name="F:HttpServer.Logging.LogLevel.Info">
            <summary>
            Information to be able to keep track of state changes etc.
            </summary>
        </member>
        <member name="F:HttpServer.Logging.LogLevel.Warning">
            <summary>
            Something did not go as we expected, but it's no problem.
            </summary>
        </member>
        <member name="F:HttpServer.Logging.LogLevel.Error">
            <summary>
            Something that should not fail failed, but we can still keep
            on going.
            </summary>
        </member>
        <member name="F:HttpServer.Logging.LogLevel.Fatal">
            <summary>
            Something failed, and we cannot handle it properly.
            </summary>
        </member>
        <member name="T:HttpServer.Logging.ConsoleLogger">
            <summary>
            This class writes to the console. 
            </summary>
            <remarks>
            It colors the output depending on the log level 
            and includes a 3-level stack trace (in debug mode)
            </remarks>
            <seealso cref="T:HttpServer.Logging.ILogger"/>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.#ctor(System.Type,HttpServer.Logging.ILogFilter)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Logging.ConsoleLogger"/> class.
            </summary>
            <param name="loggingType">Type being logged.</param>
            <param name="filter">Log filter.</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.GetColor(HttpServer.Logging.LogLevel)">
            <summary>
            Get color for the specified log level
            </summary>
            <param name="level">Level for the log entry</param>
            <returns>A <see cref="T:System.ConsoleColor"/> for the level</returns>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Write(HttpServer.Logging.LogLevel,System.String)">
            <summary>
            Write an entry
            </summary>
            <param name="level">Importance of the log message</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Debug(System.String)">
            <summary>
            Write an entry that helps when debugging code.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Debug(System.String,System.Exception)">
            <summary>
            Write an entry that helps when debugging code.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Trace(System.String)">
            <summary>
            Write a entry needed when following through code during hard to find bugs.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Trace(System.String,System.Exception)">
            <summary>
            Write a entry that helps when trying to find hard to find bugs.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Info(System.String)">
            <summary>
            Informational message, needed when helping customer to find a problem.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Info(System.String,System.Exception)">
            <summary>
            Informational message, needed when helping customer to find a problem.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Warning(System.String)">
            <summary>
            Something is not as we expect, but the code can continue to run without any changes.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Warning(System.String,System.Exception)">
            <summary>
            Something is not as we expect, but the code can continue to run without any changes.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Error(System.String)">
            <summary>
            Something went wrong, but the application do not need to die. The current thread/request
            cannot continue as expected.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Error(System.String,System.Exception)">
            <summary>
            Something went wrong, but the application do not need to die. The current thread/request
            cannot continue as expected.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Fatal(System.String)">
            <summary>
            Something went very wrong, application might not recover.
            </summary>
            <param name="message">Log message</param>
        </member>
        <member name="M:HttpServer.Logging.ConsoleLogger.Fatal(System.String,System.Exception)">
            <summary>
            Something went very wrong, application might not recover.
            </summary>
            <param name="message">Log message</param>
            <param name="exception">Thrown exception to log.</param>
        </member>
        <member name="P:HttpServer.Logging.ConsoleLogger.LoggingType">
            <summary>
            Gets or sets type that the logger is for
            </summary>
        </member>
        <member name="T:HttpServer.HttpContext">
            <summary>
            A HTTP context
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="T:HttpServer.IHttpContext">
            <summary>
            Context that received a HTTP request.
            </summary>
        </member>
        <member name="M:HttpServer.IHttpContext.Disconnect">
            <summary>
            Disconnect context.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpContext.IsSecure">
            <summary>
            Gets if current context is using a secure connection.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpContext.Logger">
            <summary>
            Gets logger.
            </summary>
        </member>
        <member name="P:HttpServer.IHttpContext.RemoteEndPoint">
            <summary>
            Gets remote end point
            </summary>
        </member>
        <member name="P:HttpServer.IHttpContext.Stream">
            <summary>
            Gets stream used to send/receive data to/from remote end point.
            </summary>
            <remarks>
            <para>
            The stream can be any type of stream, do not assume that it's a network
            stream. For instance, it can be a <see cref="T:System.Net.Security.SslStream"/> or a ZipStream.
            </para>
            </remarks>
        </member>
        <member name="P:HttpServer.IHttpContext.Request">
            <summary>
            Gets the currently handled request
            </summary>
            <value>The request.</value>
        </member>
        <member name="P:HttpServer.IHttpContext.Response">
            <summary>
            Gets the response that is going to be sent back
            </summary>
            <value>The response.</value>
        </member>
        <member name="M:HttpServer.HttpContext.#ctor(System.Net.Sockets.Socket,HttpServer.Messages.MessageFactoryContext)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.HttpContext"/> class.
            </summary>
            <param name="socket">Socket received from HTTP listener.</param>
            <param name="context">Context used to parse incoming messages.</param>
        </member>
        <member name="M:HttpServer.HttpContext.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:HttpServer.HttpContext.Disconnect">
            <summary>
            Disconnect context.
            </summary>
        </member>
        <member name="M:HttpServer.HttpContext.Close">
            <summary>
            Close and release socket.
            </summary>
        </member>
        <member name="M:HttpServer.HttpContext.CreateStream(System.Net.Sockets.Socket)">
            <summary>
            Create stream used to send and receive bytes from the socket.
            </summary>
            <param name="socket">Socket to wrap</param>
            <returns>Stream</returns>
            <exception cref="T:System.InvalidOperationException">Stream could not be created.</exception>
        </member>
        <member name="M:HttpServer.HttpContext.OnReceive(System.IAsyncResult)">
            <summary>
            Interpret incoming data.
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:HttpServer.HttpContext.OnRequest(System.Object,HttpServer.Messages.FactoryRequestEventArgs)">
            <summary>
            A request was received from the parser.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:HttpServer.HttpContext.ParseBuffer(System.Int32)">
            <summary>
            Parse all complete requests in buffer.
            </summary>
            <param name="bytesLeft"></param>
            <returns>offset in buffer where parsing stopped.</returns>
            <exception cref="T:System.InvalidOperationException">Parsing failed.</exception>
        </member>
        <member name="M:HttpServer.HttpContext.Start">
            <summary>
            Start content.
            </summary>
            <exception cref="T:System.Net.Sockets.SocketException">A socket operation failed.</exception>
            <exception cref="T:System.IO.IOException">Reading from stream failed.</exception>
        </member>
        <member name="P:HttpServer.HttpContext.Current">
            <summary>
            Gets currently executing HTTP context.
            </summary>
        </member>
        <member name="P:HttpServer.HttpContext.HttpFactory">
            <summary>
            Gets or sets description
            </summary>
        </member>
        <member name="P:HttpServer.HttpContext.MessageFactoryContext">
            <summary>
            gets factory used to build request objects
            </summary>
        </member>
        <member name="P:HttpServer.HttpContext.Socket">
            <summary>
            Gets socket
            </summary>
        </member>
        <member name="P:HttpServer.HttpContext.RemoteEndPoint">
            <summary>
            Gets remove end point
            </summary>
        </member>
        <member name="P:HttpServer.HttpContext.Stream">
            <summary>
            Gets network stream.
            </summary>
        </member>
        <member name="P:HttpServer.HttpContext.Request">
            <summary>
            Gets the currently handled request
            </summary>
            <value>The request.</value>
        </member>
        <member name="P:HttpServer.HttpContext.Response">
            <summary>
            Gets the response that is going to be sent back
            </summary>
            <value>The response.</value>
        </member>
        <member name="P:HttpServer.HttpContext.Logger">
            <summary>
            Gets logger.
            </summary>
        </member>
        <member name="P:HttpServer.HttpContext.IsSecure">
            <summary>
            Gets if current context is using a secure connection.
            </summary>
        </member>
        <member name="E:HttpServer.HttpContext.CurrentRequestCompleted">
            <summary>
            Triggered for all requests in the server (after the response have been sent)
            </summary>
        </member>
        <member name="E:HttpServer.HttpContext.RequestCompleted">
            <summary>
            Triggered for current request (after the response have been sent)
            </summary>
        </member>
        <member name="E:HttpServer.HttpContext.RequestReceived">
            <summary>
            A new request have been received.
            </summary>
        </member>
        <member name="E:HttpServer.HttpContext.CurrentRequestReceived">
            <summary>
            A new request have been received (invoked for ALL requests)
            </summary>
        </member>
        <member name="E:HttpServer.HttpContext.Disconnected">
            <summary>
            Client have been disconnected.
            </summary>
        </member>
        <member name="E:HttpServer.HttpContext.ContinueResponseRequested">
            <summary>
            Client asks if he may continue.
            </summary>
            <remarks>
            If the body is too large or anything like that you should respond <see cref="F:System.Net.HttpStatusCode.ExpectationFailed"/>.
            </remarks>
        </member>
        <member name="M:HttpServer.SecureHttpContext.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Authentication.SslProtocols,System.Net.Sockets.Socket,HttpServer.Messages.MessageFactoryContext)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.SecureHttpContext"/> class.
            </summary>
            <param name="protocols">SSL protocol to use.</param>
            <param name="socket">The socket.</param>
            <param name="context">The context.</param>
            <param name="certificate">Server certificate to use.</param>
        </member>
        <member name="M:HttpServer.SecureHttpContext.CreateStream(System.Net.Sockets.Socket)">
            <summary>
            Create stream used to send and receive bytes from the socket.
            </summary>
            <param name="socket">Socket to wrap</param>
            <returns>Stream</returns>
            <exception cref="T:System.InvalidOperationException">Stream could not be created.</exception>
        </member>
        <member name="P:HttpServer.SecureHttpContext.ClientCertificate">
            <summary>
            Gets or sets client certificate.
            </summary>
        </member>
        <member name="P:HttpServer.SecureHttpContext.Protocol">
            <summary>
            Gets used protocol.
            </summary>
        </member>
        <member name="P:HttpServer.SecureHttpContext.UseClientCertificate">
            <summary>
            Gets or sets if client certificate should be used instead of server certificate.
            </summary>
        </member>
        <member name="T:HttpServer.Resources.Resource">
            <summary>
            Resource information.
            </summary>
            <remarks>
            Used by content providers to be able to get information
            on resources (views, files etc).
            </remarks>
        </member>
        <member name="P:HttpServer.Resources.Resource.ModifiedAt">
            <summary>
            Gets or sets date when resource was modified.
            </summary>
            <value>
            <see cref="F:System.DateTime.MinValue"/> if not used.
            </value>
            <remarks>
            Should always be universal time.
            </remarks>
        </member>
        <member name="P:HttpServer.Resources.Resource.Stream">
            <summary>
            Gets or sets resource stream.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.HeaderParameterCollection">
            <summary>
            Contains parameters for HTTP headers.
            </summary>
        </member>
        <member name="M:HttpServer.Headers.HeaderParameterCollection.Add(System.String,System.String)">
            <summary>
            Add a parameter
            </summary>
            <param name="name">name</param>
            <param name="value">value</param>
            <remarks>
            Existing parameter with the same name will be replaced.
            </remarks>
        </member>
        <member name="M:HttpServer.Headers.HeaderParameterCollection.Parse(HttpServer.Tools.ITextReader)">
            <summary>
            Parse parameters.
            </summary>
            <param name="reader">Parser containing buffer to parse.</param>
            <returns>A collection with all parameters (or just a empty collection).</returns>
            <exception cref="T:System.FormatException">Expected a value after equal sign.</exception>
        </member>
        <member name="M:HttpServer.Headers.HeaderParameterCollection.Parse(HttpServer.Tools.ITextReader,System.Char)">
            <summary>
            Parse parameters.
            </summary>
            <param name="reader">Parser containing buffer to parse.</param>
            <param name="delimiter">Parameter delimiter</param>
            <returns>A collection with all parameters (or just a empty collection).</returns>
            <exception cref="T:System.FormatException">Expected a value after equal sign.</exception>
        </member>
        <member name="M:HttpServer.Headers.HeaderParameterCollection.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:HttpServer.Headers.HeaderParameterCollection.Item(System.String)">
            <summary>
            Gets or sets a value
            </summary>
            <param name="name">parameter name</param>
            <returns>value if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:HttpServer.Messages.Response">
            <summary>
            Create a HTTP response object.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Response.#ctor(System.String,System.Net.HttpStatusCode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Response"/> class.
            </summary>
            <param name="version">HTTP Version.</param>
            <param name="code">HTTP status code.</param>
            <param name="reason">Why the status code was selected.</param>
            <exception cref="T:System.FormatException">Version must start with 'HTTP/'</exception>
        </member>
        <member name="M:HttpServer.Messages.Response.#ctor(HttpServer.IHttpContext,HttpServer.IRequest)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Response"/> class.
            </summary>
            <param name="context">Context that the response will be sent through.</param>
            <param name="request">Request that the response is for.</param>
            <exception cref="T:System.FormatException">Version must start with 'HTTP/'</exception>
        </member>
        <member name="M:HttpServer.Messages.Response.Redirect(System.String)">
            <summary>
            Redirect user.
            </summary>
            <param name="uri">Where to redirect to.</param>
            <remarks>
            Any modifications after a redirect will be ignored.
            </remarks>
        </member>
        <member name="M:HttpServer.Messages.Response.Add(System.String,HttpServer.Headers.IHeader)">
            <summary>
            Add a new header.
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:HttpServer.Messages.Response.Add(HttpServer.Headers.IHeader)">
            <summary>
            Add a new header.
            </summary>
            <param name="header">Header to add.</param>
        </member>
        <member name="M:HttpServer.Messages.Response.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:HttpServer.Messages.Response.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:HttpServer.Messages.Response.Item(System.String)">
            <summary>
            Gets a header.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:HttpServer.Messages.Response.Connection">
            <summary>
            Gets connection type.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Response.Status">
            <summary>
            Status code that is sent to the client.
            </summary>
            <remarks>Default is <see cref="F:System.Net.HttpStatusCode.OK"/></remarks>
        </member>
        <member name="P:HttpServer.Messages.Response.HttpVersion">
            <summary>
            Gets HTTP version.
            </summary>
            <remarks>
            Default is HTTP/1.1
            </remarks>
        </member>
        <member name="P:HttpServer.Messages.Response.Reason">
            <summary>
            Information about why a specific status code was used.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Response.ContentLength">
            <summary>
            Size of the body. MUST be specified before sending the header,
            unless property Chunked is set to <c>true</c>.
            </summary>
            <value>
            Any specifically assigned value or Body stream length.
            </value>
        </member>
        <member name="P:HttpServer.Messages.Response.ContentType">
            <summary>
            Kind of content in the body
            </summary>
            <remarks>Default is <c>text/html</c></remarks>
        </member>
        <member name="P:HttpServer.Messages.Response.Encoding">
            <summary>
            Gets or sets encoding
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Response.Cookies">
            <summary>
            Gets cookies.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Response.Body">
            <summary>
            Gets body stream.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Response.Headers">
            <summary>
            Gets headers.
            </summary>
        </member>
        <member name="T:HttpServer.Messages.Parser.RequestEventArgs">
            <summary>
            A request have been received.
            </summary>
        </member>
        <member name="M:HttpServer.Messages.Parser.RequestEventArgs.#ctor(HttpServer.IRequest,System.Net.EndPoint)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Messages.Parser.RequestEventArgs"/> class.
            </summary>
            <param name="request">The request.</param>
            <param name="endPoint">End point that the request was received from.</param>
        </member>
        <member name="P:HttpServer.Messages.Parser.RequestEventArgs.RemoteEndPoint">
            <summary>
            End point that the message was received from.
            </summary>
        </member>
        <member name="P:HttpServer.Messages.Parser.RequestEventArgs.Request">
            <summary>
            Received request.
            </summary>
        </member>
        <member name="T:HttpServer.Routing.RegExRouter">
            <summary>
            Class to make dynamic binding of redirects. Instead of having to specify a number of similar redirect rules
            a regular expression can be used to identify redirect URLs and their targets.
            </summary>
            <example>
            <![CDATA[
            new RegexRedirectRule("/(?<target>[a-z0-9]+)", "/users/${target}/?find=true", RegexOptions.IgnoreCase)
            ]]>
            </example>
        </member>
        <member name="M:HttpServer.Routing.RegExRouter.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Routing.RegExRouter"/> class.
            </summary>
            <param name="fromUrlExpression">Expression to match URL</param>
            <param name="toUrlExpression">Expression to generate URL</param>
            <example>
            <![CDATA[
            server.Add(new RegexRedirectRule("/(?<first>[a-zA-Z0-9]+)", "/user/${first}"));
            Result of ie. /employee1 will then be /user/employee1
            ]]>
            </example>
        </member>
        <member name="M:HttpServer.Routing.RegExRouter.#ctor(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Routing.RegExRouter"/> class.
            </summary>
            <param name="fromUrlExpression">Expression to match URL</param>
            <param name="toUrlExpression">Expression to generate URL</param>
            <param name="options">Regular expression options to use, can be <c>null</c></param>
            <example>
            <![CDATA[
            server.Add(new RegexRedirectRule("/(?<first>[a-zA-Z0-9]+)", "/user/{first}", RegexOptions.IgnoreCase));
            Result of ie. /employee1 will then be /user/employee1
            ]]>
            </example>
        </member>
        <member name="M:HttpServer.Routing.RegExRouter.#ctor(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Routing.RegExRouter"/> class.
            </summary>
            <param name="fromUrlExpression">Expression to match URL</param>
            <param name="toUrlExpression">Expression to generate URL</param>
            <param name="options">Regular expression options to apply</param>
            <param name="shouldRedirect"><c>true</c> if request should be redirected, <c>false</c> if the request URI should be replaced.</param>
            <example>
            <![CDATA[
            server.Add(new RegexRedirectRule("/(?<first>[a-zA-Z0-9]+)", "/user/${first}", RegexOptions.None));
            Result of ie. /employee1 will then be /user/employee1
            ]]>
            </example>
            <exception cref="T:System.ArgumentNullException">Argument is <c>null</c>.</exception>
            <seealso cref="P:HttpServer.Routing.SimpleRouter.ShouldRedirect"/>
        </member>
        <member name="M:HttpServer.Routing.RegExRouter.Process(HttpServer.RequestContext)">
            <summary>
            Process the incoming request.
            </summary>
            <param name="context">Request context.</param>
            <returns>Processing result.</returns>
            <exception cref="T:System.ArgumentNullException">If any parameter is <c>null</c>.</exception>
        </member>
        <member name="T:HttpServer.Messages.ResponseCookie">
            <summary>
            cookie being sent back to the browser.
            </summary>
            <seealso cref="T:HttpServer.Messages.ResponseCookie"/>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookie.#ctor(System.String,System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="id">cookie identifier</param>
            <param name="content">cookie content</param>
            <param name="expiresAt">cookie expiration date. Use <see cref="F:System.DateTime.MinValue"/> for session cookie.</param>
            <exception cref="T:System.ArgumentNullException">id or content is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">id is empty</exception>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookie.#ctor(System.String,System.String,System.DateTime,System.String,System.String)">
            <summary>
            Create a new cookie
            </summary>
            <param name="name">name identifying the cookie</param>
            <param name="value">cookie value</param>
            <param name="expires">when the cookie expires. Setting <see cref="F:System.DateTime.MinValue"/> will delete the cookie when the session is closed.</param>
            <param name="path">Path to where the cookie is valid</param>
            <param name="domain">Domain that the cookie is valid for.</param>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookie.#ctor(HttpServer.Messages.RequestCookie,System.DateTime)">
            <summary>
            Create a new cookie
            </summary>
            <param name="cookie">Name and value will be used</param>
            <param name="expires">when the cookie expires.</param>
        </member>
        <member name="M:HttpServer.Messages.ResponseCookie.ToString">
            <summary>
            Gets the cookie HTML representation.
            </summary>
            <returns>cookie string</returns>
        </member>
        <member name="P:HttpServer.Messages.ResponseCookie.Expires">
            <summary>
            Gets when the cookie expires.
            </summary>
            <remarks><see cref="F:System.DateTime.MinValue"/> means that the cookie expires when the session do so.</remarks>
        </member>
        <member name="P:HttpServer.Messages.ResponseCookie.Path">
            <summary>
            Gets path that the cookie is valid under.
            </summary>
        </member>
        <member name="T:HttpServer.Headers.CacheControlHeader">
             <summary>
               The Cache-Control general-header field is used to specify directives that
               MUST be obeyed by all caching mechanisms along the request/response
               chain. .
             </summary>
             <remarks>
             <para>
             The directives specify behavior intended to prevent caches from adversely
             interfering with the request or response. These directives typically
             override the default caching algorithms. Cache directives are
             unidirectional in that the presence of a directive in a request does not
             imply that the same directive is to be given in the response.
            </para><para>Note that HTTP/1.0 caches might not implement Cache-Control and
            might only implement Pragma: no-cache (see section 14.32 in RFC2616).
            </para><para>Cache directives MUST be passed through by a proxy or gateway
            application, regardless of their significance to that application, since the
            directives might be applicable to all recipients along the request/response
            chain. It is not possible to specify a cache- directive for a specific cache
             </para>
             <para>
               When a directive appears without any 1#field-name parameter, the
               directive applies to the entire request or response. When such a
               directive appears with a 1#field-name parameter, it applies only to
               the named field or fields, and not to the rest of the request or
               response. This mechanism supports extensibility; implementations of
               future versions of the HTTP protocol might apply these directives to
               header fields not defined in HTTP/1.1.
             </para>
             <para>
               The cache-control directives can be broken down into these general
               categories:
             <list type="bullet">
             <item>
                  Restrictions on what are cacheable; these may only be imposed by
                  the origin server.
            </item><item>
                  Restrictions on what may be stored by a cache; these may be
                  imposed by either the origin server or the user agent.
            </item><item>
                  Modifications of the basic expiration mechanism; these may be
                  imposed by either the origin server or the user agent.
            </item><item>
                  Controls over cache revalidation and reload; these may only be
                  imposed by a user agent.
            </item><item>
                  Control over transformation of entities.
            </item><item>
                  Extensions to the caching system.
             </item>
             </list>
            	</para>
             </remarks>
        </member>
        <member name="F:HttpServer.Headers.CacheControlHeader.NAME">
            <summary>
            Header name
            </summary>
        </member>
        <member name="P:HttpServer.Headers.CacheControlHeader.Name">
            <summary>
            Gets header name
            </summary>
        </member>
        <member name="T:HttpServer.Modules.FileModule">
            <summary>
            Serves files in the web server.
            </summary>
            <example>
            <code>
            FileModule fileModule = new FileModule();
            fileModule.Resources.Add(new FileResources("/", "C:\\inetpub\\myweb"));
            </code>
            </example>
        </member>
        <member name="M:HttpServer.Modules.FileModule.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:HttpServer.Modules.FileModule"/> class.
            </summary>
            <exception cref="T:System.ArgumentNullException"><c>baseUri</c> or <c>basePath</c> is <c>null</c>.</exception>
        </member>
        <member name="M:HttpServer.Modules.FileModule.AddDefaultMimeTypes">
            <summary>
            Mime types that this class can handle per default
            </summary>
            <remarks>
            Contains the following mime types:
            <list type="table">
            <item><term><![CDATA[txt]]></term><value><![CDATA[text/plain]]></value></item>
            <item><term><![CDATA[html]]></term><value><![CDATA[text/html]]></value></item>
            <item><term><![CDATA[htm]]></term><value><![CDATA[text/html]]></value></item>
            <item><term><![CDATA[jpg]]></term><value><![CDATA[image/jpg]]></value></item>
            <item><term><![CDATA[jpeg]]></term><value><![CDATA[image/jpg]]></value></item>
            <item><term><![CDATA[bmp]]></term><value><![CDATA[image/bmp]]></value></item>
            <item><term><![CDATA[gif]]></term><value><![CDATA[image/gif]]></value></item>
            <item><term><![CDATA[png]]></term><value><![CDATA[image/png]]></value></item>
            <item><term><![CDATA[ico]]></term><value><![CDATA[image/vnd.microsoft.icon]]></value></item>
            <item><term><![CDATA[css]]></term><value><![CDATA[text/css]]></value></item>
            <item><term><![CDATA[gzip]]></term><value><![CDATA[application/x-gzip]]></value></item>
            <item><term><![CDATA[zip]]></term><value><![CDATA[multipart/x-zip]]></value></item>
            <item><term><![CDATA[tar]]></term><value><![CDATA[application/x-tar]]></value></item>
            <item><term><![CDATA[pdf]]></term><value><![CDATA[application/pdf]]></value></item>
            <item><term><![CDATA[rtf]]></term><value><![CDATA[application/rtf]]></value></item>
            <item><term><![CDATA[xls]]></term><value><![CDATA[application/vnd.ms-excel]]></value></item>
            <item><term><![CDATA[ppt]]></term><value><![CDATA[application/vnd.ms-powerpoint]]></value></item>
            <item><term><![CDATA[doc]]></term><value><![CDATA[application/application/msword]]></value></item>
            <item><term><![CDATA[js]]></term><value><![CDATA[application/javascript]]></value></item>
            <item><term><![CDATA[au]]></term><value><![CDATA[audio/basic]]></value></item>
            <item><term><![CDATA[snd]]></term><value><![CDATA[audio/basic]]></value></item>
            <item><term><![CDATA[es]]></term><value><![CDATA[audio/echospeech]]></value></item>
            <item><term><![CDATA[mp3]]></term><value><![CDATA[audio/mpeg]]></value></item>
            <item><term><![CDATA[mp2]]></term><value><![CDATA[audio/mpeg]]></value></item>
            <item><term><![CDATA[mid]]></term><value><![CDATA[audio/midi]]></value></item>
            <item><term><![CDATA[wav]]></term><value><![CDATA[audio/x-wav]]></value></item>
            <item><term><![CDATA[swf]]></term><value><![CDATA[application/x-shockwave-flash]]></value></item>
            <item><term><![CDATA[avi]]></term><value><![CDATA[video/avi]]></value></item>
            <item><term><![CDATA[rm]]></term><value><![CDATA[audio/x-pn-realaudio]]></value></item>
            <item><term><![CDATA[ram]]></term><value><![CDATA[audio/x-pn-realaudio]]></value></item>
            <item><term><![CDATA[aif]]></term><value><![CDATA[audio/x-aiff]]></value></item>
            </list>
            </remarks>
        </member>
        <member name="M:HttpServer.Modules.FileModule.SendFile(HttpServer.IHttpContext,HttpServer.IResponse,System.IO.Stream)">
            <summary>
            Will send a file to client.
            </summary>
            <param name="context">HTTP context containing outbound stream.</param>
            <param name="response">Response containing headers.</param>
            <param name="stream">File stream</param>
        </member>
        <member name="M:HttpServer.Modules.FileModule.Process(HttpServer.RequestContext)">
            <summary>
            Process a request.
            </summary>
            <param name="context">Request information</param>
            <returns>What to do next.</returns>
            <exception cref="T:HttpServer.InternalServerException">Failed to find file extension</exception>
            <exception cref="T:HttpServer.ForbiddenException">Forbidden file type.</exception>
        </member>
        <member name="P:HttpServer.Modules.FileModule.ContentTypes">
            <summary>
            Gets a list with all allowed content types. 
            </summary>
            <remarks>All other mime types will result in <see cref="F:System.Net.HttpStatusCode.Forbidden"/>.</remarks>
        </member>
        <member name="P:HttpServer.Modules.FileModule.Resources">
            <summary>
            Gets provider used to add files to the file manager,
            </summary>
        </member>
        <member name="T:HttpServer.HttpFileCollection">
            <summary>
            Collection of files.
            </summary>
        </member>
        <member name="M:HttpServer.HttpFileCollection.Contains(System.String)">
            <summary>
            Checks if a file exists.
            </summary>
            <param name="name">Name of the file (form item name)</param>
            <returns></returns>
        </member>
        <member name="M:HttpServer.HttpFileCollection.Add(HttpServer.HttpFile)">
            <summary>
            Add a new file.
            </summary>
            <param name="file">File to add.</param>
        </member>
        <member name="M:HttpServer.HttpFileCollection.Clear">
            <summary>
            Remove all files from disk.
            </summary>
        </member>
        <member name="P:HttpServer.HttpFileCollection.Item(System.String)">
            <summary>
            Get a file
            </summary>
            <param name="name">Name in form</param>
            <returns>File if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="P:HttpServer.HttpFileCollection.Count">
            <summary>
            Gets number of files
            </summary>
        </member>
    </members>
</doc>

```
### Folder: `temp_TShock-5.2.4/scripts`
#### File: `temp_TShock-5.2.4/scripts/create_release.py`
```
'''
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

# Hey there, this is used to compile TShock on the build server.
# Don't change it. Thanks!

import os
import shutil
import subprocess
import urllib2
import zipfile

cur_wd = os.getcwd()
release_dir = os.path.join(cur_wd, "releases")

terraria_bin_name = "TerrariaServer.exe"
otapi_bin_name = "OTAPI.dll"
mysql_bin_name = "MySql.Data.dll"
sqlite_dep_name = "sqlite3.dll"
sqlite_bin_name = "Mono.Data.Sqlite.dll"
json_bin_name = "Newtonsoft.Json.dll"
http_bin_name = "HttpServer.dll"
tshock_bin_name = "TShockAPI.dll"
tshock_symbols = "TShockAPI.pdb"
bcrypt_bin_name = "BCrypt.Net.dll"
geoip_db_name = "GeoIP.dat"

terraria_release_bin = os.path.join(cur_wd, "TerrariaServerAPI", "TerrariaServerAPI", "bin", "Release", terraria_bin_name)
terraria_debug_bin = os.path.join(cur_wd, "TerrariaServerAPI", "TerrariaServerAPI", "bin", "Debug", terraria_bin_name)
otapi_bin = os.path.join(cur_wd, "TerrariaServerAPI", "TerrariaServerAPI", "bin", "Release", otapi_bin_name)
mysql_bin = os.path.join(cur_wd, "packages", "MySql.Data.6.9.8", "lib", "net45", mysql_bin_name)
sqlite_dep = os.path.join(cur_wd, "prebuilts", sqlite_dep_name)
sqlite_bin = os.path.join(cur_wd, "prebuilts", sqlite_bin_name)
http_bin = os.path.join(cur_wd, "prebuilts", http_bin_name)
json_bin = os.path.join(cur_wd, "packages", "Newtonsoft.Json.10.0.3", "lib", "net45", json_bin_name)
bcrypt_bin = os.path.join(cur_wd, "packages", "BCrypt.Net.0.1.0", "lib", "net35", bcrypt_bin_name)
geoip_db = os.path.join(cur_wd, "prebuilts", geoip_db_name)
release_bin = os.path.join(cur_wd, "TShockAPI", "bin", "Release", tshock_bin_name)
debug_folder = os.path.join(cur_wd, "TShockAPI", "bin", "Debug")


def create_release_folder():
  os.mkdir(release_dir)

def copy_dependencies():
  shutil.copy(http_bin, release_dir)
  shutil.copy(json_bin, release_dir)
  shutil.copy(bcrypt_bin, release_dir)
  shutil.copy(sqlite_dep, release_dir)
  shutil.copy(mysql_bin, release_dir)
  shutil.copy(sqlite_bin, release_dir)
  shutil.copy(geoip_db, release_dir)
  
def copy_debug_files():
  shutil.copy(terraria_debug_bin, release_dir)
  shutil.copy(otapi_bin, release_dir)
  shutil.copy(os.path.join(debug_folder, tshock_bin_name), release_dir)
  shutil.copy(os.path.join(debug_folder, tshock_symbols), release_dir)

def copy_release_files():
  shutil.copy(terraria_release_bin, release_dir)
  shutil.copy(otapi_bin, release_dir)
  shutil.copy(release_bin, release_dir)

def create_base_zip(name):
  os.chdir(release_dir)
  zip = zipfile.ZipFile(name, "w")
  zip.write(terraria_bin_name)
  zip.write(otapi_bin_name)
  zip.write(sqlite_dep_name)
  zip.write(geoip_db_name)
  zip.write(http_bin_name, os.path.join("ServerPlugins", http_bin_name))
  zip.write(json_bin_name, json_bin_name)
  zip.write(bcrypt_bin_name, os.path.join("ServerPlugins", bcrypt_bin_name))
  zip.write(mysql_bin_name, os.path.join("ServerPlugins", mysql_bin_name))
  zip.write(sqlite_bin_name, os.path.join("ServerPlugins", sqlite_bin_name))
  return zip

def package_release():
  copy_release_files()
  zip = create_base_zip("tshock_release.zip")
  zip.write(tshock_bin_name, os.path.join("ServerPlugins", tshock_bin_name))
  zip.close()
  os.remove(tshock_bin_name)
  os.remove(terraria_bin_name)
  os.chdir(cur_wd)

def package_debug():
  copy_debug_files()
  zip = create_base_zip("tshock_debug.zip")
  zip.write(tshock_bin_name, os.path.join("ServerPlugins", tshock_bin_name))
  zip.write(tshock_symbols, os.path.join("ServerPlugins", tshock_symbols))
  zip.close()
  os.remove(tshock_bin_name)
  os.remove(tshock_symbols)
  os.remove(terraria_bin_name)
  os.chdir(cur_wd)

def delete_files():
  os.chdir(release_dir)
  os.remove(mysql_bin_name)
  # os.remove(sqlite_bin_name)
  # os.remove(sqlite_dep)
  os.remove(json_bin_name)
  os.remove(bcrypt_bin_name)
  os.remove(http_bin_name)
  os.remove(geoip_db_name)
  os.chdir(cur_wd)

def upload_artifacts():
  if os.environ.get('TRAVIS_PULL_REQUEST', 'false') == 'false':
    os.chdir(cur_wd)
    os.mkdir(os.environ.get('TRAVIS_BRANCH', 'test-branch'))
    os.chdir(os.environ.get('TRAVIS_BRANCH', 'test-branch'))
    os.mkdir(os.environ.get('TRAVIS_BUILD_NUMBER', 'test-0407'))
    os.chdir(cur_wd)
    shutil.copy(os.path.join(release_dir, 'tshock_release.zip'), os.path.join(os.environ.get('TRAVIS_BRANCH', 'test-branch'), os.environ.get('TRAVIS_BUILD_NUMBER', 'test-0407')))
    shutil.copy(os.path.join(release_dir, 'tshock_debug.zip'), os.path.join(os.environ.get('TRAVIS_BRANCH', 'test-branch'), os.environ.get('TRAVIS_BUILD_NUMBER', 'test-0407')))
    decrypt_process = subprocess.Popen(['openssl', 'aes-256-cbc', '-K', os.environ.get('encrypted_1d7cd15ffdb4_key'), '-iv', os.environ.get('encrypted_1d7cd15ffdb4_iv'), '-in', './scripts/ssh_private_key.enc', '-out', './scripts/ssh_private_key', '-d'])
    decrypt_process.wait()
    os.chmod('./scripts/ssh_private_key', 0600)
    upload_process = subprocess.Popen(['scp', '-oStrictHostKeyChecking=no', '-i', './scripts/ssh_private_key', '-r', os.environ.get('TRAVIS_BRANCH', 'test-branch'), 'tshock-travis@arc.shanked.me:/usr/share/nginx/tshock-travis/'])
    upload_process.wait()

def update_terraria_source():
  subprocess.check_call(['/usr/bin/git', 'submodule', 'init'])
  subprocess.check_call(['/usr/bin/git', 'submodule', 'update'])
  subprocess.check_call(['nuget', 'restore'])
  subprocess.check_call(['nuget', 'restore', 'TerrariaServerAPI/'])

def run_bootstrapper():
  for build_config in ['Debug','Release'] :
    mintaka = subprocess.Popen(['msbuild', './TerrariaServerAPI/TShock.4.OTAPI.sln', '/p:Configuration=' + build_config])
    
    mintaka.wait()
    
    if (mintaka.returncode != 0):
      raise CalledProcessError(mintaka.returncode)

    # run the bootstrapper to generate the new OTAPI.dll
    os.chdir('./TerrariaServerAPI/TShock.Modifications.Bootstrapper/bin/' + build_config)
    bootstrapper_proc = subprocess.Popen(['mono', 'TShock.Modifications.Bootstrapper.exe', '-in=OTAPI.dll', '-mod=../../../TShock.Modifications.**/bin/' + build_config + '/TShock.Modifications.*.dll', '-o=Output/OTAPI.dll'])
    os.chdir(cur_wd)
    
    bootstrapper_proc.wait()
    if (bootstrapper_proc.returncode != 0):
      raise CalledProcessError(bootstrapper_proc.returncode)

    tsapi_proc = subprocess.Popen(['msbuild', './TerrariaServerAPI/TerrariaServerAPI/TerrariaServerAPI.csproj', '/p:Configuration=' + build_config])
    
    tsapi_proc.wait()
    
    if (tsapi_proc.returncode != 0):
      raise CalledProcessError(tsapi_proc.returncode)

def build_software():
  release_proc = subprocess.Popen(['msbuild', './TShockAPI/TShockAPI.csproj', '/p:Configuration=Release'])
  debug_proc = subprocess.Popen(['msbuild', './TShockAPI/TShockAPI.csproj', '/p:Configuration=Debug'])
  release_proc.wait()
  debug_proc.wait()
  if (release_proc.returncode != 0):
    raise CalledProcessError(release_proc.returncode)
  if (debug_proc.returncode != 0):
    raise CalledProcessError(debug_proc.returncode)
  
    
if __name__ == '__main__':
  create_release_folder()
  update_terraria_source()
  run_bootstrapper()
  copy_dependencies()
  build_software()
  package_release()
  package_debug()
  delete_files()
  upload_artifacts()

```
#### File: `temp_TShock-5.2.4/scripts/deploy_release.py`
```
'''
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import requests
import json 
import sys 
import os
import subprocess
import base64
import urllib

create_release_url = 'https://api.github.com/repos/NyxStudios/TShock/releases'
config_doc_get_url = 'https://tshock.atlassian.net/wiki/rest/api/content/%s?expand=body.storage,version,ancestors'
config_doc_put_url = 'https://tshock.atlassian.net/wiki/rest/api/content/%s'
conversion_page_url = 'https://tshock.atlassian.net/wiki/rest/api/contentbody/convert/storage'

config_desc_page = "3047451"
ssc_desc_page = "39845891"
permissions_desc_page = "3047433"
rest_desc_page = "40632322"

def convert_view_to_storage(page):
    print("Converting " + str(page['id']))
    confluence_header = {"Content-Type":"application/json"}
    r = requests.post(conversion_page_url, auth=(os.environ["bamboo_confluence_username"], os.environ["bamboo_confluence_password"]), headers=confluence_header, data=json.dumps(page['body']['storage']), verify=True)
    page['body']['storage'] = json.loads(r.text)
    return page

def get_confluence_page(id):
    print("Fetching page " + str(id))
    confluence_header = {"Content-Type":"application/json"}
    r = requests.get(config_doc_get_url % id, auth=(os.environ["bamboo_confluence_username"], os.environ["bamboo_confluence_password"]), headers=confluence_header, verify=True)
    page = json.loads(r.text)
    return page

def put_confluence_page(page):
    print("Storing page " + str(page['id']))
    confluence_header = {"Content-Type":"application/json"}
    page['version']['number'] = page['version']['number'] + 1
    page = convert_view_to_storage(page)
    r = requests.put(config_doc_put_url % page['id'], auth=(os.environ["bamboo_confluence_username"], os.environ["bamboo_confluence_password"]), headers=confluence_header, data=json.dumps(page), verify=True)
    page = json.loads(r.text)
    return page

def update_confluence_page(id, content):
    page = get_confluence_page(id)
    page['body']['storage']['value'] = content
    page['body']['storage']['representation'] = 'wiki'
    put_confluence_page(page)
    
def read_and_update_config_on_confluence(id, file):
    #Read the Config
    config = ""
    with open(file, "r") as f:
        line = f.readline()
        while (line is not ""):
            config = config + line
            line = f.readline()
    #update confluence page
    config = config.replace("{", "\{")
    config = config.replace("}", "\}")
    config = config.replace("[", "\[")
    config = config.replace("]", "\]")
    config = config.replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;")
    update_confluence_page(id, config)
    
#Load variables from ENV, which are put there by the bamboo build.
branch = os.environ["GIT_BRANCH"]
tag_name = os.environ["bamboo_tag_name"]
name = os.environ["bamboo_release_name"]
body = os.environ["bamboo_release_body"]
token = os.environ["bamboo_github_oauth_password"]

#build release file name using the tag, stripping the 'v' off the front ie 'v.1.2.3' => '.1.2.3' resulting in a file called 'tshock.1.2.3.zip'
release_name = 'tshock_' + tag_name[1:] + '.zip'

#invoke the mv command on the artifact from bamboo to the new name above
subprocess.call('mv tshock_release.zip ' + release_name, shell=True)

#construct the payload for the post request to github to create the release.
data = {'tag_name':tag_name, 'target_commitish':branch, 'name':name, 'body':body, 'draft':False, 'prerelease':False}
#headers for the post request with our oauth token, allowing us write access
create_headers = {'Content-Type': 'application/json', 'Authorization': 'token ' + token}
#payload is a json string, not a strong typed json object
json_data = json.dumps(data)

#make the post request, creating a release
r = requests.post(create_release_url, data=json_data, headers=create_headers)
#parse the response into an object
json_response = json.loads(r.text)

#extract the relevant information from the object needed to attach a binary to the release created previously
release_id = json_response['id']
upload_url = json_response['upload_url'].rsplit('{')[0]

#construct the post url using the release name, as that is required by the api
upload_url = upload_url + '?name=' + release_name

#headers for the post request, need to specify that our file is a zip, and how large it is
upload_headers = {'Authorization': 'token ' + token, 'Content-Type':'application/zip', 'Content-Length':str(os.path.getsize(release_name))}

#upload the binary, resulting in a complete binary
r = requests.post(upload_url, data=open(release_name, 'rb'), headers = upload_headers, verify=False)

# read_and_update_config_on_confluence(config_desc_page, "ConfigDescriptions.txt")
# read_and_update_config_on_confluence(ssc_desc_page, "ServerSideConfigDescriptions.txt")
# read_and_update_config_on_confluence(permissions_desc_page, "PermissionsDescriptions.txt")
# read_and_update_config_on_confluence(rest_desc_page, "RestDescriptions.txt")
```
#### File: `temp_TShock-5.2.4/scripts/gpltext.py`
```
''' TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import re
import os
import glob

extensions = {'.cs', '.py'}
path = "./"
pattern = "/\*\s?\n?TShock, a server mod for Terraria(\n|.)*\*/"
pypattern = "'''\s?\n?TShock, a server mod for Terraria(\n|.)*'''"
year = "2019"
filename = "./README.md"
text = "/*\n\
TShock, a server mod for Terraria\n\
Copyright (C) 2011-2019 Pryaxis & TShock Contributors\n\
\n\
This program is free software: you can redistribute it and/or modify\n\
it under the terms of the GNU General Public License as published by\n\
the Free Software Foundation, either version 3 of the License, or\n\
(at your option) any later version.\n\
\n\
This program is distributed in the hope that it will be useful,\n\
but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
GNU General Public License for more details.\n\
\n\
You should have received a copy of the GNU General Public License\n\
along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\
*/\n\
\n\
"
pytext = re.sub(r"\*/", "'''", text)
pytext = re.sub(r"/\*", "'''", pytext)

def changeText(filename):
	content = ''

	with open(filename, 'r') as f:
		content = f.read()

	if filename.endswith('.py'):
		if re.search(pypattern, content):
			content = re.sub(r"Copyright \(C\) 2011-[\d]{4}", "Copyright (C) 2011-%s" % year, content)
		else:
			content = pytext + content
	else:
		if re.search(pattern, content):
			content = re.sub(r"Copyright \(C\) 2011-[\d]{4}", "Copyright (C) 2011-%s" % year, content)
		else:
			content = text + content

	with open(filename, 'w') as f:
		f.write(content)

def getFiles(path):
	list = os.listdir(path)

	for f in list:
		#print (f)
		if os.path.isdir(f):
			getFiles(path + f + '/')
		else:
			for ext in extensions:
				if f.endswith(ext):
					if f.endswith('.Designer.cs'):
						break
					print (path + f)
					changeText(path + f)
					break

getFiles(path)
```
#### File: `temp_TShock-5.2.4/scripts/test_release.py`
```
'''
TShock, a server mod for Terraria
Copyright (C) 2011-2019 Pryaxis & TShock Contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import subprocess
import shutil
import os.path
import zipfile

def generate_release():
    zip = zipfile.ZipFile("tshock_release.zip", "r")
    zip.extractall()

def generate_configs():
    subprocess.call(['/usr/local/bin/mono', 'TerrariaServer.exe', '-dump'])
    if not os.path.isfile('ConfigDescriptions.txt') or not os.path.isfile('PermissionsDescriptions.txt') or not os.path.isfile('ServerSideConfigDescriptions.txt') or not os.path.isfile('RestDescriptions.txt'):
        raise CalledProcessError(1)

if __name__ == '__main__':
  generate_release()
  generate_configs()
```
