name: Compile and Commit TShock Plugins

on:
  workflow_dispatch:
    inputs:
      plugin_source_paths:
        description: 'Space-separated list of directories to search recursively for plugins. Defaults to the "Plugins" folder.'
        required: true
        type: string
        default: 'Plugins'
      output_directory:
        description: 'Directory to place the final compiled plugins.'
        required: true
        type: string
        default: 'ServerPlugins'
      commit_message:
        description: 'The commit message for the compiled plugins.'
        required: true
        type: string
        default: 'build: Compile plugins from source'

jobs:
  compile-and-commit:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup .NET 6.0 SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.428'

      - name: Clean and Prepare Output Directory
        run: |
          echo "Cleaning and preparing the output directory: ${{ github.event.inputs.output_directory }}"
          rm -rf ${{ github.event.inputs.output_directory }}
          mkdir -p ${{ github.event.inputs.output_directory }}

      - name: Discover, Compile, and Collect Plugins
        run: |
          # This flag will be used to fail the job if any single plugin fails to build.
          had_errors=false
          
          # This is the core logic. It uses the `find` command to search for all files
          # ending in .csproj within the paths you provide. It then loops through each one.
          find ${{ github.event.inputs.plugin_source_paths }} -type f -name "*.csproj" | while read -r csproj_file; do
            if [ -z "$csproj_file" ]; then continue; fi
            
            project_dir=$(dirname "$csproj_file")
            echo "--- Processing project: $csproj_file ---"
            
            echo "Building project..."
            # Build the specific project. If it fails, print an error and continue to the next one.
            if ! dotnet build "$csproj_file" --configuration Release -p:PlatformTarget=x64; then
              echo "❌ Error: Build failed for '$csproj_file'."
              had_errors=true
              continue
            fi
            
            # --- Path detection for finding the compiled DLL ---
            build_config="Release"
            target_framework="net6.0"
            
            # Standard .NET build output path
            output_source_path="$project_dir/bin/$build_config/$target_framework"
            
            # Some older TShock projects might have a custom output path.
            # We check for the standard one first, but you could add more checks here if needed.
            
            if [ -d "$output_source_path" ]; then
              echo "Collecting files from: $output_source_path"
              # Copy all compiled files (.dll, .pdb, etc.) to the final output directory.
              cp -r "$output_source_path"/* "${{ github.event.inputs.output_directory }}/"
            else
              echo "❌ Error: Could not find compiled output in standard path for '$csproj_file'."
              had_errors=true
              continue
            fi
          done

          # After trying to build all projects, fail the entire step if any of them had an error.
          if [ "$had_errors" = true ]; then
            echo "One or more plugins failed to compile. See logs above for details."
            exit 1
          fi

      - name: Commit and Push Compiled Files
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add ${{ github.event.inputs.output_directory }}
          
          if [ -n "$(git status --porcelain)" ]; then
            echo "Changes detected. Committing and pushing..."
            git commit -m "${{ github.event.inputs.commit_message }}"
            git push
          else
            echo "No changes to commit."
          fi
